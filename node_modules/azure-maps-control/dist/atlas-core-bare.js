/*!
MICROSOFT SOFTWARE LICENSE TERMS
MICROSOFT AZURE MAPS WEB SDK
These license terms are an agreement between you and Microsoft Corporation (or one of its affiliates). They apply to the software named above and any Microsoft services or software updates (except to the extent such services or updates are accompanied by new or additional terms, in which case those different terms apply prospectively and do not alter your or Microsoft’s rights relating to pre-updated software or services). IF YOU COMPLY WITH THESE LICENSE TERMS, YOU HAVE THE RIGHTS BELOW.  BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.
1. INSTALLATION AND USE RIGHTS.
  a) General. You may install and use any number of copies of the software to develop and test your applications.
  b) User Region Parameters. The software will allow you to select from a View list to set the map view within your application for a given customer. By default the View parameter (also referred to as “user region parameter” is set to “Unified”.  Countries/Regions that are not on the View list will default to the “Unified” View. It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via the software is made available. 
  c) Third Party Software. The software may include third party applications that Microsoft, not the third party, licenses to you under this agreement. Any included notices for third party applications are for your information only.
  d) Microsoft Online Subscription Agreement. Some features of the software provide access to, or rely on, Microsoft Azure Services. The use of those services (but not the software) is governed by the separate terms and privacy policies associated with your Microsoft Azure subscription. The services may not be available in all regions. For more information see https://go.microsoft.com/fwLink/?LinkID=522330&amp;clcid=0x9.
2. DISTRIBUTABLE CODE. The software is comprised of “Distributable Code”. “Distributable Code” is code that you are permitted to distribute in applications you develop if you comply with the terms below and otherwise set forth in these license terms. 
  a) Distribution Rights. 
    i. You may copy and distribute the object code form of the software.
    i. Third Party Distribution. You may permit distributors of your applications to copy and distribute any of this distributable code you elect to distribute with your applications.
  b) Distribution Requirements. For any code you distribute, you must:
    i. add significant primary functionality to it in your applications;
    ii. require distributors and external end users to agree to terms that protect it and Microsoft at least as much as this agreement; and
    iii. indemnify, defend, and hold harmless Microsoft from any claims, including attorneys’ fees, related to the distribution or use of your applications, except to the extent that any claim is based solely on the unmodified distributable code.
  c) Distribution Restrictions. You may not:
    i. use Microsoft’s trademarks or trade dress in your application in any way that suggests your application comes from or is endorsed by Microsoft; or
    ii. modify or distribute the source code of any distributable code so that any part of it becomes subject to any license that requires that the distributable code, any other part of the software, or any of Microsoft’s other intellectual property be disclosed or distributed in source code form, or that others have the right to modify it.
3. DATA COLLECTION. The software may collect information about you and your use of the software and send that to Microsoft. Microsoft may use this information to provide services and improve Microsoft’s products and services. Your opt-out rights, if any, are described in the product documentation. Some features in the software may enable collection of data from users of your applications that access or use the software. If you use these features to enable data collection in your applications, you must comply with applicable law, including getting any required user consent, and maintain a prominent privacy policy that accurately informs users about how you use, collect, and share their data. You can learn more about Microsoft’s data collection and use in the product documentation and the Microsoft Privacy Statement at https://go.microsoft.com/fwlink/?LinkId=512132. You agree to comply with all applicable provisions of the Microsoft Privacy Statement.
4. SCOPE OF LICENSE. The software is licensed, not sold. Microsoft reserves all other rights. Unless applicable law gives you more rights despite this limitation, you will not (and have no right to):
  a) work around any technical limitations in the software that only allow you to use it in certain ways;
  b) reverse engineer, decompile, or disassemble the software, or attempt to do so, except and only to the extent permitted by licensing terms governing the use of open-source components that may be included with the software;
  c) remove, minimize, block, or modify any notices of Microsoft or its suppliers in the software;
  d) use the software in any way that is against the law or to create or propagate malware; or
  e) share, publish, distribute, or lend the software (except for any distributable code, subject to the terms above), provide the software as a stand-alone hosted solution for others to use, or transfer the software or this agreement to any third party.
5. EXPORT RESTRICTIONS. You must comply with all domestic and international export laws and regulations that apply to the software, which include restrictions on destinations, end users, and end use. For further information on export restrictions, visit http://aka.ms/exporting.
6. SUPPORT SERVICES. Microsoft is not obligated under this agreement to provide any support services for the software. Any support provided is “as is”, “with all faults”, and without warranty of any kind.
7. UPDATES. The software may periodically check for updates, and download and install them for you. You may obtain updates only from Microsoft or authorized sources. Microsoft may need to update your system to provide you with updates. You agree to receive these automatic updates without any additional notice. Updates may not include or support all existing software features, services, or peripheral devices.
8. ENTIRE AGREEMENT. This agreement, and any other terms Microsoft may provide for supplements, updates, or third-party applications, is the entire agreement for the software.
9. APPLICABLE LAW AND PLACE TO RESOLVE DISPUTES. If you acquired the software in the United States or Canada, the laws of the state or province where you live (or, if a business, where your principal place of business is located) govern the interpretation of this agreement, claims for its breach, and all other claims (including consumer protection, unfair competition, and tort claims), regardless of conflict of laws principles. If you acquired the software in any other country, its laws apply. If U.S. federal jurisdiction exists, you and Microsoft consent to exclusive jurisdiction and venue in the federal court in King County, Washington for all disputes heard in court. If not, you and Microsoft consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington for all disputes heard in court.
10. CONSUMER RIGHTS; REGIONAL VARIATIONS. This agreement describes certain legal rights. You may have other rights, including consumer rights, under the laws of your state or country. Separate and apart from your relationship with Microsoft, you may also have rights with respect to the party from which you acquired the software. This agreement does not change those other rights if the laws of your state or country do not permit it to do so. For example, if you acquired the software in one of the below regions, or mandatory country law applies, then the following provisions apply to you:
  a) Australia. You have statutory guarantees under the Australian Consumer Law and nothing in this agreement is intended to affect those rights.
  b) Canada. If you acquired this software in Canada, you may stop receiving updates by turning off the automatic update feature, disconnecting your device from the Internet (if and when you re-connect to the Internet, however, the software will resume checking for and installing updates), or uninstalling the software. The product documentation, if any, may also specify how to turn off updates for your specific device or software.
  c) Germany and Austria.
    i. Warranty. The properly licensed software will perform substantially as described in any Microsoft materials that accompany the software. However, Microsoft gives no contractual guarantee in relation to the licensed software.
    ii. Limitation of Liability. In case of intentional conduct, gross negligence, claims based on the Product Liability Act, as well as, in case of death or personal or physical injury, Microsoft is liable according to the statutory law.
  Subject to the foregoing clause ii., Microsoft will only be liable for slight negligence if Microsoft is in breach of such material contractual obligations, the fulfillment of which facilitate the due performance of this agreement, the breach of which would endanger the purpose of this agreement and the compliance with which a party may constantly trust in (so-called "cardinal obligations"). In other cases of slight negligence, Microsoft will not be liable for slight negligence.
11. DISCLAIMER OF WARRANTY. THE SOFTWARE IS LICENSED “AS IS.” YOU BEAR THE RISK OF USING IT. MICROSOFT GIVES NO EXPRESS WARRANTIES, GUARANTEES, OR CONDITIONS. TO THE EXTENT PERMITTED UNDER APPLICABLE LAWS, MICROSOFT EXCLUDES ALL IMPLIED WARRANTIES, INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
12. LIMITATION ON AND EXCLUSION OF DAMAGES. IF YOU HAVE ANY BASIS FOR RECOVERING DAMAGES DESPITE THE PRECEDING DISCLAIMER OF WARRANTY, YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT, OR INCIDENTAL DAMAGES.
This limitation applies to (a) anything related to the software, services, content (including code) on third party Internet sites, or third party applications; and (b) claims for breach of contract, warranty, guarantee, or condition; strict liability, negligence, or other tort; or any other claim; in each case to the extent permitted by applicable law.
It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your state, province, or country may not allow the exclusion or limitation of incidental, consequential, or other damages.
Please note: As this software is distributed in Canada, some of the clauses in this agreement are provided below in French.
Remarque: Ce logiciel étant distribué au Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en français.
EXONÉRATION DE GARANTIE. Le logiciel visé par une licence est offert « tel quel ». Toute utilisation de ce logiciel est à votre seule risque et péril. Microsoft n’accorde aucune autre garantie expresse. Vous pouvez bénéficier de droits additionnels en vertu du droit local sur la protection des consommateurs, que ce contrat ne peut modifier. La ou elles sont permises par le droit locale, les garanties implicites de qualité marchande, d’adéquation à un usage particulier et d’absence de contrefaçon sont exclues.
LIMITATION DES DOMMAGES-INTÉRÊTS ET EXCLUSION DE RESPONSABILITÉ POUR LES DOMMAGES. Vous pouvez obtenir de Microsoft et de ses fournisseurs une indemnisation en cas de dommages directs uniquement à hauteur de 5,00 $ US. Vous ne pouvez prétendre à aucune indemnisation pour les autres dommages, y compris les dommages spéciaux, indirects ou accessoires et pertes de bénéfices.
Cette limitation concerne:
• tout ce qui est relié au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers; et
• les réclamations au titre de violation de contrat ou de garantie, ou au titre de responsabilité stricte, de négligence ou d’une autre faute dans la limite autorisée par la loi en vigueur.
Elle s’applique également, même si Microsoft connaissait ou devrait connaître l’éventualité d’un tel dommage. Si votre pays n’autorise pas l’exclusion ou la limitation de responsabilité pour les dommages indirects, accessoires ou de quelque nature que ce soit, il se peut que la limitation ou l’exclusion ci-dessus ne s’appliquera pas à votre égard.
EFFET JURIDIQUE. Le présent contrat décrit certains droits juridiques. Vous pourriez avoir d’autres droits prévus par les lois de votre pays. Le présent contrat ne modifie pas les droits que vous confèrent les lois de votre pays si celles-ci ne le permettent pas.
*/

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('azuremaps-maplibre-gl')) :
	typeof define === 'function' && define.amd ? define(['exports', 'azuremaps-maplibre-gl'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.atlas = global.atlas || {}, global.maplibregl));
})(this, (function (exports, maplibregl) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var uuidRandom = {exports: {}};

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: _nodeResolve_empty
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

	(function (module) {

		(function(){

		  var
		    buf,
		    bufIdx = 0,
		    hexBytes = [],
		    i
		  ;

		  // Pre-calculate toString(16) for speed
		  for (i = 0; i < 256; i++) {
		    hexBytes[i] = (i + 0x100).toString(16).substr(1);
		  }

		  // Buffer random numbers for speed
		  // Reduce memory usage by decreasing this number (min 16)
		  // or improve speed by increasing this number (try 16384)
		  uuid.BUFFER_SIZE = 4096;

		  // Binary uuids
		  uuid.bin = uuidBin;

		  // Clear buffer
		  uuid.clearBuffer = function() {
		    buf = null;
		    bufIdx = 0;
		  };

		  // Test for uuid
		  uuid.test = function(uuid) {
		    if (typeof uuid === 'string') {
		      return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid);
		    }
		    return false;
		  };

		  // Node & Browser support
		  var crypt0;
		  if (typeof crypto !== 'undefined') {
		    crypt0 = crypto;
		  } else if( (typeof window !== 'undefined') && (typeof window.msCrypto !== 'undefined')) {
		    crypt0 = window.msCrypto; // IE11
		  }

		  if ((typeof commonjsRequire === 'function')) {
		    crypt0 = crypt0 || require$$0;
		    module.exports = uuid;
		  } else if (typeof window !== 'undefined') {
		    window.uuid = uuid;
		  }

		  // Use best available PRNG
		  // Also expose this so you can override it.
		  uuid.randomBytes = (function(){
		    if (crypt0) {
		      if (crypt0.randomBytes) {
		        return crypt0.randomBytes;
		      }
		      if (crypt0.getRandomValues) {
		        if (typeof Uint8Array.prototype.slice !== 'function') {
		          return function(n) {
		            var bytes = new Uint8Array(n);
		            crypt0.getRandomValues(bytes);
		            return Array.from(bytes);
		          };
		        }
		        return function(n) {
		          var bytes = new Uint8Array(n);
		          crypt0.getRandomValues(bytes);
		          return bytes;
		        };
		      }
		    }
		    return function(n) {
		      var i, r = [];
		      for (i = 0; i < n; i++) {
		        r.push(Math.floor(Math.random() * 256));
		      }
		      return r;
		    };
		  })();

		  // Buffer some random bytes for speed
		  function randomBytesBuffered(n) {
		    if (!buf || ((bufIdx + n) > uuid.BUFFER_SIZE)) {
		      bufIdx = 0;
		      buf = uuid.randomBytes(uuid.BUFFER_SIZE);
		    }
		    return buf.slice(bufIdx, bufIdx += n);
		  }

		  // uuid.bin
		  function uuidBin() {
		    var b = randomBytesBuffered(16);
		    b[6] = (b[6] & 0x0f) | 0x40;
		    b[8] = (b[8] & 0x3f) | 0x80;
		    return b;
		  }

		  // String UUIDv4 (Random)
		  function uuid() {
		    var b = uuidBin();
		    return hexBytes[b[0]] + hexBytes[b[1]] +
		      hexBytes[b[2]] + hexBytes[b[3]] + '-' +
		      hexBytes[b[4]] + hexBytes[b[5]] + '-' +
		      hexBytes[b[6]] + hexBytes[b[7]] + '-' +
		      hexBytes[b[8]] + hexBytes[b[9]] + '-' +
		      hexBytes[b[10]] + hexBytes[b[11]] +
		      hexBytes[b[12]] + hexBytes[b[13]] +
		      hexBytes[b[14]] + hexBytes[b[15]]
		    ;
		  }

		})(); 
	} (uuidRandom));

	var uuidRandomExports = uuidRandom.exports;
	var uuid = /*@__PURE__*/getDefaultExportFromCjs(uuidRandomExports);

	var env = {
		domain: "atlas.microsoft.com",
		staticAssetsDomain: "atlas.microsoft.com",
		stylePath: "styling",
		styleDefinitionsVersion: "2023-01-01",
		appInsightsKey: "e96cb745-c6f5-409c-a775-c4313e468c1d",
		aadInstance: "https://login.microsoftonline.com/"
	};
	var constants = {
		apiVersionQueryParameter: "api-version",
		authorizationHeaderName: "Authorization",
		authorizationTokenPrefix: "Bearer ",
		jwtSasPrefix: "jwt-sas ",
		domainPlaceHolder: "{{azMapsDomain}}",
		legacyDomainPlaceHolder: "{azMapsDomain}",
		viewPlaceHolder: "{{azMapsView}}",
		viewParameter: "view",
		languagePlaceHolder: "{{azMapsLanguage}}",
		stylePathHolder: "{{azMapsStylingPath}}",
		styleResourcePlaceholder: "{{azMapsStylePath}}",
		stylePath: "styling",
		styleResourcePath: "styles",
		styleApiVersion: "2.0",
		mapAgentHeaderName: "Map-Agent",
		msClientIdHeaderName: "x-ms-client-id",
		msOriginHeaderName: "Ms-Am-Request-Origin",
		msOriginHeaderValue: "MapControl",
		aadResourceId: "https://atlas.microsoft.com/.default",
		sessionIdHeaderName: "Session-Id"
	};

	var __values$k = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * @private
	 */
	var Options = /** @class */ (function () {
	    function Options() {
	    }
	    /**
	     * @internal
	     */
	    Options.prototype.merge = function () {
	        var e_1, _a;
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        var defaults;
	        try {
	            for (var valuesList_1 = __values$k(valuesList), valuesList_1_1 = valuesList_1.next(); !valuesList_1_1.done; valuesList_1_1 = valuesList_1.next()) {
	                var values = valuesList_1_1.value;
	                if (!values) {
	                    continue;
	                }
	                for (var property in values) {
	                    if (values.hasOwnProperty(property) && this.hasOwnProperty(property)) {
	                        if (values[property] !== undefined && values[property] != null) {
	                            // Check for nested options and merge them rather than simply overwriting.
	                            if (this[property] instanceof Options) {
	                                this[property].merge(values[property]);
	                            }
	                            else {
	                                this[property] = values[property];
	                            }
	                        }
	                        else {
	                            // Assume a value of undefined or null intends to take the default value.
	                            // Create a new object to access its defaults.
	                            if (!defaults) {
	                                defaults = new (Object.getPrototypeOf(this).constructor)();
	                            }
	                            this[property] = defaults[property];
	                        }
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valuesList_1_1 && !valuesList_1_1.done && (_a = valuesList_1.return)) _a.call(valuesList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return this;
	    };
	    return Options;
	}());

	var __extends$1n = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __read$h = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @private
	 */
	var UrlOptions = /** @class */ (function (_super) {
	    __extends$1n(UrlOptions, _super);
	    function UrlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.domain = undefined;
	        _this.headers = {};
	        _this.path = "";
	        _this.protocol = "https";
	        _this.queryParams = {};
	        _this.subdomain = "";
	        return _this;
	    }
	    return UrlOptions;
	}(Options));
	/**
	 * @private
	 */
	// tslint:disable-next-line:max-classes-per-file
	var Url = /** @class */ (function () {
	    function Url(options) {
	        this.options = new UrlOptions().merge(options);
	    }
	    // tslint:disable-next-line:no-reserved-keywords
	    Url.prototype.get = function () {
	        return fetch(this.toString(), {
	            method: "GET",
	            mode: "cors",
	            headers: new Headers(this.options.headers),
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
	            }
	        });
	    };
	    Url.prototype.toString = function () {
	        var self = this;
	        var queryParamsString = Object.entries(self.options.queryParams)
	            .map(function (_a) {
	            var _b = __read$h(_a, 2), key = _b[0], value = _b[1];
	            return "".concat(key, "=").concat(value);
	        })
	            .join("&");
	        var url = [];
	        var path = self.options.path || "";
	        // If path contains the protocol, don't add domain to the url.
	        if (Url.protoRegEx.test(path)) {
	            url.push(path);
	        }
	        else {
	            // domain may be empty for absolute paths or
	            // path itself might start with '/' for absolute paths
	            if (self.options.domain) {
	                if (!Url.protoRegEx.test(self.options.domain)) {
	                    // If the domain doesn't include a protocol use the separate protocol and subdomain properties.
	                    // If the domain includes a protocol assume it also includes the subdomain.
	                    url.push("".concat(self.options.protocol, "://"));
	                    url.push(self.options.subdomain ? "".concat(self.options.subdomain, ".") : "");
	                }
	                url.push(self.options.domain);
	            }
	            url.push(self.options.path ? "/".concat(path) : "");
	        }
	        url.push(queryParamsString ? "?".concat(queryParamsString) : "");
	        return url.join("");
	    };
	    Url.protoRegEx = new RegExp(/^(((file|http|https):\/\/)|blob:)/i);
	    return Url;
	}());

	/**
	 * A helper class that will parses and splits a culture code into its language and region parts.
	 */
	var CultureCode = /** @class */ (function () {
	    function CultureCode() {
	    }
	    /**
	     * Parses and splits the specified culture code.
	     * Splits based on the last index of "-".
	     * If a split can not be made the specified code will be considered just the language leaving region undefined.
	     * All string properties will be in lowercase for simplified string matching.
	     * @param code The culture code.
	     */
	    CultureCode.parse = function (code) {
	        code = code.toLowerCase();
	        var index = code.lastIndexOf("-");
	        if (index !== -1) {
	            return {
	                code: code,
	                language: code.substring(0, index),
	                region: code.substring(index + 1)
	            };
	        }
	        return {
	            code: code,
	            language: code,
	        };
	    };
	    return CultureCode;
	}());

	/**
	 * A specific implementation of the LocaleIndex interface.
	 * Contains real information about the available/supported locales.
	 */
	var localeIndex = {
	    localizationsPath: "locs/mapcontrol/2019-3-12",
	    sensitiveUserRegions: ["il", "kr", "pk", "in", "cn", "ar", "bh", "eg", "jo", "sa", "kw", "om", "qa", "ma", "ae"],
	    locales: {
	        defaultLanguage: {
	            defaultRegion: {
	                code: "NGT",
	                strings: "en/resource.json"
	            },
	            latn: {
	                code: "NGT-Latn",
	                strings: "en/resource.json"
	            }
	        },
	        ar: {
	            defaultRegion: {
	                code: "ar",
	                strings: "ar-sa/resource.json"
	            }
	        },
	        bg: {
	            defaultRegion: {
	                code: "bg-BG",
	                strings: "bg-bg/resource.json"
	            }
	        },
	        cs: {
	            defaultRegion: {
	                code: "cs-CZ",
	                strings: "cs-cz/resource.json"
	            }
	        },
	        da: {
	            defaultRegion: {
	                code: "da-DK",
	                strings: "da-dk/resource.json"
	            }
	        },
	        de: {
	            defaultRegion: {
	                code: "de-DE",
	                strings: "de-de/resource.json"
	            }
	        },
	        el: {
	            defaultRegion: {
	                code: "el-GR",
	                strings: "el-gr/resource.json"
	            }
	        },
	        en: {
	            defaultRegion: {
	                code: "en",
	                strings: "en/resource.json"
	            },
	            us: {
	                code: "en-US",
	                strings: "en/resource.json"
	            },
	            au: {
	                code: "en-AU",
	                strings: "en/resource.json"
	            },
	            gb: {
	                code: "en-GB",
	                strings: "en/resource.json"
	            },
	            nz: {
	                code: "en-NZ",
	                strings: "en/resource.json"
	            }
	        },
	        es: {
	            defaultRegion: {
	                code: "es-ES",
	                strings: "es-es/resource.json"
	            },
	            mx: {
	                code: "es-MX",
	                strings: "es-mx/resource.json"
	            }
	        },
	        fi: {
	            defaultRegion: {
	                code: "fi-FI",
	                strings: "fi-fi/resource.json"
	            }
	        },
	        fr: {
	            defaultRegion: {
	                code: "fr-FR",
	                strings: "fr-fr/resource.json"
	            }
	        },
	        hu: {
	            defaultRegion: {
	                code: "hu-HU",
	                strings: "hu-hu/resource.json"
	            }
	        },
	        id: {
	            defaultRegion: {
	                code: "id-ID",
	                strings: "id-id/resource.json"
	            }
	        },
	        it: {
	            defaultRegion: {
	                code: "it-IT",
	                strings: "it-it/resource.json"
	            }
	        },
	        ko: {
	            defaultRegion: {
	                code: "ko-KR",
	                strings: "ko-kr/resource.json"
	            }
	        },
	        lt: {
	            defaultRegion: {
	                code: "lt-LT",
	                strings: "lt-lt/resource.json"
	            }
	        },
	        ms: {
	            defaultRegion: {
	                code: "ms-MY",
	                strings: "ms-my/resource.json"
	            }
	        },
	        nb: {
	            defaultRegion: {
	                code: "nb-NO",
	                strings: "nb-no/resource.json"
	            }
	        },
	        nl: {
	            defaultRegion: {
	                code: "nl-NL",
	                strings: "nl-nl/resource.json"
	            }
	        },
	        pl: {
	            defaultRegion: {
	                code: "pl-PL",
	                strings: "pl-pl/resource.json"
	            }
	        },
	        pt: {
	            defaultRegion: {
	                code: "pt-PT",
	                strings: "pt-pt/resource.json"
	            },
	            br: {
	                code: "pt-BR",
	                strings: "pt-br/resource.json"
	            }
	        },
	        ru: {
	            defaultRegion: {
	                code: "ru-RU",
	                strings: "ru-ru/resource.json"
	            }
	        },
	        sk: {
	            defaultRegion: {
	                code: "sk-SK",
	                strings: "sk-sk/resource.json"
	            }
	        },
	        sl: {
	            defaultRegion: {
	                code: "sl-SL",
	                strings: "sl-sl/resource.json"
	            }
	        },
	        sv: {
	            defaultRegion: {
	                code: "sv-SE",
	                strings: "sv-se/resource.json"
	            }
	        },
	        th: {
	            defaultRegion: {
	                code: "th-TH",
	                strings: "th-th/resource.json"
	            }
	        },
	        tr: {
	            defaultRegion: {
	                code: "tr-TR",
	                strings: "tr-tr/resource.json"
	            }
	        },
	        zh: {
	            // per https://microsoft.sharepoint.com/sites/globalreadiness/SitePages/Language-fallback.aspx
	            // Chinese - Neutral (zh) fallbacks to en-US
	            defaultRegion: {
	                code: "zh",
	                strings: "en/resource.json"
	            }
	        },
	        "zh-hans": {
	            defaultRegion: {
	                code: "zh-Hans",
	                strings: "zh-cn/resource.json"
	            },
	            cn: {
	                code: "zh-Hans-CN",
	                strings: "zh-cn/resource.json"
	            }
	        },
	        "zh-hant": {
	            // per discussion with global readiness team, we were explicitly asked to not fallback zh-hant to zh-tw
	            defaultRegion: {
	                code: "zh-Hant",
	                strings: "en/resource.json"
	            },
	            tw: {
	                code: "zh-Hant-TW",
	                strings: "zh-tw/resource.json"
	            }
	        }
	    }
	};

	/**
	 * An interface defining the contents of a specific localized strings json.
	 */
	var LocalizedStrings = /** @class */ (function () {
	    function LocalizedStrings() {
	        /**
	         * A localized version of `"Unknown"`.
	         */
	        this.Unknown = "Unknown";
	        /**
	         * A localized version of `"Accident"`.
	         */
	        this.Accident = "Accident";
	        /**
	         * A localized version of `"Fog"`.
	         */
	        this.Fog = "Fog";
	        /**
	         * A localized version of `"Danger"`.
	         */
	        this.Danger = "Danger";
	        /**
	         * A localized version of `"Rain"`.
	         */
	        this.Rain = "Rain";
	        /**
	         * A localized version of `"Ice"`.
	         */
	        this.Ice = "Ice";
	        /**
	         * A localized version of `"Jam"`.
	         */
	        this.Jam = "Jam";
	        /**
	         * A localized version of `"Lane Closed"`.
	         */
	        this.LaneClosed = "Lane Closed";
	        /**
	         * A localized version of `"Road Closed"`.
	         */
	        this.RoadClosed = "Road Closed";
	        /**
	         * A localized version of `"Road Works"`.
	         */
	        this.RoadWorks = "Road Works";
	        /**
	         * A localized version of `"Wind"`.
	         */
	        this.Wind = "Wind";
	        /**
	         * A localized version of `"Flood"`.
	         */
	        this.Flood = "Flood";
	        /**
	         * A localized version of `"Detour"`.
	         */
	        this.Detour = "Detour";
	    }
	    return LocalizedStrings;
	}());

	/**
	 * A static class used for fetching localized strings and validating supported language codes.
	 */
	var Localizer = /** @class */ (function () {
	    function Localizer() {
	    }
	    /**
	     * Returns a supported culture code that best fits the requested one.
	     * @param locale The requested culture code.
	     */
	    Localizer.getCode = function (locale) {
	        var code = CultureCode.parse(locale);
	        // If the requested culture code includes a sensitive region simply return the original code.
	        // This is to hopefully reduce the risk or providing bad content to users in a sensitive region.
	        return (localeIndex.sensitiveUserRegions.indexOf(code.region) === -1) ?
	            this.getLocaleData(code).code :
	            locale;
	    };
	    /**
	     * Returns a collection of localized strings that best fits the requested culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getStrings = function (locale) {
	        var localeData = this.getLocaleData(locale);
	        // For default locale no need to make a network request
	        // Its value is already defined in LocalizedStrings
	        // This will also make sure that request is not made for Bing maps
	        if (localeIndex.locales.defaultLanguage.defaultRegion.code === localeData.code) {
	            return new Promise(function (resolve) {
	                resolve(new LocalizedStrings());
	            });
	        }
	        else {
	            // Start a GET request
	            var request = new Url({
	                domain: env.staticAssetsDomain,
	                path: "".concat(localeIndex.localizationsPath, "/").concat(localeData.strings)
	            }).get();
	            // Return the response as a LocalizedStrings object.
	            return request.then(function (response) {
	                return response;
	            }, function () {
	                // If the request for the localized strings json fails return a default localization in English.
	                return new LocalizedStrings();
	            });
	        }
	    };
	    /**
	     * Gets the best fit locale data based on the specified culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getLocaleData = function (locale) {
	        // Convert the locale to a culture code if one wasn't already provided.
	        if (typeof locale === "string") {
	            locale = CultureCode.parse(locale);
	        }
	        // Check if the locale could be just the language.
	        // If so return the default locale data for that language.
	        if (localeIndex.locales[locale.code]) {
	            return localeIndex.locales[locale.code].defaultRegion;
	        }
	        // Check if the language is supported.
	        // If not use the default language.
	        var regionIndex;
	        if (localeIndex.locales[locale.language]) {
	            regionIndex = localeIndex.locales[locale.language];
	        }
	        else if (locale.language.indexOf("-") !== -1) {
	            // If the current language can't be matched but there is another "-"
	            // Try to use the language as if it is a full culture code.
	            return this.getLocaleData(locale.language);
	        }
	        else {
	            regionIndex = localeIndex.locales.defaultLanguage;
	        }
	        // Check if the region is supported for the chosen language.
	        // If not use the default region for the chosen language.
	        if (locale.region && regionIndex[locale.region]) {
	            return regionIndex[locale.region];
	        }
	        else {
	            return regionIndex.defaultRegion;
	        }
	    };
	    return Localizer;
	}());

	var UserAgent = /** @class */ (function () {
	    function UserAgent() {
	    }
	    /**
	     * Returns the Edge or IE browser version number.
	     * Edge will be version 12 or greater.
	     * IE will be version 11 or less.
	     * If the browser is not Edge or IE -1 will be returned.
	     */
	    UserAgent.getEdgeOrIEVersion = function () {
	        var ua = window.navigator.userAgent;
	        var msie = ua.indexOf("MSIE ");
	        if (msie > 0) {
	            // IE 10 or older
	            return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
	        }
	        var trident = ua.indexOf("Trident/");
	        if (trident > 0) {
	            // IE 11
	            var rv = ua.indexOf("rv:");
	            return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
	        }
	        var edge = ua.indexOf("Edge/");
	        if (edge > 0) {
	            // Edge (IE 12+)
	            return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
	        }
	        // other browser
	        return -1;
	    };
	    /**
	     * Detects if the browser is IE or Edge.
	     */
	    UserAgent.isEdgeOrIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1;
	    };
	    /**
	     * Detects if the browser is IE but not Edge.
	     */
	    UserAgent.isIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1 && version <= 11;
	    };
	    return UserAgent;
	}());

	var version$2 = "3.5.0";

	/**
	 * A helper class that provides methods for getting various forms of the map controls current version.
	 */
	var Version = /** @class */ (function () {
	    function Version() {
	    }
	    /**
	     * Returns the full version string for the map control.
	     * For example, `"1.3.5"`.
	     */
	    Version.getFullVersion = function () {
	        return version$2;
	    };
	    /**
	     * Returns the endpoint compatible version string for the map control.
	     * For example, `"1.3.5"` becomes `"1.3"`.
	     */
	    Version.getEndpointVersion = function () {
	        // Get the index of the second "."
	        var index = version$2.indexOf(".");
	        index = version$2.indexOf(".", index + 1);
	        // If the index of the second "." can't be found just return the whole version string.
	        if (index === -1) {
	            return version$2;
	        }
	        return version$2.substring(0, index);
	    };
	    return Version;
	}());

	var __extends$1m = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __read$g = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$b = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * An enumeration used to specify the type of authentication mechanism to use.
	 */
	exports.AuthenticationType = void 0;
	(function (AuthenticationType) {
	    /**
	     * The subscription key authentication mechanism.
	     * Literal value `"subscriptionKey"`
	     */
	    AuthenticationType["subscriptionKey"] = "subscriptionKey";
	    /**
	     * The AAD implicit grant mechanism. Recommended for pages protected by a sign-in.
	     * By default the page will be redirected to the AAD login when the map control initializes.
	     * Specify a logged-in `PublicClientApplication` in the `AuthenticationOptions`
	     * for greater control over when/how the users signs in.
	     * Literal value `"aad"`
	     */
	    AuthenticationType["aad"] = "aad";
	    /**
	     * The anonymous authentication mechanism. Recommended for public pages.
	     * Allows a callback responsible for acquiring an authentication token to be provided.
	     * Literal value `"anonymous"`
	     */
	    AuthenticationType["anonymous"] = "anonymous";
	    /**
	     * The shared access signature authentication mechanism. Allows a callback responsible for acquiring a token to be provided on requests.
	     * Literal value `"sas"`.
	     */
	    AuthenticationType["sas"] = "sas";
	})(exports.AuthenticationType || (exports.AuthenticationType = {}));
	/**
	 * Options for specifying how the map control should authenticate with the Azure Maps services.
	 */
	var AuthenticationOptions = /** @class */ (function (_super) {
	    __extends$1m(AuthenticationOptions, _super);
	    function AuthenticationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication mechanism to be used.
	         */
	        _this.authType = undefined;
	        /**
	         * Subscription key from your Azure Maps account.
	         * Must be specified for subscription key authentication type.
	         */
	        _this.subscriptionKey = undefined;
	        /**
	         * The Azure Maps client ID, This is an unique identifier used to identify the maps account.
	         * Preferred to always be specified, but must be specified for AAD and anonymous authentication types.
	         */
	        _this.clientId = undefined;
	        /**
	         * The Azure AD registered app ID. This is the app ID of an app registered in your Azure AD tenant.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadAppId = undefined;
	        /**
	         * The AAD tenant that owns the registered app specified by `aadAppId`.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadTenant = undefined;
	        /**
	         * The AAD instance to use for logging in.
	         * Can be optionally specified when using the AAD authentication type.
	         * By default the `https://login.microsoftonline.com/` instance will be used.
	         */
	        _this.aadInstance = undefined;
	        /**
	         * A callback to use with the anonymous/sas authentication mechanism.
	         * This callback will be responsible for resolving to a authentication token.
	         * E.g. fetching a CORS protected token from an endpoint.
	         */
	        _this.getToken = undefined;
	        /**
	         * Optionally provide an initial token for sas authentication.
	         */
	        _this.sasToken = undefined;
	        /**
	         * Optionally provide an existing `PublicClientApplication` from the MSAL.js library.
	         * This authentication context will be used to acquire the AAD token.
	         * Only used with the AAD authentication type.
	         * This auth context must be configured to use the same AAD app ID as `this.aadAppId`.
	         * If this is not provided all map instances will share their own private auth context.
	         */
	        _this.authContext = undefined;
	        return _this;
	    }
	    /**
	     * Sets the required options to configure the subscription key authentication mechanism.
	     * @param subscriptionKey Subscription Key from your azure maps account
	     */
	    AuthenticationOptions.prototype.setSubscriptionKey = function (key) {
	        this.authType = exports.AuthenticationType.subscriptionKey;
	        this.subscriptionKey = key;
	    };
	    /**
	     * Sets the required authentication options to configure the AAD implicit grant mechanism.
	     * @param clientId Client ID from your azure maps account
	     * @param aadAppId Azure AD App ID
	     * @param aadTenant Azure AD Tenant Name
	     * @param aadInstance An optional Azure AD Instance
	     * @param authContext An optional `PublicClientApplication` from the MSAL.js library
	     */
	    AuthenticationOptions.prototype.setAadProperties = function (clientId, aadAppId, aadTenant, aadInstance, authContext) {
	        this.authType = exports.AuthenticationType.aad;
	        this.authContext = authContext || this.authContext;
	        this.aadInstance = aadInstance || this.aadInstance;
	        this.clientId = clientId;
	        this.aadAppId = aadAppId;
	        this.aadTenant = aadTenant;
	    };
	    /**
	     * Sets the required options to configure the anonymous authentication method.
	     * @param getTokenCallback Callback function responsible for resolving to an authentication token.
	     */
	    AuthenticationOptions.prototype.setTokenCallbackFunction = function (getTokenCallback) {
	        this.authType = exports.AuthenticationType.anonymous;
	        this.getToken = getTokenCallback;
	    };
	    /**
	     * Sets the required options to configure the sas authentication method.
	     * @param getTokenCallback Callback function responsible for resolving to an authentication token.
	     */
	    AuthenticationOptions.prototype.setSasCallbackFunction = function (getTokenCallback) {
	        this.authType = exports.AuthenticationType.sas;
	        this.getToken = getTokenCallback;
	    };
	    /**
	     * Override the standard merge behavior to handle mutually exclusive options.
	     * @internal
	     */
	    AuthenticationOptions.prototype.merge = function () {
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var merged = _super.prototype.merge.apply(this, __spreadArray$b([], __read$g(valueList), false));
	        if (merged.authType === exports.AuthenticationType.subscriptionKey) {
	            merged.authContext = merged.aadAppId = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.aad) {
	            merged.subscriptionKey = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.anonymous) {
	            merged.subscriptionKey = merged.authContext = merged.aadAppId = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.sas) {
	            merged.authContext = merged.subscriptionKey = merged.aadAppId = undefined;
	        }
	        return merged;
	    };
	    return AuthenticationOptions;
	}(Options));

	/**
	 * Test whether the current browser supports Mapbox GL JS
	 * @param {Object} options
	 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] Return `false`
	 *   if the performance of Mapbox GL JS would be dramatically worse than
	 *   expected (i.e. a software renderer is would be used)
	 * @return {boolean}
	 */
	function isSupported$1(options) {
	    return !notSupportedReason(options);
	}

	function notSupportedReason(options) {
	    if (!isBrowser()) return 'not a browser';
	    if (!isArraySupported()) return 'insufficent Array support';
	    if (!isFunctionSupported()) return 'insufficient Function support';
	    if (!isObjectSupported()) return 'insufficient Object support';
	    if (!isJSONSupported()) return 'insufficient JSON support';
	    if (!isWorkerSupported()) return 'insufficient worker support';
	    if (!isUint8ClampedArraySupported()) return 'insufficient Uint8ClampedArray support';
	    if (!isArrayBufferSupported()) return 'insufficient ArrayBuffer support';
	    if (!isCanvasGetImageDataSupported()) return 'insufficient Canvas/getImageData support';
	    if (!isWebGLSupportedCached(options && options.failIfMajorPerformanceCaveat)) return 'insufficient WebGL support';
	    if (!isNotIE()) return 'insufficient ECMAScript 6 support';
	}

	function isBrowser() {
	    return typeof window !== 'undefined' && typeof document !== 'undefined';
	}

	function isArraySupported() {
	    return (
	        Array.prototype &&
	        Array.prototype.every &&
	        Array.prototype.filter &&
	        Array.prototype.forEach &&
	        Array.prototype.indexOf &&
	        Array.prototype.lastIndexOf &&
	        Array.prototype.map &&
	        Array.prototype.some &&
	        Array.prototype.reduce &&
	        Array.prototype.reduceRight &&
	        Array.isArray
	    );
	}

	function isFunctionSupported() {
	    return Function.prototype && Function.prototype.bind;
	}

	function isObjectSupported() {
	    return (
	        Object.keys &&
	        Object.create &&
	        Object.getPrototypeOf &&
	        Object.getOwnPropertyNames &&
	        Object.isSealed &&
	        Object.isFrozen &&
	        Object.isExtensible &&
	        Object.getOwnPropertyDescriptor &&
	        Object.defineProperty &&
	        Object.defineProperties &&
	        Object.seal &&
	        Object.freeze &&
	        Object.preventExtensions
	    );
	}

	function isJSONSupported() {
	    return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
	}

	function isWorkerSupported() {
	    if (!('Worker' in window && 'Blob' in window && 'URL' in window)) {
	        return false;
	    }

	    var blob = new Blob([''], { type: 'text/javascript' });
	    var workerURL = URL.createObjectURL(blob);
	    var supported;
	    var worker;

	    try {
	        worker = new Worker(workerURL);
	        supported = true;
	    } catch (e) {
	        supported = false;
	    }

	    if (worker) {
	        worker.terminate();
	    }
	    URL.revokeObjectURL(workerURL);

	    return supported;
	}

	// IE11 only supports `Uint8ClampedArray` as of version
	// [KB2929437](https://support.microsoft.com/en-us/kb/2929437)
	function isUint8ClampedArraySupported() {
	    return 'Uint8ClampedArray' in window;
	}

	// https://github.com/mapbox/mapbox-gl-supported/issues/19
	function isArrayBufferSupported() {
	    return ArrayBuffer.isView;
	}

	// Some browsers or browser extensions block access to canvas data to prevent fingerprinting.
	// Mapbox GL uses this API to load sprites and images in general.
	function isCanvasGetImageDataSupported() {
	    var canvas = document.createElement('canvas');
	    canvas.width = canvas.height = 1;
	    var context = canvas.getContext('2d');
	    if (!context) {
	        return false;
	    }
	    var imageData = context.getImageData(0, 0, 1, 1);
	    return imageData && imageData.width === canvas.width;
	}

	var isWebGLSupportedCache = {};
	function isWebGLSupportedCached(failIfMajorPerformanceCaveat) {

	    if (isWebGLSupportedCache[failIfMajorPerformanceCaveat] === undefined) {
	        isWebGLSupportedCache[failIfMajorPerformanceCaveat] = isWebGLSupported(failIfMajorPerformanceCaveat);
	    }

	    return isWebGLSupportedCache[failIfMajorPerformanceCaveat];
	}

	isSupported$1.webGLContextAttributes = {
	    antialias: false,
	    alpha: true,
	    stencil: true,
	    depth: true
	};

	function getWebGLContext(failIfMajorPerformanceCaveat) {
	    var canvas = document.createElement('canvas');

	    var attributes = Object.create(isSupported$1.webGLContextAttributes);
	    attributes.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;

	    return (
	        canvas.getContext('webgl', attributes) ||
	        canvas.getContext('experimental-webgl', attributes)
	    );
	}

	function isWebGLSupported(failIfMajorPerformanceCaveat) {
	    var gl = getWebGLContext(failIfMajorPerformanceCaveat);
	    if (!gl) {
	        return false;
	    }

	    // Try compiling a shader and get its compile status. Some browsers like Brave block this API
	    // to prevent fingerprinting. Unfortunately, this also means that Mapbox GL won't work.
	    var shader;
	    try {
	        shader = gl.createShader(gl.VERTEX_SHADER);
	    } catch (e) {
	        // some older browsers throw an exception that `createShader` is not defined
	        // so handle this separately from the case where browsers block `createShader`
	        // for security reasons
	        return false;
	    }

	    if (!shader || gl.isContextLost()) {
	        return false;
	    }
	    gl.shaderSource(shader, 'void main() {}');
	    gl.compileShader(shader);
	    return gl.getShaderParameter(shader, gl.COMPILE_STATUS) === true;
	}

	function isNotIE() {
	    return !document.documentMode;
	}

	var defaultView;
	var defaultLanguage = "NGT";
	var defaultSessionId = uuid();
	var defaultDomain = env.domain;
	var defaultStaticAssetsDomain = env.staticAssetsDomain;
	var defaultStyleDefinitionsPath = env.stylePath;
	var defaultStyleDefinitionsVersion = env.styleDefinitionsVersion;
	var defaultStyleAPIVersion = constants.styleApiVersion;
	var defaultAuthOptions = new AuthenticationOptions();
	var hasSetView = false;
	var hasSetDomain = false;
	var hasSetStyleDefinitionsPath = false;
	var hasSetStyleDefinitionsVersion = false;
	var hasWorkerCount = false;
	var hasMaxParallelImageRequests = false;
	var hasSetLanguage = false;
	var hasSetSessionId = false;
	var hasSetAuthenticationOptions = false;
	/**
	 * Gets the default authentication options that were provided.
	 * If not previously set all properties will be undefined.
	 */
	function getAuthenticationOptions() {
	    return Object.assign({}, defaultAuthOptions);
	}
	/**
	 * Getrs the defawult static assets domain.
	 * @internal
	 */
	function getStaticAssetsDomain() {
	    return defaultStaticAssetsDomain;
	}
	/**
	 * Gets the default domain that was provided.
	 * If not previously set the default value is `"atlas.microsoft.com"`.
	 */
	function getDomain() {
	    return defaultDomain;
	}
	/**
	 * Gets the default styleDefinitionsPath that was provided.
	 * @internal
	 */
	function getStyleDefinitionsPath() {
	    return defaultStyleDefinitionsPath;
	}
	/**
	 * Gets the default styleDefinitionsVersion that was provided.
	 * @internal
	 */
	function getStyleDefinitionsVersion() {
	    return defaultStyleDefinitionsVersion;
	}
	/**
	 * Gets the default styleAPI version that was provided
	 * @internal
	 */
	function getStyleAPIVersion() {
	    return defaultStyleAPIVersion;
	}
	/**
	 * Gets the worker count that will get created.
	 */
	function getWorkerCount() {
	    return maplibregl.getWorkerCount();
	}
	/**
	 * Gets the Maximum number of images (raster tiles, sprites, icons) to load in parallel
	 */
	function getMaxParallelImageRequests() {
	    return maplibregl.getMaxParallelImageRequests();
	}
	/**
	 * Gets the default language that was provided.
	 * If not previously set the default value is `"NGT"`.
	 */
	function getLanguage() {
	    return defaultLanguage;
	}
	/**
	 * Gets the default session id that was provided.
	 * If not previously set the default value is a random UUID.
	 */
	function getSessionId() {
	    return defaultSessionId;
	}
	/**
	 * Gets the default Azure Maps subscription key that was provided.
	 */
	function getSubscriptionKey() {
	    return defaultAuthOptions.authType === exports.AuthenticationType.subscriptionKey ?
	        defaultAuthOptions.subscriptionKey : undefined;
	}
	/**
	 * @deprecated use atlas.getView() instead
	 */
	function getUserRegion() {
	    return defaultView;
	}
	/**
	 * Gets the default view setting of the map control.
	 * If not previously set the default value is `undefined`.
	 */
	function getView() {
	    return defaultView;
	}
	/**
	 * Current API version number based on build number.
	 */
	function getVersion() {
	    return Version.getFullVersion();
	}
	/**
	 * Checks to see if the user's browser is supported by the map control.
	 * @param failIfMajorPerformanceCaveat If true the function will return false
	 * if the performance of the map control would be dramatically worse than expected
	 * (e.g. a software WebGL renderer would be used).
	 */
	function isSupported(failIfMajorPerformanceCaveat) {
	    var result;
	    // Always return false for IE since we don't support it ourselves.
	    result = !UserAgent.isIE();
	    return result;
	}
	/**
	 * Sets your authentication options as the default options in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the authentication options explicitly defined and
	 * setAuthenticationOptions hasn't previously been called it will automatically be called by the Map constructor.
	 * @param options The new default authentication options.
	 */
	function setAuthenticationOptions(options) {
	    defaultAuthOptions = new AuthenticationOptions().merge(defaultAuthOptions, options);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * Sets the default domain used by the map and service modules unless the
	 * domain is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the domain explicitly defined and
	 * setDomain hasn't previously been called it will automatically be called by the Map constructor.
	 * If the protocol is not specified `https` is assumed.
	 * @param domain The new default domain.
	 */
	function setDomain(domain) {
	    defaultDomain = domain;
	    hasSetDomain = true;
	}
	/**
	 * Sets the default styleDefinitionsPath to use for getting the map styles.
	 * If a Map is initialized with the styleDefinitionsPath explicitly defined and
	 * setStyleDefinitionsPath hasn't previously been called it will automatically be called by the Map constructor.
	 * @param styleDefinitionsPath The new default styleDefinitionsPath.
	 * @internal
	 */
	function setStyleDefinitionsPath(styleDefinitionsPath) {
	    defaultStyleDefinitionsPath = styleDefinitionsPath;
	    hasSetStyleDefinitionsPath = true;
	}
	/**
	 * Sets the default styleDefinitionsVersion to use when requesting style definitions
	 * from styleDefinitionsPath.  If a map is initialized with the with the styleDefinitionsVersion
	 * explicitly defined and setStyleDefinitionsVersion hasn't previously been called it will be
	 * automatically called by the Map constructor.
	 * @param styleDefinitionsVersion
	 */
	function setStyleDefinitionsVersion(styleDefinitionsVersion) {
	    defaultStyleDefinitionsVersion = styleDefinitionsVersion;
	    hasSetStyleDefinitionsVersion = true;
	}
	function setStyleAPIVersion(styleAPIVersion) {
	    defaultStyleAPIVersion = styleAPIVersion;
	}
	/**
	 * Sets number of web workers instantiated on a page.
	 * By default, it is set to half the number of CPU cores (capped at 6).
	 * @param workerCount worker count.
	 */
	function setWorkerCount(workerCount) {
	    if (workerCount > 0) {
	        maplibregl.setWorkerCount(workerCount);
	        hasWorkerCount = true;
	    }
	}
	/**
	 * Sets Maximum number of images (raster tiles, sprites, icons) to load in parallel,
	 * which affects performance in raster-heavy maps. 16 by default.
	 * @param maxParallelImageRequests Maximum number of images to load in parallel.
	 */
	function setMaxParallelImageRequests(maxParallelImageRequests) {
	    if (maxParallelImageRequests > 0) {
	        maplibregl.setMaxParallelImageRequests(maxParallelImageRequests);
	        hasMaxParallelImageRequests = true;
	    }
	}
	/**
	 * Sets the default language used by the map and service modules unless the
	 * language is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the language explicitly defined and
	 * setLanguage hasn't previously been called it will automatically be called by the Map constructor.
	 * @param language The new default language.
	 */
	function setLanguage(language) {
	    // Find the best fit supported language.
	    defaultLanguage = Localizer.getCode(language);
	    hasSetLanguage = true;
	}
	/**
	 * Sets the default session id used by the map and service modules unless the
	 * session id is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the session ID explicitly defined and
	 * setSessionId hasn't previously been called it will automatically be called by the Map constructor.
	 * @param id The new default session id.
	 */
	function setSessionId(id) {
	    defaultSessionId = id;
	    hasSetSessionId = true;
	}
	/**
	 * Sets your Azure Maps subscription key as the default subscription key in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the subscription key explicitly defined and
	 * setSubscriptionKey hasn't previously been called it will automatically be called by the Map constructor.
	 * @param key The new default subscription key.
	 */
	function setSubscriptionKey(key) {
	    defaultAuthOptions.setSubscriptionKey(key);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * @deprecated use atlas.setView(view: string) instead.
	 */
	function setUserRegion(userRegion) {
	    defaultView = userRegion;
	    hasSetView = true;
	}
	/**
	 * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	 * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews }.
	 * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country/region where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	 * @param view The new default view
	 */
	function setView(view) {
	    defaultView = view;
	    hasSetView = true;
	}
	/**
	 * Adds an image template to the atlas namespace.
	 * @param templateName The name of the template.
	 * @param template The SVG template to add. Supports {color}, {secondaryColor}, {scale}, {text}.
	 * @param override Specifies if it should override existing templates if one with the same name already exists.
	 */
	function addImageTemplate(templateName, template, override) {
	    if (override || !imageTemplates[templateName.toLowerCase()]) {
	        imageTemplates[templateName.toLowerCase()] = template;
	    }
	}
	/**
	 * Retrieves an SVG template by name.
	 * @param templateName The name of the template to retrieve.
	 * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	 */
	function getImageTemplate(templateName, scale) {
	    scale = Math.abs(scale || 1);
	    if (typeof templateName === "string" && imageTemplates[templateName.toLowerCase()]) {
	        var template = imageTemplates[templateName.toLowerCase()];
	        // Firefox/Edge don't support calc for inline SVG's. Need to manually calculate this.
	        var pattern = /calc\(([0-9.]+)[px]*\s*\*\s*\{scale\}\)/gi;
	        var t = template;
	        var match = pattern.exec(template);
	        while (match) {
	            t = t.replace(match[0], parseFloat(match[1]) * scale + "");
	            match = pattern.exec(template);
	        }
	        // Just for good measure incase the pattern doesn't match.
	        t = t.replace("{scale}", scale + "");
	        return t;
	    }
	    else {
	        throw new Error("Invalid templateName.");
	    }
	}
	/**
	 * Retrieves an array of names for all image templates that are available in the atlas namespace.
	 */
	function getAllImageTemplateNames() {
	    return Object.keys(imageTemplates);
	}
	/**
	 * Initializes resources like WebWorkers that can be shared across maps to lower load
	 * times in some situations. `atlas.setWorkerCount`, if being
	 * used, must be set before `prewarm()` is called to have an effect.
	 *
	 * By default, the lifecycle of these resources is managed automatically, and they are
	 * lazily initialized when a Map is first created. By invoking `prewarm()`, these
	 * resources will be created ahead of time, and will not be cleared when the last Map
	 * is removed from the page. This allows them to be re-used by new Map instances that
	 * are created later. They can be manually cleared by calling
	 * `atlas.clearPrewarmedResources()`. This is only necessary if your web page remains
	 * active but stops using maps altogether.
	 *
	 * This is primarily useful when using GL-JS maps in a single page app, wherein a user
	 * would navigate between various views that can cause Map instances to constantly be
	 * created and destroyed.
	 */
	function prewarm() {
	    maplibregl.prewarm();
	}
	/**
	 * Clears up resources that have previously been created by `atlas.prewarm()`.
	 * Note that this is typically not necessary. You should only call this function
	 * if you expect the user of your app to not return to a Map view at any point
	 * in your application.
	 */
	function clearPrewarmedResources() {
	    maplibregl.clearPrewarmedResources();
	}
	/**
	 * Adds a custom load resource function that will be called when using a URL that starts with a custom url schema.
	 * @param customProtocol - the protocol to hook, for example 'custom'
	 * @param loadFn - the function to use when trying to fetch a tile specified by the customProtocol
	 */
	function addProtocol(customProtocol, loadFn) {
	    maplibregl.addProtocol(customProtocol, loadFn);
	}
	/**
	 * Removes a previously added protocol in the main thread.
	 * @param customProtocol - the custom protocol to remove registration for
	 */
	function removeProtocol(customProtocol) {
	    maplibregl.removeProtocol(customProtocol);
	}
	/**
	 * Returns if authentication options are set.
	 * @internal
	 */
	function _hasSetAuthenticationOptions() {
	    return hasSetAuthenticationOptions;
	}
	/**
	 * Returns if the default domain has been set yet.
	 * @internal
	 */
	function _hasSetDomain() {
	    return hasSetDomain;
	}
	/**
	 * Returns if the default StyleDefinitionsPath has been set yet.
	 * @internal
	 */
	function _hasSetStyleDefinitionsPath() {
	    return hasSetStyleDefinitionsPath;
	}
	/**
	 * Returns if the default StyleDefinitionsVersion has been set yet.
	 * @internal
	 */
	function _hasSetStyleDefinitionsVersion() {
	    return hasSetStyleDefinitionsVersion;
	}
	/**
	 * Returns if the default workerCount has been set yet.
	 * @internal
	 */
	function _hasWorkerCount() {
	    return hasWorkerCount;
	}
	/**
	 * Returns if the default MaxParallelImageRequests has been set yet.
	 * @internal
	 */
	function _hasMaxParallelImageRequests() {
	    return hasMaxParallelImageRequests;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetLanguage() {
	    return hasSetLanguage;
	}
	/**
	 * Returns is a default session id has been set yet.
	 * @internal
	 */
	function _hasSetSessionId() {
	    return hasSetSessionId;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetView() {
	    return hasSetView;
	}
	/**
	 * Gets the base domain used for asset retrieval.
	 * @internal
	 */
	function _getAssetDomain() {
	    return env.domain;
	}
	/**
	 * Gets the base domain used for general map services.
	 * @internal
	 */
	// TODO Remove once all internal dependencies of this function are gone.
	function _getDomain() {
	    return getDomain();
	}
	/**
	 * Enable the map's RTL text plugin. Necessary for supporting the Arabic and Hebrew languages, which are written right-to-left.
	 * @internal
	 */
	function _enableRTLTextPlugin() {
	    var rtlPluginUrl = new Url({
	        domain: env.staticAssetsDomain,
	        path: "sdk/javascript/mapcontrol/".concat(Version.getEndpointVersion(), "/mapbox-gl-rtl-text.min.js")
	    });
	    maplibregl.setRTLTextPlugin(rtlPluginUrl.toString(), true).catch(function (error) {
	        if (error) {
	            console.warn(error);
	        }
	    });
	}
	var imageTemplates = {
	    /**********************
	     * Marker templates
	     **********************/
	    // Default built in marker. Supports {color} and {secondaryColor}
	    "marker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 26 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><text x="12.5" y="17.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:2"/><text x="12.5" y="18.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-circle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><circle cx="12.5" cy="12.5" r="9" fill="{secondaryColor}"/><text x="12" y="17.5" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(24 * {scale})" height="calc(28 * {scale})" viewBox="0 0 24 28"><path d="m11.988 16.615a5.15 5.15 0 0 1-2.268-.525 4.909 4.909 0 0 1-2.805-4.442 5.019 5.019 0 0 1 5.072-4.936h.012a5.03 5.03 0 0 1 5.085 4.961 4.907 4.907 0 0 1-.549 2.224 5.114 5.114 0 0 1-4.548 2.718zm0-8.06a3.173 3.173 0 0 0-3.226 3.099 3.081 3.081 0 0 0 1.77 2.782 3.299 3.299 0 0 0 4.365-1.386 3.049 3.049 0 0 0 .342-1.381 3.184 3.184 0 0 0-3.239-3.114h-.012z" fill="{secondaryColor}"/><path d="m11.999.922a10.908 10.908 0 0 0-11.076 10.732 10.639 10.639 0 0 0 4.418 8.598l6.658 6.464 6.658-6.463a10.537 10.537 0 0 0 2.198-15.041 11.182 11.182 0 0 0-8.856-4.289zm1.873 14.341a4.221 4.221 0 0 1-5.589-1.789 3.945 3.945 0 0 1-.445-1.8 4.164 4.164 0 0 1 8.323-.037 4.028 4.028 0 0 1-2.289 3.626Z" fill="{color}"/><path d="m11.999 28-7.256-7.044a11.611 11.611 0 0 1-4.743-9.303 11.844 11.844 0 0 1 11.988-11.652.102 .102 0 0 1 .02 0 12.164 12.164 0 0 1 9.577 4.647 11.357 11.357 0 0 1 2.299 8.614 11.521 11.521 0 0 1-4.63 7.695zm-.01-26.157a9.997 9.997 0 0 0-10.143 9.812 9.769 9.769 0 0 0 4.04 7.853l.099.083 6.014 5.838 6.113-5.922a9.7 9.7 0 0 0 3.945-6.505 9.533 9.533 0 0 0-1.933-7.229 10.305 10.305 0 0 0-8.116-3.931h-.021zm.021 14.772a5.11 5.11 0 0 1-4.547-2.718 4.868 4.868 0 0 1 .932-5.743 5.118 5.118 0 0 1 3.58-1.46h.024a5.031 5.031 0 0 1 5.084 4.938 4.92 4.92 0 0 1-2.805 4.457h0a5.152 5.152 0 0 1-2.269.525zm-.011-8.079h-.015a3.277 3.277 0 0 0-2.295.933 3.029 3.029 0 0 0-.587 3.58 3.297 3.297 0 0 0 4.364 1.386h0a3.092 3.092 0 0 0 1.772-2.795 3.185 3.185 0 0 0-3.239-3.105z" fill="{secondaryColor}"/><text x="12" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin-round style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin-round": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25 * {scale})" height="calc(25 * {scale})" viewBox="0 0 25 25"><g transform="translate(0 1)"><circle cx="12.25" cy="11.5833" r="11" fill="{color}"/><path d="m12.25 23.583a12 12 0 1 1 12-12 12 12 0 0 1-12 12zm0-22a10 10 0 1 0 10 10 10 10 0 0 0-10-10z" fill="{secondaryColor}"/><circle cx="12.25" cy="11.5833" r="4.2386" fill="{secondaryColor}"/></g><text x="12.5" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-flat": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(42.8 * {scale})"  viewBox="0 0 1600 2570"><g fill="{color}"><path d="M691 2419c-409-575-641-1086-683-1504-10-106-10-136 5-224 31-188 105-330 241-458 129-124 270-190 453-214 69-9 113-10 182-1 373 46 655 326 703 698 40 308-120 801-424 1309-134 224-348 535-369 535-4 0-53-63-108-141z"/></g><g fill="rgba(0,0,0,0.15)" style="transform:scale(-1,1);transform-origin:center"><path d="M691 2419c-407-571-639-1083-682-1498-14-139-3-249 37-371 69-208 254-402 459-481 68-27 217-59 271-59h24v160 180 940 635c0 349-2 635-5 635-2 0-49-63-104-141z"/></g><circle cx="800" cy="800" r="600" fill="{secondaryColor}"/><text x="800" y="1100" style="font-size:800px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-arrow": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25.47 * {scale})" height="calc(35.18 * {scale})" viewBox="0 0 4330 5980"><g fill="{color}"><path d="m2080 5969c-49-20-93-63-115-113-25-55-1928-5486-1953-5573-40-138 67-282 210-283 36 0 246 73 987 345 518 190 947 345 955 345 8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29-33 0-71-5-85-10z"/></g><g fill="{secondaryColor}"><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z"/><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z" style="transform:scale(-1,1);transform-origin:center"/></g><g fill="rgba(0,0,0,0.2)" ><path d="m2165 685c8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29z"/></g><text x="2165" y="3300" style="font-size:2500px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-ball-pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15.67 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 235 452"><g transform="translate(-135 10)"><path fill="{secondaryColor}" d="m256 442 0 0c-13 0-18-11-18-24l-6-323c0-13 11-24 24-24h0c13 0 24 11 24 24l-6 323c0 13-5 24-18 24z"/><circle style="fill:{color};stroke-width:10;stroke:{secondaryColor}" cx="256" cy="112" r="111"/><ellipse transform="matrix(0.834 0.5518 -0.5518 0.834 65.7916 -97.18)" fill="rgba(255,255,255,0.3)" cx="194.399" cy="60.749" rx="19.076" ry="32.428"/></g><text x="117.5" y="160" style="font-size:160px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.67 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2000 2420"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M845 2152c-22-37-58-95-80-129-22-35-62-99-90-143l-50-80-312 0-313 0 0-900 0-900 900 0 900 0 0 900 0 900-313 0-313 0-34 58c-19 31-38 59-42 60-5 2-8 8-8 12 0 9-69 123-88 145-5 6-11 15-13 21-16 39-77 123-89 124-8 0-33-31-55-68z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(38.8 * {scale})" viewBox="0 0 2500 2910"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m866 2652c-17-31-37-68-46-82-9-14-32-54-51-90-19-36-50-92-70-125l-36-60-332-3-331-2 0-905 0-905 660 0 660 0 0-38c0-71 50-196 102-258 71-85 189-164 244-164 12 0 26-4 29-10 8-13 222-13 230 0 3 6 17 10 30 10 25 0 117 45 154 76 130 107 191 232 191 392 0 155-63 284-190 386-36 29-129 76-150 76-11 0-22 5-25 10-3 6-31 10-61 10l-54 0 0 660 0 660-332 2-332 3-29 50c-17 28-48 84-70 125-22 41-47 86-56 100-9 14-30 51-46 83-17 32-36 57-45 57-8 0-28-25-44-58z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.8 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2010 2410"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M856 2155c-20-30-36-59-36-65 0-5-4-10-10-10-5 0-10-5-10-11 0-5-18-37-40-69-22-32-40-64-40-69 0-6-4-11-10-11-5 0-10-5-10-10 0-6-15-33-32-60l-33-50-127 0c-74 0-129-4-133-10-3-5-17-10-30-10-25 0-116-45-155-76-87-69-142-151-178-265-15-46-17-1075-2-1084 5-3 10-17 10-30 0-13 5-27 10-30 6-3 10-13 10-22 0-22 83-135 122-168 57-46 62-50 112-75l50-25 585 0 586 0 63 34c84 46 169 133 212 218l35 68 0 565 0 565-28 59c-32 69-100 157-139 180-15 9-33 22-40 29-23 22-99 57-123 57-13 0-27 5-30 10-4 6-60 10-135 10l-128 0-128 205c-84 136-133 205-144 205-10 0-33-24-54-55z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(32.13 * {scale})" viewBox="0 0 2500 2900"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m874 2669c-9-18-26-49-37-68-11-20-30-55-43-78-13-24-36-64-51-90-14-27-38-69-52-95l-26-48-142 0c-84 0-144-4-148-10-3-5-17-10-30-10-25 0-118-46-154-76-91-76-136-142-175-254-13-38-16-119-16-554 0-358 3-520 12-545 40-125 106-219 195-278 127-84 116-83 646-83l467 0 0-42c0-46 11-87 45-163 54-121 169-220 306-264 46-14 232-14 278 0 165 53 284 175 340 350 19 61 14 204-10 273-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-3 6-28 10-56 10l-49 0 0 462c0 446-1 464-21 522-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-4 6-65 10-149 10-138 0-143 1-154 23-12 23-62 114-112 202-16 28-44 79-63 115-42 77-67 88-93 39z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(23.5 * {scale})" height="calc(40 * {scale})" viewBox="34 28 198 308"><path style="stroke:{secondaryColor};stroke-width:15;stroke-linecap:round;" d="M42 327l0 -291"/><path style="fill:{color};stroke:{secondaryColor};stroke-width:10;stroke-linejoin:round;" d="M49 50c70 30 104 28 178 2-21 42-21 74 0 116-72 25-101 25-178 0l0-118z"/><text x="130" y="165" style="font-size:100px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag-triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(35.33 * {scale})" viewBox="0 0 40.5 53"><g transform="translate(-31 -20)"><path fill="{secondaryColor}" d="M34.7,73.3V48.4l34.6-10.1c0.7-0.2,1.2-0.8,1.2-1.5s-0.4-1.4-1-1.7L33.7,20.5c-0.5-0.2-1.1-0.2-1.6,0.2 c-0.5,0.3-0.7,0.8-0.7,1.4v51.2H34.7z"/><polygon points="34.7,24.5 66,36.5 34.7,45 34.7,10" fill="{color}"/></g><text x="11" y="21" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(34 * {scale})" height="calc(34 * {scale})" viewBox="0 0 34 34"><g transform="translate(2 2)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17" y="22" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(38 * {scale})" height="calc(38 * {scale})" viewBox="0 0 38 38"><g transform="translate(4 4)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19" y="24" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(36 * {scale})" height="calc(36 * {scale})" viewBox="0 0 36 36"><g transform="translate(2 2)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="30" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><g transform="translate(4 4)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="32" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(35 * {scale})" height="calc(40 * {scale})" viewBox="0 0 35 40"><g transform="translate(2 2)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="25" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(39 * {scale})" height="calc(44 * {scale})" viewBox="0 0 39 44"><g transform="translate(4 4)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="27" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1100 1100"><g transform="translate(50 50)"><path style="stroke:{secondaryColor};stroke-width:50;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="550" y="700" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1200 1200"><g transform="translate(100 100)"><path style="stroke:{secondaryColor};stroke-width:100;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="600" y="750" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="12,0 0,24 12,17 24,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="17" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-left": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="24,12 0,0 7,12 0,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="16.5" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(12.16 * {scale})" height="calc(30.1 * {scale})" viewBox="0 0 902 364"><g fill="{color}" transform="matrix(0,2.4,-2.4,0,897,-930)"><polygon points="902,222 233,222 233,364 0,182 233,0 233,141 902,141 902,222"/></g><text x="450" y="700" style="font-size:900px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "arrow-up-thin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 12 25"><g transform="translate(-136.91823 -751.91998)"><path fill="{color}" d="m148.271 760.71c-1.641-.547-3.186-1.47-4.633-2.769l0 18.07-1.675 0 0-18.07c-1.447 1.299-2.986 2.222-4.616 2.769l0-1.231c2.325-1.596 4.006-3.812 5.043-6.65l.838 0c1.037 2.838 2.718 5.055 5.043 6.65l0 1.231z"/></g><text x="6" y="20" style="font-size:10px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "car": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(21.93 * {scale})" height="calc(40.9 * {scale})" viewBox="0 0 6580 12270"><g transform="translate(0 12270) rotate(-90)"><path fill="{secondaryColor}" d="M7045 6566c-42-13-105-44-105-51 0-2 23-105 50-228 28-123 50-230 50-236 0-8-241-11-907-11-855 0-1145 6-1513 30-85 6-189 13-230 15-41 3-133 10-205 15-286 21-430 32-705 50-953 63-1459 18-2335-205-304-77-746-209-799-238-131-72-221-408-285-1062-34-345-42-532-48-1130-16-1557 108-2532 336-2649 32-17 469-149 676-205 409-110 819-191 1205-238 116-14 224-18 540-18 395 1 494 5 1140 50 1124 79 1224 82 2496 78l641-3-53-237c-29-131-52-238-51-239 1-1 31-14 66-29 56-23 76-26 142-23 67 3 83 7 120 33 23 17 50 41 61 55 10 14 51 117 91 230l73 205 674 3 675 2 90-39c98-43 198-72 315-93 122-21 829-18 990 5 321 45 626 143 849 270 293 168 516 378 704 662 266 402 416 893 467 1527 15 174 8 882-9 998-6 41-18 127-27 190-69 502-253 969-523 1325-79 105-262 284-381 374-189 142-355 229-574 300-336 110-526 139-952 148-457 9-685-23-887-124l-47-24-678-6-678-6-64 179c-79 224-92 253-121 284-67 70-177 97-274 66zm-2752-5073c-23-2-64-2-90 0-26 2-7 3 42 3 50 0 71-1 48-3zm395 0c-21-2-55-2-75 0-21 2-4 4 37 4 41 0 58-2 38-4z"/><path fill="{color}" d="M7043 6498c-13-6-23-19-23-28 0-9 23-117 50-240 28-123 50-230 50-237 0-22-2126-13-2465 10-132 10-400 28-595 42-661 47-824 55-1160 62-435 7-656-8-1040-73-415-70-865-183-1447-365-168-53-272-556-325-1569-16-319-16-1311 0-1630 45-872 129-1366 257-1518 22-26 51-39 172-77 557-177 1122-310 1563-369 271-36 351-40 690-40 361 1 463 6 1165 54 1122 78 1288 83 2337 79 460-2 840-7 843-11 4-4-17-117-47-252l-55-245 39-16c76-30 180-8 224 47 10 13 54 124 98 246l79 222 709 0 709 0 47-24c74-37 219-83 322-101 122-22 606-32 802-16 374 29 658 102 933 238 124 62 271 155 361 230l61 51 6 100c19 278 103 497 247 643 88 89 173 136 278 152l70 11 41 131c116 369 159 673 168 1170 10 584-38 984-167 1397l-40 126-70 12c-193 33-348 175-441 405-56 139-89 302-89 445 0 43-3 47-58 91-290 235-644 384-1068 450-191 29-796 39-974 16-135-18-263-54-368-102l-75-35-701 0-701 0-79 223c-82 232-102 267-163 293-38 16-138 17-170 2zm-2023-820c332-15 1155-12 1835 6 308 8 563 12 566 8 4-4 10-21 13-38 7-30 6-31-92-77-518-244-1197-396-2112-474-295-25-1282-25-1579 0-231 20-473 46-479 51-6 7 49 110 93 171 160 226 416 335 855 365 142 10 539 5 900-12zm3304-263c525-111 899-887 934-1935 19-557-37-1023-172-1435-186-563-521-900-896-899-81 0-158 14-525 92-426 91-431 92-540 146-195 96-287 207-306 368-12 104-11 2985 1 3078 22 170 135 291 365 389 49 21 191 55 480 115 226 47 419 87 430 89 45 10 164 6 229-8zm-5570-485c112-43 197-156 216-291 12-83 13-2623 1-2706-23-158-125-273-270-304-44-9-100-1-542 75-272 47-514 91-539 98-266 68-487 424-594 958-56 280-70 548-40 800 56 484 207 878 414 1081 115 114 122 116 702 218 277 49 524 90 550 90 26 1 72-8 102-19zm2111-3440c1023-44 1884-213 2462-486l113-53-7-33c-3-18-8-35-10-37-2-3-236 1-521 7-993 24-1271 26-1708 11-541-18-1128-18-1249-1-377 56-588 181-734 437-32 55-41 79-32 84 12 8 246 32 491 51 356 28 815 36 1195 20z"/></g><text x="3250" y="8250" style="font-size:3000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    /**********************
	     * Fill Patterns
	     **********************/
	    "checker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 16 16"><pattern id="p" x="0" y="0" width="16" height="16" patternUnits="userSpaceOnUse"><rect fill="{color}" x="0" width="8" height="8" y="0"/><rect fill="{color}" x="8" width="8" height="8" y="8"/></pattern><rect x="0" y="0" width="16" height="16" fill="{secondaryColor}"/><rect x="0" y="0" width="16" height="16" fill="url(#p)"/></svg>',
	    "checker-rotated": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 60 60"><rect width="60" height="60" fill="{secondaryColor}"/><rect width="42.42" height="42.42" transform="translate(30 0) rotate(45)" fill="{color}"/></svg>',
	    "zig-zag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 120 60 120 90 90 120 60 120 0 120 0 60 60 0 0 0 60 30 90 60 120 120 120"/></svg>',
	    "zig-zag-vertical": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 0 120 60 90 30 60 0 0 0 0 0 60 60 0 120 60 120 90 90 120 60 120 0"/></svg>',
	    "circles-spaced": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="2" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "circles": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(7 * {scale})" height="calc(7 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="6" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "diagonal-lines-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-lines-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-stripes-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "diagonal-stripes-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(14 * {scale})" height="calc(14 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(45 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}" transform="rotate(-45 3 3)"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-stripes": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "x-fill": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="45.3" height="45.3" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z"/></g></svg>',
	    "dots": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(13 * {scale})" height="calc(13 * {scale})" viewBox="0 0 20 20"><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><g fill="{color}"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>'
	};

	/** The vertical distance between the tooltip and its target */
	var tooltipVerticalOffset = 4;
	/**
	  * Creates tooltip content element
	  */
	var buildAccessibleTooltip = function (name) {
	    var tooltipContent = document.createElement("span");
	    tooltipContent.innerText = name;
	    tooltipContent.classList.add('tooltiptext');
	    if (navigator.userAgent.indexOf('Edg') != -1) {
	        tooltipContent.classList.add('edge');
	    }
	    else if (navigator.userAgent.indexOf('Chrome') != -1) {
	        tooltipContent.classList.add('chrome');
	    }
	    else if (navigator.userAgent.indexOf('Safari') != -1) {
	        tooltipContent.classList.add('safari');
	    }
	    else if (navigator.userAgent.indexOf('Firefox') != -1) {
	        tooltipContent.classList.add('firefox');
	    }
	    if (navigator.userAgent.indexOf('Windows') != -1) {
	        tooltipContent.classList.add('win');
	    }
	    else if (navigator.userAgent.indexOf('Macintosh') != -1) {
	        tooltipContent.classList.add('mac');
	    }
	    return tooltipContent;
	};
	/**
	 * Determines tooltip position
	 * @param tooltip tooltip to position
	 * @param eventTarget target element that tooltip is bound to
	 * @param forceAbsolute position:fixed is generally desired, however since tooltip is positioned alongside the target,
	 *  the runtime transform of the parent container(maplibre marker) will apply to tooltip as well, in such case resort to position:absolute
	 */
	var positionTooltip = function (tooltip, eventTarget, forceAbsolute) {
	    if (forceAbsolute === void 0) { forceAbsolute = false; }
	    var positionTooltip = function (event) {
	        var buttonRect = eventTarget.getBoundingClientRect();
	        var tooltipRect = tooltip.getBoundingClientRect();
	        var left, top;
	        if ((buttonRect.x + tooltipRect.width) > window.innerWidth) {
	            // the tooltip body may not fit the visible window width
	            left = window.innerWidth - tooltipRect.width;
	        }
	        else {
	            left = buttonRect.x;
	        }
	        if ((buttonRect.y + buttonRect.height + tooltipRect.height + tooltipVerticalOffset) > window.innerHeight) {
	            // the tooltip body may not fit the visible window height
	            // position above the target element
	            top = buttonRect.y - tooltipRect.height - tooltipVerticalOffset;
	        }
	        else {
	            top = buttonRect.y + buttonRect.height + tooltipVerticalOffset;
	        }
	        if (forceAbsolute && eventTarget.parentElement) {
	            var parentRect = eventTarget.parentElement ? eventTarget.parentElement.getBoundingClientRect() : null;
	            tooltip.style.position = 'absolute';
	            left = left - parentRect.x;
	            top = top - parentRect.y;
	        }
	        tooltip.style.transform = "translate(".concat(left, "px, ").concat(top, "px)");
	        tooltip.style.display = "block";
	    };
	    // Accessibility: tooltip should be dismissible with the escape key
	    var dismissTooltip = function (event) {
	        if ((event.key === "Escape" || event.key === "Esc") && tooltip.style.display === "block") {
	            event.stopPropagation();
	            tooltip.style.display = "none";
	        }
	    };
	    eventTarget.addEventListener("mouseover", positionTooltip);
	    eventTarget.addEventListener("focusin", positionTooltip);
	    eventTarget.addEventListener("keydown", dismissTooltip);
	};

	var __extends$1l = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Positions where the control can be placed on the map.
	 */
	exports.ControlPosition = void 0;
	(function (ControlPosition) {
	    /**
	     * Places the control in the top left of the map.
	     * Literal value `"top-left"`
	     */
	    ControlPosition["TopLeft"] = "top-left";
	    /**
	     * Places the control in the top right of the map.
	     * Literal value `"top-right"`
	     */
	    ControlPosition["TopRight"] = "top-right";
	    /**
	     * Places the control in the bottom left of the map.
	     * Literal value `"bottom-left"`
	     */
	    ControlPosition["BottomLeft"] = "bottom-left";
	    /**
	     * Places the control in the bottom right of the map.
	     * Literal value `"bottom-right"`
	     */
	    ControlPosition["BottomRight"] = "bottom-right";
	    /**
	     * The control will place itself in its default location.
	     * Literal value `"non-fixed"`
	     */
	    ControlPosition["NonFixed"] = "non-fixed";
	})(exports.ControlPosition || (exports.ControlPosition = {}));
	/**
	 * The options for adding a control to the map.
	 */
	var ControlOptions = /** @class */ (function (_super) {
	    __extends$1l(ControlOptions, _super);
	    function ControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The position the control will be placed on the map. If not specified, the control will be located at the
	         * default position it defines.
	         * default `ControlPosition.NonFixed`
	         * @default ControlPosition.NonFixed
	         */
	        _this.position = exports.ControlPosition.NonFixed;
	        return _this;
	    }
	    return ControlOptions;
	}(Options));

	/**
	 * Color helper class to get the RGBA and luminosity of the color
	 * @private
	 */
	var Color = /** @class */ (function () {
	    function Color(color) {
	        if (color) {
	            var rgba = void 0;
	            if (typeof color === "string") {
	                rgba = this.getRBGA(color);
	            }
	            else {
	                rgba = color;
	            }
	            if (rgba.length >= 3) {
	                this.r = rgba[0];
	                this.g = rgba[1];
	                this.b = rgba[2];
	                if (rgba.length > 3) {
	                    this.a = rgba[3];
	                }
	            }
	        }
	    }
	    /**
	     * Get Luminosity of color
	     */
	    Color.prototype.getLuminosity = function () {
	        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
	        var rgb = [this.r, this.g, this.b];
	        var luminosity = [];
	        for (var i = 0; i < rgb.length; i++) {
	            var chan = rgb[i] / 255;
	            luminosity[i] =
	                chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
	        }
	        return (0.2126 * luminosity[0] + 0.7152 * luminosity[1] + 0.0722 * luminosity[2]);
	    };
	    /**
	     * Get RGBA value of the color
	     */
	    Color.prototype.getRBGA = function (color) {
	        var canvas = document.createElement("canvas");
	        var ctx = canvas.getContext("2d");
	        ctx.globalAlpha = 1;
	        ctx.fillStyle = color;
	        ctx.fillRect(0, 0, 1, 1);
	        var data = ctx.getImageData(0, 0, 1, 1).data;
	        return [data[0], data[1], data[2], data[3]];
	    };
	    return Color;
	}());

	/**
	 * Available styles for a Control.
	 */
	exports.ControlStyle = void 0;
	(function (ControlStyle) {
	    /**
	     * The control will be in the light style.
	     * Literal value `"light"`
	     */
	    ControlStyle["light"] = "light";
	    /**
	     * The control will be in the dark style.
	     * Literal value `"dark"`
	     */
	    ControlStyle["dark"] = "dark";
	    /**
	     * The control will automatically switch styles based on the style of the map.
	     * If a control doesn't support automatic styling the light style will be used by default.
	     * Literal value `"auto"`
	     */
	    ControlStyle["auto"] = "auto";
	})(exports.ControlStyle || (exports.ControlStyle = {}));

	var Dictionary = Map;

	/**
	 * An internal abstract class that can be extended to provide event listening/firing.
	 * This class is for internal use only, and users will find little use with it.
	 * Not to be used by the Map class. MapCallbackHandler implements the more complex logic for handling map events.
	 */
	var EventEmitter = /** @class */ (function () {
	    function EventEmitter() {
	        // Event listeners.
	        this.listeners = new Dictionary();
	    }
	    EventEmitter.prototype._addEventListener = function (eventType, callback, once) {
	        if (!this.listeners.has(eventType)) {
	            this.listeners.set(eventType, new Dictionary());
	        }
	        this.listeners.get(eventType).set(callback, once);
	    };
	    EventEmitter.prototype._removeEventListener = function (eventType, callback) {
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).delete(callback);
	        }
	    };
	    /**
	     * Invokes a given event type.
	     * @param eventType The event name.
	     * @param eventData The data to pass to the listener callbacks.
	     */
	    EventEmitter.prototype._invokeEvent = function (eventType, eventData) {
	        var _this = this;
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).forEach(function (once, callback) {
	                if (once) {
	                    _this._removeEventListener(eventType, callback);
	                }
	                try {
	                    callback(eventData);
	                }
	                catch (error) {
	                    // tslint:disable-next-line:no-console
	                    console.error(error);
	                }
	            });
	        }
	    };
	    return EventEmitter;
	}());

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		EventEmitter: EventEmitter
	});

	var __extends$1k = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * For internal use only.
	 * Implements control interface and provides support for automatic styling based on the map style.
	 */
	var ControlBase = /** @class */ (function (_super) {
	    __extends$1k(ControlBase, _super);
	    function ControlBase() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A callback for when the map's style changes.
	         * Used for auto styling.
	         */
	        _this._onStyleChange = function () {
	            if (_this._map.getStyle().style.toLowerCase().startsWith("blank")) {
	                // If the style is blank the div background should decide the theme.
	                if (!_this._observer) {
	                    // Add an observer to see changes to the background.
	                    _this._onBackgroundChange();
	                    _this._observer = new MutationObserver(_this._onBackgroundChange);
	                    _this._observer.observe(_this._map.getMapContainer(), { attributes: true, attributeFilter: ["style"] });
	                }
	            }
	            else {
	                if (_this._observer) {
	                    // Remove any existing observer for non-blank styles.
	                    _this._observer.disconnect();
	                    delete _this._observer;
	                }
	                // If the style is anything but blank the style definition should decide the theme.
	                _this._map.styles.getThemeAsync(_this._map.getStyle()).then(function (theme) {
	                    _this._setTheme(theme);
	                });
	            }
	        };
	        /**
	         * A callback for when the map's
	         */
	        _this._onBackgroundChange = function () {
	            // Calculate the luminosity of the map div's background to determine the theme.
	            // Try to parse the color, could fail if something complex like a gradient is used.
	            var color = new Color(_this._map.getMapContainer().style.backgroundColor);
	            var luminosity = color.getLuminosity();
	            // If the background color can't be parsed assume it is light.
	            var theme = isNaN(luminosity) || luminosity > 0.5
	                ? exports.ControlStyle.light
	                : exports.ControlStyle.dark;
	            _this._setTheme(theme);
	        };
	        return _this;
	    }
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    ControlBase.prototype.onRemove = function () {
	        if (this._container) {
	            this._container.remove();
	            delete this._container;
	        }
	        if (this._map) {
	            this._map.events.remove("stylechanged", this._onStyleChange);
	            delete this._map;
	        }
	        if (this._observer) {
	            this._observer.disconnect();
	            delete this._observer;
	        }
	        delete this._theme;
	    };
	    /**
	     * Build the outermost container for the control, applies styling including any listeners for auto styling.
	     */
	    ControlBase.prototype.buildContainer = function (map, style, ariaLabel, tagName) {
	        this._map = map;
	        this._container = document.createElement(tagName || "div");
	        this._container.classList.add("azure-maps-control-container");
	        if (typeof ariaLabel === "string") {
	            this._container.setAttribute("aria-label", ariaLabel);
	        }
	        // Set the style or add the auto listener.
	        if (style.toLowerCase() === exports.ControlStyle.auto) {
	            if (this._map) {
	                this._map.events.add("stylechanged", this._onStyleChange);
	            }
	        }
	        else {
	            this._container.classList.add(style);
	        }
	        return this._container;
	    };
	    /**
	     * Sets the control's theme (light/dark).
	     * Only applies changes if the theme is different than the previous.
	     */
	    ControlBase.prototype._setTheme = function (theme) {
	        // Only update if the theme is different.
	        if (this._theme !== theme) {
	            this._container.classList.remove(this._theme);
	            this._container.classList.add(theme);
	            this._theme = theme;
	        }
	    };
	    /** The delay between activating the control and when a click should occur, else assume it's a touch */
	    ControlBase.activateClickDelay = 100;
	    return ControlBase;
	}(EventEmitter));

	var __extends$1j = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a CompassControl object.
	 */
	var CompassControlOptions = /** @class */ (function (_super) {
	    __extends$1j(CompassControlOptions, _super);
	    function CompassControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will rotate with each click of the control.
	         * Default `15`.
	         * @default 15
	         */
	        _this.rotationDegreesDelta = 15;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Inverts the direction of map rotation controls.
	         * @default false
	         */
	        _this.inverted = false;
	        return _this;
	    }
	    return CompassControlOptions;
	}(Options));

	var __extends$1i = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control for changing the rotation of the map.
	 */
	var CompassControl = /** @class */ (function (_super) {
	    __extends$1i(CompassControl, _super);
	    /**
	     * Constructs a CompassControl.
	     * @param options The options for the control.
	     */
	    function CompassControl(options) {
	        var _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.options = new CompassControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    CompassControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Rotation Control");
	        var rotationButton = this.constructRotationButton(map);
	        var grid = this.constructRotationGrid(map, options);
	        var tooltip = buildAccessibleTooltip("Reset to Default Rotation");
	        var expandGrid = function (expanded) {
	            if (expanded) {
	                container.classList.add("in-use");
	                grid.setAttribute("aria-hidden", "false");
	                grid.classList.remove("hidden-accessible-element");
	            }
	            else {
	                container.classList.remove("in-use");
	                grid.setAttribute("aria-hidden", "true");
	                grid.classList.add("hidden-accessible-element");
	            }
	        };
	        container.addEventListener("mouseover", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasMouse = true;
	            expandGrid(true);
	        });
	        container.addEventListener("focusin", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasFocus = true;
	            expandGrid(true);
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                delete _this.lastActiveTime;
	                expandGrid(false);
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    delete _this.lastActiveTime;
	                    expandGrid(false);
	                }
	            }
	        });
	        // Keep the focus on this control when esc key is pressed on the grid
	        grid.addEventListener("keydown", function (event) {
	            if (event.key === "Escape" || event.key === "Esc") {
	                event.stopPropagation();
	                rotationButton.focus();
	                expandGrid(false);
	            }
	        });
	        // Dismiss the grid when esc key is pressed on the reset button and the tooltip is not visible
	        rotationButton.addEventListener("keydown", function (event) {
	            if ((event.key === "Escape" || event.key === "Esc") &&
	                (container === null || container === void 0 ? void 0 : container.classList.contains("in-use")) &&
	                (tooltip === null || tooltip === void 0 ? void 0 : tooltip.style.display) === "none") {
	                event.stopPropagation();
	                expandGrid(false);
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && CompassControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(grid);
	            container.appendChild(rotationButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, rotationButton);
	        }
	        else {
	            container.appendChild(rotationButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, rotationButton);
	            container.appendChild(grid);
	        }
	        return container;
	    };
	    CompassControl.prototype.constructRotationGrid = function (map, options) {
	        var grid = document.createElement("div");
	        grid.classList.add("sub-container");
	        grid.classList.add("hidden-accessible-element");
	        grid.setAttribute("aria-hidden", "true");
	        var rotationRightButton = this.constructRightRotationButton(map);
	        var rotationLeftButton = this.constructLeftRotationButton(map);
	        var tooltipLeft = buildAccessibleTooltip("Rotate Left");
	        var tooltipRight = buildAccessibleTooltip("Rotate Right");
	        if (options && CompassControl.InvertOrderPositions.includes(options.position)) {
	            grid.appendChild(rotationRightButton);
	            grid.appendChild(tooltipRight);
	            positionTooltip(tooltipRight, rotationRightButton);
	            grid.appendChild(rotationLeftButton);
	            grid.appendChild(tooltipLeft);
	            positionTooltip(tooltipLeft, rotationLeftButton);
	        }
	        else {
	            grid.appendChild(rotationLeftButton);
	            grid.appendChild(tooltipLeft);
	            positionTooltip(tooltipLeft, rotationLeftButton);
	            grid.appendChild(rotationRightButton);
	            grid.appendChild(tooltipRight);
	            positionTooltip(tooltipRight, rotationRightButton);
	        }
	        return grid;
	    };
	    CompassControl.prototype.constructRotationButton = function (map) {
	        var _this = this;
	        var rotationButton = document.createElement("button");
	        rotationButton.classList.add("azure-maps-control-button");
	        rotationButton.classList.add("rotation");
	        rotationButton.setAttribute("aria-label", "Reset to Default Rotation");
	        rotationButton.setAttribute("alt", "Reset to Default Rotation");
	        rotationButton.setAttribute("type", "button");
	        var icon = document.createElement("div");
	        rotationButton.appendChild(icon);
	        rotationButton.addEventListener("click", function (event) {
	            // If the click is happening just after the control became active assume it's a touch event from Edge.
	            if (event.timeStamp - _this.lastActiveTime > ControlBase.activateClickDelay) {
	                map.setCamera({
	                    bearing: CompassControl.DefaultRotation
	                }, true);
	            }
	        });
	        map.events.add("rotate", function (e) {
	            icon.style.transform = "rotate(".concat(-e.map.getCamera().bearing, "deg)");
	        });
	        return rotationButton;
	    };
	    CompassControl.prototype.constructRightRotationButton = function (map) {
	        var _this = this;
	        var rotationRightButton = document.createElement("button");
	        rotationRightButton.classList.add("azure-maps-control-button");
	        rotationRightButton.classList.add("rotation-right");
	        rotationRightButton.setAttribute("aria-label", "Rotate Right");
	        rotationRightButton.setAttribute("alt", "Rotate Right");
	        rotationRightButton.setAttribute("type", "button");
	        rotationRightButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing - (_this.options.inverted ? -1 : 1) * _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease",
	            }, true);
	        });
	        return rotationRightButton;
	    };
	    CompassControl.prototype.constructLeftRotationButton = function (map) {
	        var _this = this;
	        var rotationLeftButton = document.createElement("button");
	        rotationLeftButton.classList.add("azure-maps-control-button");
	        rotationLeftButton.classList.add("rotation-left");
	        rotationLeftButton.setAttribute("aria-label", "Rotate Left");
	        rotationLeftButton.setAttribute("alt", "Rotate Left");
	        rotationLeftButton.setAttribute("type", "button");
	        rotationLeftButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing + (_this.options.inverted ? -1 : 1) * _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease"
	            }, true);
	        });
	        return rotationLeftButton;
	    };
	    CompassControl.DefaultRotation = 0;
	    /** @internal */ CompassControl.RotationDuration = 100;
	    CompassControl.InvertOrderPositions = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return CompassControl;
	}(ControlBase));

	var __extends$1h = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a PitchControl object.
	 */
	var PitchControlOptions = /** @class */ (function (_super) {
	    __extends$1h(PitchControlOptions, _super);
	    function PitchControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will tilt with each click of the control.
	         * Default `10`.
	         * @default 10
	         */
	        _this.pitchDegreesDelta = 10;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Inverts the direction of map pitch controls.
	         * @default false
	         */
	        _this.inverted = false;
	        return _this;
	    }
	    return PitchControlOptions;
	}(Options));

	var __extends$1g = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control for changing the pitch of the map.
	 */
	var PitchControl = /** @class */ (function (_super) {
	    __extends$1g(PitchControl, _super);
	    /**
	     * Constructs a PitchControl.
	     * @param options The options for the control.
	     */
	    function PitchControl(options) {
	        var _this = _super.call(this) || this;
	        _this.container = null;
	        _this.map = null;
	        _this.pitchButton = null;
	        _this.pitchIncrementButton = null;
	        _this.pitchDecrementButton = null;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.pitchChanged = function (map) { return _this.updatePitchButtonsState(); };
	        _this.updatePitchButtonsState = function () {
	            var minPitchReached = _this.map.getCamera().pitch <= 0;
	            var maxPitchReached = _this.map.getCamera().pitch >= 60;
	            // Keep the focus on this control when max/min pitch is reached
	            if (_this.hasFocus && _this.pitchButton && (minPitchReached || maxPitchReached)) {
	                _this.pitchButton.focus();
	            }
	            if (_this.options.inverted) {
	                if (_this.pitchIncrementButton && _this.pitchIncrementButton.disabled != minPitchReached) {
	                    _this.pitchIncrementButton.disabled = minPitchReached;
	                }
	                if (_this.pitchDecrementButton && _this.pitchDecrementButton.disabled != maxPitchReached) {
	                    _this.pitchDecrementButton.disabled = maxPitchReached;
	                }
	            }
	            else {
	                if (_this.pitchIncrementButton && _this.pitchIncrementButton.disabled != maxPitchReached) {
	                    _this.pitchIncrementButton.disabled = maxPitchReached;
	                }
	                if (_this.pitchDecrementButton && _this.pitchDecrementButton.disabled != minPitchReached) {
	                    _this.pitchDecrementButton.disabled = minPitchReached;
	                }
	            }
	        };
	        _this.options = new PitchControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    PitchControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Pitch Control");
	        var pitchButton = this.constructPitchButton(map);
	        var grid = this.constructPitchGrid(map, options);
	        var tooltip = buildAccessibleTooltip("Reset to Default Pitch");
	        var expandGrid = function (expanded) {
	            if (expanded) {
	                container.classList.add("in-use");
	                grid.setAttribute("aria-hidden", "false");
	                grid.classList.remove("hidden-accessible-element");
	            }
	            else {
	                container.classList.remove("in-use");
	                grid.setAttribute("aria-hidden", "true");
	                grid.classList.add("hidden-accessible-element");
	            }
	        };
	        container.addEventListener("mouseover", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasMouse = true;
	            expandGrid(true);
	        });
	        container.addEventListener("focusin", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasFocus = true;
	            expandGrid(true);
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                delete _this.lastActiveTime;
	                expandGrid(false);
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    delete _this.lastActiveTime;
	                    expandGrid(false);
	                }
	            }
	        });
	        // Keep the focus on this control when esc key is pressed on the grid
	        grid.addEventListener("keydown", function (event) {
	            if (event.key === "Escape" || event.key === "Esc") {
	                event.stopPropagation();
	                pitchButton.focus();
	                expandGrid(false);
	            }
	        });
	        // Dismiss the grid when esc key is pressed on the reset button and the tooltip is not visible
	        pitchButton.addEventListener("keydown", function (event) {
	            if ((event.key === "Escape" || event.key === "Esc") &&
	                (container === null || container === void 0 ? void 0 : container.classList.contains("in-use")) &&
	                (tooltip === null || tooltip === void 0 ? void 0 : tooltip.style.display) === "none") {
	                event.stopPropagation();
	                expandGrid(false);
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && PitchControl.INVERT_ORDER_POSITIONS.includes(options.position)) {
	            container.appendChild(grid);
	            container.appendChild(pitchButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, container);
	        }
	        else {
	            container.appendChild(pitchButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, container);
	            container.appendChild(grid);
	        }
	        this.map = map;
	        this.container = container;
	        this.pitchButton = pitchButton;
	        map.events.add('pitch', this.pitchChanged);
	        this.updatePitchButtonsState();
	        return container;
	    };
	    PitchControl.prototype.onRemove = function () {
	        if (this.container) {
	            this.container.remove();
	            this.container = null;
	            this.pitchButton = null;
	            this.pitchIncrementButton = null;
	            this.pitchDecrementButton = null;
	        }
	        if (this.map) {
	            this.map.events.remove('pitch', this.pitchChanged);
	            this.map = null;
	        }
	    };
	    PitchControl.prototype.constructPitchGrid = function (map, options) {
	        var grid = document.createElement("div");
	        grid.classList.add("sub-container");
	        grid.classList.add("hidden-accessible-element");
	        grid.setAttribute("aria-hidden", "true");
	        this.pitchIncrementButton = this.constructPitchIncrementButton(map);
	        this.pitchDecrementButton = this.constructPitchDecrementButton(map);
	        var tooltipIncrement = buildAccessibleTooltip("Increase Pitch");
	        var tooltipDecrease = buildAccessibleTooltip("Decrease Pitch");
	        if (options && PitchControl.INVERT_ORDER_POSITIONS.includes(options.position)) {
	            grid.appendChild(this.pitchDecrementButton);
	            grid.appendChild(tooltipDecrease);
	            positionTooltip(tooltipDecrease, this.pitchDecrementButton);
	            grid.appendChild(this.pitchIncrementButton);
	            grid.appendChild(tooltipIncrement);
	            positionTooltip(tooltipIncrement, this.pitchIncrementButton);
	        }
	        else {
	            grid.appendChild(this.pitchIncrementButton);
	            grid.appendChild(tooltipIncrement);
	            positionTooltip(tooltipIncrement, this.pitchIncrementButton);
	            grid.appendChild(this.pitchDecrementButton);
	            grid.appendChild(tooltipDecrease);
	            positionTooltip(tooltipDecrease, this.pitchDecrementButton);
	        }
	        return grid;
	    };
	    PitchControl.prototype.constructPitchButton = function (map) {
	        var _this = this;
	        var pitchButton = document.createElement("button");
	        pitchButton.classList.add("azure-maps-control-button");
	        pitchButton.classList.add("pitch");
	        pitchButton.setAttribute("aria-label", "Reset to Default Pitch");
	        pitchButton.setAttribute("alt", "Reset to Default Pitch");
	        pitchButton.setAttribute("type", "button");
	        pitchButton.addEventListener("click", function () {
	            // If the click is happening just after the control became active assume it's a touch event from Edge.
	            if (event.timeStamp - _this.lastActiveTime > ControlBase.activateClickDelay) {
	                map.setCamera({
	                    pitch: PitchControl.DEFAULT_PITCH
	                }, true);
	            }
	        });
	        return pitchButton;
	    };
	    PitchControl.prototype.constructPitchDecrementButton = function (map) {
	        var _this = this;
	        var pitchDecrementButton = document.createElement("button");
	        pitchDecrementButton.classList.add("azure-maps-control-button");
	        pitchDecrementButton.classList.add("pitch-down");
	        pitchDecrementButton.setAttribute("aria-label", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("alt", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("type", "button");
	        pitchDecrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch - (_this.options.inverted ? -1 : 1) * _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchDecrementButton;
	    };
	    PitchControl.prototype.constructPitchIncrementButton = function (map) {
	        var _this = this;
	        var pitchIncrementButton = document.createElement("button");
	        pitchIncrementButton.classList.add("azure-maps-control-button");
	        pitchIncrementButton.classList.add("pitch-up");
	        pitchIncrementButton.setAttribute("aria-label", "Increase Pitch");
	        pitchIncrementButton.setAttribute("alt", "Increase Pitch");
	        pitchIncrementButton.setAttribute("type", "button");
	        pitchIncrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch + (_this.options.inverted ? -1 : 1) * _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchIncrementButton;
	    };
	    PitchControl.PITCH_DURATION_MS = 100;
	    PitchControl.DEFAULT_PITCH = 0;
	    PitchControl.INVERT_ORDER_POSITIONS = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return PitchControl;
	}(ControlBase));

	var __extends$1f = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control to display a scale bar on the map.
	 */
	var ScaleControl = /** @class */ (function (_super) {
	    __extends$1f(ScaleControl, _super);
	    /**
	     * A control to displays a scale bar relative to the pixel resolution at the center of the map.
	     * @param options Options for defining how the control is rendered and functions.
	     */
	    function ScaleControl(options) {
	        var _this = _super.call(this) || this;
	        _this.map = null;
	        _this.control = new maplibregl.ScaleControl({
	            maxWidth: options === null || options === void 0 ? void 0 : options.maxWidth,
	            unit: options === null || options === void 0 ? void 0 : options.unit
	        });
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    ScaleControl.prototype.onAdd = function (map, options) {
	        var _a, _b, _c;
	        this.map = map;
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.addControl(this.control);
	        var container = this.buildContainer(map, exports.ControlStyle.auto, "Scale Bar");
	        container.appendChild((_c = this.control) === null || _c === void 0 ? void 0 : _c._container);
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    ScaleControl.prototype.onRemove = function () {
	        var _a, _b;
	        _super.prototype.onRemove.call(this);
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.removeControl(this.control);
	        this.map = null;
	    };
	    /**
	     * Set the scale's unit of the distance
	     * @param unit - Unit of the distance (`"imperial"`, `"metric"` or `"nautical"`).
	     */
	    ScaleControl.prototype.setUnit = function (unit) {
	        var _a;
	        (_a = this.control) === null || _a === void 0 ? void 0 : _a.setUnit(unit);
	    };
	    return ScaleControl;
	}(ControlBase));

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */

	function listCacheClear$1() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear$1;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */

	function eq$5(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq$5;

	var eq$4 = eq_1;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf$4(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq$4(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf$4;

	var assocIndexOf$3 = _assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$3(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete$1;

	var assocIndexOf$2 = _assocIndexOf;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$2(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet$1;

	var assocIndexOf$1 = _assocIndexOf;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas$1(key) {
	  return assocIndexOf$1(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas$1;

	var assocIndexOf = _assocIndexOf;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet$1(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet$1;

	var listCacheClear = _listCacheClear,
	    listCacheDelete = _listCacheDelete,
	    listCacheGet = _listCacheGet,
	    listCacheHas = _listCacheHas,
	    listCacheSet = _listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache$4(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache$4.prototype.clear = listCacheClear;
	ListCache$4.prototype['delete'] = listCacheDelete;
	ListCache$4.prototype.get = listCacheGet;
	ListCache$4.prototype.has = listCacheHas;
	ListCache$4.prototype.set = listCacheSet;

	var _ListCache = ListCache$4;

	var ListCache$3 = _ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear$1() {
	  this.__data__ = new ListCache$3;
	  this.size = 0;
	}

	var _stackClear = stackClear$1;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function stackDelete$1(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete$1;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */

	function stackGet$1(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet$1;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function stackHas$1(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas$1;

	/** Detect free variable `global` from Node.js. */

	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal$1;

	var freeGlobal = _freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$8 = freeGlobal || freeSelf || Function('return this')();

	var _root = root$8;

	var root$7 = _root;

	/** Built-in value references. */
	var Symbol$5 = root$7.Symbol;

	var _Symbol = Symbol$5;

	var Symbol$4 = _Symbol;

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$f.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$f.toString;

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$1(value) {
	  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag$1;

	/** Used for built-in method references. */

	var objectProto$e = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$e.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString.call(value);
	}

	var _objectToString = objectToString$1;

	var Symbol$3 = _Symbol,
	    getRawTag = _getRawTag,
	    objectToString = _objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$5(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	var _baseGetTag = baseGetTag$5;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */

	function isObject$8(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject$8;

	var baseGetTag$4 = _baseGetTag,
	    isObject$7 = isObject_1;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$3(value) {
	  if (!isObject$7(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag$4(value);
	  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction$3;

	var root$6 = _root;

	/** Used to detect overreaching core-js shims. */
	var coreJsData$1 = root$6['__core-js_shared__'];

	var _coreJsData = coreJsData$1;

	var coreJsData = _coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked$1(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked$1;

	/** Used for built-in method references. */

	var funcProto$2 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource$2(func) {
	  if (func != null) {
	    try {
	      return funcToString$2.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource$2;

	var isFunction$2 = isFunction_1,
	    isMasked = _isMasked,
	    isObject$6 = isObject_1,
	    toSource$1 = _toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$d = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$d.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative$1(value) {
	  if (!isObject$6(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource$1(value));
	}

	var _baseIsNative = baseIsNative$1;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */

	function getValue$1(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue$1;

	var baseIsNative = _baseIsNative,
	    getValue = _getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative$7(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative$7;

	var getNative$6 = _getNative,
	    root$5 = _root;

	/* Built-in method references that are verified to be native. */
	var Map$5 = getNative$6(root$5, 'Map');

	var _Map = Map$5;

	var getNative$5 = _getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate$4 = getNative$5(Object, 'create');

	var _nativeCreate = nativeCreate$4;

	var nativeCreate$3 = _nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear$1() {
	  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear$1;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function hashDelete$1(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete$1;

	var nativeCreate$2 = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$c.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet$1(key) {
	  var data = this.__data__;
	  if (nativeCreate$2) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$2 ? undefined : result;
	  }
	  return hasOwnProperty$a.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet$1;

	var nativeCreate$1 = _nativeCreate;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas$1(key) {
	  var data = this.__data__;
	  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$9.call(data, key);
	}

	var _hashHas = hashHas$1;

	var nativeCreate = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet$1(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet$1;

	var hashClear = _hashClear,
	    hashDelete = _hashDelete,
	    hashGet = _hashGet,
	    hashHas = _hashHas,
	    hashSet = _hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype['delete'] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;

	var _Hash = Hash$1;

	var Hash = _Hash,
	    ListCache$2 = _ListCache,
	    Map$4 = _Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear$1() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map$4 || ListCache$2),
	    'string': new Hash
	  };
	}

	var _mapCacheClear = mapCacheClear$1;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */

	function isKeyable$1(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable$1;

	var isKeyable = _isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData$4(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData$4;

	var getMapData$3 = _getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete$1(key) {
	  var result = getMapData$3(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete$1;

	var getMapData$2 = _getMapData;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet$1(key) {
	  return getMapData$2(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet$1;

	var getMapData$1 = _getMapData;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas$1(key) {
	  return getMapData$1(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas$1;

	var getMapData = _getMapData;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet$1(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet$1;

	var mapCacheClear = _mapCacheClear,
	    mapCacheDelete = _mapCacheDelete,
	    mapCacheGet = _mapCacheGet,
	    mapCacheHas = _mapCacheHas,
	    mapCacheSet = _mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache$2(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache$2.prototype.clear = mapCacheClear;
	MapCache$2.prototype['delete'] = mapCacheDelete;
	MapCache$2.prototype.get = mapCacheGet;
	MapCache$2.prototype.has = mapCacheHas;
	MapCache$2.prototype.set = mapCacheSet;

	var _MapCache = MapCache$2;

	var ListCache$1 = _ListCache,
	    Map$3 = _Map,
	    MapCache$1 = _MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet$1(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache$1) {
	    var pairs = data.__data__;
	    if (!Map$3 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache$1(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet$1;

	var ListCache = _ListCache,
	    stackClear = _stackClear,
	    stackDelete = _stackDelete,
	    stackGet = _stackGet,
	    stackHas = _stackHas,
	    stackSet = _stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack$3(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack$3.prototype.clear = stackClear;
	Stack$3.prototype['delete'] = stackDelete;
	Stack$3.prototype.get = stackGet;
	Stack$3.prototype.has = stackHas;
	Stack$3.prototype.set = stackSet;

	var _Stack = Stack$3;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */

	function arrayEach$1(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var _arrayEach = arrayEach$1;

	var getNative$4 = _getNative;

	var defineProperty$2 = (function() {
	  try {
	    var func = getNative$4(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty = defineProperty$2;

	var defineProperty$1 = _defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue$3(object, key, value) {
	  if (key == '__proto__' && defineProperty$1) {
	    defineProperty$1(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue$3;

	var baseAssignValue$2 = _baseAssignValue,
	    eq$3 = eq_1;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue$2(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$8.call(object, key) && eq$3(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue$2(object, key, value);
	  }
	}

	var _assignValue = assignValue$2;

	var assignValue$1 = _assignValue,
	    baseAssignValue$1 = _baseAssignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject$5(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue$1(object, key, newValue);
	    } else {
	      assignValue$1(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject$5;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */

	function baseTimes$1(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes$1;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */

	function isObjectLike$9(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike$9;

	var baseGetTag$3 = _baseGetTag,
	    isObjectLike$8 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments$1(value) {
	  return isObjectLike$8(value) && baseGetTag$3(value) == argsTag$3;
	}

	var _baseIsArguments = baseIsArguments$1;

	var baseIsArguments = _baseIsArguments,
	    isObjectLike$7 = isObjectLike_1;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments$2 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike$7(value) && hasOwnProperty$7.call(value, 'callee') &&
	    !propertyIsEnumerable$1.call(value, 'callee');
	};

	var isArguments_1 = isArguments$2;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */

	var isArray$5 = Array.isArray;

	var isArray_1 = isArray$5;

	var isBuffer$4 = {exports: {}};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */

	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	isBuffer$4.exports;

	(function (module, exports) {
		var root = _root,
		    stubFalse = stubFalse_1;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer$4, isBuffer$4.exports));

	var isBufferExports = isBuffer$4.exports;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex$2(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER$1 : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex$2;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength$2(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	var isLength_1 = isLength$2;

	var baseGetTag$2 = _baseGetTag,
	    isLength$1 = isLength_1,
	    isObjectLike$6 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag$5 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    objectTag$4 = '[object Object]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$3 = '[object String]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
	typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
	typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
	typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
	typedArrayTags[uint32Tag$2] = true;
	typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
	typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
	typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
	typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] =
	typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
	typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] =
	typedArrayTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray$1(value) {
	  return isObjectLike$6(value) &&
	    isLength$1(value.length) && !!typedArrayTags[baseGetTag$2(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray$1;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */

	function baseUnary$3(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary$3;

	var _nodeUtil = {exports: {}};

	_nodeUtil.exports;

	(function (module, exports) {
		var freeGlobal = _freeGlobal;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));

	var _nodeUtilExports = _nodeUtil.exports;

	var baseIsTypedArray = _baseIsTypedArray,
	    baseUnary$2 = _baseUnary,
	    nodeUtil$2 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray$3 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;

	var isTypedArray_1 = isTypedArray$3;

	var baseTimes = _baseTimes,
	    isArguments$1 = isArguments_1,
	    isArray$4 = isArray_1,
	    isBuffer$3 = isBufferExports,
	    isIndex$1 = _isIndex,
	    isTypedArray$2 = isTypedArray_1;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys$2(value, inherited) {
	  var isArr = isArray$4(value),
	      isArg = !isArr && isArguments$1(value),
	      isBuff = !isArr && !isArg && isBuffer$3(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray$2(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex$1(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys$2;

	/** Used for built-in method references. */

	var objectProto$7 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype$3(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$7;

	  return value === proto;
	}

	var _isPrototype = isPrototype$3;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */

	function overArg$2(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg$2;

	var overArg$1 = _overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys$1 = overArg$1(Object.keys, Object);

	var _nativeKeys = nativeKeys$1;

	var isPrototype$2 = _isPrototype,
	    nativeKeys = _nativeKeys;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys$1(object) {
	  if (!isPrototype$2(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys$1;

	var isFunction$1 = isFunction_1,
	    isLength = isLength_1;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike$4(value) {
	  return value != null && isLength(value.length) && !isFunction$1(value);
	}

	var isArrayLike_1 = isArrayLike$4;

	var arrayLikeKeys$1 = _arrayLikeKeys,
	    baseKeys = _baseKeys,
	    isArrayLike$3 = isArrayLike_1;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$3(object) {
	  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
	}

	var keys_1 = keys$3;

	var copyObject$4 = _copyObject,
	    keys$2 = keys_1;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign$1(object, source) {
	  return object && copyObject$4(source, keys$2(source), object);
	}

	var _baseAssign = baseAssign$1;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */

	function nativeKeysIn$1(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn$1;

	var isObject$5 = isObject_1,
	    isPrototype$1 = _isPrototype,
	    nativeKeysIn = _nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn$1(object) {
	  if (!isObject$5(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype$1(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$4.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn$1;

	var arrayLikeKeys = _arrayLikeKeys,
	    baseKeysIn = _baseKeysIn,
	    isArrayLike$2 = isArrayLike_1;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$5(object) {
	  return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	var keysIn_1 = keysIn$5;

	var copyObject$3 = _copyObject,
	    keysIn$4 = keysIn_1;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn$1(object, source) {
	  return object && copyObject$3(source, keysIn$4(source), object);
	}

	var _baseAssignIn = baseAssignIn$1;

	var _cloneBuffer = {exports: {}};

	_cloneBuffer.exports;

	(function (module, exports) {
		var root = _root;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var length = buffer.length,
		      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		  buffer.copy(result);
		  return result;
		}

		module.exports = cloneBuffer; 
	} (_cloneBuffer, _cloneBuffer.exports));

	var _cloneBufferExports = _cloneBuffer.exports;

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */

	function copyArray$2(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray$2;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */

	function arrayFilter$1(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter$1;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */

	function stubArray$2() {
	  return [];
	}

	var stubArray_1 = stubArray$2;

	var arrayFilter = _arrayFilter,
	    stubArray$1 = stubArray_1;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols$3;

	var copyObject$2 = _copyObject,
	    getSymbols$2 = _getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols$1(source, object) {
	  return copyObject$2(source, getSymbols$2(source), object);
	}

	var _copySymbols = copySymbols$1;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */

	function arrayPush$2(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush$2;

	var overArg = _overArg;

	/** Built-in value references. */
	var getPrototype$3 = overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype$3;

	var arrayPush$1 = _arrayPush,
	    getPrototype$2 = _getPrototype,
	    getSymbols$1 = _getSymbols,
	    stubArray = stubArray_1;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush$1(result, getSymbols$1(object));
	    object = getPrototype$2(object);
	  }
	  return result;
	};

	var _getSymbolsIn = getSymbolsIn$2;

	var copyObject$1 = _copyObject,
	    getSymbolsIn$1 = _getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn$1(source, object) {
	  return copyObject$1(source, getSymbolsIn$1(source), object);
	}

	var _copySymbolsIn = copySymbolsIn$1;

	var arrayPush = _arrayPush,
	    isArray$3 = isArray_1;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$3(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys$2;

	var baseGetAllKeys$1 = _baseGetAllKeys,
	    getSymbols = _getSymbols,
	    keys$1 = keys_1;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys$2(object) {
	  return baseGetAllKeys$1(object, keys$1, getSymbols);
	}

	var _getAllKeys = getAllKeys$2;

	var baseGetAllKeys = _baseGetAllKeys,
	    getSymbolsIn = _getSymbolsIn,
	    keysIn$3 = keysIn_1;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn$1(object) {
	  return baseGetAllKeys(object, keysIn$3, getSymbolsIn);
	}

	var _getAllKeysIn = getAllKeysIn$1;

	var getNative$3 = _getNative,
	    root$4 = _root;

	/* Built-in method references that are verified to be native. */
	var DataView$1 = getNative$3(root$4, 'DataView');

	var _DataView = DataView$1;

	var getNative$2 = _getNative,
	    root$3 = _root;

	/* Built-in method references that are verified to be native. */
	var Promise$2 = getNative$2(root$3, 'Promise');

	var _Promise = Promise$2;

	var getNative$1 = _getNative,
	    root$2 = _root;

	/* Built-in method references that are verified to be native. */
	var Set$2 = getNative$1(root$2, 'Set');

	var _Set = Set$2;

	var getNative = _getNative,
	    root$1 = _root;

	/* Built-in method references that are verified to be native. */
	var WeakMap$1 = getNative(root$1, 'WeakMap');

	var _WeakMap = WeakMap$1;

	var DataView = _DataView,
	    Map$2 = _Map,
	    Promise$1 = _Promise,
	    Set$1 = _Set,
	    WeakMap = _WeakMap,
	    baseGetTag$1 = _baseGetTag,
	    toSource = _toSource;

	/** `Object#toString` result references. */
	var mapTag$4 = '[object Map]',
	    objectTag$3 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$4 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$3 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map$2),
	    promiseCtorString = toSource(Promise$1),
	    setCtorString = toSource(Set$1),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag$4 = baseGetTag$1;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
	    (Map$2 && getTag$4(new Map$2) != mapTag$4) ||
	    (Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag) ||
	    (Set$1 && getTag$4(new Set$1) != setTag$4) ||
	    (WeakMap && getTag$4(new WeakMap) != weakMapTag$1)) {
	  getTag$4 = function(value) {
	    var result = baseGetTag$1(value),
	        Ctor = result == objectTag$3 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$3;
	        case mapCtorString: return mapTag$4;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$4;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag$4;

	/** Used for built-in method references. */

	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray$1(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$3.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	var _initCloneArray = initCloneArray$1;

	var root = _root;

	/** Built-in value references. */
	var Uint8Array$3 = root.Uint8Array;

	var _Uint8Array = Uint8Array$3;

	var Uint8Array$2 = _Uint8Array;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer$3(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer$3;

	var cloneArrayBuffer$2 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView$1(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	var _cloneDataView = cloneDataView$1;

	/** Used to match `RegExp` flags from their coerced string values. */

	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp$1(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	var _cloneRegExp = cloneRegExp$1;

	var Symbol$2 = _Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
	    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol$1(symbol) {
	  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
	}

	var _cloneSymbol = cloneSymbol$1;

	var cloneArrayBuffer$1 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray$2(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray$2;

	var cloneArrayBuffer = _cloneArrayBuffer,
	    cloneDataView = _cloneDataView,
	    cloneRegExp = _cloneRegExp,
	    cloneSymbol = _cloneSymbol,
	    cloneTypedArray$1 = _cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    mapTag$3 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$3 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$2 = '[object Symbol]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag$1(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$2:
	      return cloneArrayBuffer(object);

	    case boolTag$2:
	    case dateTag$2:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return cloneTypedArray$1(object, isDeep);

	    case mapTag$3:
	      return new Ctor;

	    case numberTag$2:
	    case stringTag$2:
	      return new Ctor(object);

	    case regexpTag$2:
	      return cloneRegExp(object);

	    case setTag$3:
	      return new Ctor;

	    case symbolTag$2:
	      return cloneSymbol(object);
	  }
	}

	var _initCloneByTag = initCloneByTag$1;

	var isObject$4 = isObject_1;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate$1 = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject$4(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate$1;

	var baseCreate = _baseCreate,
	    getPrototype$1 = _getPrototype,
	    isPrototype = _isPrototype;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject$2(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype$1(object))
	    : {};
	}

	var _initCloneObject = initCloneObject$2;

	var getTag$3 = _getTag,
	    isObjectLike$5 = isObjectLike_1;

	/** `Object#toString` result references. */
	var mapTag$2 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap$1(value) {
	  return isObjectLike$5(value) && getTag$3(value) == mapTag$2;
	}

	var _baseIsMap = baseIsMap$1;

	var baseIsMap = _baseIsMap,
	    baseUnary$1 = _baseUnary,
	    nodeUtil$1 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;

	var isMap_1 = isMap$1;

	var getTag$2 = _getTag,
	    isObjectLike$4 = isObjectLike_1;

	/** `Object#toString` result references. */
	var setTag$2 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet$1(value) {
	  return isObjectLike$4(value) && getTag$2(value) == setTag$2;
	}

	var _baseIsSet = baseIsSet$1;

	var baseIsSet = _baseIsSet,
	    baseUnary = _baseUnary,
	    nodeUtil = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	var isSet_1 = isSet$1;

	var Stack$2 = _Stack,
	    arrayEach = _arrayEach,
	    assignValue = _assignValue,
	    baseAssign = _baseAssign,
	    baseAssignIn = _baseAssignIn,
	    cloneBuffer$1 = _cloneBufferExports,
	    copyArray$1 = _copyArray,
	    copySymbols = _copySymbols,
	    copySymbolsIn = _copySymbolsIn,
	    getAllKeys$1 = _getAllKeys,
	    getAllKeysIn = _getAllKeysIn,
	    getTag$1 = _getTag,
	    initCloneArray = _initCloneArray,
	    initCloneByTag = _initCloneByTag,
	    initCloneObject$1 = _initCloneObject,
	    isArray$2 = isArray_1,
	    isBuffer$2 = isBufferExports,
	    isMap = isMap_1,
	    isObject$3 = isObject_1,
	    isSet = isSet_1,
	    keys = keys_1,
	    keysIn$2 = keysIn_1;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$2 = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG$2 = 4;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag$1 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$1 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag$1 = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
	cloneableTags[boolTag$1] = cloneableTags[dateTag$1] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
	cloneableTags[numberTag$1] = cloneableTags[objectTag$2] =
	cloneableTags[regexpTag$1] = cloneableTags[setTag$1] =
	cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone$2(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG$2,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject$3(value)) {
	    return value;
	  }
	  var isArr = isArray$2(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray$1(value, result);
	    }
	  } else {
	    var tag = getTag$1(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer$2(value)) {
	      return cloneBuffer$1(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$1 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject$1(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack$2);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys$1)
	    : (isFlat ? keysIn$2 : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	var _baseClone = baseClone$2;

	var baseClone$1 = _baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
	}

	var cloneDeep_1 = cloneDeep;

	var cloneDeep$1 = /*@__PURE__*/getDefaultExportFromCjs(cloneDeep_1);

	var baseAssignValue = _baseAssignValue,
	    eq$2 = eq_1;

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue$2(object, key, value) {
	  if ((value !== undefined && !eq$2(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	var _assignMergeValue = assignMergeValue$2;

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */

	function createBaseFor$1(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	var _createBaseFor = createBaseFor$1;

	var createBaseFor = _createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor$1 = createBaseFor();

	var _baseFor = baseFor$1;

	var isArrayLike$1 = isArrayLike_1,
	    isObjectLike$3 = isObjectLike_1;

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject$1(value) {
	  return isObjectLike$3(value) && isArrayLike$1(value);
	}

	var isArrayLikeObject_1 = isArrayLikeObject$1;

	var baseGetTag = _baseGetTag,
	    getPrototype = _getPrototype,
	    isObjectLike$2 = isObjectLike_1;

	/** `Object#toString` result references. */
	var objectTag$1 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject$2(value) {
	  if (!isObjectLike$2(value) || baseGetTag(value) != objectTag$1) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	var isPlainObject_1 = isPlainObject$2;

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */

	function safeGet$2(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	var _safeGet = safeGet$2;

	var copyObject = _copyObject,
	    keysIn$1 = keysIn_1;

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject$1(value) {
	  return copyObject(value, keysIn$1(value));
	}

	var toPlainObject_1 = toPlainObject$1;

	var assignMergeValue$1 = _assignMergeValue,
	    cloneBuffer = _cloneBufferExports,
	    cloneTypedArray = _cloneTypedArray,
	    copyArray = _copyArray,
	    initCloneObject = _initCloneObject,
	    isArguments = isArguments_1,
	    isArray$1 = isArray_1,
	    isArrayLikeObject = isArrayLikeObject_1,
	    isBuffer$1 = isBufferExports,
	    isFunction = isFunction_1,
	    isObject$2 = isObject_1,
	    isPlainObject$1 = isPlainObject_1,
	    isTypedArray$1 = isTypedArray_1,
	    safeGet$1 = _safeGet,
	    toPlainObject = toPlainObject_1;

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet$1(object, key),
	      srcValue = safeGet$1(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue$1(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray$1(srcValue),
	        isBuff = !isArr && isBuffer$1(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray$1(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject$2(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue$1(object, key, newValue);
	}

	var _baseMergeDeep = baseMergeDeep$1;

	var Stack$1 = _Stack,
	    assignMergeValue = _assignMergeValue,
	    baseFor = _baseFor,
	    baseMergeDeep = _baseMergeDeep,
	    isObject$1 = isObject_1,
	    keysIn = keysIn_1,
	    safeGet = _safeGet;

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge$1(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    stack || (stack = new Stack$1);
	    if (isObject$1(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	var _baseMerge = baseMerge$1;

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */

	function identity$2(value) {
	  return value;
	}

	var identity_1 = identity$2;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */

	function apply$1(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	var _apply = apply$1;

	var apply = _apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest$1(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	var _overRest = overRest$1;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */

	function constant$1(value) {
	  return function() {
	    return value;
	  };
	}

	var constant_1 = constant$1;

	var constant = constant_1,
	    defineProperty = _defineProperty,
	    identity$1 = identity_1;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	var _baseSetToString = baseSetToString$1;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */

	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut$1(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	var _shortOut = shortOut$1;

	var baseSetToString = _baseSetToString,
	    shortOut = _shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString$1 = shortOut(baseSetToString);

	var _setToString = setToString$1;

	var identity = identity_1,
	    overRest = _overRest,
	    setToString = _setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest$1(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	var _baseRest = baseRest$1;

	var eq$1 = eq_1,
	    isArrayLike = isArrayLike_1,
	    isIndex = _isIndex,
	    isObject = isObject_1;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall$1(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq$1(object[index], value);
	  }
	  return false;
	}

	var _isIterateeCall = isIterateeCall$1;

	var baseRest = _baseRest,
	    isIterateeCall = _isIterateeCall;

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner$1(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	var _createAssigner = createAssigner$1;

	var baseMerge = _baseMerge,
	    createAssigner = _createAssigner;

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	var merge_1 = merge;

	var merge$1 = /*@__PURE__*/getDefaultExportFromCjs(merge_1);

	var __extends$1e = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a StyleControl object.
	 */
	var StyleControlOptions = /** @class */ (function (_super) {
	    __extends$1e(StyleControlOptions, _super);
	    function StyleControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The layout to display the styles in.<br />
	         * `"icons"`: A row of clickable icons for each style.<br />
	         * `"list"`: A scrollable list with the icons and names for each style.<br />
	         * Default `"icons"`
	         * @default "icons"
	         */
	        _this.layout = "icons";
	        /**
	         * The map styles to show in the control.
	         * Style names are case sensitive.
	         * If an included style isn't supported by the map it will be ignored.
	         * Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article.
	         * If "all" is specified, all map styles will be shown.
	         * Default `["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]`
	         * @default ["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]
	         */
	        _this.mapStyles = [
	            "road",
	            "grayscale_light",
	            "grayscale_dark",
	            "night",
	            "road_shaded_relief",
	        ];
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Whether to let style control automatically set the style, once user select a map style.
	         * If set to `false`, then clicking on style will not set the set the style automatically.
	         * Default `true`
	         */
	        _this.autoSelectionMode = true;
	        return _this;
	    }
	    return StyleControlOptions;
	}(Options));

	var __extends$1d = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter$7 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$7 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$f = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * A control for changing the style of the map.
	 */
	var StyleControl = /** @class */ (function (_super) {
	    __extends$1d(StyleControl, _super);
	    /**
	     * Constructs a StyleControl.
	     * @param options The options for the control.
	     */
	    function StyleControl(options) {
	        var _this = _super.call(this) || this;
	        _this.styleOpsGrid = null;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.styleButtons = new Dictionary();
	        _this.styleIcons = new Dictionary();
	        // we need to rely on this to avoid potentially redundant thumbnail requests and .blob calls
	        _this.thumbnailCache = {
	            assumedConfiguration: undefined,
	            response: new Dictionary(),
	            blob: new Dictionary()
	        };
	        /**
	         * Callback handler for the style changing.
	         */
	        _this.onStyleChange = function () {
	            if (_this.options.autoSelectionMode) {
	                var newStyle = _this.map.getStyle().style;
	                _this.setSelectedStyle(newStyle);
	            }
	        };
	        _this.onMapConfigurationChange = function (definitions) {
	            if (!_this.styleOpsGrid) {
	                return;
	            }
	            // do not recreate the styleOpsGrid if it is initialized and configuration object reference has not changed
	            if (_this.styleOpsGrid.children.length > 0 && _this.thumbnailCache.assumedConfiguration === definitions) {
	                return;
	            }
	            _this.thumbnailCache.assumedConfiguration = definitions;
	            Array.from(_this.styleOpsGrid.children).forEach(function (element) { return element.remove(); });
	            _this.styleButtons.clear();
	            _this.populateOpsGridFromDefinitions(definitions);
	        };
	        _this.mapToFriendlyStyleName = function (name, mapConfiguration) {
	            var style = mapConfiguration.configurations.find(function (style) { return style.name === name; });
	            return (style === null || style === void 0 ? void 0 : style.displayName) || name;
	        };
	        _this.options = new StyleControlOptions().merge(cloneDeep$1(options));
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    StyleControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        this.map = map;
	        var container = this.buildContainer(map, this.options.style, "Map Style Control");
	        var styleOpsGrid = this.buildStyleOpsGrid();
	        this.styleOpsGrid = styleOpsGrid;
	        var currStyleButton = this.buildCurrStyleBtn();
	        var tooltip = buildAccessibleTooltip("Select Style");
	        var expandGrid = function (expanded) {
	            if (expanded) {
	                container.classList.add(StyleControl.Css.inUse);
	                styleOpsGrid.setAttribute("aria-hidden", "false");
	                styleOpsGrid.classList.remove("hidden-accessible-element");
	            }
	            else {
	                container.classList.remove(StyleControl.Css.inUse);
	                styleOpsGrid.setAttribute("aria-hidden", "true");
	                styleOpsGrid.classList.add("hidden-accessible-element");
	            }
	        };
	        styleOpsGrid.classList.add(options ? options.position || 'top-right' : 'top-right');
	        container.addEventListener("mouseover", function () {
	            _this.hasMouse = true;
	            expandGrid(true);
	        });
	        container.addEventListener("focusin", function () {
	            _this.hasFocus = true;
	            expandGrid(true);
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                expandGrid(false);
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (event.target === currStyleButton) {
	                // on focusout from reveal button -> reset the tabIndex on the styleOpsGrid elements that could have been set to -1 on esc key press
	                Array.from(styleOpsGrid.children).forEach(function (e) { return e.removeAttribute('tabIndex'); });
	            }
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    expandGrid(false);
	                }
	            }
	        });
	        // explictly hijack esc key behavior: we should not interrupt normal tab-navigation flow
	        // but focus out via esc from to the parent container should instead bring focus to the reveal button
	        styleOpsGrid.addEventListener('keydown', function (event) {
	            if (event.keyCode === 27) {
	                event.stopPropagation();
	                currStyleButton.focus();
	                Array.from(styleOpsGrid.children).forEach(function (e) { return e.setAttribute('tabIndex', "-1"); });
	                if (container.classList.contains(StyleControl.Css.inUse)) {
	                    expandGrid(false);
	                }
	            }
	        });
	        currStyleButton.addEventListener("click", function (event) {
	            if (container.classList.contains(StyleControl.Css.inUse)) {
	                expandGrid(false);
	            }
	            else {
	                expandGrid(true);
	                // clicking on a reveal button should move the focus to the first styleOpsGrid button
	                if (styleOpsGrid.firstElementChild) {
	                    styleOpsGrid.firstElementChild.focus();
	                }
	            }
	        });
	        if (options && StyleControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(styleOpsGrid);
	            container.appendChild(currStyleButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, currStyleButton);
	        }
	        else {
	            container.appendChild(currStyleButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, currStyleButton);
	            container.appendChild(styleOpsGrid);
	        }
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    StyleControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        this.styleOpsGrid = null;
	        this.styleButtons.clear();
	        this.thumbnailCache.response.clear();
	        this.thumbnailCache.blob.clear();
	        this.thumbnailCache.assumedConfiguration = undefined;
	        this.map.events.remove("stylechanged", this.onStyleChange);
	        this.map.events.remove("mapconfigurationchanged", this.onMapConfigurationChange);
	    };
	    /**
	     * Set the style that need to be displayed as currently selected.
	     * Style will automatically get selected if `StyleControlOptions.autoSelectionMode` is `true`
	     * @param styleName - Style name that need to be disabled as currently selected
	     */
	    StyleControl.prototype.setSelectedStyle = function (styleName) {
	        var _this = this;
	        if (this.styleIcons.has(styleName)) {
	            var image_1 = this.currStyleImage;
	            var newSrc = this.styleIcons.get(styleName);
	            if (image_1.src !== newSrc) {
	                image_1.src = newSrc;
	            }
	            Object.entries(this.styleButtons).forEach(function (_a) {
	                var _b = __read$f(_a, 2), buttonStyleName = _b[0], button = _b[1];
	                return button.setAttribute('aria-current', buttonStyleName === styleName ? 'true' : 'false');
	            });
	            this.map.styles.definitions().then(function (mapConfiguration) {
	                var newAlt = _this.mapToFriendlyStyleName(styleName, mapConfiguration);
	                if (image_1.alt !== newAlt) {
	                    image_1.alt = newAlt;
	                }
	                if (image_1.parentElement.lastChild instanceof Text) {
	                    image_1.parentElement.lastChild.textContent = newAlt;
	                }
	            });
	        }
	    };
	    /**
	     * Set style in a disabled state
	     * @param styleName Style to be disabled
	     */
	    StyleControl.prototype.disableStyle = function (styleName) {
	        var styleButton = this.styleButtons[styleName];
	        if (styleButton) {
	            styleButton.setAttribute("disabled", "true");
	        }
	    };
	    /**
	     * Enabled style that was previously disabled
	     * @param styleName Style to be disabled
	     */
	    StyleControl.prototype.enableStyle = function (styleName) {
	        var styleButton = this.styleButtons[styleName];
	        if (styleButton) {
	            styleButton.removeAttribute("disabled");
	        }
	    };
	    StyleControl.prototype.buildSelectStyleBtn = function (name, mapConfiguration, fetchIconPromise) {
	        var _this = this;
	        var styleOptionButton = document.createElement("button");
	        var friendlyName = this.mapToFriendlyStyleName(name, mapConfiguration);
	        styleOptionButton.setAttribute("aria-label", friendlyName);
	        styleOptionButton.setAttribute("type", "button");
	        var styleIconImage = new Image();
	        fetchIconPromise
	            .then(function (response) {
	            if (_this.thumbnailCache.blob.has(response.url)) {
	                return _this.thumbnailCache.blob.get(response.url);
	            }
	            else {
	                // we need the response.clone() to allow reading over body multiple times since response objects are cached 
	                // and can be reused across multiple invocations
	                var blobPromise = response.clone().blob();
	                _this.thumbnailCache.blob.set(response.url, blobPromise);
	                return blobPromise;
	            }
	        })
	            .then(function (blob) {
	            var iconUrl = URL.createObjectURL(blob);
	            styleIconImage.src = iconUrl;
	            if (name === _this.map.getStyle().style) {
	                _this.currStyleImage.src = iconUrl;
	                _this.currStyleImage.alt = friendlyName;
	                if (_this.currStyleImage.parentElement.lastChild.nodeType == Node.TEXT_NODE) {
	                    _this.currStyleImage.parentElement.lastChild.textContent = friendlyName;
	                }
	                else {
	                    _this.currStyleImage.parentElement.appendChild(document.createTextNode(friendlyName));
	                }
	            }
	            _this.styleIcons.set(name, iconUrl);
	        });
	        styleIconImage.setAttribute("aria-hidden", "true");
	        styleOptionButton.appendChild(styleIconImage);
	        if (this.options.layout === "icons") {
	            styleOptionButton.classList.add(StyleControl.Css.button);
	        }
	        else {
	            styleOptionButton.classList.add(StyleControl.Css.listButton);
	            styleOptionButton.classList.add(StyleControl.Css.expanded);
	            styleOptionButton.appendChild(document.createTextNode(friendlyName));
	        }
	        styleOptionButton.addEventListener("click", function () {
	            _this.hasMouse = false;
	            _this.hasFocus = false;
	            var styleButton = _this.styleButtons[name];
	            if (styleButton && !styleButton.hasAttribute("disabled")) {
	                _this._invokeEvent("styleselected", name);
	                if (_this.options.autoSelectionMode) {
	                    _this.map.setStyle({ style: name });
	                }
	                Object.entries(_this.styleButtons).forEach(function (_a) {
	                    var _b = __read$f(_a, 2), styleName = _b[0], button = _b[1];
	                    return button.setAttribute('aria-current', styleName === name ? 'true' : 'false');
	                });
	            }
	        });
	        var iconDiv = document.createElement('div');
	        iconDiv.classList.add('selected-icon');
	        styleOptionButton.appendChild(iconDiv);
	        return styleOptionButton;
	    };
	    StyleControl.prototype.buildCurrStyleBtn = function () {
	        var selectCurrButton = document.createElement("button");
	        if (this.options.layout == 'icons') {
	            selectCurrButton.classList.add(StyleControl.Css.button);
	        }
	        else {
	            selectCurrButton.classList.add(StyleControl.Css.listButton);
	        }
	        selectCurrButton.classList.add(StyleControl.Css.currentStyle);
	        selectCurrButton.setAttribute("aria-label", "Select Style");
	        selectCurrButton.setAttribute("tabindex", "-1");
	        this.currStyleImage = new Image();
	        selectCurrButton.appendChild(this.currStyleImage);
	        var selectCurrButtonIcon = document.createElement("div");
	        selectCurrButtonIcon.classList.add("icon");
	        selectCurrButton.appendChild(selectCurrButtonIcon);
	        return selectCurrButton;
	    };
	    StyleControl.prototype.buildStyleOpsGrid = function () {
	        var _this = this;
	        var styleOpsGrid = document.createElement("div");
	        styleOpsGrid.classList.add(StyleControl.Css.styleOptions);
	        if (this.options.layout === 'icons') {
	            styleOpsGrid.classList.add(this.options.layout);
	        }
	        else {
	            styleOpsGrid.classList.add(StyleControl.Css.dropdown);
	        }
	        styleOpsGrid.setAttribute("aria-label", "Style Options");
	        styleOpsGrid.classList.add("hidden-accessible-element");
	        styleOpsGrid.setAttribute("aria-hidden", "true");
	        // Once the map's style definition is initialized create a map between style names and icons.
	        // If a style is one of those to be shown by the style picker also create it's element.
	        this.map.styles.definitions().then(function (definitions) { return __awaiter$7(_this, void 0, void 0, function () {
	            return __generator$7(this, function (_a) {
	                this.onMapConfigurationChange(definitions);
	                this.map.events.add("stylechanged", this.onStyleChange);
	                return [2 /*return*/];
	            });
	        }); });
	        this.map.events.add("mapconfigurationchanged", this.onMapConfigurationChange);
	        return styleOpsGrid;
	    };
	    StyleControl.prototype.populateOpsGridFromDefinitions = function (definitions) {
	        var _this = this;
	        if (!this.styleOpsGrid) {
	            return;
	        }
	        var styles = definitions.configurations;
	        if (Array.isArray(this.options.mapStyles)) {
	            styles = styles.filter(function (style) { return _this.options.mapStyles.includes(style.name.split("_indoor")[0]); });
	        }
	        styles.forEach(function (style) {
	            // Create fetch thumbnail request
	            var requestParams = {
	                url: style.thumbnail
	            };
	            style.thumbnail && _this.map.styles._transformStyleRequest(style.thumbnail, requestParams);
	            // Apply the users specified transform after ours
	            var mapServiceOptions = _this.map.getServiceOptions();
	            if (mapServiceOptions.transformRequest) {
	                merge$1(requestParams, mapServiceOptions.transformRequest(requestParams.url, "Thumbnail"));
	            }
	            var fetchThumbnailPromise;
	            if (_this.thumbnailCache.response.has(requestParams.url)) {
	                fetchThumbnailPromise = Promise.resolve(_this.thumbnailCache.response.get(requestParams.url));
	            }
	            else {
	                fetchThumbnailPromise = fetch(requestParams.url, { headers: requestParams.headers });
	                _this.thumbnailCache.response.set(requestParams.url, fetchThumbnailPromise);
	            }
	            // Add button for each style
	            var styleOptionButton = _this.buildSelectStyleBtn(style.name, definitions, fetchThumbnailPromise);
	            _this.styleOpsGrid.appendChild(styleOptionButton);
	            _this.styleButtons[style.name] = styleOptionButton;
	            if (_this.options.layout === "icons") {
	                var tooltip = buildAccessibleTooltip(_this.mapToFriendlyStyleName(style.name, definitions));
	                _this.styleOpsGrid.appendChild(tooltip);
	                positionTooltip(tooltip, styleOptionButton);
	            }
	        });
	        var targetStyleName = this.map.getStyle().style;
	        Object.entries(this.styleButtons).forEach(function (_a) {
	            var _b = __read$f(_a, 2), styleName = _b[0], button = _b[1];
	            return button.setAttribute('aria-current', styleName === targetStyleName ? 'true' : 'false');
	        });
	    };
	    StyleControl.InvertOrderPositions = [exports.ControlPosition.TopRight, exports.ControlPosition.BottomRight];
	    StyleControl.Css = {
	        button: "azure-maps-control-button",
	        listButton: "azure-maps-control-list-button",
	        expanded: 'expanded',
	        currentStyle: "curr-style",
	        inUse: "in-use",
	        styleOptions: "style-options",
	        dropdown: "azure-maps-control-dropdown"
	    };
	    return StyleControl;
	}(ControlBase));

	var __extends$1c = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for setting traffic on the map.
	 */
	var TrafficOptions = /** @class */ (function (_super) {
	    __extends$1c(TrafficOptions, _super);
	    function TrafficOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of traffic flow to display:<br />
	         * `"none"` is to display no traffic flow data<br />
	         * `"relative"` is the speed of the road relative to free-flow<br />
	         * @deprecated `"absolute"` is the absolute speed of the road<br />
	         * @deprecated `"relative-delay"` displays relative speed only where they differ from free-flow;
	         * false to stop displaying the traffic flow.<br />
	         * default `"none"`
	         * @default "none"
	         */
	        _this.flow = "none";
	        /**
	         * Whether to display incidents on the map.
	         * default `false`
	         * @default false
	         */
	        _this.incidents = false;
	        return _this;
	    }
	    return TrafficOptions;
	}(Options));

	var __extends$1b = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a TrafficControl object.
	 */
	var TrafficControlOptions = /** @class */ (function (_super) {
	    __extends$1b(TrafficControlOptions, _super);
	    function TrafficControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the control is in the active state (displaying traffic).
	         * Default: false
	         * @default false
	         */
	        _this.isActive = false;
	        /**
	         * The style of the control. Can be; light, dark, auto, or any CSS3 color. When set to auto, the style will change based on the map style.
	         * Default `light'.
	         * @default light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return TrafficControlOptions;
	}(TrafficOptions));

	var __extends$1a = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control that toggles traffic data on the map.
	 */
	var TrafficControl = /** @class */ (function (_super) {
	    __extends$1a(TrafficControl, _super);
	    /**
	     * Constructs a TrafficControl
	     * @param options The options for the control.
	     */
	    function TrafficControl(options) {
	        var _this = this;
	        var _a, _b;
	        _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        // desired map traffic state when control is enabled 
	        _this.options = new TrafficOptions().merge({
	            flow: 'relative',
	            incidents: true
	        });
	        _this.style = exports.ControlStyle.light;
	        _this.container = null;
	        _this.trafficButton = null;
	        _this.map = null;
	        if (options) {
	            _this.initIsActive = (_a = options.isActive) !== null && _a !== void 0 ? _a : false;
	            _this.options.flow = options.flow || 'relative';
	            _this.options.incidents = (_b = options.incidents) !== null && _b !== void 0 ? _b : true;
	            _this.style = options.style || exports.ControlStyle.light;
	        }
	        return _this;
	    }
	    Object.defineProperty(TrafficControl.prototype, "isActive", {
	        /**
	         * Current control state (is traffic information displayed?)
	         */
	        get: function () {
	            if (!this.map) {
	                return false;
	            }
	            var trafficState = this.map.getTraffic();
	            return trafficState.flow !== "none" || trafficState.incidents;
	        },
	        /**
	         * Sets the control state
	         */
	        set: function (newValue) {
	            if (!this.map) {
	                return;
	            }
	            this.map.setTraffic({
	                flow: newValue ? this.options.flow : 'none',
	                incidents: newValue ? this.options.incidents : false
	            });
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    TrafficControl.prototype.onAdd = function (map) {
	        this.map = map;
	        map.getTraffic();
	        // bring map traffic state in sync with desired if initIsActive have been set
	        if (this.initIsActive !== undefined) {
	            this.isActive = this.initIsActive;
	        }
	        this.container = this.buildContainer(map, this.style, "Traffic Control");
	        this.container.style.flexDirection = "column";
	        var trafficButton = this.constructTrafficButton(map);
	        this.container.appendChild(trafficButton);
	        var tooltip = buildAccessibleTooltip("Toggle Traffic Display");
	        this.container.appendChild(tooltip);
	        positionTooltip(tooltip, trafficButton);
	        return this.container;
	    };
	    TrafficControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        this.map = null;
	    };
	    /**
	     * Get the TrafficControlOptions
	     */
	    TrafficControl.prototype.getOptions = function () {
	        return new TrafficControlOptions().merge({
	            isActive: this.isActive,
	            flow: this.options.flow,
	            incidents: this.options.incidents,
	            style: this.style
	        });
	    };
	    /**
	     * Updates the button state according to current traffic state
	     * This is invoked on init in constructTrafficButton and on each Map.setTraffic()
	     */
	    TrafficControl.prototype.updateButtonState = function () {
	        if (this.trafficButton) {
	            if (this.isActive) {
	                this.container.classList.add("in-use");
	                this.trafficButton.setAttribute("aria-description", "Traffic is displayed");
	            }
	            else {
	                this.container.classList.remove("in-use");
	                this.trafficButton.removeAttribute("aria-description");
	            }
	            this.trafficButton.setAttribute("aria-pressed", this.isActive ? "true" : "false");
	        }
	    };
	    TrafficControl.prototype.constructTrafficButton = function (map) {
	        var _this = this;
	        var trafficButton = document.createElement("button");
	        trafficButton.classList.add("azure-maps-control-button");
	        trafficButton.classList.add("traffic");
	        trafficButton.setAttribute("aria-label", "Toggle Traffic Display");
	        trafficButton.setAttribute("alt", "Toggle Traffic Display");
	        trafficButton.setAttribute("type", "button");
	        this.trafficButton = trafficButton;
	        this.updateButtonState();
	        // toggle button
	        trafficButton.addEventListener("click", function () {
	            _this.isActive = !_this.isActive;
	        });
	        return trafficButton;
	    };
	    return TrafficControl;
	}(ControlBase));

	var __extends$19 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$j = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A control that display traffic legend on the map.
	 */
	var TrafficLegendControl = /** @class */ (function (_super) {
	    __extends$19(TrafficLegendControl, _super);
	    /**
	     * Construct a traffic legend control
	     */
	    function TrafficLegendControl() {
	        var _this = _super.call(this) || this;
	        _this.table = ["Fast",
	            ["green", "yellow", "red", "dark-red"],
	            "Slow"];
	        _this.map = null;
	        _this.syncHiddenState = null;
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    TrafficLegendControl.prototype.onAdd = function (map) {
	        this.map = map;
	        var container = this.buildContainer(map, exports.ControlStyle.auto, "Traffic Legend");
	        var TrafficLegendDiv = this.buildTrafficLegendDiv(map);
	        container.setAttribute("role", "definition");
	        container.appendChild(TrafficLegendDiv);
	        return container;
	    };
	    TrafficLegendControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        if (this.syncHiddenState) {
	            this.map.events.remove('styledata', this.syncHiddenState);
	            this.syncHiddenState = null;
	        }
	        this.map = null;
	    };
	    TrafficLegendControl.prototype.buildTrafficLegendDiv = function (map) {
	        var e_1, _a, e_2, _b;
	        var trafficLegend = document.createElement("div");
	        trafficLegend.classList.add("traffic-legend", "hidden");
	        trafficLegend.setAttribute("alt", "Traffic Legend");
	        var trafficLegendTable = document.createElement("table");
	        // legend table title
	        var tr1 = document.createElement("tr");
	        var td = document.createElement("td");
	        td.setAttribute("alt", "Traffic");
	        td.appendChild(document.createTextNode("Traffic"));
	        var tooltip = buildAccessibleTooltip("Traffic");
	        td.classList.add("traffic-legend-title");
	        td.colSpan = 6;
	        tr1.appendChild(td);
	        tr1.appendChild(tooltip);
	        positionTooltip(tooltip, td);
	        trafficLegendTable.appendChild(tr1);
	        // legend table contents
	        var tr2 = document.createElement("tr");
	        try {
	            for (var _c = __values$j(this.table), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var col = _d.value;
	                var data = document.createElement("td");
	                if (col === "Fast" || col === "Slow") {
	                    data.setAttribute("alt", col);
	                    data.appendChild(document.createTextNode(col));
	                    data.classList.add("traffic-legend-text");
	                }
	                else {
	                    data.classList.add("traffic-legend-colors");
	                    data.setAttribute("aria-label", "Traffic Legend");
	                    data.setAttribute("role", "img");
	                    try {
	                        for (var col_1 = (e_2 = void 0, __values$j(col)), col_1_1 = col_1.next(); !col_1_1.done; col_1_1 = col_1.next()) {
	                            var color = col_1_1.value;
	                            var div = document.createElement("div");
	                            div.classList.add(color);
	                            data.appendChild(div);
	                        }
	                    }
	                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                    finally {
	                        try {
	                            if (col_1_1 && !col_1_1.done && (_b = col_1.return)) _b.call(col_1);
	                        }
	                        finally { if (e_2) throw e_2.error; }
	                    }
	                }
	                tr2.appendChild(data);
	                var tooltip_1 = buildAccessibleTooltip(col instanceof Array ? "Traffic Legend" : col);
	                tr2.appendChild(tooltip_1);
	                positionTooltip(tooltip_1, data);
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        trafficLegendTable.appendChild(tr2);
	        trafficLegend.appendChild(trafficLegendTable);
	        this.syncHiddenState = function (eventData) {
	            if (eventData.dataType === "style") {
	                var trafficOptions = map.getTraffic();
	                if (trafficOptions.flow && trafficOptions.flow !== "none") {
	                    trafficLegend.classList.remove("hidden");
	                }
	                else {
	                    trafficLegend.classList.add("hidden");
	                }
	            }
	        };
	        // display legend when the traffic flow is shown, hide it otherwise
	        this.syncHiddenState({ dataType: 'style' });
	        map.events.add("styledata", this.syncHiddenState);
	        return trafficLegend;
	    };
	    return TrafficLegendControl;
	}(ControlBase));

	/** Used to stand-in for `undefined` hash values. */

	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd$1(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	var _setCacheAdd = setCacheAdd$1;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */

	function setCacheHas$1(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas$1;

	var MapCache = _MapCache,
	    setCacheAdd = _setCacheAdd,
	    setCacheHas = _setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache$1(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
	SetCache$1.prototype.has = setCacheHas;

	var _SetCache = SetCache$1;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */

	function arraySome$1(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arraySome = arraySome$1;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function cacheHas$1(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas$1;

	var SetCache = _SetCache,
	    arraySome = _arraySome,
	    cacheHas = _cacheHas;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	var _equalArrays = equalArrays$2;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */

	function mapToArray$1(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	var _mapToArray = mapToArray$1;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */

	function setToArray$1(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray$1;

	var Symbol$1 = _Symbol,
	    Uint8Array$1 = _Uint8Array,
	    eq = eq_1,
	    equalArrays$1 = _equalArrays,
	    mapToArray = _mapToArray,
	    setToArray = _setToArray;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	var _equalByTag = equalByTag$1;

	var getAllKeys = _getAllKeys;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	var _equalObjects = equalObjects$1;

	var Stack = _Stack,
	    equalArrays = _equalArrays,
	    equalByTag = _equalByTag,
	    equalObjects = _equalObjects,
	    getTag = _getTag,
	    isArray = isArray_1,
	    isBuffer = isBufferExports,
	    isTypedArray = isTypedArray_1;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	var _baseIsEqualDeep = baseIsEqualDeep$1;

	var baseIsEqualDeep = _baseIsEqualDeep,
	    isObjectLike$1 = isObjectLike_1;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual$1(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike$1(value) && !isObjectLike$1(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
	}

	var _baseIsEqual = baseIsEqual$1;

	var baseIsEqual = _baseIsEqual;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	var isEqual_1 = isEqual;

	var isEqual$1 = /*@__PURE__*/getDefaultExportFromCjs(isEqual_1);

	/**
	 * A GeoJSON Feature object - a JSON object representing a spatially bounded entity. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.2}.
	 */
	var Feature = /** @class */ (function () {
	    /**
	     * Constructs a Feature.
	     * @param geometry The geometry of the feature.
	     * @param properties The properties of the feature.
	     * @param id The id of the feature.
	     * @param bbox The bounding box of the feature.
	     */
	    function Feature(geometry, properties, id, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "Feature".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Feature";
	        this.type = Feature.TYPE;
	        this.properties = properties || {};
	        this.id = id;
	        this.geometry = geometry;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Feature class to be used in runtime comparisons.
	     */
	    Feature.TYPE = "Feature";
	    return Feature;
	}());

	var __extends$18 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represent a pixel coordinate or offset. Extends an array of [x, y].
	 */
	var Pixel = /** @class */ (function (_super) {
	    __extends$18(Pixel, _super);
	    /**
	     * Constructs a Pixel object and initializes it with the specified x and y coordinates.
	     * @param x The horizontal pixel offset.
	     * @param y The vertical pixel offset.
	     */
	    function Pixel(x, y) {
	        return _super.call(this, x, y) || this;
	    }
	    /**
	     * Generates a Pixel object from an object that contains coordinate information.
	     * The object is scanned for x and y properties using a case insensitive test.
	     * @param data The object to extract coordinate information from.
	     * @returns A Pixel object that represents the provided data information.
	     */
	    Pixel.fromData = function (data) {
	        var x = NaN;
	        var y = NaN;
	        var xNames = new Set(["y"]);
	        var yNames = new Set(["x"]);
	        // Do a case insensitive search through the object properties.
	        Object.keys(data).forEach(function (key) {
	            var smallKey = key.toLowerCase();
	            if (isNaN(x) && xNames.has(smallKey) && typeof data[key] === "number") {
	                x = data[key];
	            }
	            else if (isNaN(y) && yNames.has(smallKey) && typeof data[key] === "number") {
	                y = data[key];
	            }
	        });
	        // If an x and y value were found return the Pixel constructed from them.
	        if (!isNaN(x) && !isNaN(y)) {
	            return new Pixel(x, y);
	        }
	        return null;
	    };
	    /**
	     * Return the x coordinate of the specified pixel.
	     * @param pixel The pixel to get the x coordinate of.
	     */
	    Pixel.getX = function (pixel) {
	        if (pixel.length > 0) {
	            return pixel[0];
	        }
	        return NaN;
	    };
	    /**
	     * Return the y coordinate of the specified pixel.
	     * @param pixel The pixel to get the y coordinate of.
	     */
	    Pixel.getY = function (pixel) {
	        if (pixel.length > 1) {
	            return pixel[1];
	        }
	        return NaN;
	    };
	    /**
	     * Calculates a destination pixel given an origin pixel,​
	     * a heading relative to the y-axis (0 = north) with clockwise-rotation,​
	     * and a distance in pixel units.​
	     * @param origin The starting pixel.​
	     * @param heading The heading at which to move away from the origin pixel.​
	     * @param distance The distance to move from the origin pixel.​
	     */
	    Pixel.getDestination = function (origin, heading, distance) {
	        return new Pixel(Pixel.getX(origin) + distance * Math.cos((heading + 270) * Math.PI / 180), Pixel.getY(origin) + distance * Math.sin((heading + 270) * Math.PI / 180));
	    };
	    /**
	     * Calculates the distance between two pixels.
	     * Returned value is in screen pixel units.
	     * @param p1 The first pixel.
	     * @param p2 The second pixel.
	     */
	    Pixel.getDistance = function (p1, p2) {
	        var dx = Pixel.getX(p1) - Pixel.getX(p2);
	        var dy = Pixel.getY(p1) - Pixel.getY(p2);
	        return Math.sqrt(dx * dx + dy * dy);
	    };
	    /**​
	     * Calculates the heading between two pixels.​ The heading value is relative to the y-axis (0 = north) with clockwise-rotation.
	     * @param origin The pixel the heading will point away from.​
	     * @param destination The pixel the heading will point toward.​
	     */
	    Pixel.getHeading = function (origin, destination) {
	        var dx = Pixel.getX(destination) - Pixel.getX(origin);
	        var dy = Pixel.getY(origin) - Pixel.getY(destination);
	        return ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * 180 / Math.PI % 360;
	    };
	    return Pixel;
	}(Array));

	/**
	 * A GeoJSON Point object - a JSON object that represents a geographic position. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.2}.
	 */
	var Point = /** @class */ (function () {
	    /**
	     * Constructs a Point.
	     * @param coordinates The position defining the point.
	     */
	    function Point(coordinates) {
	        /**
	         * A GeoJSON type descriptor with value "Point".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Point";
	        this.type = Point.TYPE;
	        this.coordinates = coordinates;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Point class to be used in runtime comparisons.
	     */
	    Point.TYPE = "Point";
	    return Point;
	}());

	var __read$e = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __values$i = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	//////////////////////
	/// Constants
	//////////////////////
	/**
	 * Earth Radius Semi Major Axis in meters
	 */
	var EARTH_RADIUS_SEMI_MAJOR_AXIS = 6378137;
	/**
	 * A constant for Math.PI/180. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var PI_BY_180 = Math.PI / 180;
	/**
	 * A constant for 180 / Math.PI. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var INV_PI_BY_180 = 180 / Math.PI;
	/**
	 * Cached array of powers of 10. This will be faster than call Math.pow.
	 */
	var POWERS_OF_10 = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
	/**
	 * Maximum latitude as defined in WebMercator
	 */
	var WEBMERCATOR_MAXLAT = 85.0511;
	//////////////////////
	/// Private Functions
	//////////////////////
	/**
	 * Converts an angle that is in degrees to radians. Angle * (PI / 180).
	 * @param angle An angle in degrees.
	 * @returns An angle in radians.
	 */
	function _toRadians(angle) {
	    return angle * PI_BY_180;
	}
	/**
	 * Converts an angle that is in radians to degrees. Angle * (180 / PI).
	 * @param angle An angle in radians.
	 * @returns An angle in degrees.
	 */
	function _toDegrees(angle) {
	    return angle * INV_PI_BY_180;
	}
	/**
	 * Clips a number to the specified minimum and maximum values.
	 * @param val The number to clip.
	 * @param minValue Minimum allowable value.
	 * @param maxValue Maximum allowable value.
	 * @returns The clipped value.
	 */
	function _clip(val, minValue, maxValue) {
	    return Math.min(Math.max(val, minValue), maxValue);
	}
	/**
	 * Calculates geodetic distance between two Position objects using Haversine formula in meters.
	 * @param origin Position to calculate distance from.
	 * @param destination Position to calculate distance to.
	 * @returns A distance in meters between the two positions.
	 */
	function _haversineDistance(origin, destination) {
	    // https://en.wikipedia.org/wiki/Haversine_formula
	    var dLat = _toRadians(destination[1] - origin[1]);
	    var dLon = _toRadians(destination[0] - origin[0]);
	    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(_toRadians(origin[1])) * Math.cos(_toRadians(destination[1])) * Math.pow(Math.sin(dLon / 2), 2);
	    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    return Math.round(EARTH_RADIUS_SEMI_MAJOR_AXIS * c * 100) / 100; // Round to 1cm precision.
	}
	/**
	 * Normalizes a distance unit string. Defaults to meters.
	 * @param units The distance units to normalize.
	 * @returns A normalized distance unit string.
	 */
	function _normalizeDistanceUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feet":
	            case "foot":
	            case "ft":
	                return DistanceUnits.feet;
	            case "kilometers":
	            case "kilometer":
	            case "kilometres":
	            case "kilometre":
	            case "km":
	            case "kms":
	                return DistanceUnits.kilometers;
	            case "miles":
	            case "mile":
	            case "mi":
	                return DistanceUnits.miles;
	            case "nauticalmiles":
	            case "nauticalmile":
	            case "nms":
	            case "nm":
	                return DistanceUnits.nauticalMiles;
	            case "yards":
	            case "yard":
	            case "yds":
	            case "yrd":
	            case "yrds":
	                return DistanceUnits.yards;
	            case "meters":
	            case "metres":
	            case "m":
	            default:
	                return DistanceUnits.meters;
	        }
	    }
	    return DistanceUnits.meters;
	}
	/**
	 * Normailzes a acceleration unit string. Defaults to metersPerSecondSquared.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param units The acceleration units to normalize.
	 * @returns A normailzed acceleration unit string.
	 */
	function _normalizeAccelerationUnit(units) {
	    // Convert to metersPerSecondSquared
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milespersecondsquared": // mi/s^2
	            case "milepersecondsquared":
	            case "mi/s^2":
	            case "mi/s2":
	                return AccelerationUnits.milesPerSecondSquared;
	            case "kilometerspersecondsquared": // km/s^2
	            case "kilometrespersecondsquared":
	            case "kilometerpersecondsquared":
	            case "kilometrepersecondsquared":
	            case "km/s^2":
	            case "km/s2":
	                return AccelerationUnits.kilometersPerSecondSquared;
	            case "knotspersecond": // knts/s
	            case "knotpersecond":
	            case "knts/s":
	            case "kn/s":
	            case "kt/s":
	                return AccelerationUnits.knotsPerSecond;
	            case "standardgravity": // g
	            case "g":
	                return AccelerationUnits.standardGravity;
	            case "feetpersecondsquared": // ft/s^2
	            case "footpersecondsquared":
	            case "ft/s^2":
	            case "ft/s2":
	                return AccelerationUnits.feetPerSecondSquared;
	            case "yardspersecondsquared": // yds/s^2
	            case "yardpersecondsquared":
	            case "yds/s^2":
	            case "yds/s2":
	            case "yd/s^2":
	            case "yd/s2":
	                return AccelerationUnits.yardsPerSecondSquared;
	            case "milesperhoursecond": // mi/h/s
	            case "mileperhoursecond":
	            case "milesperhourseconds":
	            case "mileperhourseconds":
	            case "mi/h/s":
	                return AccelerationUnits.milesPerHourSecond;
	            case "kilometersperhoursecond": // km/h/s
	            case "kilometrespersoursecond":
	            case "kilometerperhoursecond":
	            case "kilometrepersoursecond":
	            case "kilometersperhourssecond":
	            case "kilometrespersourssecond":
	            case "kilometerperhourssecond":
	            case "kilometrepersourssecond":
	            case "kmhs":
	            case "km/h/s":
	                return AccelerationUnits.kilometersPerHourSecond;
	            case "meterspersecondsquared": // m/s^2
	            case "metrespersecondsquared":
	            case "meterpersecondsquared":
	            case "metrepersecondsquared":
	            case "m/s^2":
	            case "m/s2":
	            default:
	                return AccelerationUnits.metersPerSecondSquared;
	        }
	    }
	    return AccelerationUnits.metersPerSecondSquared;
	}
	/**
	 * Normailzes an area unit string. Defaults to squareMeters.
	 * @param units The area units to normalize.
	 * @returns A normailzed area unit string.
	 */
	function _normalizeAreaUnits(units) {
	    if (units) {
	        switch (units) {
	            case "acres":
	            case "ac":
	                return AreaUnits.acres;
	            case "hectares":
	            case "ha":
	                return AreaUnits.hectares;
	            case "squareFeet":
	            case "ft^2":
	            case "ft2":
	                return AreaUnits.squareFeet;
	            case "squareYards":
	            case "squareYard":
	            case "yds^2":
	            case "yds2":
	            case "yd^2":
	            case "yd2":
	                return AreaUnits.squareYards;
	            case "squareKilometers":
	            case "squareKilometres":
	            case "squareKilometer":
	            case "squareKilometre":
	            case "km^2":
	            case "km2":
	                return AreaUnits.squareKilometers;
	            case "squareMiles":
	            case "squareMile":
	            case "mi^2":
	            case "mi2":
	                return AreaUnits.squareMiles;
	            case "squareMeters":
	            case "squareMetres":
	            case "squareMeter":
	            case "squareMetre":
	            case "m^2":
	            case "m2":
	            default:
	                return AreaUnits.squareMeters;
	        }
	    }
	    return AreaUnits.squareMeters;
	}
	/**
	 * Normailzes a speed unit string. Defaults to metersPerSecond.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param units The speed units to normalize.
	 * @returns A normailzed speed unit string.
	 */
	function _normalizeSpeedUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feetpersecond":
	            case "footsecond":
	            case "ftps":
	            case "ft/s":
	                return SpeedUnits.feetPerSecond;
	            case "milesperhour":
	            case "mileperhour":
	            case "mph":
	            case "mi/hr":
	            case "mi/h":
	                return SpeedUnits.milesPerHour;
	            case "knots":
	            case "knot":
	            case "knts":
	            case "knt":
	            case "kn":
	            case "kt":
	                return SpeedUnits.knots;
	            case "mach":
	            case "m":
	                return SpeedUnits.mach;
	            case "kilometersperhour":
	            case "kilometresperhour":
	            case "kmperhour":
	            case "kmph":
	            case "km/hr":
	            case "km/h":
	                return SpeedUnits.kilometersPerHour;
	            case "meterspersecond":
	            case "metrespersecond":
	            case "mps":
	            case "ms":
	            case "m/s":
	            default:
	                return SpeedUnits.metersPerSecond;
	        }
	    }
	    return SpeedUnits.metersPerSecond;
	}
	/**
	 * Normailzes a time unit string. Defaults to seconds.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param units The time units to normalize.
	 * @returns A normailzed time unit string.
	 */
	function _normalizeTimeUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milliseconds":
	            case "ms":
	                return TimeUnits.ms;
	            case "minutes":
	            case "minute":
	            case "mins":
	            case "min":
	                return TimeUnits.minutes;
	            case "hours":
	            case "hour":
	            case "hr":
	            case "h":
	                return TimeUnits.hours;
	            case "days":
	            case "day":
	            case "d":
	                return TimeUnits.days;
	            case "seconds":
	            case "second":
	            case "secs":
	            case "sec":
	            case "s":
	            default:
	                return TimeUnits.seconds;
	        }
	    }
	    return TimeUnits.seconds;
	}
	/**
	 * Calculates the area of a polygon in square meters.
	 * @param coordinates The coordinates of the polygon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @returns The area of a polygon in square meters.
	 */
	function _calculatePolygonArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates && coordinates.length > 0) {
	        // Calculate the area of the outer/exterior ring of the polygon.
	        area = Math.abs(_calculatePolygonRingArea(coordinates[0]));
	        // Subtract the area of the holes of the polygon.
	        for (var i = 1, len = coordinates.length; i < len; i++) {
	            area -= Math.abs(_calculatePolygonRingArea(coordinates[i]));
	        }
	    }
	    return area;
	}
	/**
	 * Calculates the area of a polygon ring  in square meters.
	 * The area value will be positive if the coordinates in the ring are ordered clockwise,
	 * and negative if ordered counter-clockwise.
	 * @param coordinates The coordinates of the polygon ring.
	 * @returns The area of the ring in square meters.
	 */
	function _calculatePolygonRingArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates.length >= 3) {
	        var p1 = void 0;
	        var p2 = void 0;
	        var p3 = void 0;
	        for (var i = 0, len = coordinates.length; i < len; i++) {
	            // Create triangles from the coordinates.
	            if (i === len - 2) { // i = N-2
	                p1 = len - 2;
	                p2 = len - 1;
	                p3 = 0;
	            }
	            else if (i === len - 1) { // i = N-1
	                p1 = len - 1;
	                p2 = 0;
	                p3 = 1;
	            }
	            else { // i = 0 to N-3
	                p1 = i;
	                p2 = i + 1;
	                p3 = i + 2;
	            }
	            area += (_toRadians(coordinates[p3][0]) - _toRadians(coordinates[p1][0])) * Math.sin(_toRadians(coordinates[p2][1]));
	        }
	        area = area * EARTH_RADIUS_SEMI_MAJOR_AXIS * EARTH_RADIUS_SEMI_MAJOR_AXIS / 2;
	    }
	    return area;
	}
	/**
	 * 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.
	 * Returns a positive value, if OAB makes a counter-clockwise turn,
	 * negative for clockwise turn, and zero if the points are collinear.
	 * @param a Position A
	 * @param b Position B
	 * @param o Position O
	 * @returns The 2D cross product of OA and OB vectors.
	 */
	function _cross(a, b, o) {
	    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
	}
	/**
	 * Takes an array of positions that form a path and calculates the closest point on the path to a specified position.
	 * @param pos The position to find the closest point to.
	 * @param px The pixel value of the position at zoom level 22.
	 * @param path An array of positions that form a path.
	 * @returns The closest point on the path to the specified position.
	 */
	function _closestPointOnPath(pos, px, path) {
	    // Need atleast two points
	    if (path.length >= 2) {
	        var minDis = Infinity;
	        var d = void 0;
	        var closest = null;
	        // Convert path to pixels.
	        var pixels = mercatorPositionsToPixels(path, 22);
	        var cPx = void 0;
	        for (var i = 0, len = pixels.length - 1; i < len; i++) {
	            cPx = _closestPixelOnLineSegment(px, pixels[i], pixels[i + 1]);
	            d = Pixel.getDistance(px, cPx);
	            if (d < minDis) {
	                minDis = d;
	                closest = cPx;
	            }
	        }
	        if (closest) {
	            var cPos = mercatorPixelsToPositions([closest], 22)[0];
	            return new Feature(new Point(cPos), {
	                distance: getDistanceTo(pos, cPos)
	            });
	        }
	    }
	    else if (path.length === 1) {
	        return new Feature(new Point(path[0]), {
	            distance: getDistanceTo(pos, path[0])
	        });
	    }
	    return null;
	}
	/**
	 * Calculates the closest pixel on a line segment from a given point in 2D space.
	 * @param px The pixel near the line that we are working with.
	 * @param sPx Start pixel of the line segment.
	 * @param ePx End pixel of the line segment.
	 * @returns The closest pixel on the line segement to the specified pixel.
	 */
	function _closestPixelOnLineSegment(px, sPx, ePx) {
	    // If start and end points of line are equal, then that is the closest point.
	    if (sPx[0] === ePx[0] && sPx[1] === ePx[1]) {
	        return sPx;
	    }
	    var APx = px[0] - sPx[0];
	    var APy = px[1] - sPx[1];
	    var ABx = ePx[0] - sPx[0];
	    var ABy = ePx[1] - sPx[1];
	    var magAB2 = ABx * ABx + ABy * ABy;
	    var ABdotAP = ABx * APx + ABy * APy;
	    var t = ABdotAP / magAB2;
	    if (t < 0) {
	        return sPx;
	    }
	    else if (t > 1) {
	        return ePx;
	    }
	    else {
	        return [sPx[0] + ABx * t, sPx[1] + ABy * t];
	    }
	}
	//////////////////////
	/// Internal Functions
	//////////////////////
	/**
	 * Round a number to the specified number of decimal places.
	 * @param val The value to round.
	 * @param decimals The number of decimals.
	 * @returns A number rounded to the specified number of decimal places.
	 * @internal
	 */
	function _precision(val, decimals) {
	    if (!isNaN(val) && typeof decimals === "number" && decimals >= 0) {
	        var power = void 0;
	        if (decimals < POWERS_OF_10.length) {
	            power = POWERS_OF_10[decimals];
	        }
	        else {
	            power = Math.pow(10, decimals);
	        }
	        val = Math.round(val * power) / power;
	    }
	    return val;
	}
	//////////////////////
	/// Public Enums
	//////////////////////
	/**
	 * Units of measurement for areas.
	 */
	var AreaUnits;
	(function (AreaUnits) {
	    /**
	     * Represents areas in square meters (m^2).
	     * Literal value `""`
	     */
	    AreaUnits["squareMeters"] = "squareMeters";
	    /**
	     * Represents areas in acres (ac).
	     * Literal value `"acres"`
	     */
	    AreaUnits["acres"] = "acres";
	    /**
	     * Represents areas in hectares (ha).
	     * Literal value `"hectares"`
	     */
	    AreaUnits["hectares"] = "hectares";
	    /**
	     * Represents areas in feet (ft^2).
	     * Literal value `"squareFeet"`
	     */
	    AreaUnits["squareFeet"] = "squareFeet";
	    /**
	     * Represents areas in square kilometers (km^2).
	     * Literal value `"squareKilometers"`
	     */
	    AreaUnits["squareKilometers"] = "squareKilometers";
	    /**
	     * Represents areas in miles (mi^2).
	     * Literal value `"squareMiles"`
	     */
	    AreaUnits["squareMiles"] = "squareMiles";
	    /**
	     * Represents areas in yards (yds^2).
	     * Literal value `"squareYards"`
	     */
	    AreaUnits["squareYards"] = "squareYards";
	})(AreaUnits || (AreaUnits = {}));
	/**
	 * Units of measurement for distances.
	 */
	var DistanceUnits;
	(function (DistanceUnits) {
	    /**
	     * Represents a distance in meters (m).
	     * Literal value `"meters"`
	     */
	    DistanceUnits["meters"] = "meters";
	    /**
	     * Represents a distance in kilometers (km).
	     * Literal value `"kilometers"`
	     */
	    DistanceUnits["kilometers"] = "kilometers";
	    /**
	     * Represents a distance in feet (ft).
	     * Literal value `"feet"`
	     */
	    DistanceUnits["feet"] = "feet";
	    /**
	     * Represents a distance in miles (mi).
	     * Literal value `"miles"`
	     */
	    DistanceUnits["miles"] = "miles";
	    /**
	     * Represents a distance in nautical miles.
	     * Literal value `"nauticalMiles"`
	     */
	    DistanceUnits["nauticalMiles"] = "nauticalMiles";
	    /**
	     * Represents a distance in yards (yds).
	     * Literal value `"yards"`
	     */
	    DistanceUnits["yards"] = "yards";
	})(DistanceUnits || (DistanceUnits = {}));
	/**
	 * Units of measurement for time.
	 */
	var TimeUnits;
	(function (TimeUnits) {
	    /**
	     * Represents a time in seconds (s).
	     * Literal value `"seconds"`
	     */
	    TimeUnits["seconds"] = "seconds";
	    /**
	     * Represents a time in hours (hr).
	     * Literal value `"hours"`
	     */
	    TimeUnits["hours"] = "hours";
	    /**
	     * Represents a time in milliseconds (ms).
	     * Literal value `"ms"`
	     */
	    TimeUnits["ms"] = "ms";
	    /**
	     * Represents a time in minutes (min).
	     * Literal value `"minutes"`
	     */
	    TimeUnits["minutes"] = "minutes";
	    /**
	     * Represents a time in days (d).
	     * Literal value `"days"`
	     */
	    TimeUnits["days"] = "days";
	})(TimeUnits || (TimeUnits = {}));
	/**
	 * Units of measurement for speed.
	 */
	var SpeedUnits;
	(function (SpeedUnits) {
	    /**
	     * Represents a speed in meters per second (m/s).
	     * Literal value `"metersPerSecond"`
	     */
	    SpeedUnits["metersPerSecond"] = "metersPerSecond";
	    /**
	     * Represents a speed in kilometers per hour (km/h).
	     * Literal value `"kilometersPerHour"`
	     */
	    SpeedUnits["kilometersPerHour"] = "kilometersPerHour";
	    /**
	     * Represents a speed in feet per second (ft/s).
	     * Literal value `"feetPerSecond"`
	     */
	    SpeedUnits["feetPerSecond"] = "feetPerSecond";
	    /**
	     * Represents a speed in miles per hour (mph).
	     * Literal value `"milesPerHour"`
	     */
	    SpeedUnits["milesPerHour"] = "milesPerHour";
	    /**
	     * Represents a speed in knots (knts).
	     * Literal value `"knots"`
	     */
	    SpeedUnits["knots"] = "knots";
	    /**
	     * Represents a speed in mach.
	     * Literal value `"mach"`
	     */
	    SpeedUnits["mach"] = "mach";
	})(SpeedUnits || (SpeedUnits = {}));
	/**
	 * Units of measurement for acceleration.
	 */
	var AccelerationUnits;
	(function (AccelerationUnits) {
	    /**
	     * Represents an acceleration in miles per second squared (mi/s^2).
	     * Literal value `"milesPerSecondSquared"`
	     */
	    AccelerationUnits["milesPerSecondSquared"] = "milesPerSecondSquared";
	    /**
	     * Represents an acceleration in kilometers per second squared (km/s^2).
	     * Literal value `"kilometersPerSecondSquared"`
	     */
	    AccelerationUnits["kilometersPerSecondSquared"] = "kilometersPerSecondSquared";
	    /**
	     * Represents an acceleration in knots per second (knts/s).
	     * Literal value `"knotsPerSecond"`
	     */
	    AccelerationUnits["knotsPerSecond"] = "knotsPerSecond";
	    /**
	     * Represents an acceleration in standard gravity units (g).
	     * Literal value `"standardGravity"`
	     */
	    AccelerationUnits["standardGravity"] = "standardGravity";
	    /**
	     * Represents an acceleration in feet per second squared (ft/s^2).
	     * Literal value `"feetPerSecondSquared"`
	     */
	    AccelerationUnits["feetPerSecondSquared"] = "feetPerSecondSquared";
	    /**
	     * Represents an acceleration in yards per second squared (yds/s^2).
	     * Literal value `"yardsPerSecondSquared"`
	     */
	    AccelerationUnits["yardsPerSecondSquared"] = "yardsPerSecondSquared";
	    /**
	     * Represents an acceleration in miles per hour second (mi/h/s).
	     * Literal value `"milesPerHourSecond"`
	     */
	    AccelerationUnits["milesPerHourSecond"] = "milesPerHourSecond";
	    /**
	     * Represents an acceleration in kilometers per hours second (km/h/s).
	     * Literal value `"kilometersPerHourSecond"`
	     */
	    AccelerationUnits["kilometersPerHourSecond"] = "kilometersPerHourSecond";
	    /**
	     * Represents an acceleration in meters per second squared (m/s^2).
	     * Literal value `"metersPerSecondSquared"`
	     */
	    AccelerationUnits["metersPerSecondSquared"] = "metersPerSecondSquared";
	})(AccelerationUnits || (AccelerationUnits = {}));
	//////////////////////
	/// Public Methods
	//////////////////////
	/**
	 * Takes a BoundingBox and converts it to a polygon.
	 * @param bounds The BoundingBox to convert to a Polygon.
	 * @returns A polygon representation of the BoundingBox.
	 */
	function boundingBoxToPolygon(bounds) {
	    var w = normalizeLongitude(BoundingBox.getWest(bounds));
	    var e = normalizeLongitude(BoundingBox.getEast(bounds));
	    var n = normalizeLatitude(BoundingBox.getNorth(bounds));
	    var s = normalizeLatitude(BoundingBox.getSouth(bounds));
	    var center = BoundingBox.getCenter(bounds);
	    var pos = [
	        [w, n],
	        [w, s],
	        [center[0], s],
	        [e, s],
	        [e, n],
	        [center[0], n],
	        [w, n]
	    ];
	    return new Polygon([pos]);
	}
	/**
	 * Converts a distance from one distance units to another. Supported units: miles, nauticalMiles, yards, meters, kilometers, feet
	 * @param distance A number that represents a distance to convert.
	 * @param fromUnits The distance units the original distance is in.
	 * @param toUnits The desired distance units to convert to.
	 * @param decimals Specifies the number of decimal places to round the result to. If undefined, no rounding will occur.
	 * @returns A distance in the new units.
	 */
	function convertDistance(distance, fromUnits, toUnits, decimals) {
	    // Convert the distance to kilometers
	    switch (_normalizeDistanceUnit(fromUnits)) {
	        case DistanceUnits.meters:
	            distance /= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance /= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance /= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance /= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance /= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    // Convert from kilometers to output distance unit
	    switch (_normalizeDistanceUnit(toUnits)) {
	        case DistanceUnits.meters:
	            distance *= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance *= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance *= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance *= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance *= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    if (typeof decimals === "number" && decimals >= 0) {
	        var power = Math.pow(10, decimals);
	        distance = Math.round(distance * power) / power;
	    }
	    return distance;
	}
	/**
	 * Calculates an array of positions that form a cardinal spline between the specified array of positions.
	 * @param positions The array of positions to calculate the spline through.
	 * @param tension A number that indicates the tightness of the curve. Can be any number, although a value between 0 and 1 is usually used. Default: 0.5
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @param close A boolean indicating if the spline should be a closed ring or not. Default: false
	 * @returns An array of positions that form a cardinal spline between the specified array of positions.
	 */
	function getCardinalSpline(positions, tension, nodeSize, close) {
	    // Resources:
	    // http://www.cubic.org/docs/hermite.htm
	    // http://codeplea.com/introduction-to-splines
	    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms536358(v=vs.85).aspx
	    var locs;
	    if (!positions || positions.length <= 2) {
	        return locs;
	    }
	    if (typeof tension !== "number") {
	        tension = 0.5;
	    }
	    if (typeof nodeSize !== "number" || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    // Get the number of locations the spline passs through.
	    var len = positions.length;
	    // Create a copy of the array of locations so that we don't alter the original array.
	    locs = positions.slice(0);
	    // Add additional locations to array so that tangents can be calculated for end points.
	    if (close) {
	        // If the location array forms a closed ring, remove the last location.
	        if (Position.areEqual(locs[0], locs[len - 1])) {
	            locs.pop();
	            len--;
	        }
	        // Insert the last coordinate as the first point.
	        locs.unshift(positions[len - 1]);
	        // Add the first two points to the end of the array.
	        locs.push(positions[0]);
	        locs.push(positions[1]);
	        // Increase index so that spline wraps back around to starting location.
	        len++;
	    }
	    else {
	        // In this case the spline is not closed, so tanget of end points will be 0.
	        // Buffer the end-points so that tanget calculations can be performed.
	        locs.unshift(positions[0]);
	        locs.push(positions[len - 1]);
	    }
	    // Precalculate the hermite basis function steps along the spline.
	    var hermiteSteps = [];
	    // Force the first step between two locations to be the first location.
	    hermiteSteps.push([1, 0, 0, 0]);
	    var step;
	    var step2;
	    var step3;
	    // Calculate the steps along the spline between two locations.
	    for (var i = 1; i < nodeSize - 1; i++) {
	        step = i / nodeSize; // Scale step to go from 0 to 1.
	        step2 = step * step; // s^2
	        step3 = step * step2; // s^3
	        hermiteSteps.push([
	            2 * step3 - 3 * step2 + 1,
	            -2 * step3 + 3 * step2,
	            step3 - 2 * step2 + step,
	            step3 - step2
	        ]); // Calculate hermite basis function 4.
	    }
	    // Force the last step between two locations to be the last location.
	    hermiteSteps.push([0, 1, 0, 0]);
	    var splineLocs = [];
	    var hermiteStep;
	    // Tangents
	    var t1x;
	    var t1y;
	    var t2x;
	    var t2y;
	    var lat;
	    var lon;
	    // Loop through and calculate the spline path between each location pair.
	    for (var i = 1; i < len; i++) {
	        t1x = tension * (locs[i + 1][0] - locs[i - 1][0]);
	        t1y = tension * (locs[i + 1][1] - locs[i - 1][1]);
	        t2x = tension * (locs[i + 2][0] - locs[i][0]);
	        t2y = tension * (locs[i + 2][1] - locs[i][1]);
	        for (step = 0; step < nodeSize; step++) {
	            hermiteStep = hermiteSteps[step];
	            lon = hermiteStep[0] * locs[i][0] + hermiteStep[1] * locs[i + 1][0] + hermiteStep[2] * t1x + hermiteStep[3] * t2x;
	            lat = hermiteStep[0] * locs[i][1] + hermiteStep[1] * locs[i + 1][1] + hermiteStep[2] * t1y + hermiteStep[3] * t2y;
	            lat = _clip(lat, -85, 85);
	            splineLocs.push([lon, lat]);
	        }
	    }
	    return splineLocs;
	}
	/**
	 * Calculates a destination position based on a starting position, a heading, a distance, and a distance unit type.
	 * @param origin Position that the destination is relative to.
	 * @param heading A heading angle between 0 - 360 degrees. 0 - North, 90 - East, 180 - South, 270 - West.
	 * @param distance Distance that destination is away.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position that is the specified distance away from the origin.
	 */
	function getDestination(origin, heading, distance, units) {
	    units = units || "meters";
	    origin = getPosition(origin);
	    var radius = getEarthRadius(units);
	    // convert latitude, longitude and heading into radians
	    var latRad = _toRadians(origin[1]);
	    var lonRad = _toRadians(origin[0]);
	    var headingRad = _toRadians(heading);
	    var centralAngle = distance / radius;
	    var desLatRad = Math.asin(Math.sin(latRad) * Math.cos(centralAngle) + Math.cos(latRad) * Math.sin(centralAngle) * Math.cos(headingRad));
	    var desLonRad = lonRad + Math.atan2(Math.sin(headingRad) * Math.sin(centralAngle) * Math.cos(latRad), Math.cos(centralAngle) - Math.sin(latRad) * Math.sin(desLatRad));
	    var lat = _clip(normalizeLatitude(_toDegrees(desLatRad)), -85, 85);
	    var lon = normalizeLongitude(_toDegrees(desLonRad));
	    return [lon, lat];
	}
	/**
	 * Calculate the distance between two position objects on the surface of the earth using the Haversine formula.
	 * @param origin First position to calculate distance between.
	 * @param destination Second position to calculate distance between.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns The shortest distance between two positions in the specified units.
	 */
	function getDistanceTo(origin, destination, units) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var d = _haversineDistance(origin, destination);
	    if (units === "meters") {
	        return d;
	    }
	    return convertDistance(d, "meters", units || "meters");
	}
	/**
	 * Retrieves the radius of the earth in a specific distance unit for WGS84.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns A number that represents the radius of the earth in a specific distance unit.
	 */
	function getEarthRadius(units) {
	    var normalUnit = _normalizeDistanceUnit(units);
	    return convertDistance(EARTH_RADIUS_SEMI_MAJOR_AXIS, DistanceUnits.meters, normalUnit);
	}
	/**
	 * constructs raw geodesic path that doesn't handle antimeridian crossing
	 */
	function _constructGeodesic(position, nextPosition, nodeSize) {
	    var geodesic = [];
	    // Convert positions from degrees to Radians
	    var lat1 = _toRadians(position[1]);
	    var lon1 = _toRadians(position[0]);
	    var lat2 = _toRadians(nextPosition[1]);
	    var lon2 = _toRadians(nextPosition[0]);
	    // Calculate the total extent of the route
	    var d = 2 * Math.asin(Math.sqrt(Math.pow((Math.sin((lat1 - lat2) / 2)), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow((Math.sin((lon1 - lon2) / 2)), 2)));
	    // Calculate positions at fixed intervals along the route
	    for (var k = 0; k <= nodeSize; k++) {
	        var f = (k / nodeSize);
	        var A = Math.sin((1 - f) * d) / Math.sin(d);
	        var B = Math.sin(f * d) / Math.sin(d);
	        // Obtain 3D Cartesian coordinates of each point
	        var x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
	        var y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
	        var z = A * Math.sin(lat1) + B * Math.sin(lat2);
	        // Convert these to latitude/longitude
	        var lat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
	        var lon = Math.atan2(y, x);
	        lat = _clip(_toDegrees(lat), -85, 85);
	        lon = _toDegrees(lon);
	        // Add this to the array
	        geodesic.push([lon, lat]);
	    }
	    return geodesic;
	}
	/**
	 * Denormalizes path on antimeridian, this makes lines with coordinates on the opposite side of the antimeridian to always cross it. Note that the path crossing antimeridian will contain longitude outside of -180 to 180 range.
	 * See getPathSplitByAntimeridian when this is not desired.
	 * @param path Array of position objects or linestring to denormalize
	 * @returns A denormalized array of position objects, path crossing antimeridian will contain longitude outside of -180 to 180 range.
	 */
	function getPathDenormalizedAtAntimerian(path) {
	    var coords = Array.isArray(path) ? path : path.coordinates;
	    return coords.reduce(function (targetPath, coord) {
	        var last = targetPath.length > 0 ? targetPath[targetPath.length - 1] : null;
	        // denormalize longitude on antimeridian crossing
	        if (last && Math.abs(coord[0] - last[0]) > 180.0) {
	            var denormLon = last[0] < 0 ? coord[0] - 360.0 : coord[0] + 360.0;
	            targetPath.push([denormLon, coord[1]]);
	        }
	        else {
	            targetPath.push(coord);
	        }
	        return targetPath;
	    }, []);
	}
	/**
	 * Split path on antimeridian into multiple paths.
	 * See getPathDenormalizedAtAntimerian when this is not desired.
	 * @param path Array of position objects or linestring to split
	 * @returns A path split into multiple paths by antimeridian.
	 */
	function getPathSplitByAntimeridian(path) {
	    var coords = Array.isArray(path) ? path : path.coordinates;
	    var currentNonCrossing = [];
	    var outputPaths = [];
	    for (var k = 0; k < coords.length; k++) {
	        currentNonCrossing.push(coords[k]);
	        if (k + 1 >= coords.length) {
	            continue;
	        }
	        var _a = __read$e(coords[k], 2), lon1 = _a[0], lat1 = _a[1];
	        var _b = __read$e(coords[k + 1], 2), lon2 = _b[0], lat2 = _b[1];
	        // split the line by antimeridian
	        // and break geodesic into two line segments
	        if (Math.abs(lon2 - lon1) > 180.0) {
	            var denormLon2 = lon1 > 0 ? lon2 + 360.0 : lon2 - 360.0;
	            var antiLon = lon1 > 0 ? 180.0 : -180.0;
	            var abs = Math.abs(denormLon2 - lon1);
	            var antiAbs = Math.abs(antiLon - lon1);
	            var f = antiAbs / abs;
	            var dLat = (lat2 - lat1) * f;
	            var antiLat = lat1 + dLat;
	            currentNonCrossing.push([antiLon, antiLat]);
	            outputPaths.push(currentNonCrossing);
	            currentNonCrossing = [[-antiLon, antiLat]];
	        }
	    }
	    outputPaths.push(currentNonCrossing);
	    return outputPaths;
	}
	/**
	 * Takes an array of positions objects and fills in the space between them with accurately positioned positions to form an approximated Geodesic path.
	 * @param path Array of position objects that form a path to fill in.
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @returns An array of position objects that form a geodesic paths, geodesic path crossing antimeridian will contain longitude outside of -180 to 180 range. See getGeodesicPaths() when this is undesired.
	 */
	function getGeodesicPath(path, nodeSize) {
	    if (!nodeSize || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    var len = locs.length - 1;
	    var geodesic = [];
	    for (var i = 0; i < len; i++) {
	        // Convert positions from degrees to Radians
	        geodesic = geodesic.concat(_constructGeodesic(locs[i], locs[i + 1], nodeSize));
	    }
	    return getPathDenormalizedAtAntimerian(geodesic);
	}
	/**
	 * Takes an array of positions objects and fills in the space between them with accurately positioned positions to form an approximated Geodesic path broken by antimeridian into multiple sub-paths.
	 * @param path Array of position objects that form a path to fill in.
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @returns An array of paths that form geodesic paths, Comparing to getGeodesicPath, sub-paths will always contain longitude in -180 to 180 range
	 */
	function getGeodesicPaths(path, nodeSize) {
	    if (!nodeSize || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    var len = locs.length - 1;
	    var currentNonCrossing = [];
	    var outputLocs = [];
	    for (var i = 0; i < len; i++) {
	        var geodesic = _constructGeodesic(locs[i], locs[i + 1], nodeSize);
	        for (var k = 0; k < geodesic.length; k++) {
	            currentNonCrossing.push(geodesic[k]);
	            if (k + 1 >= geodesic.length) {
	                continue;
	            }
	            var _a = __read$e(geodesic[k], 2), lon1 = _a[0], lat1 = _a[1];
	            var _b = __read$e(geodesic[k + 1], 2), lon2 = _b[0], lat2 = _b[1];
	            // split the line by antimeridian
	            // and break geodesic into two line segments
	            if (Math.abs(lon2 - lon1) > 180.0) {
	                var denormLon2 = lon1 > 0 ? lon2 + 360.0 : lon2 - 360.0;
	                var antiLon = lon1 > 0 ? 180.0 : -180.0;
	                var abs = Math.abs(denormLon2 - lon1);
	                var antiAbs = Math.abs(antiLon - lon1);
	                var f = antiAbs / abs;
	                var dLat = (lat2 - lat1) * f;
	                var antiLat = lat1 + dLat;
	                currentNonCrossing.push([antiLon, antiLat]);
	                outputLocs.push(currentNonCrossing);
	                currentNonCrossing = [[-antiLon, antiLat]];
	            }
	        }
	    }
	    outputLocs.push(currentNonCrossing);
	    return outputLocs;
	}
	/**
	 * Calculates the heading from one position object to another.
	 * @param origin Point of origin.
	 * @param destination Destination to calculate relative heading to.
	 * @returns A heading in degrees between 0 and 360. 0 degrees points due North.
	 */
	function getHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    if (origin && origin.length >= 2 && destination && destination.length >= 2) {
	        var radianLat1 = _toRadians(origin[1]);
	        var radianLat2 = _toRadians(destination[1]);
	        var dLon = _toRadians(destination[0] - origin[0]);
	        var dy = Math.sin(dLon) * Math.cos(radianLat2);
	        var dx = Math.cos(radianLat1) * Math.sin(radianLat2) - Math.sin(radianLat1) * Math.cos(radianLat2) * Math.cos(dLon);
	        return (_toDegrees(Math.atan2(dy, dx)) + 360) % 360;
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance between all position objects in an array.
	 * @param path The array of position objects that make up the path to calculate the length of.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns The distance between all positions in between all position objects in an array on the surface of a earth in the specified units.
	 */
	function getLengthOfPath(path, units) {
	    var totalLength = 0;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    for (var i = 0, len = locs.length - 1; i < len; i++) {
	        totalLength += _haversineDistance(locs[i], locs[i + 1]);
	    }
	    return convertDistance(totalLength, "meters", units || "meters");
	}
	/**
	 * Calculates the position object on a path that is a specified distance away from the start of the path. If the specified distance is longer
	 * than the length of the path, the last position of the path will be returned.
	 * @param path A polyline or array of position coordinates that form a path.
	 * @param distance The distance along the path (from the start) to calculate the position for.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position object that is the specified distance away from the start of the path when following the path.
	 */
	function getPositionAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                return getDestination(locs[i - 1], heading, distance - travelled, units);
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return locs[len - 1];
	        }
	        return locs[0];
	    }
	    return null;
	}
	/**
	 * constructs raw regular polygon path that doesn't handle antimeridian crossing
	 */
	function _constructRegularPolygonPath(origin, radius, numberOfPositions, units, offset) {
	    units = units || "meters";
	    offset = (offset) ? offset : 0;
	    origin = getPosition(origin);
	    var points = [];
	    var centralAngle = 360 / numberOfPositions;
	    for (var i = 0; i <= numberOfPositions; i++) {
	        points.push(getDestination(origin, (i * centralAngle + offset) % 360, radius, units));
	    }
	    return points;
	}
	/**
	 * Calculates an array of position objects that are an equal distance away from a central point to create a regular polygon.
	 * @param origin Center of the regular polygon.
	 * @param radius Radius of the regular polygon.
	 * @param numberOfPositions Number of positions the polygon should have.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param offset An offset to rotate the polygon. When 0 the first position will align with North.
	 * @returns An array of position objects that form a regular polygon. Path crossing antimeridian will contain longitude outside of -180 to 180 range. See getRegularPolygonPaths() when this is undesired.
	 */
	function getRegularPolygonPath(origin, radius, numberOfPositions, units, offset) {
	    return getPathDenormalizedAtAntimerian(_constructRegularPolygonPath(origin, radius, numberOfPositions, units, offset));
	}
	/**
	 * Calculates an array of position objects that are an equal distance away from a central point to create a regular polygon broken by antimeridian into multiple sub-paths.
	 * @param origin Center of the regular polygon.
	 * @param radius Radius of the regular polygon.
	 * @param numberOfPositions Number of positions the polygon should have.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param offset An offset to rotate the polygon. When 0 the first position will align with North.
	 * @returns An array of paths that form a regular polygon. Comparing to getRegularPolygonPath, sub-paths will always contain longitude in -180 to 180 range
	 */
	function getRegularPolygonPaths(origin, radius, numberOfPositions, units, offset) {
	    return getPathSplitByAntimeridian(_constructRegularPolygonPath(origin, radius, numberOfPositions, units, offset));
	}
	/**
	 * Calculates a position object that is a fractional distance between two position objects.
	 * @param origin First position to calculate mid-point between.
	 * @param destination Second position to calculate mid-point between.
	 * @param fraction The fractional parameter to calculate a mid-point for. Default 0.5.
	 * @returns A position that lies a fraction of the distance between two position objects, relative to the first position object.
	 */
	function interpolate(origin, destination, fraction) {
	    fraction = (typeof fraction === "undefined") ? 0.5 : fraction;
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var arcLength = getDistanceTo(origin, destination, "kilometers");
	    var brng = getHeading(origin, destination);
	    return getDestination(origin, brng, arcLength * fraction, "kilometers");
	}
	/**
	 * Normalizes a latitude value between -90 and 90 degrees.
	 * @param lat The latitude value to normalize.
	 */
	function normalizeLatitude(lat) {
	    if (lat > 90) {
	        lat = (lat + 90) % 360;
	        return lat > 180 ? 90 - (lat - 180) : lat - 90;
	    }
	    else if (lat < -90) {
	        lat = (lat - 90) % 360;
	        return lat < -180 ? -90 - (lat + 180) : lat + 90;
	    }
	    else {
	        return lat;
	    }
	}
	/**
	 * Normalizes a longitude value between -180 and 180 degrees.
	 * @param lng The longitude value to normalize.
	 */
	function normalizeLongitude(lng) {
	    if (lng > 180) {
	        return ((lng + 180) % 360) - 180;
	    }
	    else if (lng < -180) {
	        return ((lng - 180) % 360) + 180;
	    }
	    else {
	        return lng;
	    }
	}
	/**
	 * Takes an array of positions and rotates them around a given position for the specified angle of rotation.
	 * @param positions An array of positions to be rotated.
	 * @param origin The position to rotate the positions around.
	 * @param angle The amount to rotate the array of positions in degrees clockwise.
	 */
	function rotatePositions(positions, origin, angle) {
	    if (angle === 0) {
	        // When the rotation is 0 the results can sometimes be odd if the coordinates are on the meridians.
	        return Object.assign({}, positions);
	    }
	    origin = getPosition(origin);
	    var rotatedPositions = [];
	    var distance;
	    var heading;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        distance = getDistanceTo(origin, positions[i]);
	        heading = getHeading(origin, positions[i]);
	        rotatedPositions.push(getDestination(origin, heading + angle, distance));
	    }
	    return rotatedPositions;
	}
	/**
	 * Calculates the pixel accurate heading from one position to another based on the Mercator map projection. This heading is visually accurate.
	 * @param origin
	 * @param destination
	 */
	function getPixelHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var _a = __read$e(mercatorPositionsToPixels([origin, destination], 21), 2), p1 = _a[0], p2 = _a[1];
	    var dx = (p2[0] - p1[0]);
	    var dy = (p1[1] - p2[1]);
	    var alpha = ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * INV_PI_BY_180 % 360;
	    return alpha;
	}
	/**
	 * Converts an array of global Mercator pixel coordinates into an array of geospatial positions at a specified zoom level.
	 * Global pixel coordinates are relative to the top left corner of the map [-180, 90].
	 * @param pixels Array of pixel coordinates.
	 * @param zoom Zoom level.
	 * @returns An array of positions.
	 */
	function mercatorPixelsToPositions(pixels, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var positions = [];
	    var x;
	    var y;
	    for (var i = 0, len = pixels.length; i < len; i++) {
	        x = (pixels[i][0] / mapSize) - 0.5;
	        y = 0.5 - (pixels[i][1] / mapSize);
	        positions.push([
	            360 * x,
	            90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI
	        ]);
	    }
	    return positions;
	}
	/**
	 * Converts an array of positions into an array of global Mercator pixel coordinates at a specified zoom level.
	 * @param positions Array of positions.
	 * @param zoom Zoom level.
	 * @returns Array of global Mercator pixels.
	 */
	function mercatorPositionsToPixels(positions, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var pixels = [];
	    var x;
	    var y;
	    var sinLatitude;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        sinLatitude = Math.sin(positions[i][1] * Math.PI / 180);
	        x = (positions[i][0] + 180) / 360;
	        y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
	        pixels.push([
	            Math.round(x * mapSize),
	            Math.round(y * mapSize)
	        ]);
	    }
	    return pixels;
	}
	/**
	 * Converts an acceleration value from one unit to another.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param acceleration The acceleration value to convert.
	 * @param fromUnits The acceleration units the value is in.
	 * @param toUnits The acceleration units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration value convertered from one unit to another.
	 */
	function convertAcceleration(acceleration, fromUnits, toUnits, decimals) {
	    // Convert the speed to meters per second squared and then convert to the toUnits.
	    switch (_normalizeAccelerationUnit(fromUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration /= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration /= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration /= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration /= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration /= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration /= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration /= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration /= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	    }
	    // metersPerSecondSquared to toUnit.
	    switch (_normalizeAccelerationUnit(toUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration *= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration *= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration *= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration *= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration *= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration *= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration *= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration *= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	    }
	    return _precision(acceleration, decimals);
	}
	/**
	 * Converts an area value from one unit to another.
	 * Supported units: squareMeters, acres, hectares, squareFeet, squareYards, squareMiles, squareKilometers
	 * @param area The area value to convert.
	 * @param fromUnits The area units the value is in.
	 * @param toUnits The area units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An area value convertered from one unit to another.
	 */
	function convertArea(area, fromUnits, toUnits, decimals) {
	    switch (_normalizeAreaUnits(fromUnits)) {
	        case AreaUnits.acres:
	            area *= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area *= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area *= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area *= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area *= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area *= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	    }
	    switch (_normalizeAreaUnits(toUnits)) {
	        case AreaUnits.acres:
	            area /= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area /= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area /= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area /= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area /= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area /= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	    }
	    return _precision(area, decimals);
	}
	/**
	 * Converts a speed value from one unit to another.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param speed The speed value to convert.
	 * @param fromUnits The speed units to convert from.
	 * @param toUnits The speed units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A speed value convertered from one unit to another.
	 */
	function convertSpeed(speed, fromUnits, toUnits, decimals) {
	    // Convert the speed to kilometers per hour and then convert to the toUnits.
	    switch (_normalizeSpeedUnit(fromUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed *= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed *= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed *= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed *= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed *= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	    }
	    // KMPH to toUnit.
	    switch (_normalizeSpeedUnit(toUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed /= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed /= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed /= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed /= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed /= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	    }
	    return _precision(speed, decimals);
	}
	/**
	 * Converts a timespan value from one unit to another.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param timespan The time value to convert.
	 * @param fromUnits The time units to convert from.
	 * @param toUnits The time units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A time value convertered from one unit to another.
	 */
	function convertTimespan(timespan, fromUnits, toUnits, decimals) {
	    // Convert the time to seconds as base units.
	    switch (_normalizeTimeUnit(fromUnits)) {
	        case TimeUnits.ms:
	            timespan /= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan *= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan *= 60;
	            break;
	        case TimeUnits.days:
	            timespan *= 86400;
	            break;
	        case TimeUnits.seconds:
	    }
	    // seconds to toUnit.
	    switch (_normalizeTimeUnit(toUnits)) {
	        case TimeUnits.ms:
	            timespan *= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan /= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan /= 60;
	            break;
	        case TimeUnits.days:
	            timespan /= 86400;
	            break;
	        case TimeUnits.seconds:
	    }
	    return _precision(timespan, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, travel distance and timespan. Formula: a = 2*(d - v*t)/t^2
	 * @param initialSpeed The initial speed.
	 * @param distance The distance that has been travelled.
	 * @param timespan The timespan that was travelled.
	 * @param distanceUnits The units of the distance information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param speedUnits The units of the speed information. If not specified m/s are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, travel distance and timespan.
	 */
	function getAcceleration(initialSpeed, distance, timespan, speedUnits, distanceUnits, timeUnits, accelerationUnits, decimals) {
	    var d = convertDistance(distance, distanceUnits, DistanceUnits.meters);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    var v = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    return convertAcceleration(2 * (d - v * t) / (t * t), AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, final speed and timespan. Formula: a = 2* (v2 - v1)/t
	 * @param initialSpeed The initial speed.
	 * @param finalSpeed The final speed.
	 * @param timespan The timespan that was travelled.
	 * @param speedUnits The units of the speed information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, final speed and timespan.
	 */
	function getAccelerationFromSpeeds(initialSpeed, finalSpeed, timespan, speedUnits, timeUnits, accelerationUnits, decimals) {
	    var v1 = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var v2 = convertSpeed(finalSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    return convertAcceleration((v2 - v1) / t, AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration between two point features that have a timestamp property and optionally a speed property.
	 * if speeds are provided, ignore distance between points as the path may not have been straight and calculate: a = (v2 - v1)/(t2 - t1)
	 * if speeds not provided or only provided on first point, calculate straight line distance between points and calculate: a = 2*(d - v*t)/t^2
	 * @param origin The initial point in which the acceleration is calculated from.
	 * @param destination The final point in which the acceleration is calculated from.
	 * @param timestampProperty The name of the property on the features that contains the timestamp information.
	 * @param speedProperty The name of the property on the features that contains a speed information.
	 * @param speedUnits The units of the speed information. If not specified m/s is used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration between two point features that have a timestamp property and optionally a speed property. Returns NaN if unable to parse timestamp.
	 */
	function getAccelerationFromFeatures(origin, destination, timestampProperty, speedProperty, speedUnits, accelerationUnits, decimals) {
	    if (typeof timestampProperty === "string" && origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            var v = 0;
	            if (speedProperty && typeof speedProperty === "string") {
	                var v1 = origin.properties[speedProperty];
	                var v2 = destination.properties[speedProperty];
	                if (typeof v1 === "number") {
	                    v = v1;
	                    if (typeof v2 === "number") {
	                        return getAccelerationFromSpeeds(v1, v2, timespan, speedUnits, TimeUnits.seconds, accelerationUnits, decimals);
	                    }
	                }
	            }
	            var d = getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return getAcceleration(v, d, timespan, speedUnits, DistanceUnits.meters, TimeUnits.seconds, accelerationUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the approximate area of a geometry in the specified units
	 * @param coordinates The coordinates of the polyon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @param areaUnits Unit of area measurement. Default is squareMeters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The area of a geometry in the specified units.
	 */
	function getArea(data, areaUnits, decimals) {
	    // https://github.com/Turfjs/turf/blob/master/packages/turf-area/index.ts#L68-L75
	    if (data) {
	        var area = 0;
	        data = data instanceof Shape ? data.toJson() : data;
	        switch (data.type) {
	            case "Feature":
	                var f = data;
	                if (f.geometry) {
	                    return getArea(f.geometry, areaUnits, decimals);
	                }
	                break;
	            case "Polygon":
	                var p = data;
	                if (p.coordinates) {
	                    area = _calculatePolygonArea(p.coordinates);
	                }
	                break;
	            case "MultiPolygon":
	                var mp = data;
	                if (mp.coordinates) {
	                    for (var i = 0, len = mp.coordinates.length; i < len; i++) {
	                        area += _calculatePolygonArea(mp.coordinates[i]);
	                    }
	                }
	                break;
	        }
	        return convertArea(area, AreaUnits.squareMeters, areaUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two points based on the provided amount of time.
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param time The time take to travel between the start and end points.
	 * @param timeUnits The units of the time value. If not specified seconds are used.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The average speed of travel between two points based on the provided amount of time.
	 */
	function getSpeed(origin, destination, timespan, timeUnits, speedUnits, decimals) {
	    var org = getPosition(origin);
	    var dest = getPosition(destination);
	    if (org && dest) {
	        // Convert the time value to seconds.
	        var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	        // Calculate the distance`between the points in meters.
	        var d = getDistanceTo(org, dest, DistanceUnits.meters);
	        // Calculate the speed and convert it into the requested units.
	        return convertSpeed(d / t, SpeedUnits.metersPerSecond, speedUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two point features that have a property containing a timestamp.
	 * The timestamp can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param timestampProperty The name of the property on the features which has the timestamp information.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The speed in the specified units or NaN if valid timestamps are not found.
	 */
	function getSpeedFromFeatures(origin, destination, timestampProperty, speedUnits, decimals) {
	    if (typeof timestampProperty === "string" &&
	        origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            // Calculate the distance`between the points in meters.
	            var d = getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return convertSpeed(d / timespan, SpeedUnits.metersPerSecond, speedUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the timespan between two dates or timestamps.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param startTime The start date or time.
	 * @param endTime The end date or time.
	 * @param units The units to return the time value in. If not specified seconds are used.
	 * @returns A timespan between two dates or timestamps. Returns NaN if unable to parse timestamps.
	 */
	function getTimespan(startTime, endTime, units, decimals) {
	    var st = parseTimestamp(startTime);
	    var et = parseTimestamp(endTime);
	    // Ensure that the start and end point features have the specified timeStamp
	    if (st != null && et != null) {
	        // Calculate timespan between the time stamps in seconds.
	        return convertTimespan(et.getTime() - st.getTime(), TimeUnits.ms, units, decimals);
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance traveled for a specified timespan, speed and optionally an acceleration.
	 * Formula: d = v*t + 0.5*a*t^2
	 * @param distanceUnits The distance units in which to return the distance in.
	 * @param timespan The timespan to calculate the distance for.
	 * @param speed The initial or constant speed.
	 * @param acceleration Optional. An acceleration which increases the speed over time.
	 * @param timeUnits The units of the timespan. If not specified seconds are used.
	 * @param speedUnits The units of the speed value. If not specified m/s are used.
	 * @param accelerationUnits Optional. The units of the acceleration value. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The distance traveled for a specified timespan, speed and optionally an acceleration.
	 */
	function getTravelDistance(distanceUnits, timespan, speed, acceleration, timeUnits, speedUnits, accelerationUnits, decimals) {
	    // Convert timespan to seconds.
	    timespan = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    // Convert speed to meters per second.
	    speed = convertSpeed(speed, speedUnits, SpeedUnits.metersPerSecond);
	    var distance = speed * timespan;
	    if (typeof acceleration === "number") {
	        // Convert acceleration to meters per second squared.
	        distance += 0.5 * convertAcceleration(acceleration, accelerationUnits, AccelerationUnits.metersPerSecondSquared) * timespan * timespan;
	    }
	    return convertDistance(distance, DistanceUnits.meters, distanceUnits, decimals);
	}
	/**
	 * Parses a timestamp into a JavaScript Date object.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param timestamp The timestamp value to parse.
	 * @returns A Date object that represents the timestamp or null if the timestamp could not be parsed.
	 */
	function parseTimestamp(timestamp) {
	    if (Object.prototype.toString.call(timestamp) === "[object Date]") {
	        return timestamp;
	    }
	    if (typeof timestamp === "string") {
	        // ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	        // RFC282 / IETF date syntax (section 3.3)
	        var d = Date.parse(timestamp);
	        if (!isNaN(d)) {
	            return new Date(d);
	        }
	        // OData Date format "/Date(1235764800000)/"
	        if (timestamp.indexOf("Date(") >= 0) {
	            timestamp = timestamp.replace("/Date(", "").replace(")/", "");
	            var ms = 0; // number of milliseconds since midnight Jan 1, 1970
	            if (timestamp.indexOf("+") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("+")), 10);
	            }
	            else if (timestamp.indexOf("-") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("-")), 10);
	            }
	            else {
	                ms = parseInt(timestamp, 10);
	            }
	            return new Date(ms);
	        }
	    }
	    else if (typeof timestamp === "number") {
	        // Assume the number is the number of milliseconds from Jan 1st, 1970.
	        return new Date(timestamp);
	    }
	    return null;
	}
	/**
	 * Calculates a Convex Hull from an array of positions, geometries or features.
	 * @param data The array of positions, geometries or features to calculate a convex hull for.
	 * @returns A Convex Hull from an array of positions, geometries or features.
	 */
	function getConvexHull(data) {
	    var e_1, _a;
	    // Uses a Monotone chain algorithm for convex hulls:
	    // https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	    var positions = getPositions(data).map(function (pos) {
	        return [normalizeLongitude(pos[0]), normalizeLatitude(pos[1])];
	    });
	    positions.sort(function (a, b) {
	        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
	    });
	    var lower = [];
	    try {
	        for (var positions_1 = __values$i(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
	            var position = positions_1_1.value;
	            while (lower.length >= 2 && _cross(lower[lower.length - 2], lower[lower.length - 1], position) <= 0) {
	                lower.pop();
	            }
	            lower.push(position);
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    var upper = [];
	    for (var i = positions.length - 1; i >= 0; i--) {
	        while (upper.length >= 2 && _cross(upper[upper.length - 2], upper[upper.length - 1], positions[i]) <= 0) {
	            upper.pop();
	        }
	        upper.push(positions[i]);
	    }
	    return new Polygon([lower.concat(upper)]);
	}
	/**
	 * Retrieves an array of all positions in the provided geometry, feature or array of geometries/features.
	 * @param data The geometries or features to retrieve the positions from.
	 * @returns An array of all positions in the provided geometry, feature or array of geometries/features.
	 */
	function getPositions(data) {
	    var loc = [];
	    var loc2d = null;
	    var loc3d = null;
	    if (Array.isArray(data) && data.length > 0) {
	        if (Array.isArray(data[0]) && typeof data[0][0] === "number") {
	            loc = data;
	        }
	        else {
	            var len = data.length;
	            for (var i = 0; i < len; i++) {
	                loc = loc.concat(getPositions(data[i]));
	            }
	        }
	    }
	    else if (data["type"]) {
	        switch (data["type"]) {
	            case "Point":
	                loc = [data.coordinates];
	                break;
	            case "LineString":
	                loc = data.coordinates;
	                break;
	            case "Polygon":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPoint":
	                loc = data.coordinates;
	                break;
	            case "MultiLineString":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPolygon":
	                loc3d = data.coordinates;
	                break;
	            case "Feature":
	                var f = data;
	                if (Shape._isCircle(f)) {
	                    loc = Shape._getCirclePositions(f);
	                }
	                else {
	                    loc = getPositions(f.geometry);
	                }
	                break;
	            case "FeatureCollection":
	                loc = getPositions(data.features);
	                break;
	            case "GeometryCollection":
	                loc = getPositions(data.geometries);
	                break;
	        }
	    }
	    else if (data instanceof Shape) {
	        return getPositions(data.toJson());
	    }
	    if (loc2d) {
	        var len = loc2d.length;
	        for (var i = 0; i < len; i++) {
	            loc = loc.concat(loc2d[i]);
	        }
	    }
	    else if (loc3d) {
	        var outerLen = loc3d.length;
	        for (var i = 0; i < outerLen; i++) {
	            var innerLen = loc3d[i].length;
	            for (var j = 0; j < innerLen; j++) {
	                loc = loc.concat(loc3d[i][j]);
	            }
	        }
	    }
	    return loc;
	}
	/**
	 * Gets the position of an object that is a position, point, point feature, or circle. If it is a circle, its center coordinate will be returned.
	 * @param data The data object to extract the position from.
	 * @returns The position of an object that is a position, point, or point feature. Returns null if invalid data passed in.
	 */
	function getPosition(data) {
	    if (Array.isArray(data) && typeof data[0] === "number") {
	        return data;
	    }
	    else if (data["type"]) {
	        if (data["type"] === "Point") {
	            return data.coordinates;
	        }
	        else if (data["type"] === "Feature" && data["geometry"]["type"] === "Point") {
	            return data.geometry.coordinates;
	        }
	    }
	    else if (data instanceof Shape && data.getType() === "Point") {
	        return data.getCoordinates();
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced positions along a path.
	 * @param path The path to get the positions from.
	 * @param numPositions The number of positions to get.
	 * @returns An array of evenly spaced positions along a path.
	 */
	function getPositionsAlongPath(path, numPositions) {
	    if (numPositions < 2) {
	        return [];
	    }
	    var positions = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the positions. There is one less gap than there are positions.
	    var dx = len / (numPositions - 1);
	    for (var i = 0; i < numPositions; i++) {
	        var p = getPositionAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            positions.push(p);
	        }
	    }
	    return positions;
	}
	/**
	 * Gets a point with heading a specified distance along a path.
	 * @param path The path to get the point from.
	 * @param distance The distance along the path to get the point at.
	 * @param units The distance units.
	 * @returns A point with heading a specified distance along a path.
	 */
	function getPointWithHeadingAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                var p = getDestination(locs[i - 1], heading, distance - travelled, units);
	                return new Feature(new Point(p), {
	                    heading: heading
	                });
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return new Feature(new Point(locs[len - 1]), {
	                heading: getHeading(locs[len - 2], locs[len - 1])
	            });
	        }
	        return new Feature(new Point(locs[0]), {
	            heading: getHeading(locs[0], locs[1])
	        });
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced points with headings along a path.
	 * @param path The path to get the positions from.
	 * @param numPoints The number of points to get.
	 * @returns An array of evenly spaced points with headings along a path.
	 */
	function getPointsWithHeadingsAlongPath(path, numPoints) {
	    if (numPoints <= 0) {
	        return [];
	    }
	    var points = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the points. There is one less gap than there are points.
	    var dx = len / (numPoints - 1);
	    for (var i = 0; i < numPoints; i++) {
	        var p = getPointWithHeadingAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            points.push(p);
	        }
	    }
	    return points;
	}
	/**
	 * Calculates the closest point on the edge of a geometry to a specified point or position.
	 * The returned point feature will have a `distance` property that specifies the distance between the two points in the specified units.
	 * If the geometry is a Point, that points position will be used for the result.
	 * If the geometry is a MultiPoint, the distances to the individual positions will be used.
	 * If the geometry is a Polygon or MultiPolygon, the point closest to any edge will be returned regardless of if the point intersects the geometry or not.
	 * @param pt The point or position to find the closest point on the edge of the geometry.
	 * @param geom The geometry to find the closest point on.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns
	 */
	function getClosestPointOnGeometry(pt, geom, units, decimals) {
	    // Does not support geometries that cross the antimerdian.
	    var pos = getPosition(pt);
	    var px = mercatorPositionsToPixels([pos], 22)[0];
	    var result = null;
	    var paths;
	    var minDis = Infinity;
	    geom = geom instanceof Shape ? geom.toJson() : geom;
	    switch (geom.type) {
	        case "Feature":
	            return getClosestPointOnGeometry(pt, geom.geometry, units);
	        case "Point":
	            paths = [[geom.coordinates]];
	            break;
	        case "MultiPoint":
	            var d = void 0;
	            var mp = geom.coordinates;
	            for (var i = 0, len = mp.length; i < len; i++) {
	                d = getDistanceTo(pos, mp[i]);
	                if (d < minDis) {
	                    minDis = d;
	                    result = new Feature(new Point(mp[i]), {
	                        distance: d
	                    });
	                }
	            }
	            break;
	        case "LineString":
	            paths = [geom.coordinates];
	            break;
	        case "Polygon":
	        case "MultiLineString":
	            paths = geom.coordinates;
	            break;
	        case "MultiPolygon":
	            var mPaths = geom.coordinates;
	            if (mPaths.length > 0) {
	                paths = mPaths[0];
	                for (var i = 1, len = mPaths.length; i < len; i++) {
	                    paths = paths.concat(mPaths[i]);
	                }
	            }
	            break;
	    }
	    if (paths) {
	        var temp = void 0;
	        for (var i = 0, len = paths.length; i < len; i++) {
	            temp = _closestPointOnPath(pos, px, paths[i]);
	            if (temp && temp.properties.distance < minDis) {
	                minDis = temp.properties.distance;
	                result = temp;
	            }
	        }
	    }
	    if (result) {
	        result.properties.distance = convertDistance(result.properties.distance, "meters", units, decimals);
	    }
	    return result;
	}

	var __extends$17 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A GeoJSON Position object - an array that specifies the longitude and latitude of a location. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.1}.
	 */
	var Position = /** @class */ (function (_super) {
	    __extends$17(Position, _super);
	    /**
	     * Constructs a Position.
	     * @param longitude The position's longitude.
	     * @param latitude The position's latitude.
	     * @param elevation The position's elevation.
	     */
	    function Position(longitude, latitude, elevation) {
	        var _this = this;
	        if (elevation) {
	            _this = _super.call(this, longitude, latitude, elevation) || this;
	        }
	        else {
	            _this = _super.call(this, longitude, latitude) || this;
	        }
	        return _this;
	    }
	    /**
	     * Clones a position.
	     * @param position The position to clone.
	     */
	    Position.fromPosition = function (position) {
	        if (position.length === 2) {
	            return new Position(position[0], position[1]);
	        }
	        else if (position.length > 2) {
	            return new Position(position[0], position[1], position[2]);
	        }
	        return null;
	    };
	    /**
	     * Compares the longitude and latitude values of two positions to see if they are equal at an accuracy of 6 decimal places.
	     * @param pos1 First position to compare.
	     * @param pos2 Second position to compare.
	     * @param precision The number of decimal places to compare to. Default: 6.
	     * @returns A boolean indicating if two positions to see if they are equal at an accuracy of the specified precision or 6 decimal places.
	     */
	    Position.areEqual = function (pos1, pos2, precision) {
	        if (typeof (precision) === "undefined") {
	            precision = 6;
	        }
	        if (pos1 && pos1.length >= 2 && pos2 && pos2.length >= 2) {
	            var offset = Math.pow(10, precision);
	            var lat1 = normalizeLatitude(pos1[1]);
	            var lat2 = normalizeLatitude(pos2[1]);
	            var lon1 = normalizeLongitude(pos1[0]);
	            var lon2 = normalizeLongitude(pos2[0]);
	            var latDiff = Math.round((lat1 - lat2) * offset) / offset;
	            if (latDiff !== 0) {
	                return false;
	            }
	            // A diff of 360 is also allowed because -180 and 180 are the same longitude
	            var lonDiff = Math.round((lon1 - lon2) * offset) / offset;
	            if (lonDiff !== 0 && lonDiff !== 360) {
	                return false;
	            }
	            return true;
	        }
	        return false;
	    };
	    Position.fromLatLng = function (y, x, z) {
	        var position = [];
	        if (typeof y === "number") {
	            if (typeof x === "number") {
	                position.push(x);
	            }
	            position.push(y);
	            if (typeof z === "number") {
	                position.push(z);
	            }
	        }
	        else if (Array.isArray(y)) {
	            // Assume array is in the form [lat, lng] or [lat, lng, elv]
	            if (y.length >= 2 && typeof y[0] === "number" && typeof y[1] === "number") {
	                if (y.length >= 3 && typeof y[2] === "number") {
	                    position.push(y[1], y[0], y[2]);
	                }
	                else {
	                    position.push(y[1], y[0]);
	                }
	            }
	        }
	        else if (typeof y === "object") {
	            // Consider pulling these out into static variable so that we don't constantly create instances of these.
	            var latNames_1 = ["lat", "latitude", "y"];
	            var lngNames_1 = ["lng", "longitude", "lon", "x"];
	            var elvNames_1 = ["elv", "elevation", "alt", "altitude", "z"];
	            var lat_1 = NaN;
	            var lng_1 = NaN;
	            var elv_1 = NaN;
	            // Do a case insensitive search through the object properties.
	            Object.keys(y).forEach(function (key, idx, arr) {
	                var smallKey = key.toLowerCase();
	                if (isNaN(lat_1) && latNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lat_1 = y[key];
	                }
	                else if (isNaN(lng_1) && lngNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lng_1 = y[key];
	                }
	                else if (isNaN(elv_1) && elvNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    elv_1 = y[key];
	                }
	            });
	            if (!isNaN(lat_1) && !isNaN(lng_1)) {
	                position.push(lng_1, lat_1);
	                if (!isNaN(elv_1)) {
	                    position.push(elv_1);
	                }
	            }
	        }
	        if (position.length >= 2) {
	            return position;
	        }
	        return null;
	    };
	    /**
	     * Converts an array of objects that contain coordinate information into an array of Positions. Objects that can't be converted are discarded.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns An array of Position objects that contain all the provided coordinate information.
	     */
	    Position.fromLatLngs = function (latLngs) {
	        var positions = [];
	        if (Array.isArray(latLngs)) {
	            for (var i = 0, len = latLngs.length; i < len; i++) {
	                var p = Position.fromLatLng(latLngs[i]);
	                // skip undetermined positions.
	                if (p) {
	                    positions.push(p);
	                }
	            }
	        }
	        return positions;
	    };
	    /**
	     * Returns the number of dimensions in the specified coordinates.
	     * Does not include the extra dimension form the Position type.
	     * @param coords The coordinates to get the dimension count for.
	     * @private
	     */
	    Position._getDimensions = function (coords) {
	        var count = 0;
	        while (Array.isArray(coords)) {
	            coords = coords[0];
	            count++;
	        }
	        // If the inner most array has a number for it's first
	        // element it is a position and the count must be reduced by 1.
	        if (typeof coords === "number") {
	            count--;
	        }
	        return count;
	    };
	    return Position;
	}(Array));

	/**
	 * A GeoJSON Polygon object - a JSON object that represents a geographic polygon. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.6}.
	 */
	var Polygon = /** @class */ (function () {
	    /**
	     * Constructs a Polygon.
	     * @param coordinates The array of linear ring coordinate arrays defining the polygon.
	     * @param bbox The bounding box of the polygon.
	     */
	    function Polygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "Polygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Polygon";
	        this.type = Polygon.TYPE;
	        // check if it has only one ring
	        if (Position._getDimensions(coordinates) === 1) {
	            this.coordinates = [coordinates];
	        }
	        else {
	            this.coordinates = coordinates;
	        }
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Polygon class to be used in runtime comparisons.
	     */
	    Polygon.TYPE = "Polygon";
	    return Polygon;
	}());

	var __extends$16 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$h = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A helper class that wraps a Geometry or Feature and makes it easy to update and maintain.
	 */
	var Shape = /** @class */ (function (_super) {
	    __extends$16(Shape, _super);
	    function Shape(data, id, properties) {
	        var _this = _super.call(this) || this;
	        var geometry;
	        if (data.type === "Feature") {
	            var feature = data;
	            geometry = cloneDeep$1(feature.geometry);
	            properties = feature.properties ? cloneDeep$1(feature.properties) : {};
	            id = feature.id == null || feature.id === "" ? uuid() : feature.id;
	        }
	        else {
	            geometry = cloneDeep$1(data);
	            id = id == null || id === "" ? uuid() : id;
	            properties = properties ? cloneDeep$1(properties) : {};
	        }
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = id;
	        // Always create a new feature to guarantee the data matches our definition of a Feature.
	        _this.data = new Feature(geometry, properties, id);
	        _this._handleCircle();
	        return _this;
	    }
	    /**
	     * Adds or updates an existing property value in the shape.
	     * @param key
	     * @param value
	     */
	    Shape.prototype.addProperty = function (key, value) {
	        // Only add the property if it is a new value.
	        if (!isEqual$1(this.data.properties[key], value)) {
	            this.data.properties[key] = cloneDeep$1(value);
	            if (key === "subType" || key === "radius") {
	                this._handleCircle();
	            }
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Gets the bounding box of the shape
	     */
	    Shape.prototype.getBounds = function () {
	        var e_1, _a, e_2, _b;
	        var positions = this.getCoordinates();
	        var bbox;
	        var geoType = this.getType();
	        if (geoType === "Point") {
	            if (this.circlePolygon) { // If a circle from the extended GeoJSON spec.
	                var pos = this.circlePolygon.geometry.coordinates;
	                bbox = BoundingBox.fromPositions(pos[0]);
	            }
	            else {
	                var pos = positions;
	                bbox = new BoundingBox(pos, pos);
	            }
	        }
	        else if (geoType === "MultiPoint" || geoType === "LineString") {
	            var pos = positions;
	            bbox = BoundingBox.fromPositions(pos);
	        }
	        else if (geoType === "Polygon") {
	            var pos = positions;
	            // only need to check the exterior ring of Polygon
	            bbox = BoundingBox.fromPositions(pos[0]);
	        }
	        else if (geoType === "MultiLineString") {
	            var pos = positions;
	            try {
	                for (var pos_1 = __values$h(pos), pos_1_1 = pos_1.next(); !pos_1_1.done; pos_1_1 = pos_1.next()) {
	                    var p = pos_1_1.value;
	                    bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p));
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (pos_1_1 && !pos_1_1.done && (_a = pos_1.return)) _a.call(pos_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else if (geoType === "MultiPolygon") {
	            var pos = positions;
	            try {
	                for (var pos_2 = __values$h(pos), pos_2_1 = pos_2.next(); !pos_2_1.done; pos_2_1 = pos_2.next()) {
	                    var p1 = pos_2_1.value;
	                    // only need to check the exterior ring of Polygon
	                    bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p1[0]));
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (pos_2_1 && !pos_2_1.done && (_b = pos_2.return)) _b.call(pos_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        return bbox;
	    };
	    /**
	     * Gets the coordinates of the shape.
	     */
	    Shape.prototype.getCoordinates = function () {
	        return cloneDeep$1(this.data.geometry.coordinates);
	    };
	    /**
	     * If the shape is a circle, this gets its coordinates. Otherwise returns null.
	     */
	    Shape.prototype.getCircleCoordinates = function () {
	        if (this.circlePolygon) {
	            return cloneDeep$1(this.circlePolygon.geometry.coordinates[0]);
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * Gets the id of the shape.
	     */
	    Shape.prototype.getId = function () {
	        return this.data.id;
	    };
	    /**
	     * Gets the properties of the shape.
	     */
	    Shape.prototype.getProperties = function () {
	        return cloneDeep$1(this.data.properties);
	    };
	    /**
	     * Returns a string indicating the type of geometry this shape contains.
	     */
	    Shape.prototype.getType = function () {
	        return this.data.geometry.type;
	    };
	    /**
	     * Indicates if the contained shape is a Circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isCircle = function () {
	        return Shape._isCircle(this.data);
	    };
	    /**
	     * Indicates if the contained shape is a Rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isRectangle = function () {
	        return Shape._isRectangle(this.data);
	    };
	    /**
	     * Updates the coordinates of the shape
	     * @param coords Point: Position, LineString: Position[], Polygon: Position[][],
	     * MultiPoint: Position[], MultiLineString: Position[][], MultiPolygon: Position[][]
	     */
	    Shape.prototype.setCoordinates = function (coords) {
	        // If a Position[] is supplied for a polygon wrap it in an array.
	        var newCoords;
	        if (this.getType() === "Polygon" &&
	            Position._getDimensions(coords) === 1) {
	            newCoords = [coords];
	        }
	        else {
	            newCoords = coords;
	        }
	        // Only update the coordinates if they've actually changed.
	        if (!isEqual$1(this.data.geometry.coordinates, newCoords)) {
	            this.data.geometry.coordinates = cloneDeep$1(newCoords);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Sets the properties on the shape. Overwrites all existing properties.
	     * @param properties
	     */
	    Shape.prototype.setProperties = function (properties) {
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = this.data.id;
	        // Only update the properties if they've actually changed.
	        if (!isEqual$1(this.data.properties, properties)) {
	            this.data.properties = cloneDeep$1(properties);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Returns a GeoJSON feature that represents the shape.
	     */
	    Shape.prototype.toJson = function () {
	        return JSON.parse(JSON.stringify(this.data));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape.prototype._toJson = function () {
	        return this.circlePolygon || this.data;
	    };
	    /**
	     * @internal
	     */
	    Shape.prototype._setDataSource = function (dataSource) {
	        if (dataSource === undefined || dataSource == null) {
	            delete this.dataSource;
	        }
	        else {
	            this.dataSource = dataSource;
	        }
	    };
	    /**
	     * Check if the shape's wrapped feature is a circle form the extended GeoJSON spec.
	     * If so it will calculate a polygon feature that approximates the specified circle.
	     * @private
	     */
	    Shape.prototype._handleCircle = function () {
	        if (this.isCircle()) {
	            var coords = Shape._getCirclePositions(this.data);
	            this.circlePolygon = new Feature(new Polygon([coords]), this.data.properties, this.data.id);
	            // Set the subType to "Circle" to make sure the case is correct.
	            this.data.properties.subType = "Circle";
	        }
	        else {
	            delete this.circlePolygon;
	        }
	    };
	    /**
	     * Indicates if the specified feature is a circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isCircle = function (data) {
	        return data && data.geometry &&
	            data.geometry.type === "Point" &&
	            data.geometry.coordinates && data.properties &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "circle" &&
	            typeof data.properties.radius === "number";
	    };
	    /**
	     * Indicates if the specified feature is a rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isRectangle = function (data) {
	        if (data.geometry.type === "Polygon" &&
	            data.geometry.coordinates &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "rectangle") {
	            // If type is Polygon we can assume the coordinates are a Position[][].
	            var coords = data.geometry.coordinates;
	            if (coords.length === 1) {
	                var ring = coords[0];
	                if (ring.length === 5) {
	                    return ring[0][0] === ring[4][0] &&
	                        ring[0][1] === ring[4][1];
	                }
	                else if (ring.length === 4) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    /**
	     * Calculates to positions that should be used to approximate the specified circle feature.
	     * @internal
	     */
	    Shape._getCirclePositions = function (data) {
	        return getRegularPolygonPath(data.geometry.coordinates, data.properties.radius, 72, "meters");
	    };
	    /**
	     * Represents the feature property name that the shape's id will be assigned to.
	     * This is a workaround for the Mapbox bug preventing non-numerical ids from being returned by some functions.
	     * TODO Remove once this issue if fixed.
	     * {@link https://github.com/mapbox/mapbox-gl-js/issues/2716}
	     * @internal
	     */
	    // tslint:disable-next-line: variable-name
	    Shape._shapeIdPropName = "_azureMapsShapeId";
	    return Shape;
	}(EventEmitter));

	var __extends$15 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$g = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A GeoJSON BoundingBox object - an array that defines a shape whose edges follow lines of constant longitude,
	 * latitude, and elevation. All axes of the most southwesterly point are followed by all axes of the more northeasterly
	 * point. The axes order of the BoundingBox follows the axes order of geometries. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-5}.
	 */
	var BoundingBox = /** @class */ (function (_super) {
	    __extends$15(BoundingBox, _super);
	    function BoundingBox(southwestPositionOrPositions, northeastPosition) {
	        var _this = this;
	        if (southwestPositionOrPositions && northeastPosition) {
	            var southwestPosition = southwestPositionOrPositions;
	            if (southwestPosition[2] && northeastPosition[2]) {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], southwestPosition[2] || 0, northeastPosition[0], northeastPosition[1], northeastPosition[2] || 0) || this;
	            }
	            else {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], northeastPosition[0], northeastPosition[1]) || this;
	            }
	        }
	        else if (southwestPositionOrPositions) {
	            var positions = southwestPositionOrPositions;
	            if (positions) {
	                if (positions.length === 4) {
	                    // [west, south, east, north]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3]) || this;
	                }
	                else if (positions.length >= 6) {
	                    // [west, south, elevation1, east, north, elevation2]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3], positions[4], positions[5]) || this;
	                }
	            }
	        }
	        return _this;
	    }
	    /**
	     * Clones a bounding box.
	     * @param boundingBox The bounding box to clone.
	     */
	    BoundingBox.fromBoundingBox = function (boundingBox) {
	        var west = BoundingBox.getWest(boundingBox);
	        var south = BoundingBox.getSouth(boundingBox);
	        var east = BoundingBox.getEast(boundingBox);
	        var north = BoundingBox.getNorth(boundingBox);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified dimensions.
	     * @param center The center position of the bounding box.
	     * @param width The width of the bounding box.
	     * @param height The height of the bounding box.
	     */
	    BoundingBox.fromDimensions = function (center, width, height) {
	        var lon = center[0];
	        var lat = center[1];
	        var north = Math.min(Math.max(lat + height / 2, -85.5), 85.5);
	        var south = Math.min(Math.max(lat - height / 2, -85.5), 85.5);
	        var east = normalizeLongitude(lon + width / 2);
	        var west = normalizeLongitude(lon - width / 2);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified edges.
	     * @param west The west edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param north The north edge of the bounding box.
	     */
	    BoundingBox.fromEdges = function (west, south, east, north) {
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Determines if a position is within a bounding box.
	     * @param bounds The bounding box to see if the position is in.
	     * @param position The position to see if it is in the bounding box.
	     * @returns True if the position is within the bounding box.
	     */
	    BoundingBox.containsPosition = function (bounds, position) {
	        // Allow a small difference to account for arithmetic accuracy errors.
	        // This is important for points on the edge of the bounding box which is the case when using BoundingBox.fromLocations
	        var accuracyAllowance = 0.00000001;
	        // Use the distance between the position and center of the bounding box to determine if they intersect.
	        var center = BoundingBox.getCenter(bounds);
	        var diffLatitude = Math.abs(center[1] - position[1]);
	        var diffLongitude = Math.abs(center[0] - position[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height = BoundingBox.getHeight(bounds);
	        var width = BoundingBox.getWidth(bounds);
	        return (diffLatitude <= (height / 2) + accuracyAllowance) && (diffLongitude <= (width / 2) + accuracyAllowance);
	    };
	    /**
	     * Determines if a bounding box is within another bounding box
	     * @param outer The outer bounding box
	     * @param inner The inner bounding box (the one that should be contained within outer)
	     * @returns True if the inner bounding box is fully container in outer
	     */
	    BoundingBox.containsBoundingBox = function (outer, inner) {
	        var outerValid = outer && outer.length === 4;
	        var innerValid = inner && inner.length === 4;
	        if (!outerValid || !innerValid) {
	            return false;
	        }
	        return BoundingBox.getWest(outer) < BoundingBox.getWest(inner) && BoundingBox.getWest(inner) < BoundingBox.getEast(outer) &&
	            BoundingBox.getWest(outer) < BoundingBox.getEast(inner) && BoundingBox.getEast(inner) < BoundingBox.getEast(outer) &&
	            BoundingBox.getSouth(outer) < BoundingBox.getSouth(inner) && BoundingBox.getSouth(inner) < BoundingBox.getNorth(outer) &&
	            BoundingBox.getSouth(outer) < BoundingBox.getNorth(inner) && BoundingBox.getNorth(inner) < BoundingBox.getNorth(outer);
	    };
	    /**
	     * Returns a boolean indicating if the bounding box crosses the antimeridian or not.
	     * @param bounds The bounding box to check.
	     * @returns A boolean indicating if the bounding box crosses the antimeridian or not.
	     */
	    BoundingBox.crossesAntimeridian = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        return (east - west) < 0
	            || BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(bounds)
	            || BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(bounds);
	    };
	    /**
	     * Calculates the center of a bounding box.
	     * @param bounds A bounding box to calculate the center of.
	     * @returns A position that represents the center of the bounding box.
	     */
	    BoundingBox.getCenter = function (bounds) {
	        // [west, south, east, north]
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        if (west > east) {
	            east += 360.0;
	        }
	        var centerLongitude = normalizeLongitude((west + east) / 2.0);
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var centerLatitude = normalizeLatitude((south + north) / 2.0);
	        return [centerLongitude, centerLatitude];
	    };
	    /**
	     * Gets the height of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The height of the bounding box in degrees.
	     */
	    BoundingBox.getHeight = function (bounds) {
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var height = north - south;
	        return isNaN(height) ? 0 : height;
	    };
	    /**
	     * Gets the width of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The width of the bounding box in degrees.
	     */
	    BoundingBox.getWidth = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        var width = east - west;
	        // Check to see if bounds crosses antimeridian
	        return isNaN(width) ? 0 : width < 0 ? width += 360 : width;
	    };
	    /**
	     * Returns the south west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south west position of the bounding box.
	     */
	    BoundingBox.getSouthWest = function (bounds) {
	        var south = this.getSouth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(south) || isNaN(west)) ? null : [west, south];
	    };
	    /**
	     * Returns the north east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north east position of the bounding box.
	     */
	    BoundingBox.getNorthEast = function (bounds) {
	        var north = this.getNorth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(north) || isNaN(east)) ? null : [east, north];
	    };
	    /**
	     * Returns the north west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north west position of the bounding box.
	     */
	    BoundingBox.getNorthWest = function (bounds) {
	        var north = this.getNorth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(north) || isNaN(west)) ? null : [west, north];
	    };
	    /**
	     * Returns the south east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south east position of the bounding box.
	     */
	    BoundingBox.getSouthEast = function (bounds) {
	        var south = this.getSouth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(south) || isNaN(east)) ? null : [east, south];
	    };
	    /**
	     * Returns the south position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south position value of the bounding box.
	     */
	    BoundingBox.getSouth = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[1]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the west position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The west position value of the bounding box.
	     */
	    BoundingBox.getWest = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[0]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the north position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north position value of the bounding box.
	     */
	    BoundingBox.getNorth = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[3]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[4]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Returns the east position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The east position value of the bounding box.
	     */
	    BoundingBox.getEast = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[2]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[3]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Determines is two bounding boxes intersect.
	     * @param bounds1 The first bounding box to compare with.
	     * @param bounds2 The second bounding box to compare with.
	     * @returns true if the provided bounding boxes intersect.
	     */
	    BoundingBox.intersect = function (bounds1, bounds2) {
	        var center1 = BoundingBox.getCenter(bounds1);
	        var center2 = BoundingBox.getCenter(bounds2);
	        // Use the distance between the 2 centers to determine if they intersect.
	        var diffLatitude = Math.abs(center1[1] - center2[1]);
	        var diffLongitude = Math.abs(center1[0] - center2[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height1 = BoundingBox.getHeight(bounds1);
	        var width1 = BoundingBox.getWidth(bounds1);
	        var height2 = BoundingBox.getHeight(bounds2);
	        var width2 = BoundingBox.getWidth(bounds2);
	        return (diffLatitude <= (height1 / 2 + height2 / 2) && diffLongitude <= (width1 / 2 + width2 / 2));
	    };
	    /**
	     * Merges two bounding boxes together.
	     * @param bounds1 The first bounding box to merge with.
	     * @param bounds2 The second bounding box to merge with.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.merge = function (bounds1, bounds2) {
	        var bb1Valid = bounds1 && bounds1.length === 4;
	        var bb2Valid = bounds2 && bounds2.length === 4;
	        if (bb1Valid && !bb2Valid) {
	            return bounds1;
	        }
	        else if (bb2Valid && !bb1Valid) {
	            return bounds2;
	        }
	        else if (!bb1Valid && !bb2Valid) {
	            return null;
	        }
	        var north = Math.max(normalizeLatitude(BoundingBox.getNorth(bounds1)), normalizeLatitude(BoundingBox.getNorth(bounds2)));
	        var south = Math.min(normalizeLatitude(BoundingBox.getSouth(bounds1)), normalizeLatitude(BoundingBox.getSouth(bounds2)));
	        // Find out the longitude spans of the two bounding boxes.
	        var boundingBoxes = [bounds1, bounds2];
	        var longIntervals = [];
	        var i = 0;
	        for (i = 0; i < boundingBoxes.length; i++) {
	            var b = boundingBoxes[i];
	            var w = normalizeLongitude(BoundingBox.getWest(b));
	            var e = normalizeLongitude(BoundingBox.getEast(b));
	            if (BoundingBox.crossesAntimeridian(b)) {
	                longIntervals.push([w, 180]);
	                longIntervals.push([-180, e]);
	            }
	            else {
	                longIntervals.push([w, e]);
	            }
	        }
	        // sort and merge (overlaped intervals) these intervals
	        // after the sort and merge we should have a list of intervals that don't overlap with each other.
	        longIntervals.sort(function (a, b) { return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]; });
	        var mergedIntervals = [];
	        var currentInterval = longIntervals[0];
	        i = 1;
	        while (i < longIntervals.length) {
	            var nextInterval = longIntervals[i];
	            if (currentInterval[1] >= nextInterval[0]) {
	                currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);
	            }
	            else {
	                mergedIntervals.push(currentInterval);
	                currentInterval = nextInterval;
	            }
	            i++;
	        }
	        mergedIntervals.push(currentInterval);
	        // find out the biggest gap between these intervals. suppose this gap is [A, B], then A will be the east bound and B will be the west bound of the merged rectangle.
	        var length = mergedIntervals.length;
	        var maxGapSpan = mergedIntervals[0][0] + 360 - mergedIntervals[length - 1][1];
	        var maxGap = [mergedIntervals[length - 1][1], mergedIntervals[0][0]];
	        for (i = 1; i < length; i++) {
	            var thisGapSpan = mergedIntervals[i][0] - mergedIntervals[i - 1][1];
	            if (thisGapSpan > maxGapSpan) {
	                maxGapSpan = thisGapSpan;
	                maxGap = [mergedIntervals[i - 1][1], mergedIntervals[i][0]];
	            }
	        }
	        // now we have all the edges of the rectangle
	        return new BoundingBox([maxGap[1], south], [maxGap[0], north]);
	    };
	    /**
	     * Creates a BoundingBox that contains all provided Position objects.
	     * @param positions An array of locations to use to generate the bounding box.
	     * @returns A bounding box that contains all given positions.
	     */
	    BoundingBox.fromPositions = function (positions) {
	        var north = NaN;
	        var south = NaN;
	        var west = NaN;
	        var east = NaN;
	        var position;
	        var i = positions.length;
	        var longitudes = new Array(i);
	        var longCount = 0;
	        while (i--) {
	            position = positions[i];
	            if (position && position.length >= 2) {
	                var normalizedPosition1 = normalizeLatitude(position[1]);
	                north = isNaN(north) ? normalizedPosition1 : Math.max(north, normalizedPosition1);
	                south = isNaN(south) ? normalizedPosition1 : Math.min(south, normalizedPosition1);
	                longitudes[longCount++] = normalizeLongitude(position[0]);
	            }
	        }
	        if (longCount) {
	            // Find largest gap between longitudes
	            longitudes.length = longCount;
	            longitudes.sort(function (a, b) { return a - b; });
	            var maxGap = (longitudes[0] + 360) - longitudes[longCount - 1];
	            var maxGapIndex = 0;
	            for (i = 1; i < longCount; i++) {
	                var gap = longitudes[i] - longitudes[i - 1];
	                if (gap > maxGap) {
	                    maxGap = gap;
	                    maxGapIndex = i;
	                }
	            }
	            west = longitudes[maxGapIndex];
	            east = longitudes[(maxGapIndex || longCount) - 1];
	        }
	        if (isNaN(west) || isNaN(south) || isNaN(east) || isNaN(north)) {
	            return null;
	        }
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Creates a BoundingBox from any array of objects that contain coordinate information.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns A BoundingBox that contains all the provided coordinate information.
	     */
	    BoundingBox.fromLatLngs = function (latLngs) {
	        return BoundingBox.fromPositions(Position.fromLatLngs(latLngs));
	    };
	    /**
	     * Calculates the bounding box of a FeatureCollection, Feature, Geometry, Shape or array of these objects.
	     * @param data The FeatureCollection, Feature, Geometry, Shape or array of these objects to calculate the bounding box for.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.fromData = function (data) {
	        var e_1, _a;
	        var tempBounds;
	        var bounds = null;
	        if (Array.isArray(data) && data.length > 0) {
	            try {
	                for (var data_1 = __values$g(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
	                    var datum = data_1_1.value;
	                    tempBounds = BoundingBox.fromData(datum);
	                    if (tempBounds != null) {
	                        if (bounds === null) {
	                            bounds = tempBounds;
	                        }
	                        else {
	                            bounds = BoundingBox.merge(bounds, tempBounds);
	                        }
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return bounds;
	        }
	        else if (data instanceof Shape) {
	            return data.getBounds();
	        }
	        else if (data && data["type"]) {
	            // Data is a GeoJson object.
	            var geoJsonObj = data;
	            // Check to see if the GeoJSON object has a bbox, property, and if it does, use that.
	            if (geoJsonObj["bbox"] && geoJsonObj["bbox"].length === 4) {
	                return geoJsonObj["bbox"];
	            }
	            else {
	                switch (geoJsonObj.type) {
	                    case "FeatureCollection":
	                        // features: Array<Feature<Geometry>>
	                        return BoundingBox.fromData(geoJsonObj.features);
	                    case "Feature":
	                        // geometry: G
	                        if (Shape._isCircle(geoJsonObj)) {
	                            return BoundingBox.fromPositions(Shape._getCirclePositions(geoJsonObj));
	                        }
	                        else {
	                            return BoundingBox.fromData(geoJsonObj.geometry);
	                        }
	                    case "GeometryCollection":
	                        // geometries: Geometry[]
	                        return BoundingBox.fromData(geoJsonObj.geometries);
	                    case "Point":
	                        // coordinates: Position
	                        var p = geoJsonObj.coordinates;
	                        if (p && p.length >= 2) {
	                            return [p[0], p[1], p[0], p[1]];
	                        }
	                        break;
	                    case "LineString":
	                    case "MultiPoint":
	                        // coordinates: Position[]
	                        return BoundingBox.fromPositions(geoJsonObj.coordinates);
	                    case "Polygon":
	                    case "MultiLineString":
	                        // coordinates: Position[][]
	                        var ml = geoJsonObj.coordinates;
	                        if (ml && ml.length > 0) {
	                            for (var i = 0, len = ml.length; i < len; i++) {
	                                tempBounds = BoundingBox.fromPositions(ml[i]);
	                                if (tempBounds != null) {
	                                    if (bounds === null) {
	                                        bounds = tempBounds;
	                                    }
	                                    else {
	                                        bounds = BoundingBox.merge(bounds, tempBounds);
	                                    }
	                                }
	                            }
	                            if (bounds != null) {
	                                return bounds;
	                            }
	                        }
	                        break;
	                    case "MultiPolygon":
	                        // coordinates: Position[][][]
	                        var mp = geoJsonObj.coordinates;
	                        if (mp && mp.length > 0) {
	                            for (var i = 0, len = mp.length; i < len; i++) {
	                                for (var j = 0, cnt = mp[i].length; j < cnt; j++) {
	                                    tempBounds = BoundingBox.fromPositions(mp[i][j]);
	                                    if (tempBounds != null) {
	                                        if (bounds === null) {
	                                            bounds = tempBounds;
	                                        }
	                                        else {
	                                            bounds = BoundingBox.merge(bounds, tempBounds);
	                                        }
	                                    }
	                                }
	                            }
	                            return bounds;
	                        }
	                        break;
	                }
	            }
	        }
	        return null;
	    };
	    /**
	     * Splits a BoundingBox that crosses the Antimeridian into two BoundingBox's. One entirely west of the Antimerdian and another entirely east of the Antimerdian.
	     * @param bounds
	     */
	    BoundingBox.splitOnAntimeridian = function (bounds) {
	        var bboxes = [];
	        //Test the case when the bounding box is wider than a single globe.
	        if (BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(bounds)) {
	            return [[-180, bounds[1], bounds[2], 180, bounds[4], bounds[5]]];
	        }
	        else if (BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(bounds)) {
	            return [[-180, bounds[1], 180, bounds[3]]];
	        }
	        else if (BoundingBox.crossesAntimeridian(bounds)) {
	            //Case when map less than full globe width, but crosses anti-meridian.
	            var bbox1 = void 0;
	            var bbox2 = void 0;
	            var west = normalizeLongitude(BoundingBox.getWest(bounds));
	            var east = normalizeLongitude(BoundingBox.getEast(bounds));
	            var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	            var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	            // has elevations
	            if (bounds.length >= 6) {
	                bbox1 = [west, south, bounds[2], 180, north, bounds[5]];
	                bbox2 = [-180, south, bounds[2], east, north, bounds[5]];
	            }
	            else {
	                bbox1 = [west, south, 180, north];
	                bbox2 = [-180, south, east, north];
	            }
	            bboxes.push(bbox1, bbox2);
	        }
	        else {
	            bboxes.push(bounds);
	        }
	        return bboxes;
	    };
	    BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe = function (bounds) {
	        return bounds.length >= 6 && bounds[3] - bounds[0] > 360;
	    };
	    BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe = function (bounds) {
	        return bounds.length < 6 && bounds[2] - bounds[0] > 360;
	    };
	    return BoundingBox;
	}(Array));

	/**
	 * A GeoJSON FeatureCollection object - a JSON object that contains a collection of GeoJSON features. The full
	 * description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.3}.
	 */
	var FeatureCollection = /** @class */ (function () {
	    /**
	     * Constructs a FeatureCollection.
	     * @param features The collection of features that make up the feature collection.
	     * @param bbox The bounding box of the feature collection.
	     */
	    function FeatureCollection(features, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "FeatureCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "FeatureCollection";
	        this.type = FeatureCollection.TYPE;
	        this.features = features;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the FeatureCollection class to be used in runtime comparisons.
	     */
	    FeatureCollection.TYPE = "FeatureCollection";
	    return FeatureCollection;
	}());

	/**
	 * A GeoJSON GeometryCollection object - a JSON object that contains a collection of a GeoJSON Geometry objects. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.8}.
	 */
	var GeometryCollection = /** @class */ (function () {
	    /**
	     * Constructs a GeometryCollection.
	     * @param geometries The collection of geometries that make up the geometry collection.
	     */
	    function GeometryCollection(geometries) {
	        /**
	         * A GeoJSON type descriptor with value "GeometryCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "GeometryCollection";
	        this.type = GeometryCollection.TYPE;
	        this.geometries = geometries;
	    }
	    /**
	     * A static GeoJSON type descriptor for the GeometryCollection class to be used in runtime comparisons.
	     */
	    GeometryCollection.TYPE = "GeometryCollection";
	    return GeometryCollection;
	}());

	/**
	 * A GeoJSON LineString object - a JSON object that represents a geographic curve. The full description is detailed
	 * in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.4}.
	 */
	var LineString = /** @class */ (function () {
	    /**
	     * Constructs a LineString.
	     * @param coordinates The ordered list of positions defining the linestring.
	     * @param bbox The bounding box of the linestring.
	     */
	    function LineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "LineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "LineString";
	        this.type = LineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the LineString class to be used in runtime comparisons.
	     */
	    LineString.TYPE = "LineString";
	    return LineString;
	}());

	/**
	 * A GeoJSON MultiLineString object - a JSON object that represents multiple geographic curves. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.5}.
	 */
	var MultiLineString = /** @class */ (function () {
	    /**
	     * Constructs a MultiLineString.
	     * @param coordinates The array of LineString coordinate arrays defining the multilinestring.
	     * @param bbox The bounding box of the multilinestring.
	     */
	    function MultiLineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliLineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiLineString";
	        this.type = MultiLineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiLineString class to be used in runtime comparisons.
	     */
	    MultiLineString.TYPE = "MultiLineString";
	    return MultiLineString;
	}());

	/**
	 * A GeoJSON MultiPoint object - a JSON object that represents multiple geographic positions. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.3}.
	 */
	var MultiPoint = /** @class */ (function () {
	    /**
	     * Constructs a MultiPoint.
	     * @param coordinates The array of multiple positions defining the multipoint.
	     * @param bbox The bounding box of the multipoint.
	     */
	    function MultiPoint(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPoint".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPoint";
	        this.type = MultiPoint.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPoint class to be used in runtime comparisons.
	     */
	    MultiPoint.TYPE = "MultiPoint";
	    return MultiPoint;
	}());

	/**
	 * A GeoJSON MultiPolygon object - a JSON object that represents multiple geographic polygons. The full description is
	 * detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.7}.
	 */
	var MultiPolygon = /** @class */ (function () {
	    /**
	     * Constructs a MultiPolygon.
	     * @param coordinates The array of polygon coordinate arrays defining the multipolygon.
	     * @param bbox The bounding box of the multipolygon.
	     */
	    function MultiPolygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPolygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPolygon";
	        this.type = MultiPolygon.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPolygon class to be used in runtime comparisons.
	     */
	    MultiPolygon.TYPE = "MultiPolygon";
	    return MultiPolygon;
	}());

	var __extends$14 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	//Based on: https://github.com/mapbox/mapbox-gl-js/blob/main/src/geo/mercator_coordinate.js
	/**
	 * A `MercatorPoint` object represents a projected three dimensional position.
	 *
	 * `MercatorPoint` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:
	 * - the size of 1 unit is the width of the projected world instead of the "mercator meter"
	 * - the origin of the coordinate space is at the north-west corner instead of the middle.
	 *
	 * For example, `MercatorPoint(0, 0, 0)` is the north-west corner of the mercator world and
	 * `MercatorPoint(1, 1, 0)` is the south-east corner. If you are familiar with
	 * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think
	 * of the coordinate space as the `0/0/0` tile with an extent of `1`.
	 *
	 * The `z` dimension of `MercatorPoint` is conformal. A cube in the mercator coordinate space would be rendered as a cube.
	 */
	var MercatorPoint = /** @class */ (function (_super) {
	    __extends$14(MercatorPoint, _super);
	    /**
	     * Constructs a MercatorPoint.
	     * @param x A points x position in mercator units.
	     * @param y A points y position in mercator units.
	     * @param z A points z position in mercator units.
	     */
	    function MercatorPoint(x, y, z) {
	        return _super.call(this, x, y, z ? z : 0) || this;
	    }
	    /***********************************
	     * Public static functions
	     ***********************************/
	    /**
	     * Converts a position into a mercator point.
	     * @param position Position to convert.
	     * @returns A mercator point.
	     */
	    MercatorPoint.fromPosition = function (position) {
	        if (position.length >= 2) {
	            return new MercatorPoint((180 + position[0]) / 360, MercatorPoint._latToMercatorY(position[1]), position.length >= 3 ? MercatorPoint._altitudeToMercatorZ(position[2], position[1]) : 0);
	        }
	        return [0, 0, 0];
	    };
	    /**
	     * Converts an array of positions into an array of mercator points.
	     * @param positions Array of positions to convert.
	     * @returns An array of  mercator points.
	     */
	    MercatorPoint.fromPositions = function (positions) {
	        var mercators = [];
	        for (var i = 0, len = positions.length; i < len; i++) {
	            mercators.push(this.fromPosition(positions[i]));
	        }
	        return mercators;
	    };
	    /**
	     * Converts an array of positions into a Float32Array of mercator xyz values.
	     * @param positions Array of positions to convert.
	     * @returns A Float32Array of mercator xyz values.
	     */
	    MercatorPoint.toFloat32Array = function (positions) {
	        var arr = new Float32Array(positions.length * 3);
	        for (var i = 0, len = positions.length; i < len; i++) {
	            var idx = i * 3;
	            var p = positions[i];
	            //x
	            arr[idx] = (180 + p[0]) / 360;
	            //y
	            arr[idx + 1] = MercatorPoint._latToMercatorY(p[1]);
	            //z
	            arr[idx + 2] = p.length >= 3 ? MercatorPoint._altitudeToMercatorZ(p[2], p[1]) : 0;
	        }
	        return arr;
	    };
	    /**
	     * Converts a mercator point into a map position.
	     * @param mercator Mercator point to convert.
	     * @returns A map position.
	     */
	    MercatorPoint.toPosition = function (mercator) {
	        if (mercator.length >= 2) {
	            var lat = (360 / Math.PI) * Math.atan(Math.exp(((180 - mercator[1] * 360) * Math.PI) / 180)) - 90;
	            return new Position(mercator[0] * 360 - 180, lat, mercator.length >= 3 ? MercatorPoint._mercatorZToAltitude(mercator[2], mercator[1]) : 0);
	        }
	        return [0, 0, 0];
	    };
	    /**
	     * Converts an array of mercator points into an array of map positions.
	     * @param mercators Mercator points to convert.
	     * @returns An array of map positions.
	     */
	    MercatorPoint.toPositions = function (mercators) {
	        var positions = [];
	        for (var i = 0, len = mercators.length; i < len; i++) {
	            positions.push(this.toPosition(mercators[i]));
	        }
	        return positions;
	    };
	    /**
	     * Determine the Mercator scale factor for a given latitude, see
	     * https://en.wikipedia.org/wiki/Mercator_projection#Scale_factor
	     *
	     * At the equator the scale factor will be 1, which increases at higher latitudes.
	     *
	     * @param latitude Latitude
	     * @returns The mercator scale factor.
	     */
	    MercatorPoint.mercatorScale = function (latitude) {
	        return 1 / Math.cos((latitude * Math.PI) / 180);
	    };
	    /**
	     * Returns the distance of 1 meter in `MercatorPoint` units at this latitude.
	     *
	     * For coordinates in real world units using meters, this naturally provides the scale
	     * to transform into `MercatorPoint`s.
	     *
	     * @returns {number} Distance of 1 meter in `MercatorPoint` units.
	     */
	    MercatorPoint.meterInMercatorUnits = function (latitude) {
	        // 1 meter / circumference at equator in meters * Mercator projection scale factor at this latitude
	        return ((1 / MercatorPoint.earthCircumference) *
	            MercatorPoint.mercatorScale(MercatorPoint._latToMercatorY(latitude)));
	    };
	    /***********************************
	     * Private static functions
	     ***********************************/
	    /*
	     * The circumference at a line of latitude in meters.
	     */
	    MercatorPoint._circumferenceAtLatitude = function (latitude) {
	        return MercatorPoint.earthCircumference * Math.cos((latitude * Math.PI) / 180);
	    };
	    MercatorPoint._altitudeToMercatorZ = function (altitude, latitude) {
	        return altitude / MercatorPoint._circumferenceAtLatitude(latitude);
	    };
	    MercatorPoint._mercatorZToAltitude = function (zoom, y) {
	        return zoom * MercatorPoint._circumferenceAtLatitude(MercatorPoint._latToMercatorY(y));
	    };
	    MercatorPoint._latToMercatorY = function (y) {
	        return (180 - (180 / Math.PI) * Math.log(Math.tan(Math.PI / 4 + (y * Math.PI) / 360))) / 360;
	    };
	    /*
	     * The average circumference of the world in meters.
	     */
	    MercatorPoint.earthCircumference = 2 * Math.PI * getEarthRadius(); // meters
	    return MercatorPoint;
	}(Array));

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoundingBox: BoundingBox,
		Feature: Feature,
		FeatureCollection: FeatureCollection,
		GeometryCollection: GeometryCollection,
		LineString: LineString,
		MercatorPoint: MercatorPoint,
		MultiLineString: MultiLineString,
		MultiPoint: MultiPoint,
		MultiPolygon: MultiPolygon,
		Point: Point,
		Polygon: Polygon,
		Position: Position
	});

	function getAddedSquaresAP(dx, dy) {
	    return dx * dx + dy * dy;
	}
	function getSqDistAP(p1, p2) {
	    return getAddedSquaresAP(p1[0] - p2[0], p1[1] - p2[1]);
	}
	function getSqSegDistAP(p, p1, p2) {
	    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
	    if (dx !== 0 || dy !== 0) {
	        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / getAddedSquaresAP(dx, dy);
	        if (t > 1) {
	            x = p2[0];
	            y = p2[1];
	        }
	        else if (t > 0) {
	            x += dx * t;
	            y += dy * t;
	        }
	    }
	    return getAddedSquaresAP(p[0] - x, p[1] - y);
	}
	function simplifyRadialDistAP(points, sqTolerance) {
	    var prevPoint = points[0], point;
	    var newPoints = [prevPoint];
	    for (var i = 1, len = points.length; i < len; i++) {
	        point = points[i];
	        if (getSqDistAP(point, prevPoint) > sqTolerance) {
	            newPoints.push(point);
	            prevPoint = point;
	        }
	    }
	    if (prevPoint !== point) {
	        newPoints.push(point);
	    }
	    return newPoints;
	}
	function simplifyDPStepAP(points, first, last, sqTolerance, simplified) {
	    var maxSqDist = sqTolerance, index;
	    for (var i = first + 1; i < last; i++) {
	        var sqDist = getSqSegDistAP(points[i], points[first], points[last]);
	        if (sqDist > maxSqDist) {
	            index = i;
	            maxSqDist = sqDist;
	        }
	    }
	    if (maxSqDist > sqTolerance) {
	        if (index - first > 1) {
	            simplifyDPStepAP(points, first, index, sqTolerance, simplified);
	        }
	        simplified.push(points[index]);
	        if (last - index > 1) {
	            simplifyDPStepAP(points, index, last, sqTolerance, simplified);
	        }
	    }
	}
	function simplifyDouglasPeuckerAP(points, sqTolerance) {
	    var last = points.length - 1;
	    var simplified = [points[0]];
	    simplifyDPStepAP(points, 0, last, sqTolerance, simplified);
	    simplified.push(points[last]);
	    return simplified;
	}
	function SimplifyAP(points, tolerance, highestQuality) {
	    if (tolerance === void 0) { tolerance = 1; }
	    if (highestQuality === void 0) { highestQuality = false; }
	    if (points.length <= 2) {
	        return points;
	    }
	    var sqTolerance = tolerance * tolerance;
	    points = highestQuality ? points : simplifyRadialDistAP(points, sqTolerance);
	    points = simplifyDouglasPeuckerAP(points, sqTolerance);
	    return points;
	}
	var SimplifyAP_1 = SimplifyAP;

	/**
	 * Perform a Douglas-Peucker simplification on an array of positions or pixels.
	 * @param points The position or pixel points to simplify.
	 * @param tolerance A tolerance to use in the simplification.
	 * @returns A new array of the simplified set of points.
	 */
	function simplify(points, tolerance) {
	    //Perform a Douglas-Peucker simplification of the pixels.
	    return SimplifyAP_1(points, tolerance, true);
	}

	var __values$f = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * An Affine Transform class generated from a set of reference points.
	 */
	var AffineTransform = /** @class */ (function () {
	    /**
	     * An Affine Transform class generated from a set of reference points.
	     * @param source A set of reference points from the source reference system to transform from.
	     * @param target A set of reference points from the target reference system to transform to.
	     */
	    function AffineTransform(source, target) {
	        this.M = AffineTransform._calculateAffineTransform(source, target);
	        this.inverseM = AffineTransform._calculateAffineTransform(target, source);
	    }
	    /**
	     * Converts an array of points from the source reference system to the target reference system.
	     * @param sourcePoints An array of points from the source reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the target reference system.
	     */
	    AffineTransform.prototype.toTarget = function (sourcePoints, decimals) {
	        if (typeof sourcePoints !== undefined) {
	            return this.transformArray(sourcePoints, this.M, decimals);
	        }
	        throw new Error("Invalid sourcePoints specified.");
	    };
	    /**
	     * Converts an array of points from the target reference system to the source reference system.
	     * @param targetPoints An array of points from the target reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the source reference system.
	     */
	    AffineTransform.prototype.toSource = function (targetPoints, decimals) {
	        if (typeof targetPoints !== undefined) {
	            return this.transformArray(targetPoints, this.inverseM, decimals);
	        }
	        throw new Error("Invalid targetPoints specified.");
	    };
	    /**
	     * Applies a transform matrix over a set of points and optionally rounds off the values to a specified number of decimals.
	     * @param points The array of points to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transformArray = function (points, transformMatrix, decimals) {
	        var e_1, _a;
	        if (points && Array.isArray(points) && Array.isArray(points[0])) {
	            var pos = [];
	            try {
	                for (var points_1 = __values$f(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
	                    var subPoints = points_1_1.value;
	                    pos.push(this.transform(subPoints, transformMatrix, decimals));
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return pos;
	        }
	        return null;
	    };
	    /**
	     * Applies a transform matrix on a point and optionally rounds off the values to a specified number of decimals.
	     * @param point The point to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transform = function (point, transformMatrix, decimals) {
	        var x = point[0] * transformMatrix[0][3] + point[1] * transformMatrix[1][3] + transformMatrix[2][3];
	        var y = point[0] * transformMatrix[0][4] + point[1] * transformMatrix[1][4] + transformMatrix[2][4];
	        return typeof decimals === "number" && decimals >= 0 ?
	            [_precision(x, decimals), _precision(y, decimals)] :
	            [_precision(x, 6), _precision(y, 6)];
	    };
	    /**
	     * Takes in a set of source and target points can calculates an approximate Affine Transform matrix that best fits the data.
	     * Modified version of this code: https://github.com/commenthol/affinefit
	     * @param sourcePoints A set of source points to transform from.
	     * @param targetPoints A set of target points to transform to.
	     * @returns An Affine Tranform matrix.
	     */
	    AffineTransform._calculateAffineTransform = function (sourcePoints, targetPoints) {
	        if (sourcePoints.length !== targetPoints.length || sourcePoints.length < 1) {
	            throw new Error("Error: source and target arrays must have the same length.");
	        }
	        // Use the smallest dimension of the input.
	        var dim = Math.min(sourcePoints[0].length, targetPoints[0].length);
	        var dimPlusOne = dim + 1;
	        if (sourcePoints.length < dim) {
	            throw new Error("Erorr: At least " + dim + " reference points required.");
	        }
	        // Create an empty (dim + 1) x (dim) matrix and fill it.
	        var c = [];
	        var transformMatrix = [];
	        for (var i = 0; i < dimPlusOne; i++) {
	            transformMatrix[i] = [];
	            for (var j = 0; j < dimPlusOne; j++) {
	                if (j < dim) {
	                    c[j] = 0;
	                }
	                transformMatrix[i][j] = 0;
	                for (var k = 0; k < sourcePoints.length; k++) {
	                    if (j < dim) {
	                        if (i < dim) {
	                            c[j] += sourcePoints[k][i] * targetPoints[k][j];
	                        }
	                        else {
	                            c[j] += targetPoints[k][j];
	                        }
	                    }
	                    if (i >= dim && j >= dim) {
	                        transformMatrix[i][j] += 1;
	                    }
	                    else if (i >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][j];
	                    }
	                    else if (j >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][i];
	                    }
	                    else {
	                        transformMatrix[i][j] += sourcePoints[k][i] * sourcePoints[k][j];
	                    }
	                }
	            }
	            transformMatrix[i] = transformMatrix[i].concat(c);
	        }
	        if (!this._gaussJordanElimination(transformMatrix)) {
	            throw new Error("Error: Singular matrix. Points are likely coplanar.");
	        }
	        return transformMatrix;
	    };
	    /**
	     * Puts a given matrix (2D array) into the Reduced Row Echelon Form.
	     * Returns True if successful, False if the transformMatrix is singular.
	     * Code from: https://github.com/commenthol/affinefit
	     * Modification:
	     * 1. Updated epsilon from 1e-10 to 1e-12 to reduce the possibility of valid matrix detected as singular
	     *    (can happen when points to convert are too close to each other on high LODs)
	     */
	    AffineTransform._gaussJordanElimination = function (transformMatrix) {
	        var eps = 1e-12; // 1.0 / Math.pow(10, 12)
	        var dimPlusOne = transformMatrix.length;
	        var w = 2 * dimPlusOne - 1;
	        var tempNum;
	        var tempArray;
	        for (var j = 0; j < dimPlusOne; j++) {
	            var maxrow = j;
	            for (var i = j + 1; i < dimPlusOne; i++) {
	                // Find max pivot.
	                if (Math.abs(transformMatrix[i][j]) > Math.abs(transformMatrix[maxrow][j])) {
	                    maxrow = i;
	                }
	            }
	            tempArray = transformMatrix[maxrow];
	            transformMatrix[maxrow] = transformMatrix[j];
	            transformMatrix[j] = tempArray;
	            if (Math.abs(transformMatrix[j][j]) <= eps) {
	                // Is Singular?
	                return false;
	            }
	            for (var _j = j + 1; _j < dimPlusOne; _j++) {
	                // Eliminate column y.
	                tempNum = transformMatrix[_j][j] / transformMatrix[j][j];
	                for (var _i = j; _i < w; _i++) {
	                    transformMatrix[_j][_i] -= transformMatrix[j][_i] * tempNum;
	                }
	            }
	        }
	        for (var j = dimPlusOne - 1; j > -1; j--) {
	            // Backsubstitute.
	            tempNum = transformMatrix[j][j];
	            for (var i = 0; i < j; i++) {
	                for (var _x = w - 1; _x > j - 1; _x--) {
	                    transformMatrix[i][_x] -= transformMatrix[j][_x] * transformMatrix[i][j] / tempNum;
	                }
	            }
	            transformMatrix[j][j] /= tempNum;
	            for (var _x2 = dimPlusOne; _x2 < w; _x2++) {
	                // Normalize row y.
	                transformMatrix[j][_x2] /= tempNum;
	            }
	        }
	        return true;
	    };
	    return AffineTransform;
	}());

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get AccelerationUnits () { return AccelerationUnits; },
		AffineTransform: AffineTransform,
		get AreaUnits () { return AreaUnits; },
		get DistanceUnits () { return DistanceUnits; },
		get SpeedUnits () { return SpeedUnits; },
		get TimeUnits () { return TimeUnits; },
		WEBMERCATOR_MAXLAT: WEBMERCATOR_MAXLAT,
		_precision: _precision,
		boundingBoxToPolygon: boundingBoxToPolygon,
		convertAcceleration: convertAcceleration,
		convertArea: convertArea,
		convertDistance: convertDistance,
		convertSpeed: convertSpeed,
		convertTimespan: convertTimespan,
		getAcceleration: getAcceleration,
		getAccelerationFromFeatures: getAccelerationFromFeatures,
		getAccelerationFromSpeeds: getAccelerationFromSpeeds,
		getArea: getArea,
		getCardinalSpline: getCardinalSpline,
		getClosestPointOnGeometry: getClosestPointOnGeometry,
		getConvexHull: getConvexHull,
		getDestination: getDestination,
		getDistanceTo: getDistanceTo,
		getEarthRadius: getEarthRadius,
		getGeodesicPath: getGeodesicPath,
		getGeodesicPaths: getGeodesicPaths,
		getHeading: getHeading,
		getLengthOfPath: getLengthOfPath,
		getPathDenormalizedAtAntimerian: getPathDenormalizedAtAntimerian,
		getPathSplitByAntimeridian: getPathSplitByAntimeridian,
		getPixelHeading: getPixelHeading,
		getPointWithHeadingAlongPath: getPointWithHeadingAlongPath,
		getPointsWithHeadingsAlongPath: getPointsWithHeadingsAlongPath,
		getPosition: getPosition,
		getPositionAlongPath: getPositionAlongPath,
		getPositions: getPositions,
		getPositionsAlongPath: getPositionsAlongPath,
		getRegularPolygonPath: getRegularPolygonPath,
		getRegularPolygonPaths: getRegularPolygonPaths,
		getSpeed: getSpeed,
		getSpeedFromFeatures: getSpeedFromFeatures,
		getTimespan: getTimespan,
		getTravelDistance: getTravelDistance,
		interpolate: interpolate,
		mercatorPixelsToPositions: mercatorPixelsToPositions,
		mercatorPositionsToPixels: mercatorPositionsToPixels,
		normalizeLatitude: normalizeLatitude,
		normalizeLongitude: normalizeLongitude,
		parseTimestamp: parseTimestamp,
		rotatePositions: rotatePositions,
		simplify: simplify
	});

	var __extends$13 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a ZoomControl object.
	 */
	var ZoomControlOptions = /** @class */ (function (_super) {
	    __extends$13(ZoomControlOptions, _super);
	    function ZoomControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The extent to which the map will zoom with each click of the control.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoomDelta = 1;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return ZoomControlOptions;
	}(Options));

	var __extends$12 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control for changing the zoom of the map.
	 */
	var ZoomControl = /** @class */ (function (_super) {
	    __extends$12(ZoomControl, _super);
	    /**
	     * Constructs a ZoomControl.
	     * @param options The options for the control.
	     */
	    function ZoomControl(options) {
	        var _this = _super.call(this) || this;
	        _this.container = null;
	        _this.zoomInButton = null;
	        _this.zoomOutButton = null;
	        _this.zoomChanged = function (event) { return _this.updateZoomButtonsState(); };
	        _this.minZoomChanged = function (zoom) { return _this.updateZoomButtonsState(); };
	        _this.maxZoomChanged = function (zoom) { return _this.updateZoomButtonsState(); };
	        _this.options = new ZoomControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    ZoomControl.prototype.onAdd = function (map) {
	        this.container = this.buildContainer(map, this.options.style, "Zoom Control");
	        this.container.style.flexDirection = "column";
	        this.zoomInButton = this.constructZoomInButton(map);
	        this.zoomOutButton = this.constructZoomOutButton(map);
	        var tooltipZoomIn = buildAccessibleTooltip("Zoom In");
	        var tooltipZoomOut = buildAccessibleTooltip("Zoom Out");
	        this.container.appendChild(this.zoomInButton);
	        this.container.appendChild(tooltipZoomIn);
	        this.container.appendChild(this.zoomOutButton);
	        this.container.appendChild(tooltipZoomOut);
	        positionTooltip(tooltipZoomIn, this.zoomInButton);
	        positionTooltip(tooltipZoomOut, this.zoomOutButton);
	        map.events.add('zoom', this.zoomChanged);
	        map.events.add('minzoomchanged', this.minZoomChanged);
	        map.events.add('maxzoomchanged', this.maxZoomChanged);
	        this.map = map;
	        return this.container;
	    };
	    ZoomControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        if (this.map) {
	            this.map.events.remove('zoom', this.zoomChanged);
	            this.map.events.remove('minzoomchanged', this.minZoomChanged);
	            this.map.events.remove('maxzoomchanged', this.maxZoomChanged);
	            this.map = null;
	        }
	        if (this.container) {
	            this.container.remove();
	            this.container = null;
	            this.zoomInButton = null;
	            this.zoomOutButton = null;
	        }
	    };
	    ZoomControl.prototype.updateZoomButtonsState = function () {
	        var zoomInDisabled = this.map.getCamera().zoom >= this.map._getMap().getMaxZoom();
	        // small values need special handling, since depending on the height of the map view
	        // the actual zoom we can zoom out to can be above or below 0 when the entire map fits the height into the view
	        // use web mercator bounds to check if entire latitude range is visible
	        var reachedLatitudeBoundaries = BoundingBox.getSouth(this.map.getCamera().bounds) <= -WEBMERCATOR_MAXLAT
	            && BoundingBox.getNorth(this.map.getCamera().bounds) >= WEBMERCATOR_MAXLAT;
	        var zoomOutDisabled = this.map.getCamera().zoom <= this.map._getMap().getMinZoom() || reachedLatitudeBoundaries;
	        if (this.zoomInButton && this.zoomInButton.disabled != zoomInDisabled) {
	            this.zoomInButton.disabled = zoomInDisabled;
	            this.zoomInButton.setAttribute("aria-label", zoomInDisabled ? "Zoom In disabled" : "Zoom In");
	        }
	        if (this.zoomOutButton && this.zoomOutButton.disabled != zoomOutDisabled) {
	            this.zoomOutButton.disabled = zoomOutDisabled;
	            this.zoomOutButton.setAttribute("aria-label", zoomInDisabled ? "Zoom Out disabled" : "Zoom Out");
	        }
	    };
	    ZoomControl.prototype.constructZoomInButton = function (map) {
	        var _this = this;
	        var zoomInButton = document.createElement("button");
	        zoomInButton.classList.add("azure-maps-control-button");
	        zoomInButton.classList.add("zoom-in");
	        zoomInButton.setAttribute("aria-label", "Zoom In");
	        zoomInButton.setAttribute("alt", "Zoom In");
	        zoomInButton.setAttribute("type", "button");
	        zoomInButton.addEventListener("click", function () {
	            var _a;
	            map.setCamera({
	                maxBounds: (_a = map._getMap().getMaxBounds()) === null || _a === void 0 ? void 0 : _a.toArray().flat(),
	                zoom: map.getCamera().zoom + _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomInButton;
	    };
	    ZoomControl.prototype.constructZoomOutButton = function (map) {
	        var _this = this;
	        var zoomOutButton = document.createElement("button");
	        zoomOutButton.classList.add("azure-maps-control-button");
	        zoomOutButton.classList.add("zoom-out");
	        zoomOutButton.setAttribute("aria-label", "Zoom Out");
	        zoomOutButton.setAttribute("alt", "Zoom Out");
	        zoomOutButton.setAttribute("type", "button");
	        zoomOutButton.addEventListener("click", function () {
	            var _a;
	            map.setCamera({
	                maxBounds: (_a = map._getMap().getMaxBounds()) === null || _a === void 0 ? void 0 : _a.toArray().flat(),
	                zoom: map.getCamera().zoom - _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomOutButton;
	    };
	    ZoomControl.ZOOM_DURATION_MS = 200;
	    return ZoomControl;
	}(ControlBase));

	var __extends$11 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a FullscreenControl object.
	 */
	var FullscreenControlOptions = /** @class */ (function (_super) {
	    __extends$11(FullscreenControlOptions, _super);
	    function FullscreenControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Indicates if the control should be hidden if the browser does not support fullscreen mode.
	         * Default `false`
	         * @default false
	         */
	        _this.hideIfUnsupported = false;
	        /**
	         * The HTML element which should be made full screen.
	         * If not specified, the map container element will be used.
	         */
	        _this.container = undefined;
	        return _this;
	    }
	    return FullscreenControlOptions;
	}(Options));

	var __extends$10 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control to make the map or a specified element fullscreen.
	 */
	var FullscreenControl = /** @class */ (function (_super) {
	    __extends$10(FullscreenControl, _super);
	    /**
	     * A control to make the map or a specified element fullscreen.
	     * @param options Options for defining how the control is rendered and the container to be made fullscreen.
	     */
	    function FullscreenControl(options) {
	        var _this = _super.call(this) || this;
	        _this.map = null;
	        _this.isFullscreenState = false;
	        _this.options = new FullscreenControlOptions().merge(options);
	        _this.control = new maplibregl.FullscreenControl({
	            container: _this.options.container,
	        });
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    FullscreenControl.prototype.onAdd = function (map) {
	        var _this = this;
	        var _a, _b;
	        this.map = map;
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.addControl(this.control);
	        var container = this.buildContainer(map, this.options.style, "Fullscreen Control");
	        var fullscreenButton = this.control._fullscreenButton;
	        if (fullscreenButton) {
	            var icon_1 = fullscreenButton.querySelector("span");
	            if (icon_1) {
	                var tooltip_1 = buildAccessibleTooltip("Enter Fullscreen");
	                container.appendChild(fullscreenButton);
	                // Add classes for styling.
	                fullscreenButton.classList.add("azure-maps-control-button", "fullscreen");
	                icon_1.classList.add("fullscreen-icon", "fullscreen-end");
	                // Add the tooltip and prevent the default one set by Maplibre.
	                fullscreenButton.removeAttribute("title"); // A title attribute will be converted to a tooltip by the browser.
	                container.appendChild(tooltip_1);
	                positionTooltip(tooltip_1, fullscreenButton);
	                // Update the icon and the tooltip based on the fullscreen state.
	                this.control.on("fullscreenstart", function () {
	                    // Remove the title attribute added automatically whenever fullscreen event is fired
	                    fullscreenButton.removeAttribute("title");
	                    icon_1.classList.remove("fullscreen-end");
	                    icon_1.classList.add("fullscreen-start");
	                    tooltip_1.innerText = "Exit Fullscreen";
	                    _this.isFullscreenState = true;
	                });
	                this.control.on("fullscreenend", function () {
	                    fullscreenButton.removeAttribute("title");
	                    icon_1.classList.remove("fullscreen-start");
	                    icon_1.classList.add("fullscreen-end");
	                    tooltip_1.innerText = "Enter Fullscreen";
	                    _this.isFullscreenState = false;
	                });
	            }
	        }
	        // Invisiblize the control if the browser does not support fullscreen mode.
	        if (this.options.hideIfUnsupported && !FullscreenControl.isSupported()) {
	            container.style.display = "none";
	        }
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    FullscreenControl.prototype.onRemove = function () {
	        var _a, _b;
	        _super.prototype.onRemove.call(this);
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.removeControl(this.control);
	        this.map = null;
	    };
	    /**
	     * Gets the current fullscreen state of the map.
	     * @returns A boolean indicating if the map is in fullscreen mode.
	     */
	    FullscreenControl.prototype.isFullscreen = function () {
	        return this.isFullscreenState;
	    };
	    /**
	     * Checks to see if the browser supports going into fullscreen mode.
	     * @returns A boolean indicating if the browser supports fullscreen mode.
	     */
	    FullscreenControl.isSupported = function () {
	        var d = document;
	        return d['fullscreenEnabled'] ||
	            d['msFullscreenEnabled'] ||
	            d['mozFullScreenEnabled'] ||
	            d['webkitFullscreenEnabled'];
	    };
	    return FullscreenControl;
	}(ControlBase));

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		CompassControl: CompassControl,
		ControlBase: ControlBase,
		FullscreenControl: FullscreenControl,
		PitchControl: PitchControl,
		ScaleControl: ScaleControl,
		StyleControl: StyleControl,
		TrafficControl: TrafficControl,
		TrafficLegendControl: TrafficLegendControl,
		ZoomControl: ZoomControl
	});

	var baseClone = _baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.cloneWith` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.cloneWith
	 * @example
	 *
	 * function customizer(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * }
	 *
	 * var el = _.cloneDeepWith(document.body, customizer);
	 *
	 * console.log(el === document.body);
	 * // => false
	 * console.log(el.nodeName);
	 * // => 'BODY'
	 * console.log(el.childNodes.length);
	 * // => 20
	 */
	function cloneDeepWith(value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	}

	var cloneDeepWith_1 = cloneDeepWith;

	var cloneDeepWith$1 = /*@__PURE__*/getDefaultExportFromCjs(cloneDeepWith_1);

	/**
	 * A hidden HTML element that is used to provide accessibility to shapes such as bubble.
	 */
	var AccessibleIndicator = /** @class */ (function () {
	    /**
	     * Constructs an AccessibleIndicator object by initializing a hidden `div` element.
	     * @internal
	     */
	    function AccessibleIndicator(options) {
	        var _this = this;
	        /**
	         * Attaches the indicator to the HTML document in a hidden style.
	         * @param map The map.
	         */
	        this.attach = function (map) {
	            // If attaching to a different map, remove popup on current map
	            if (_this.map !== map) {
	                // If map was defined the indicator was attached to another map.
	                if (_this.map) {
	                    _this.detachFromCurrentMap();
	                }
	                _this.map = map;
	                _this.map.indicators._getCollectionDiv().appendChild(_this.element);
	                _this.map.indicators.add(_this);
	            }
	        };
	        /**
	         * Removes the indicator from the map and the HTML document.
	        */
	        this.remove = function () {
	            _this.detachFromCurrentMap();
	            _this.element.remove();
	        };
	        /**
	         * Get the DOM element of the indicator.
	         * @returns The DOM element of the indicator.
	         */
	        this.getElement = function () {
	            return _this.element;
	        };
	        this.detachFromCurrentMap = function () {
	            if (_this.map) {
	                _this.map.indicators.remove(_this);
	                delete _this.map;
	            }
	        };
	        this.element = document.createElement("div");
	        // Set tabindex to 0 to make the element focusable.
	        this.element.setAttribute("tabindex", "0");
	        // Set the role to option, and it's container to listbox so the reader will read the listbox as a list.
	        // For example, NVDA will read "data point, {posinset} of {setsize}" when the indicator is focused.
	        this.element.setAttribute("role", "option");
	        if (options === null || options === void 0 ? void 0 : options.setSize)
	            this.element.setAttribute("aria-setsize", options.setSize.toString());
	        if (options === null || options === void 0 ? void 0 : options.positionInSet)
	            this.element.setAttribute("aria-posinset", options.positionInSet.toString());
	        this.element.setAttribute("aria-label", "data point");
	        this.element.classList.add(AccessibleIndicator.Css.hidden);
	    }
	    // CSS class names.
	    AccessibleIndicator.Css = {
	        hidden: "hidden-accessible-element"
	    };
	    return AccessibleIndicator;
	}());

	var __extends$$ = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `DataSourceOptions`.
	 * @module Object Definitions
	 */
	var DataSourceOptions = /** @class */ (function (_super) {
	    __extends$$(DataSourceOptions, _super);
	    function DataSourceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /*
	         * The size of the buffer around each tile.
	         * A buffer value of 0 will provide better performance but will be more likely to generate artifacts when rendering.
	         * Larger buffers will produce left artifacts but will result in slower performance.
	         */
	        _this.buffer = 128;
	        /**
	         * Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels).
	         * default `18`
	         * @default 18
	         */
	        _this.maxZoom = 18;
	        /**
	         * A boolean indicating if Point features in the source should be clustered or not.
	         * If set to true, points will be clustered together into groups by radius.
	         * default `false`
	         * @default false
	         */
	        _this.cluster = false;
	        /**
	         * The radius of each cluster in pixels.
	         * default `50`
	         * @default 50
	         */
	        _this.clusterRadius = 50;
	        /**
	         * The maximum zoom level in which to cluster points.
	         * Defaults to one zoom less than `maxZoom` so that last zoom features are not clustered.
	         */
	        _this.clusterMaxZoom = undefined;
	        /**
	         * Defines custom properties that are calculated using expressions against all the points within each cluster and added to the properties of each cluster point.
	         */
	        _this.clusterProperties = undefined;
	        /**
	         * Specifies whether to calculate line distance metrics.
	         * This is required for line layers that specify `lineGradient` values.
	         * default `false`
	         * @default false
	         */
	        _this.lineMetrics = false;
	        /**
	         * The Douglas-Peucker simplification tolerance that is applied to the data when rendering (higher means simpler geometries and faster performance).
	         * default `0.375`
	         * @default 0.375
	         */
	        _this.tolerance = 0.375;
	        /**
	         * Minimum number of points necessary to form a cluster if clustering is enabled.
	         * @default 2
	         */
	        _this.clusterMinPoints = 2;
	        /**
	         * Whether to generate ids for the geojson features. When enabled, the feature.id property will be auto assigned based on its index in the features array, over-writing any previous values.
	         */
	        _this.generateId = false;
	        /**
	         * A specified property name to be used as a feature ID (for feature state).
	         * This can either be a property name or an object in the form `{<sourceLayer>: <propertyName>}`.
	         */
	        _this.promoteId = undefined;
	        /**
	         * An expression for filtering features prior to processing them for rendering.
	         */
	        _this.filter = undefined;
	        return _this;
	    }
	    return DataSourceOptions;
	}(Options));

	var __extends$_ = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A base abstract class in which all other source objects extend.
	 * A source must be added to a layer before it is visible on the map.
	 */
	var Source = /** @class */ (function (_super) {
	    __extends$_(Source, _super);
	    function Source(id) {
	        var _this = _super.call(this) || this;
	        _this.id = id || uuid();
	        return _this;
	    }
	    /**
	     * Gets the id of the data source
	     */
	    Source.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Get reference to Mapbox Map
	     * @internal
	     */
	    Source.prototype._setMap = function (map, shouldInvokeEvent) {
	        if (shouldInvokeEvent === void 0) { shouldInvokeEvent = true; }
	        if (map == null || map === undefined) {
	            var temp = this.map;
	            delete this.map;
	            if (shouldInvokeEvent) {
	                this._invokeEvent("sourceremoved", this);
	                if (temp) {
	                    temp.events.invoke("sourceremoved", this);
	                }
	            }
	        }
	        else {
	            this.map = map;
	            if (shouldInvokeEvent) {
	                this._invokeEvent("sourceadded", this);
	                this.map.events.invoke("sourceadded", this);
	            }
	        }
	    };
	    return Source;
	}(EventEmitter));

	var __extends$Z = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$e = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * The DataSource class may be used with the SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, and HeatMapLayer.
	 */
	var DataSource = /** @class */ (function (_super) {
	    __extends$Z(DataSource, _super);
	    /**
	     * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	     * A data source must be added to a layer before it is visible on the map.
	     * The `DataSource` class may be used with the `SymbolLayer`, `LineLayer`, `PolygonLayer`, `BubbleLayer`, and `HeatMapLayer`.
	     * @param id a unique id that the user assigns to the data source. If this is not specified, then the data source will automatically be assigned an id.
	     * @param options the options for the data source.
	     */
	    function DataSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.requestId = undefined;
	        _this.options = new DataSourceOptions().merge(cloneDeep$1(options));
	        _this.shapes = [];
	        _this.shapesMap = new Dictionary();
	        return _this;
	    }
	    /**
	     * Adds shapes to the data source.
	     * GeoJSON objects will be wrapped within a Shape class to make them easier to manage.
	     * Optionally specify an index to insert the feature between other shapes/features in the layers.
	     * @param data
	     * @param index
	     */
	    DataSource.prototype.add = function (data, index) {
	        this._addNoUpdate(data, index);
	        this._updateSource();
	    };
	    /**
	     * Removes all data in the data source.
	     */
	    DataSource.prototype.clear = function () {
	        this._clearNoUpdate();
	        this._updateSource();
	    };
	    /**
	     * Cleans up any resources this object is consuming.
	     */
	    DataSource.prototype.dispose = function () {
	        this.options = null;
	        this.shapes = null;
	        this.shapesMap = null;
	        this.map = null;
	    };
	    /*
	     * (P3) Gets the bounding box the encloses all data in the data source.
	     * public getBounds() {}
	     */
	    /**
	     * Calculates a zoom level at which the cluster will start expanding or break apart.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterExpansionZoom = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterExpansionZoom(clusterId)
	                    .then(function (zoom) {
	                    if (typeof zoom === "number") {
	                        resolve(zoom);
	                    }
	                })
	                    .catch(function (error) {
	                    if (error) {
	                        reject(error);
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves the children of the given cluster on the next zoom level. This may be a combination of shapes and sub-clusters.
	     * The sub-clusters will be features with properties matching ClusteredProperties.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterChildren = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterChildren(clusterId)
	                    .then(function (features) {
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                    }
	                })
	                    .catch(function (error) {
	                    if (error) {
	                        reject(error);
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves shapes that are within the cluster.
	     * @param clusterId
	     * @param limit The maximum number of features to return. Set to Infinity to return all shapes.
	     * @param offset The number of shapes to skip. Allows you to page through the shapes in the cluster.
	     */
	    DataSource.prototype.getClusterLeaves = function (clusterId, limit, offset) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterLeaves(clusterId, limit, offset)
	                    .then(function (features) {
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                    }
	                })
	                    .catch(function (error) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Gets the options used by the data source.
	     */
	    DataSource.prototype.getOptions = function () {
	        return cloneDeep$1(this.options);
	    };
	    /**
	     * Returns all shapes that are in the DataSource.
	     */
	    DataSource.prototype.getShapes = function () {
	        return Array.from(this.shapes);
	    };
	    /**
	     * Downloads a GeoJSON document and imports its data into the data source.
	     * The GeoJSON document must be on the same domain or accessible using CORS.
	     * @param url
	     */
	    DataSource.prototype.importDataFromUrl = function (url) {
	        var _this = this;
	        return fetch(url, {
	            method: "GET",
	            mode: "cors"
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
	            }
	        }).then(function (geoJson) {
	            _this.add(geoJson);
	        });
	    };
	    /**
	     * Retrieves a shape with the specified id.
	     * If no shape with the specified id is contained in the data source, null will be return.
	     * @param id The id of the shape to return.
	     */
	    DataSource.prototype.getShapeById = function (id) {
	        return this.shapes[this.shapesMap.get(id)] || null;
	    };
	    /**
	     * Removes one or more shapes from the data source.
	     * If a string is passed in, it is assumed to be an id.
	     * If a number is passed in, removes the shape at that index.
	     * @param shape The shape(s), shape id(s), or feature(s) to be removed
	     */
	    DataSource.prototype.remove = function (shape) {
	        var e_1, _a;
	        var shapes = Array.isArray(shape) ? shape : [shape];
	        try {
	            for (var shapes_1 = __values$e(shapes), shapes_1_1 = shapes_1.next(); !shapes_1_1.done; shapes_1_1 = shapes_1.next()) {
	                var s = shapes_1_1.value;
	                if (typeof s === "number") {
	                    this._removeByIndex(s);
	                }
	                else {
	                    this._removeById(s);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (shapes_1_1 && !shapes_1_1.done && (_a = shapes_1.return)) _a.call(shapes_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        this._updateSource();
	    };
	    /**
	     * Removes one or more shapes from the datasource based on its id.
	     * @param shape shape id
	     */
	    DataSource.prototype.removeById = function (id) {
	        var e_2, _a;
	        var ids = Array.isArray(id) ? id : [id];
	        try {
	            for (var ids_1 = __values$e(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
	                var i = ids_1_1.value;
	                this._removeById(i);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        this._updateSource();
	    };
	    /**
	     * Sets the data source options.
	     * The data source will retain its current values for any option not specified in the supplied options.
	     * @param options the DataSourceOptions to be set
	     */
	    DataSource.prototype.setOptions = function (options) {
	        var newOptions = new DataSourceOptions().merge(this.options, cloneDeep$1(options));
	        // Only rebuild the map's style if a options has actually changed.
	        if (!isEqual$1(this.options, newOptions)) {
	            this._invokeEvent("datasourceupdated", this);
	            // Update the options before rebuilding.
	            this.options = newOptions;
	            if (this.map) {
	                this.map._rebuildStyle();
	            }
	        }
	    };
	    /**
	     * Overwrites all shapes in the data source with the new array of shapes.
	     * @param shape the new shapes to update
	     */
	    DataSource.prototype.setShapes = function (shape) {
	        this._clearNoUpdate();
	        this.add(shape);
	    };
	    /**
	     * Returns a GeoJSON FeatureCollection which contains all the shape data that is in the data source.
	     */
	    DataSource.prototype.toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape.toJson(); }));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    DataSource.prototype._toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape._toJson(); }));
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._buildSource = function () {
	        var geoJsonSource = {
	            type: "geojson",
	            data: this._toJson(),
	            maxzoom: this.options.maxZoom,
	            cluster: this.options.cluster,
	            clusterRadius: this.options.clusterRadius,
	            tolerance: this.options.tolerance,
	            lineMetrics: this.options.lineMetrics,
	            clusterProperties: this.options.clusterProperties,
	            buffer: this.options.buffer,
	            clusterMinPoints: this.options.clusterMinPoints,
	            generateId: this.options.generateId,
	            promoteId: this.options.promoteId,
	            filter: this.options.filter
	        };
	        if (typeof this.options.clusterMaxZoom === "number") {
	            geoJsonSource.clusterMaxZoom = this.options.clusterMaxZoom;
	        }
	        return geoJsonSource;
	    };
	    DataSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this._buildSource();
	        var otherSource = other._buildSource();
	        return source.type === otherSource.type &&
	            // no data comparison since it is costly and not needed. If geojson data is different, but other source properties are same, we treat it as an update.
	            //source.data === otherSource.data &&
	            source.maxzoom === otherSource.maxzoom &&
	            source.cluster === otherSource.cluster &&
	            source.clusterRadius === otherSource.clusterRadius &&
	            source.tolerance === otherSource.tolerance &&
	            source.lineMetrics === otherSource.lineMetrics &&
	            JSON.stringify(source.clusterProperties) === JSON.stringify(otherSource.clusterProperties) &&
	            source.buffer === otherSource.buffer &&
	            source.clusterMinPoints === otherSource.clusterMinPoints &&
	            source.generateId === otherSource.generateId &&
	            source.promoteId === otherSource.promoteId &&
	            source.filter === otherSource.filter;
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._addNoUpdate = function (data, index) {
	        var newShapes;
	        if (data instanceof Shape) {
	            this._addToSources(data, index);
	            newShapes = [data];
	        }
	        else if (Array.isArray(data)) {
	            newShapes = data.map(function (ele) { return ele instanceof Shape ? ele : new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "FeatureCollection") {
	            newShapes = data.features.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "GeometryCollection") {
	            newShapes = data.geometries.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else {
	            // Either a Feature or Geometry.
	            // The Shape constructor can handle either.
	            var shape = new Shape(data);
	            this._addToSources(shape, index);
	            newShapes = [shape];
	        }
	        // Invoke the dataadded event once all the new features have been wrapped with shapes.
	        this._invokeEvent("dataadded", newShapes);
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._clearNoUpdate = function () {
	        var oldShapes = this.shapes;
	        this.shapes = [];
	        this.shapesMap = new Dictionary();
	        // If any shapes were removed fire the dataremoved event.
	        if (oldShapes && oldShapes.length > 0) {
	            this._invokeEvent("dataremoved", oldShapes);
	        }
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._updateSource = function () {
	        var _this = this;
	        // throttling logic that makes DataSource waits a small amount of time before rerendering the map, so the browser won't get frozen
	        // when there is too much data
	        if (this.requestId !== undefined) {
	            return;
	        }
	        else {
	            this.requestId = requestAnimationFrame(function () {
	                _this._updateMboxSource();
	                _this.requestId = undefined;
	            });
	        }
	    };
	    DataSource.prototype._addToSources = function (data, index) {
	        var e_3, _a, e_4, _b;
	        data = Array.isArray(data) ? data : [data];
	        if (typeof index !== "number") {
	            try {
	                for (var data_1 = __values$e(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
	                    var d = data_1_1.value;
	                    this.shapes.push(d);
	                    this.shapesMap.set(d.getId(), this.shapes.length - 1);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	        }
	        else {
	            for (var i = data.length - 1; i >= 0; i--) {
	                this.shapes.splice(index, 0, data[i]);
	                this._updateShapesMap(index);
	            }
	        }
	        try {
	            for (var data_2 = __values$e(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
	                var d = data_2_1.value;
	                d._setDataSource(this);
	            }
	        }
	        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	        finally {
	            try {
	                if (data_2_1 && !data_2_1.done && (_b = data_2.return)) _b.call(data_2);
	            }
	            finally { if (e_4) throw e_4.error; }
	        }
	    };
	    DataSource.prototype._removeById = function (shape) {
	        var oldShape;
	        var i = shape instanceof Shape ? shape.getId() : typeof shape === "string" || typeof shape === "number" ? shape : shape.id;
	        oldShape = this.shapes[this.shapesMap.get(i)];
	        if (oldShape) {
	            oldShape._setDataSource(null);
	            this.shapes.splice(this.shapesMap.get(i), 1);
	            this._updateShapesMap(this.shapesMap.get(i));
	            this.shapesMap.delete(i);
	            // Invoke the dataremoved event with the single shape removed.
	            this._invokeEvent("dataremoved", [oldShape]);
	        }
	    };
	    DataSource.prototype._removeByIndex = function (i) {
	        var oldShape;
	        if (i >= this.shapes.length) {
	            throw new Error("The specified remove index '".concat(i, "' ") +
	                "is greater than the maximum possible index '".concat(this.shapes.length - 1, "'"));
	        }
	        oldShape = this.shapes[i];
	        this.shapesMap.delete(oldShape.getId());
	        oldShape._setDataSource(null);
	        this.shapes.splice(i, 1);
	        this._updateShapesMap(i);
	        // Invoke the dataremoved event with the single shape removed.
	        this._invokeEvent("dataremoved", [oldShape]);
	    };
	    DataSource.prototype._updateShapesMap = function (index) {
	        for (var i = index; i < this.shapes.length; i++) {
	            this.shapesMap.set(this.shapes[i].getId(), i);
	        }
	    };
	    DataSource.prototype._updateMboxSource = function () {
	        if (this.map && this.map._getMap()) {
	            var mbSource = this.map._getMap().getSource(this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.setData(this._toJson());
	            }
	        }
	    };
	    return DataSource;
	}(Source));

	var __extends$Y = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `VectorTileSource`.
	 * @module Object Definitions
	 */
	var VectorTileSourceOptions = /** @class */ (function (_super) {
	    __extends$Y(VectorTileSourceOptions, _super);
	    function VectorTileSourceOptions() {
	        /*
	         * TODO:
	         * (P4) An attribute to display to the user when this data source is visible.
	         *
	         * public attribute?: string;
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         */
	        _this.bounds = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * default `0`
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * default `22`
	         * @default 22
	         */
	        _this.maxZoom = 22;
	        /**
	         * Specifies is the tile systems y coordinate uses the OSGeo Tile Map Services which reverses the Y coordinate axis.
	         * default `false`
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of one or more tile source URLs. Supported URL parameters:
	         *  <ul>
	         *      <li>`{x}` - X position of tile. Tile URL usually also needs {y} and {z}.</li>
	         *      <li>`{y}` - Y position of tile. Tile URL usually also needs {x} and {z}.</li>
	         *      <li>`{z}` - Zoom level of tile. Tile URL usually also needs {x} and {y}.</li>
	         *      <li>`{quadkey}` - Tile quadkey id based on the Bing Maps tile system naming convention.</li>
	         *      <li>`{bbox-epsg-3857}` - A bounding box string with the format "{west},{south},{east},{north}" with coordinates in the EPSG 3857 Spatial Reference System also commonly known as WGS84 Web Mercator. This is useful when working with WMS imagery services.</li>
	         *  <ul>
	         */
	        _this.tiles = undefined;
	        /**
	         * A URL to a TileJSON resource.
	         * Supported protocols are `http:` and `https:`.
	         */
	        _this.url = undefined;
	        return _this;
	    }
	    return VectorTileSourceOptions;
	}(Options));

	var __extends$X = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A vector tile source describes how to access a vector tile layer.
	 * Vector tile sources can be used with; SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, HeatmapLayer and VectorTileLayer.
	 */
	var VectorTileSource = /** @class */ (function (_super) {
	    __extends$X(VectorTileSource, _super);
	    function VectorTileSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new VectorTileSourceOptions().merge(cloneDeep$1(options));
	        return _this;
	    }
	    /**
	     * Gets the options of the VectorTileSource.
	     */
	    VectorTileSource.prototype.getOptions = function () {
	        return cloneDeep$1(this.options);
	    };
	    /**
	     * Returns all GeoJSON features that are in the VectorTileSource and which satisfy the specified filter expression.
	     * @param sourceLayer Required if the source is a VectorTileSource. Specifies the layer within the VectorTileSource to query.
	     * @param filter A filter that will limit the query.
	     */
	    VectorTileSource.prototype.getShape = function (sourceLayer, filter) {
	        return this.map._getMap().querySourceFeatures(this.getId(), { sourceLayer: sourceLayer, filter: filter });
	    };
	    /**
	     * @internal
	     */
	    VectorTileSource.prototype._buildSource = function () {
	        var vectorSource = {
	            type: "vector",
	        };
	        if (this.options.bounds) {
	            vectorSource.bounds = this.options.bounds;
	        }
	        if (this.options.tiles) {
	            vectorSource.tiles = this.options.tiles;
	            vectorSource.minzoom = this.options.minZoom;
	            vectorSource.maxzoom = this.options.maxZoom;
	        }
	        else if (this.options.url) {
	            vectorSource.url = this.options.url;
	        }
	        if (this.options.isTMS) {
	            vectorSource.scheme = "tms";
	        }
	        return vectorSource;
	    };
	    /**
	     * @internal
	     */
	    VectorTileSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this._buildSource();
	        var otherSource = other._buildSource();
	        return source.type === otherSource.type &&
	            source.url === otherSource.url &&
	            ((source.tiles === undefined && otherSource.tiles === undefined) ||
	                (source.tiles && otherSource.tiles && source.tiles.length === otherSource.tiles.length && source.tiles.every(function (value, idx) { return value === otherSource.tiles[idx]; }))) &&
	            source.minzoom === otherSource.minzoom &&
	            source.maxzoom === otherSource.maxzoom &&
	            source.bounds === otherSource.bounds &&
	            source.attribution === otherSource.attribution &&
	            source.promoteId === otherSource.promoteId &&
	            source.scheme === otherSource.scheme;
	    };
	    return VectorTileSource;
	}(Source));

	var __extends$W = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent the canvas source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var CanvasSource = /** @class */ (function (_super) {
	    __extends$W(CanvasSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef Canvas source specification.
	     * @param options Unused for now
	     */
	    function CanvasSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    CanvasSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type
	            && source.canvas === otherSource.canvas
	            && JSON.stringify(source.coordinates) === JSON.stringify(otherSource.coordinates)
	            && source.animate === otherSource.animate;
	    };
	    /**
	     * @internal
	     */
	    CanvasSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return CanvasSource;
	}(Source));

	var __extends$V = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent an unkown source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var UnknownSource = /** @class */ (function (_super) {
	    __extends$V(UnknownSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef source specification.
	     * @param options Unused for now
	     */
	    function UnknownSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    UnknownSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type;
	    };
	    /**
	     * @internal
	     */
	    UnknownSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return UnknownSource;
	}(Source));

	var __extends$U = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent the image source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var ImageSource = /** @class */ (function (_super) {
	    __extends$U(ImageSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef Image source specification.
	     * @param options Unused for now
	     */
	    function ImageSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    ImageSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type
	            && JSON.stringify(source.coordinates) === JSON.stringify(otherSource.coordinates)
	            && source.url === otherSource.url;
	    };
	    /**
	     * @internal
	     */
	    ImageSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return ImageSource;
	}(Source));

	var __extends$T = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent the video source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var VideoSource = /** @class */ (function (_super) {
	    __extends$T(VideoSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef Video source specification.
	     * @param options Unused for now
	     */
	    function VideoSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    VideoSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type
	            && JSON.stringify(source.coordinates) === JSON.stringify(otherSource.coordinates)
	            && source.urls === otherSource.urls;
	    };
	    /**
	     * @internal
	     */
	    VideoSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return VideoSource;
	}(Source));

	var __extends$S = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var RasterTileSourceOptions = /** @class */ (function (_super) {
	    __extends$S(RasterTileSourceOptions, _super);
	    function RasterTileSourceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * raster tile pixel size.
	         * default `512`
	         * @default 512
	         */
	        _this.tileSize = 512;
	        return _this;
	    }
	    return RasterTileSourceOptions;
	}(VectorTileSourceOptions));

	var __extends$R = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var ElevationTileSourceOptions = /** @class */ (function (_super) {
	    __extends$R(ElevationTileSourceOptions, _super);
	    function ElevationTileSourceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * DEM tiles encoding format. Supported: `mapbox` or `terrarium`.<br />
	         * `"terrarium": Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info.<br />
	         * `"mapbox": Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info.<br />
	         * default `mapbox`
	         * @default mapbox
	         */
	        _this.encoding = undefined;
	        return _this;
	    }
	    return ElevationTileSourceOptions;
	}(RasterTileSourceOptions));

	var __extends$Q = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$c = (window && window.__assign) || function () {
	    __assign$c = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$c.apply(this, arguments);
	};
	/**
	 * Publicly exposed ElevationTileSource.
	 */
	var ElevationTileSource = /** @class */ (function (_super) {
	    __extends$Q(ElevationTileSource, _super);
	    function ElevationTileSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new ElevationTileSourceOptions().merge(cloneDeep$1(options));
	        return _this;
	    }
	    /**
	     * Gets the options of the ElevationTileSource.
	     */
	    ElevationTileSource.prototype.getOptions = function () {
	        return cloneDeep$1(this.options);
	    };
	    ElevationTileSource.prototype._buildSource = function () {
	        var t = __assign$c({ type: "raster-dem", bounds: this.options.bounds, minzoom: this.options.minZoom, maxzoom: this.options.maxZoom, tileSize: this.options.tileSize, encoding: this.options.encoding }, (!this.options.tiles ? { url: this.options.url } : { tiles: this.options.tiles }));
	        return t;
	    };
	    ElevationTileSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var otherOptions = other.getOptions();
	        return this.options.url === otherOptions.url &&
	            this.options.tiles === otherOptions.tiles &&
	            this.options.bounds === otherOptions.bounds &&
	            this.options.minZoom === otherOptions.minZoom &&
	            this.options.maxZoom === otherOptions.maxZoom &&
	            this.options.tileSize === otherOptions.tileSize &&
	            this.options.encoding === otherOptions.encoding;
	    };
	    return ElevationTileSource;
	}(Source));

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		CanvasSource: CanvasSource,
		DataSource: DataSource,
		ElevationTileSource: ElevationTileSource,
		ImageSource: ImageSource,
		Source: Source,
		UnknownSource: UnknownSource,
		VectorTileSource: VectorTileSource,
		VideoSource: VideoSource
	});

	var __extends$P = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Abstract class for other layer classes to extend.
	 */
	var Layer = /** @class */ (function (_super) {
	    __extends$P(Layer, _super);
	    function Layer(id) {
	        var _this = 
	        // Assign an random id using a UUID if none was specified.
	        _super.call(this) || this;
	        _this.id = id || uuid();
	        return _this;
	    }
	    /**
	     * Gets the id of the layer
	     */
	    Layer.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Gets the map that the layer is currently added to, or null.
	     */
	    Layer.prototype.getMap = function () {
	        return this.map || null;
	    };
	    /**
	     * Initialization method for the layer which is called when added to the map.
	     * @param map The map the layer has been added to.
	     */
	    Layer.prototype.onAdd = function (map) {
	        this.map = map;
	        this._invokeEvent("layeradded", this);
	        this.map.events.invoke("layeradded", this);
	    };
	    /**
	     * Method that is called when the layer is removed from the map.
	     * Should perform any necessary cleanup for the layer.
	     */
	    Layer.prototype.onRemove = function () {
	        var temp = this.map;
	        delete this.map;
	        this._invokeEvent("layerremoved", this);
	        if (temp) {
	            temp.events.invoke("layerremoved", this);
	        }
	    };
	    /**
	     * Returns if an event is one specified by Mapbox.
	     * False means we have defined that event.
	     * @internal
	     */
	    Layer._isMBoxEvent = function (eventType) {
	        return !this.LayerEvents.hasOwnProperty(eventType);
	    };
	    /**
	     * Updates the base layout and paint properties.
	     * Covers the follow properties: minZoom, maxZoom, filter, and visible.
	     * @param newOptions The new base layer options.
	     * @internal
	     */
	    Layer.prototype._updateBaseProperties = function (newOptions, oldOptions) {
	        this._updateFilter(newOptions.filter, oldOptions.filter);
	        this._updateZoomRange(newOptions.minZoom, oldOptions.minZoom, newOptions.maxZoom, oldOptions.maxZoom);
	        this._updateLayoutProperty("visibility", newOptions.visible, oldOptions.visible, newOptions.visible ? "visible" : "none");
	    };
	    /**
	     * Updates the filter for the layer in the maps its attached to.
	     * @param newFilter The new filter.
	     * @param oldFilter The old filter.
	     * Will be checked against newFilter to determine if an update is necessary.
	     * @param subFilter Optional filter to substitute for newFilter if updating is necessary.
	     * Useful when the option value doesn't exactly match the paint property.
	     * @internal
	     */
	    Layer.prototype._updateFilter = function (newFilter, oldFilter) {
	        if (!(isEqual$1(newFilter, oldFilter))) {
	            this.map._getMap().setFilter(this.id, newFilter);
	        }
	    };
	    Layer.prototype._updatePaintProperty = function (name, newValue, oldValue, subValue) {
	        // Only update if attached to a map and the values are changed.
	        if (!(isEqual$1(newValue, oldValue))) {
	            this.map._getMap().setPaintProperty(this.id, name, subValue || newValue);
	        }
	    };
	    Layer.prototype._updateLayoutProperty = function (name, newValue, oldValue, subValue) {
	        if (!(isEqual$1(newValue, oldValue))) {
	            this.map._getMap().setLayoutProperty(this.id, name, subValue || newValue);
	        }
	    };
	    /**
	     * Sets the zoom range for the layer in the attached map.
	     * @param minZoom The new minimum zoom value.
	     * @param maxZoom The new maximum zoom value.
	     * @internal
	     */
	    Layer.prototype._updateZoomRange = function (newMin, oldMin, newMax, oldMax) {
	        if ((newMin !== oldMin) || (oldMax !== newMax)) {
	            this.map._getMap().setLayerZoomRange(this.id, newMin, newMax);
	        }
	    };
	    // This object is accessible at runtime (unlike interfaces)
	    // and can be used to determine which events are ours vs Mapbox's.
	    Layer.LayerEvents = {
	        layeradded: undefined,
	        layerremoved: undefined,
	        focusin: undefined,
	        focusout: undefined,
	    };
	    return Layer;
	}(EventEmitter));

	var __extends$O = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A base class which all other layer options inherit from.
	 */
	var LayerOptions$1 = /** @class */ (function (_super) {
	    __extends$O(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * An expression specifying conditions on source features.
	         * Only features that match the filter are displayed.
	         */
	        _this.filter = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * This value is inclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * This value is exclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `24`.
	         * @default 24
	         */
	        _this.maxZoom = 24;
	        /**
	         * Specifies if the layer is visible or not.
	         * Default `true`.
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    LayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	        else {
	            return undefined;
	        }
	    };
	    return LayerOptions;
	}(Options));

	var __extends$N = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Point objects in a BubbleLayer.
	 */
	var BubbleLayerOptions = /** @class */ (function (_super) {
	    __extends$N(BubbleLayerOptions, _super);
	    function BubbleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the circle symbol with.
	         * Default `"#1A73AA"`.
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * The amount to blur the circles.
	         * A value of 1 blurs the circles such that only the center point if at full opacity.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The color of the circles' outlines.
	         * Default `"#FFFFFF"`.
	         * @default "#FFFFFF"
	         */
	        _this.strokeColor = "#FFFFFF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles' outlines will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The width of the circles' outlines in pixels.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        /**
	         * Specifies the orientation of circle when map is pitched.<br />
	         * `"map"`: The circle is aligned to the plane of the map.<br />
	         * `"viewport"`: The circle is aligned to the plane of the viewport.<br />
	         * Default: `"viewport"`
	         * @default "viewport"
	         */
	        _this.pitchAlignment = "viewport";
	        /**
	         * The radius of the circle symbols in pixels.
	         * Must be greater than or equal to 0.
	         * Default `8`.
	         * @default 8
	         */
	        _this.radius = 8;
	        /**
	         * @internal
	         * Specifies whether to create focusable indicators for the bubbles.
	         * The default highlighting style is provided if the source is DataSource with Shape:
	         * ```ts
	         * const datasource = new DataSource('bubble-source');
	         * datasource.setShapes([new Shape(new Point([-122.335, 47.62]))]);
	         * this.map.sources.add(datasource);
	         * const layer = new BubbleLayer(datasource, 'bubble', {
	         *  radius: 10,
	         *  color: 'cyan',
	         *  createIndicators: true,
	         * });
	         * ```
	         *
	         * For other sources, you can provide the accessibilityIdKey option to specify the property name of the feature to use as the accessibility id.
	         * ```ts
	         * const vtSource = new VectorTileSource("indoorTiles", { tiles,  // provide your tile urls });
	         * this.map.sources.add(vtSource);
	         * const layer = new BubbleLayer(vtSource, 'bubble', {
	         *  createIndicators: true,
	         *  accessibilityIdKey: '{add your ID here}'
	         * });
	         * ```
	         *
	         * If you want to customize the highlighting style, you can use the focusin/focusout events to change the style of the bubble.
	         * ```ts
	         * this.map.events.add('focusin', 'bubble', (e) => { handle the style highlight });
	         * ```
	         *
	         * Note: We treat this as an internal option for now because we hadn't fully decided the default styling for the indicators.
	         * Once we decide, we will make this a public option or remove it.
	         */
	        _this.createIndicators = false;
	        /**
	         * @internal
	         */
	        _this.accessibilityIdKey = undefined;
	        return _this;
	    }
	    return BubbleLayerOptions;
	}(LayerOptions$1));

	var __extends$M = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter$6 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$6 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$d = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$a = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * Renders Point objects as scalable circles (bubbles).
	 */
	var BubbleLayer = /** @class */ (function (_super) {
	    __extends$M(BubbleLayer, _super);
	    /**
	     * Constructs a new BubbleLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the bubble layer.
	     */
	    function BubbleLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.accessibleIndicator = [];
	        /** @internal */
	        _this._setAccessibleIndicator = function () { return __awaiter$6(_this, void 0, void 0, function () {
	            var renderedShapes, accessibilityIdKey, createIndicator, insertHiddenBefore, insertHiddenInFront, attach;
	            var _this = this;
	            return __generator$6(this, function (_a) {
	                this.accessibleIndicator.forEach(function (indicator) { return indicator.remove(); });
	                this.accessibleIndicator = [];
	                renderedShapes = this.map.layers.getRenderedShapes(this.map.getCamera().bounds, this);
	                accessibilityIdKey = this.options.accessibilityIdKey || (this._getDataSource() ? Shape._shapeIdPropName : undefined);
	                createIndicator = function (renderedShapes, idx) {
	                    var curRenderedShape = renderedShapes[idx];
	                    var bubbleFeature = curRenderedShape instanceof Shape ? curRenderedShape.toJson() : curRenderedShape;
	                    var indicator = new AccessibleIndicator({ positionInSet: idx + 1, setSize: renderedShapes.length });
	                    var element = indicator.getElement();
	                    var _a = __read$d(_this.map.positionsToPixels([_this.getFirstCoordinate(bubbleFeature.geometry.coordinates)]), 1), pixel = _a[0];
	                    element.addEventListener('focusin', function (event) {
	                        _this.accessibleIndicator.filter(function (i) { return i !== indicator; }).forEach(function (indicator) { return indicator.remove(); });
	                        // insert previous and next popups
	                        if (idx - 1 >= 0) {
	                            insertHiddenBefore(indicator, createIndicator(renderedShapes, idx - 1));
	                        }
	                        if (idx + 1 < renderedShapes.length) {
	                            attach(createIndicator(renderedShapes, idx + 1));
	                        }
	                        // if we are on boundaries: add the first / last indicator 
	                        // to maintain indicators on full page navigation cycle
	                        if (idx >= 2 && idx == renderedShapes.length - 1) {
	                            insertHiddenInFront(createIndicator(renderedShapes, 0));
	                        }
	                        if (idx == 0 && renderedShapes.length >= 2) {
	                            attach(createIndicator(renderedShapes, renderedShapes.length - 1));
	                        }
	                        if (accessibilityIdKey !== undefined) {
	                            _this.map._getMap().setPaintProperty(_this.id, 'circle-stroke-color', ['case', ['==', ['get', accessibilityIdKey], bubbleFeature.properties[accessibilityIdKey]], '#000000', _this.options.strokeColor]);
	                        }
	                        var focusEvent = {
	                            target: element,
	                            type: 'focusin',
	                            map: _this.map,
	                            shape: curRenderedShape,
	                            originalEvent: event,
	                            pixel: pixel
	                        };
	                        _this._invokeEvent('focusin', focusEvent);
	                    });
	                    element.addEventListener('focusout', function (event) {
	                        if (accessibilityIdKey !== undefined) {
	                            _this.map._getMap().setPaintProperty(_this.id, 'circle-stroke-color', ['case', ['==', ['get', accessibilityIdKey], bubbleFeature.properties[accessibilityIdKey]], _this.options.strokeColor, _this.options.strokeColor]);
	                        }
	                        var focusEvent = {
	                            target: element,
	                            type: 'focusout',
	                            map: _this.map,
	                            shape: curRenderedShape,
	                            originalEvent: event,
	                            pixel: pixel
	                        };
	                        _this._invokeEvent('focusout', focusEvent);
	                    });
	                    _this.accessibleIndicator.push(indicator);
	                    return indicator;
	                };
	                insertHiddenBefore = function (base, toInsert) {
	                    toInsert.attach(_this.map);
	                    var elementToSwapIn = toInsert.getElement();
	                    var baseElement = base.getElement();
	                    baseElement.parentElement.insertBefore(elementToSwapIn, baseElement);
	                };
	                insertHiddenInFront = function (toInsert) {
	                    toInsert.attach(_this.map);
	                    var elementToSwapIn = toInsert.getElement();
	                    var parent = elementToSwapIn.parentElement;
	                    parent.insertBefore(elementToSwapIn, parent.firstElementChild);
	                };
	                attach = function (popup) {
	                    popup.attach(_this.map);
	                };
	                if (renderedShapes.length > 0) {
	                    attach(createIndicator(renderedShapes, 0));
	                }
	                if (renderedShapes.length > 1) {
	                    attach(createIndicator(renderedShapes, renderedShapes.length - 1));
	                }
	                return [2 /*return*/];
	            });
	        }); };
	        _this.options = new BubbleLayerOptions().merge(cloneDeepWith$1(options, BubbleLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the bubble layer.
	     */
	    BubbleLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, BubbleLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    BubbleLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the bubble layer.
	     * @param newOptions The new options of the bubble layer.
	     */
	    BubbleLayer.prototype.setOptions = function (options) {
	        var newOptions = new BubbleLayerOptions().merge(this.options, cloneDeepWith$1(options, BubbleLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("circle-blur", newOptions.blur, this.options.blur);
	            this._updatePaintProperty("circle-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("circle-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("circle-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("circle-stroke-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("circle-stroke-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("circle-stroke-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("circle-pitch-alignment", newOptions.pitchAlignment, this.options.pitchAlignment);
	        }
	        this.options = newOptions;
	    };
	    BubbleLayer.prototype.onAdd = function (map) {
	        var _this = this;
	        _super.prototype.onAdd.call(this, map);
	        if (this.options.createIndicators) {
	            // Wait for map idle for the first time to ensure `layer.getRenderedShapes` return correct shapes.
	            map.events.addOnce('idle', this._setAccessibleIndicator);
	            // The rendered shapes may be changed when map is moved. Update the indicators when map is moved.
	            map.events.add('moveend', this._setAccessibleIndicator);
	            var dataSource = this._getDataSource();
	            if (dataSource) {
	                // The rendered shapes may be changed when data is added. Update the indicators when data is added.
	                map.events.add('dataadded', dataSource, function () {
	                    // Wait for map idle to ensure `layer.getRenderedShapes` return correct shapes.
	                    map.events.addOnce('idle', _this._setAccessibleIndicator);
	                });
	            }
	            else {
	                var sourceId_1 = typeof this.options.source === 'string' ? this.options.source : this.options.source.getId();
	                map.events.add('sourcedata', function (mapDataEvent) {
	                    var _a;
	                    // There's chances that mapDataEvent.isSourceLoaded doesn't update correctly when using flyTo, thus we check by using map.isSourceLoaded.
	                    if (((_a = mapDataEvent.source) === null || _a === void 0 ? void 0 : _a.getId()) === sourceId_1 && map._getMap().isSourceLoaded(sourceId_1)) {
	                        // Source event will be fired multiple times, and we are only interested when the source is loaded.
	                        // Thus design a cache key that only changed when camera & style properties are changed.
	                        var curCacheKey = _this._getSourceDataEventCacheKey();
	                        if (curCacheKey !== _this.sourceDataEventCacheKey) {
	                            _this._setAccessibleIndicator();
	                            _this.sourceDataEventCacheKey = curCacheKey;
	                        }
	                    }
	                });
	            }
	        }
	    };
	    BubbleLayer.prototype.onRemove = function () {
	        if (this.options.createIndicators) {
	            this.map.events.remove('idle', this._setAccessibleIndicator);
	            this.map.events.remove('moveend', this._setAccessibleIndicator);
	            var dataSource = this._getDataSource();
	            if (dataSource) {
	                this.map.events.remove('dataadded', dataSource, this._setAccessibleIndicator);
	            }
	            else {
	                this.map.events.remove('sourcedata', this._setAccessibleIndicator);
	            }
	        }
	        _super.prototype.onRemove.call(this);
	    };
	    BubbleLayer.prototype._getSourceDataEventCacheKey = function () {
	        if (!this.map) {
	            return undefined;
	        }
	        var mapConfiguration = this.map.getServiceOptions().mapConfiguration;
	        return __spreadArray$a(__spreadArray$a([], __read$d(this.map.getCamera().bounds), false), [
	            this.map.getCamera().zoom,
	            this.map.getCamera().pitch,
	            this.map.getStyle().style,
	            mapConfiguration instanceof Object ? mapConfiguration.id : mapConfiguration
	        ], false).join(',');
	    };
	    BubbleLayer.prototype._getDataSource = function () {
	        var source = typeof this.options.source === 'string' ? this.map.sources.getById(this.options.source) : this.options.source;
	        if (source instanceof DataSource) {
	            return source;
	        }
	        return undefined;
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "circle",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "circle-color": this.options.color,
	                "circle-blur": this.options.blur,
	                "circle-opacity": this.options.opacity,
	                "circle-stroke-color": this.options.strokeColor,
	                "circle-stroke-opacity": this.options.strokeOpacity,
	                "circle-stroke-width": this.options.strokeWidth,
	                "circle-pitch-alignment": this.options.pitchAlignment,
	                "circle-radius": this.options.radius
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    /**
	     * The coordinates can be nested, so we need to get the first coordinate.
	     * @param coordinates The property from the Geometry. Can be Position, Position[], Position[][], etc.
	     * @returns
	     */
	    BubbleLayer.prototype.getFirstCoordinate = function (coordinates) {
	        if (!Array.isArray(coordinates[0])) {
	            return coordinates;
	        }
	        return this.getFirstCoordinate(coordinates[0]);
	    };
	    return BubbleLayer;
	}(Layer));

	var __extends$L = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Point objects in a HeatMapLayer.
	 */
	var HeatMapLayerOptions = /** @class */ (function (_super) {
	    __extends$L(HeatMapLayerOptions, _super);
	    function HeatMapLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies the color gradient used to colorize the pixels in the heatmap.
	         * This is defined using an expression that uses `["heatmap-density"]` as input.
	         * Default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         * @default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         */
	        _this.color = ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0,0, 255,0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"];
	        /**
	         * Similar to `heatmap-weight` but specifies the global heatmap intensity.
	         * The higher this value is, the more ‘weight’ each point will contribute to the appearance.
	         * Default `1`
	         * @default 1
	         */
	        _this.intensity = 1;
	        /**
	         * The opacity at which the heatmap layer will be rendered defined as a number between 0 and 1.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The radius in pixels used to render a data point on the heatmap.
	         * The radius must be a number greater or equal to 1.
	         * Default `30`.
	         * @default 30
	         */
	        _this.radius = 30;
	        /**
	         * Specifies how much an individual data point contributes to the heatmap.
	         * Must be a number greater than 0. A value of 5 would be equivalent to having 5 points of weight 1 in the same spot.
	         * This is useful when clustering points to allow heatmap rendering or large datasets.
	         * Default `1`
	         * @default 1
	         */
	        _this.weight = 1;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HeatMapLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	        else {
	            return undefined;
	        }
	    };
	    return HeatMapLayerOptions;
	}(LayerOptions$1));

	var __extends$K = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represent the density of data using different colors (HeatMap).
	 */
	var HeatMapLayer = /** @class */ (function (_super) {
	    __extends$K(HeatMapLayer, _super);
	    /**
	     * Constructs a new HeatMapLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the heat map layer.
	     */
	    function HeatMapLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new HeatMapLayerOptions().merge(cloneDeepWith$1(options, HeatMapLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the heat map layer.
	     */
	    HeatMapLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, HeatMapLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    HeatMapLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the heat map layer.
	     * @param newOptions The new options of the heat map layer.
	     */
	    HeatMapLayer.prototype.setOptions = function (options) {
	        var newOptions = new HeatMapLayerOptions().merge(this.options, cloneDeepWith$1(options, HeatMapLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("heatmap-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("heatmap-intensity", newOptions.intensity, this.options.intensity);
	            this._updatePaintProperty("heatmap-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("heatmap-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("heatmap-weight", newOptions.weight, this.options.weight);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "heatmap",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "heatmap-color": this.options.color,
	                "heatmap-intensity": this.options.intensity,
	                "heatmap-opacity": this.options.opacity,
	                "heatmap-radius": this.options.radius,
	                "heatmap-weight": this.options.weight,
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return HeatMapLayer;
	}(Layer));

	var __extends$J = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering canvas, image, raster tile, and video layers
	 */
	var MediaLayerOptions = /** @class */ (function (_super) {
	    __extends$J(MediaLayerOptions, _super);
	    function MediaLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A number between -1 and 1 that increases or decreases the contrast of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.contrast = 0;
	        /**
	         * The duration in milliseconds of a fade transition when a new tile is added.
	         * Must be greater or equal to 0.
	         * Default `300`.
	         * @default 300
	         */
	        _this.fadeDuration = 300;
	        /**
	         * Rotates hues around the color wheel.
	         * A number in degrees.
	         * Default `0`.
	         * @default 0
	         */
	        _this.hueRotation = 0;
	        /**
	         * A number between 0 and 1 that increases or decreases the maximum brightness of the overlay.
	         * Default `1`.
	         * @default 1
	         */
	        _this.maxBrightness = 1;
	        /**
	         * A number between 0 and 1 that increases or decreases the minimum brightness of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minBrightness = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the overlay will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * A number between -1 and 1 that increases or decreases the saturation of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.saturation = 0;
	        return _this;
	    }
	    return MediaLayerOptions;
	}(LayerOptions$1));

	var __extends$I = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Point objects in a ImageLayer.
	 */
	var ImageLayerOptions = /** @class */ (function (_super) {
	    __extends$I(ImageLayerOptions, _super);
	    function ImageLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * URL to an image to overlay. Images hosted on other domains must have CORs enabled.
	         */
	        _this.url = undefined;
	        /**
	         * An array of positions for the corners of the image listed in clockwise order: [top left, top right, bottom right, bottom left].
	         */
	        _this.coordinates = undefined;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ImageLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	        else {
	            return undefined;
	        }
	    };
	    return ImageLayerOptions;
	}(MediaLayerOptions));

	var __extends$H = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Abstract class for other layer classes which have to build sources.
	 * @internal
	 */
	var SourceBuildingLayer = /** @class */ (function (_super) {
	    __extends$H(SourceBuildingLayer, _super);
	    function SourceBuildingLayer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @internal
	     */
	    SourceBuildingLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        ids.add(this._getSourceId());
	        return ids;
	    };
	    SourceBuildingLayer.prototype.onAdd = function (map) {
	        _super.prototype.onAdd.call(this, map);
	    };
	    return SourceBuildingLayer;
	}(Layer));

	var __extends$G = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Overlays an image on the map with each corner anchored to a coordinate on the map. Also known as a ground or image overlay.
	 */
	var ImageLayer = /** @class */ (function (_super) {
	    __extends$G(ImageLayer, _super);
	    /**
	     * Constructs a new ImageLayer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the image layer.
	     */
	    function ImageLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        _this.isLoading = false;
	        _this.options = new ImageLayerOptions().merge(cloneDeepWith$1(options, ImageLayerOptions._cloneCustomizer));
	        _this.img = new Image();
	        _this.reloadImage();
	        return _this;
	    }
	    /**
	     * Gets the options of the image layer.
	     */
	    ImageLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, ImageLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the image layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    ImageLayer.prototype.setOptions = function (options) {
	        var newOptions = new ImageLayerOptions().merge(this.options, cloneDeepWith$1(options, ImageLayerOptions._cloneCustomizer));
	        var reloadImageTransform = (typeof options.url === "string" && options.url !== this.getOptions().url);
	        var coordChanged = (typeof options.coordinates !== "undefined" && options.coordinates !== this.getOptions().coordinates);
	        if (this.map) {
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	            // TODO: the mapbox typing file doesn't support maplibregl.ImageSource.updateImage()
	            // update "as any" to "as maplibregl.ImageSource" after the typing file is updated
	            var source = this.map._getMap().getSource(this._getSourceId());
	            if (source) {
	                source.updateImage(newOptions);
	            }
	        }
	        this.options = newOptions;
	        // Modified to update transform if image url or coordinates change
	        if (reloadImageTransform) {
	            this.reloadImage();
	        }
	        else if (coordChanged) {
	            this.updateTransform();
	        }
	    };
	    /**
	     * Calculates the approximate positions that align with the provided pixels from the source image.
	     * @param pixels the provided pixels from the source image used to calculate the positions
	     */
	    ImageLayer.prototype.getPositions = function (pixels) {
	        return this.transform.then(function (t) {
	            return t.toTarget(pixels);
	        });
	    };
	    /**
	     * Calculates the approximate pixels on the source image that align with the provided positions.
	     * @param positions the provided positions from the source image used to calculate the pixels
	     */
	    ImageLayer.prototype.getPixels = function (positions) {
	        return this.transform.then(function (t) {
	            return t.toSource(positions);
	        });
	    };
	    /**
	     * Calculates the approximate corner coordinates for an image based on the image width, height and by calculating an affine transform from a set of source pixels in the image and a set of target positions that are related.
	     * The same number of source and target values must be provided as reference points. It is recommended to provide atleast 3 reference points.
	     * @param imgWidth image width
	     * @param imgHeight image height
	     * @param source a set of source pixels
	     * @param target target positions
	     */
	    ImageLayer.getCoordinatesFromRefPoints = function (imgWidth, imgHeight, source, target) {
	        var transform = new AffineTransform(source, target);
	        return transform.toTarget([
	            [0, 0],
	            [imgWidth, 0],
	            [imgWidth, imgHeight],
	            [0, imgHeight]
	        ]);
	    };
	    /**
	     * Calculates coordinates for a rotated image layer when provided with the bounding box edges and rotation value.
	     * Note: If your rotation value is from a KML Ground Overlay it will need to be converted to a clockwise rotation using the following formula: `rotation = 360 – KmlRotation`
	     * @param north The north edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param west The west edge of the bounding box.
	     * @param rotation Clockwise rotation in degrees
	     */
	    ImageLayer.getCoordinatesFromEdges = function (north, south, east, west, rotation) {
	        if (typeof rotation !== "number") {
	            rotation = 0;
	        }
	        // [minLon, minLat, maxLon, maxLat]
	        var bounds = [
	            Math.min(west, east),
	            south,
	            Math.max(west, east),
	            north
	        ];
	        // Calculate the center of the bounding box and use that as the rotation origin.
	        var origin = BoundingBox.getCenter(bounds);
	        // Calculate the corner coordinates of the bounding box.
	        var topLeft = BoundingBox.getNorthWest(bounds);
	        var topRight = BoundingBox.getNorthEast(bounds);
	        var bottomRight = BoundingBox.getSouthEast(bounds);
	        var bottomLeft = BoundingBox.getSouthWest(bounds);
	        // Calcuate to rotated corners of the bounding box.
	        return rotatePositions([
	            topLeft,
	            topRight,
	            bottomRight,
	            bottomLeft
	        ], origin, rotation);
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "raster",
	            source: this._getSourceId(),
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "raster-opacity": this.options.opacity,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-saturation": this.options.saturation,
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the imge source to include with the layer.
	     * @internal
	     */
	    ImageLayer.prototype._buildSource = function () {
	        return {
	            type: "image",
	            url: this.options.url,
	            coordinates: this.options.coordinates
	        };
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    ImageLayer.prototype._getSourceId = function () {
	        return "".concat(this.getId(), "-ImageSource");
	    };
	    ImageLayer.prototype.reloadImage = function () {
	        var _this = this;
	        if (this.options.url) {
	            this.transform = new Promise(function (resolve, reject) {
	                _this.img.onload = function () {
	                    var corners = [[0, 0], [_this.img.width, 0], [_this.img.width, _this.img.height], [0, _this.img.height]];
	                    resolve(new AffineTransform(corners, _this.options.coordinates));
	                    _this.isLoading = false;
	                };
	                _this.img.onerror = _this.img.onabort = function () {
	                    reject("Failed to load image");
	                };
	                _this.isLoading = true;
	                _this.img.src = _this.options.url;
	            });
	        }
	    };
	    ImageLayer.prototype.updateTransform = function () {
	        if (!this.isLoading) {
	            var corners = [[0, 0], [this.img.width, 0], [this.img.width, this.img.height], [0, this.img.height]];
	            this.transform = Promise.resolve(new AffineTransform(corners, this.options.coordinates));
	        }
	    };
	    ImageLayer.prototype._getSourceWrapper = function () {
	        var sourceId = this._getSourceId();
	        var source = this._buildSource();
	        return new ImageSource(sourceId, source);
	    };
	    return ImageLayer;
	}(SourceBuildingLayer));

	var __extends$F = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering SimpleLine, SimplePolygon, CirclePolygon,
	 * LineString, MultiLineString, Polygon, and MultiPolygon objects in a line layer.
	 */
	var LineLayerOptions = /** @class */ (function (_super) {
	    __extends$F(LineLayerOptions, _super);
	    function LineLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies how the ends of the lines are rendered.<br />
	         * `"butt"`: A cap with a squared-off end which is drawn to the exact endpoint of the line.<br />
	         * `"round"`: A cap with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.<br />
	         * `"square"`: A cap with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the line width.<br />
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineCap = "round";
	        /**
	         * Specifies how the joints in the lines are rendered.<br />
	         * `"bevel"`: A join with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the lines width.<br />
	         * `"round"`: A join with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.<br />
	         * `"miter"`: A join with a sharp, angled corner which is drawn with the outer sides
	         * beyond the endpoint of the path until they meet.<br />
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineJoin = "round";
	        /**
	         * The amount of blur to apply to the line in pixels.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * Specifies the color of the line.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.strokeColor = "#1E90FF";
	        /**
	         * Specifies the lengths of the alternating dashes and gaps that form the dash pattern.
	         * Numbers must be equal or greater than 0. The lengths are scaled by the strokeWidth.
	         * To convert a dash length to pixels, multiply the length by the current stroke width.
	         */
	        _this.strokeDashArray = undefined;
	        /**
	         * Defines a gradient with which to color the lines.
	         * Requires the DataSource lineMetrics option to be set to true.
	         * Disabled if strokeDashArray is set.
	         */
	        _this.strokeGradient = undefined;
	        /**
	         * The line's offset.
	         * A positive value offsets the line to the right, relative to the direction of the line.
	         * A negative value offsets to the left.
	         * Default `0`.
	         * @default 0
	         */
	        _this.offset = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the line will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The amount of offset in pixels to render the line relative to where it would render normally.
	         * Negative values indicate left and up.
	         * Default: `[0,0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.<br />
	         * `"map"`: Lines are translated relative to the map.<br />
	         * `"viewport"`: Lines are translated relative to the viewport<br />
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * The width of the line in pixels. Must be a value greater or equal to 0.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        return _this;
	    }
	    return LineLayerOptions;
	}(LayerOptions$1));

	var __extends$E = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$b = (window && window.__assign) || function () {
	    __assign$b = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$b.apply(this, arguments);
	};
	/**
	 * Renders line data on the map. Can be used with SimpleLine, SimplePolygon,
	 * CirclePolygon, LineString, MultiLineString, Polygon, and MultiPolygon objects.
	 */
	var LineLayer = /** @class */ (function (_super) {
	    __extends$E(LineLayer, _super);
	    /**
	     * Constructs a new LineLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the line layer.
	     */
	    function LineLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new LineLayerOptions().merge(cloneDeepWith$1(options, LineLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the line layer.
	     */
	    LineLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, LineLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    LineLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the line layer.
	     * @param options The new options of the line layer.
	     */
	    LineLayer.prototype.setOptions = function (options) {
	        var newOptions = new LineLayerOptions().merge(this.options, cloneDeepWith$1(options, LineLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("line-blur", newOptions.blur, this.options.blur);
	            this._updateLayoutProperty("line-cap", newOptions.lineCap, this.options.lineCap);
	            this._updateLayoutProperty("line-join", newOptions.lineJoin, this.options.lineJoin);
	            this._updatePaintProperty("line-offset", newOptions.offset, this.options.offset);
	            this._updatePaintProperty("line-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("line-dasharray", newOptions.strokeDashArray, this.options.strokeDashArray);
	            this._updatePaintProperty("line-gradient", newOptions.strokeGradient, this.options.strokeGradient);
	            this._updatePaintProperty("line-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("line-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("line-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("line-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._buildLayers = function () {
	        var layer = __assign$b(__assign$b(__assign$b(__assign$b({ id: this.id, type: "line" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	                "line-cap": this.options.lineCap,
	                "line-join": this.options.lineJoin
	            }, paint: __assign$b(__assign$b(__assign$b({ "line-blur": this.options.blur, "line-color": this.options.strokeColor }, (this.options.strokeDashArray ? { "line-dasharray": this.options.strokeDashArray } : {})), (this.options.strokeGradient ? { "line-gradient": this.options.strokeGradient } : {})), { "line-offset": this.options.offset, "line-opacity": this.options.strokeOpacity, "line-translate": this.options.translate, "line-translate-anchor": this.options.translateAnchor, "line-width": this.options.strokeWidth }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return LineLayer;
	}(Layer));

	var __extends$D = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering `Polygon` and `MultiPolygon` objects in a `PolygonExtrusionLayer`.
	 */
	var PolygonExtrusionLayerOptions = /** @class */ (function (_super) {
	    __extends$D(PolygonExtrusionLayerOptions, _super);
	    function PolygonExtrusionLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The height in meters to extrude the base of this layer.
	         * This height is relative to the ground.
	         * Must be greater or equal to 0 and less than or equal to `height`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.base = 0;
	        /**
	         * The color to fill the polygons with.
	         * Ignored if `fillPattern` is set.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * The height in meters to extrude this layer.
	         * This height is relative to the ground.
	         * Must be a number greater or equal to 0.
	         * Default `0`
	         * @default 0
	         */
	        _this.height = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.fillOpacity = 1;
	        /**
	         * Name of image in sprite to use for drawing image fills.
	         * For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        /**
	         * The polygons' pixel offset.
	         * Values are [x, y] where negatives indicate left and up, respectively.
	         * Default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.<br />
	         * `"map"`: Polygons are translated relative to the map.<br />
	         * `"viewport"`: Polygons are translated relative to the viewport.<br />
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * Specifies if the polygon should have a vertical gradient on the sides of the extrusion.
	         * Default: `true`
	         * @default true
	         */
	        _this.verticalGradient = true;
	        return _this;
	    }
	    return PolygonExtrusionLayerOptions;
	}(LayerOptions$1));

	var __extends$C = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$a = (window && window.__assign) || function () {
	    __assign$a = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$a.apply(this, arguments);
	};
	/**
	 * Renders extruded filled `Polygon` and `MultiPolygon` objects on the map.
	 */
	var PolygonExtrusionLayer = /** @class */ (function (_super) {
	    __extends$C(PolygonExtrusionLayer, _super);
	    /**
	     * Constructs a new PolygonExtrusionLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon extrusion layer.
	     */
	    function PolygonExtrusionLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonExtrusionLayerOptions().merge(cloneDeepWith$1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, PolygonExtrusionLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonExtrusionLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonExtrusionLayerOptions().merge(this.options, cloneDeepWith$1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-extrusion-base", newOptions.base, this.options.base);
	            this._updatePaintProperty("fill-extrusion-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-extrusion-height", newOptions.height, this.options.height);
	            this._updatePaintProperty("fill-extrusion-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-extrusion-pattern", newOptions.fillPattern, this.options.fillPattern);
	            this._updatePaintProperty("fill-extrusion-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("fill-extrusion-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	            this._updatePaintProperty("fill-extrusion-vertical-gradient", newOptions.verticalGradient, this.options.verticalGradient);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._buildLayers = function () {
	        var layer = __assign$a(__assign$a(__assign$a(__assign$a({ id: this.id, type: "fill-extrusion" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	            }, paint: __assign$a(__assign$a({ "fill-extrusion-base": this.options.base, "fill-extrusion-height": this.options.height, "fill-extrusion-opacity": this.options.fillOpacity }, (this.options.fillPattern ?
	                { "fill-extrusion-pattern": this.options.fillPattern } :
	                { "fill-extrusion-color": this.options.fillColor })), { "fill-extrusion-translate": this.options.translate, "fill-extrusion-translate-anchor": this.options.translateAnchor, "fill-extrusion-vertical-gradient": this.options.verticalGradient }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonExtrusionLayer;
	}(Layer));

	var __extends$B = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Polygon and MultiPolygon objects in a PolygonLayer.
	 */
	var PolygonLayerOptions$1 = /** @class */ (function (_super) {
	    __extends$B(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the polygons with.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `0.5`.
	         * @default 0.5
	         */
	        _this.fillOpacity = 0.5;
	        /**
	         * Name of image in sprite to use for drawing image fills. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        /**
	         * Whether or not the fill should be antialiased.
	         * Default `true`.
	         * @default true
	         */
	        _this.fillAntialias = true;
	        return _this;
	    }
	    return PolygonLayerOptions;
	}(LayerOptions$1));

	var __extends$A = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Renders filled Polygon and MultiPolygon objects on the map.
	 */
	var PolygonLayer = /** @class */ (function (_super) {
	    __extends$A(PolygonLayer, _super);
	    /**
	     * Constructs a new PolygonLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function PolygonLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonLayerOptions$1().merge(cloneDeepWith$1(options, PolygonLayerOptions$1._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, PolygonLayerOptions$1._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * When `fillPattern` is set, `fillColor` will be ignored.
	     * To set `fillColor`, make sure `fillPattern` is set to `undefined`.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonLayerOptions$1().merge(this.options, cloneDeepWith$1(options, PolygonLayerOptions$1._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-pattern", newOptions.fillPattern, this.options.fillPattern);
	            this._updatePaintProperty("fill-antialias", newOptions.fillAntialias, this.options.fillAntialias);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "fill",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "fill-opacity": this.options.fillOpacity,
	                "fill-antialias": this.options.fillAntialias,
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        // The property fill-pattern should only be set if there is a value for fillPattern.
	        // The property fill-color should only be set if fill-pattern isn't.
	        if (this.options.fillPattern) {
	            layer.paint["fill-pattern"] = this.options.fillPattern;
	        }
	        else {
	            layer.paint["fill-color"] = this.options.fillColor;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonLayer;
	}(Layer));

	var __extends$z = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used to customize the icons in a SymbolLayer
	 */
	var IconOptions = /** @class */ (function (_super) {
	    __extends$z(IconOptions, _super);
	    function IconOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the symbol icon can overlay other symbols on the map.
	         * If `true` the icon will be visible even if it collides with other previously drawn symbols.
	         * Tip: Set this to true if animating an symbol to ensure smooth rendering.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.<br />
	         * `"center"`: The center of the icon is placed closest to the anchor.<br />
	         * `"left"`: The left side of the icon is placed closest to the anchor.<br />
	         * `"right"`: The right side of the icon is placed closest to the anchor.<br />
	         * `"top"`: The top of the icon is placed closest to the anchor.<br />
	         * `"bottom"`: The bottom of the icon is placed closest to the anchor.<br />
	         * `"top-left"`: The top left corner of the icon is placed closest to the anchor.<br />
	         * `"top-right"`: The top right corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.<br />
	         * Default `"bottom"`.
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * Specifies if other symbols can overlap this symbol.
	         * If true, other symbols can be visible even if they collide with the icon.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * The name of the image in the map's image sprite to use for drawing the icon.
	         * Available built-in images are: `marker-black`, `marker-blue`, `marker-darkblue`,
	         * `marker-red`, `marker-yellow`, `pin-blue`, `pin-darkblue`, `pin-red`, `pin-round-blue`,
	         * `pin-round-darkblue`, `pin-round-red`.
	         * Default `"marker-blue"`.
	         * @default "marker-blue"
	         */
	        _this.image = "marker-blue";
	        /**
	         * Specifies an offset distance of the icon from its anchor in pixels.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Each component is multiplied by the value of size to obtain the final offset in pixels.
	         * When combined with rotation the offset will be as if the rotated direction was up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if a symbols icon can be hidden but its text displayed if it is overlapped with another symbol.
	         * If true, text will display without their corresponding icons
	         * when the icon collides with other symbols and the text does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Size of the additional area around the icon bounding box used for detecting symbol collisions.
	         * Default `2`.
	         * @default 2
	         */
	        _this.padding = 2;
	        /**
	         * Specifies the orientation of the icon when the map is pitched.<br />
	         * `"auto"`: Automatically matches the value of `rotationAlignment`.<br />
	         * `"map"`: The icon is aligned to the plane of the map.<br />
	         * `"viewport"`: The icon is aligned to the plane of the viewport<br />
	         * Default `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * The amount to rotate the icon clockwise in degrees
	         * Default `0`.
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the placement property of a SymbolLayerOptions
	         * this determines the rotation behavior of icons.<br />
	         * `"auto"`: When placement is "point" this is equivalent to "viewport".
	         * When placement is "line" this is equivalent to "map".<br />
	         * `"map"`: When placement is "point" aligns icons east-west.
	         * When placement is "line" aligns the icons' x-axes with the line.<br />
	         * `"viewport"`: Icons' x-axes will align with the x-axis of the viewport.<br />
	         * Default `"auto"`.
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * Scales the original size of the icon by the provided factor.
	         * Must be greater or equal to 0.
	         * Default `1`.
	         * @default 1
	         */
	        _this.size = 1;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the icon will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return IconOptions;
	}(Options));

	var __extends$y = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used to customize the text in a SymbolLayer
	 */
	var TextOptions = /** @class */ (function (_super) {
	    __extends$y(TextOptions, _super);
	    function TextOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the text will be visible if it collides with other symbols.
	         * If true, the text will be visible even if it collides with other previously drawn symbols.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.<br />
	         * `"center"`: The center of the icon is placed closest to the anchor.<br />
	         * `"left"`: The left side of the icon is placed closest to the anchor.<br />
	         * `"right"`: The right side of the icon is placed closest to the anchor.<br />
	         * `"top"`: The top of the icon is placed closest to the anchor.<br />
	         * `"bottom"`: The bottom of the icon is placed closest to the anchor.<br />
	         * `"top-left"`: The top left corner of the icon is placed closest to the anchor.<br />
	         * `"top-right"`: The top right corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.<br />
	         * Default `"center"`.
	         * @default "center"
	         */
	        _this.anchor = "center";
	        /**
	         * Specifies the name of a property on the features to use for a text label.
	         */
	        _this.textField = undefined;
	        /**
	         * The font stack to use for displaying text.
	         * Possible values: `"SegoeFrutigerHelveticaMYingHei-Bold"`, `"SegoeFrutigerHelveticaMYingHei-Medium"`,
	         * `"SegoeFrutigerHelveticaMYingHei-Regular"`, `"SegoeUi-Bold"`, `"SegoeUi-Light"`, `"SegoeUi-Regular"`,
	         * `"SegoeUi-SemiBold"`, `"SegoeUi-SemiLight"`, `"SegoeUi-SymbolRegular"`, `"StandardCondensedSegoeUi-Black"`,
	         * `"StandardCondensedSegoeUi-Bold"`, `"StandardCondensedSegoeUi-Light"`, `"StandardCondensedSegoeUi-Regular"`,
	         * `"StandardFont-Black"`, `"StandardFont-Bold"`, `"StandardFont-Light"`, `"StandardFont-Regular"`,
	         * `"StandardFontCondensed-Black"`, `"StandardFontCondensed-Bold"`, `"StandardFontCondensed-Light"`,
	         * `"StandardFontCondensed-Regular"`.
	         * Default `["StandardFont-Regular"]`.
	         * @default ["StandardFont-Regular"]
	         */
	        _this.font = ["StandardFont-Regular"];
	        /**
	         * Specifies if the other symbols are allowed to collide with the text.
	         * If true, other symbols can be visible even if they collide with the text.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * Text justification options.<br />
	         * `"auto"`: The text is aligned towards the anchor position.<br />
	         * `"left"`: The text is aligned to the left.<br />
	         * `"center"`: The text is centered.<br />
	         * `"right"`: The text is aligned to the right.<br />
	         * Default `"center"`.
	         * @default "center"
	         */
	        _this.justify = "center";
	        /**
	         * Specifies an offset distance of the icon from its anchor in ems.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if the text can be hidden if it is overlapped by another symbol.
	         * If true, icons will display without their corresponding text
	         * when the text collides wit other symbols and the icon does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Size of the additional area around the text bounding box used for detecting
	         * symbol collisions.
	         * Default `2`.
	         * @default 2
	         */
	        _this.padding = 2;
	        /**
	         * Specifies the orientation of the text when the map is pitched.<br />
	         * `"auto"`: Automatically matches the value of `rotationAlignment`.<br />
	         * `"map"`: The text is aligned to the plane of the map.<br />
	         * `"viewport"`: The text is aligned to the plane of the viewport.<br />
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * Radial offset of text, in the direction of the symbol's anchor. Useful in combination
	         * with `variableAnchor`, which defaults to using the two-dimensional `offset` if present.
	         * Default: `undefined`
	         * @default undefined
	         */
	        _this.radialOffset = undefined;
	        /**
	         * The amount to rotate the text clockwise in degrees.
	         * Default `0`
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the `placement` property of the `SymbolLayerOptions`,
	         * specifies the rotation behavior of the individual glyphs forming the text.<br />
	         * `"auto"`: When the `placement` is set to `"point"`, this is equivalent to `"map"`.
	         * When the `placement` is set to `"line"` this is equivalent to `"map"`.<br />
	         * `"map"`: When the `placement` is set to `"point"`, aligns text east-west.
	         * When the `placement` is set to `"line"`, aligns text x-axes with the line.<br />
	         * `"viewport"`: Produces glyphs whose x-axes are aligned with the x-axis of the viewport,
	         * regardless of the value of `placement`.<br />
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * List of potential anchor locations, to increase the chance of placing high-priority
	         * labels on the map. The renderer will attempt to place the label at each location,
	         * in order, before moving onto the next label. Use `justify: "auto"` to choose text
	         * justification based on anchor position. To apply an offset use the `radialOffset` or
	         * two-dimensional `offset` options.<br />
	         * `"center"`: The center of the icon is placed closest to the anchor.<br />
	         * `"left"`: The left side of the icon is placed closest to the anchor.<br />
	         * `"right"`: The right side of the icon is placed closest to the anchor.<br />
	         * `"top"`: The top of the icon is placed closest to the anchor.<br />
	         * `"bottom"`: The bottom of the icon is placed closest to the anchor.<br />
	         * `"top-left"`: The top left corner of the icon is placed closest to the anchor.<br />
	         * `"top-right"`: The top right corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.<br />
	         * Default: `undefined`
	         * @default undefined
	         */
	        _this.variableAnchor = undefined;
	        /**
	         * The size of the font in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `16`.
	         * @default 16
	         */
	        _this.size = 16;
	        /**
	         * The color of the text.
	         * Default `"#000000"`.
	         * @default "#000000"
	         */
	        _this.color = "#000000";
	        /**
	         * The halo's fadeout distance towards the outside in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloBlur = 0;
	        /**
	         * The color of the text's halo, which helps it stand out from backgrounds.
	         * Default `"rgba(0,0,0,0)"`.
	         * @default "rgba(0,0,0,0)"
	         */
	        _this.haloColor = "rgba(0,0,0,0)";
	        /**
	         * The distance of the halo to the font outline in pixels.
	         * Must be a number greater or equal to 0.
	         * The maximum text halo width is 1/4 of the font size.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloWidth = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the text will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return TextOptions;
	}(Options));

	var __extends$x = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering geometries in a SymbolLayer.
	 */
	var SymbolLayerOptions = /** @class */ (function (_super) {
	    __extends$x(SymbolLayerOptions, _super);
	    function SymbolLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Options used to customize the icons of the symbols.
	         * @see IconOptions for defaults.
	         */
	        _this.iconOptions = new IconOptions();
	        /**
	         * Options used to customize the text of the symbols.
	         * @see TextOptions for defaults.
	         */
	        _this.textOptions = new TextOptions();
	        /**
	         * Specifies the label placement relative to its geometry.<br />
	         * `"point"`: The label is placed at the point where the geometry is located.<br />
	         * `"line"`: The label is placed along the line of the geometry.
	         * Can only be used on LineString and Polygon geometries.<br />
	         *  `"line-center"`: The label is placed at the center of the line of the geometry.
	         * Can only be used on `LineString` and `Polygon` geometries <br />
	         * Default `"point"`.
	         * @default "point"
	         */
	        _this.placement = "point";
	        /**
	         * Sorts features in ascending order based on this value. Features with
	         * lower sort keys are drawn and placed first.
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.sortKey = undefined;
	        /**
	         * Determines whether overlapping symbols in the same layer are rendered in the order
	         * that they appear in the data source, or by their y position relative to the viewport.
	         * To control the order and prioritization of symbols otherwise, use `sortKey`.<br />
	         * `"auto"`: Sorts symbols by `sortKey` if set. Otherwise behaves like `"viewport-y"`.<br />
	         * `"viewport-y"`: Sorts symbols by their y position if `allowOverlap` is `true` or
	         * if `ignorePlacement` is `false`.<br />
	         * `"source"`: Sorts symbols by `sortKey` if set. Otherwise, symbols are rendered in the
	         * same order as the source data.<br />
	         * Default `"auto"`
	         * @default "auto"
	         */
	        _this.zOrder = "auto";
	        /**
	         * Distance in pixels between two symbol anchors along a line. Must be greater or equal to 1.
	         * Default `250`.
	         * @default 250
	         */
	        _this.lineSpacing = 250;
	        return _this;
	    }
	    return SymbolLayerOptions;
	}(LayerOptions$1));

	var __extends$w = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$9 = (window && window.__assign) || function () {
	    __assign$9 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$9.apply(this, arguments);
	};
	/**
	 * Renders point based data as symbols on the map using text and/or icons.
	 * Symbols can also be created for line and polygon data as well.
	 */
	var SymbolLayer = /** @class */ (function (_super) {
	    __extends$w(SymbolLayer, _super);
	    /**
	     * Constructs a new SymbolLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function SymbolLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new SymbolLayerOptions().merge(cloneDeepWith$1(options, SymbolLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the symbol layer.
	     */
	    SymbolLayer.prototype.getOptions = function () {
	        return cloneDeepWith$1(this.options, SymbolLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    SymbolLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the symbol layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    SymbolLayer.prototype.setOptions = function (options) {
	        var newOptions = new SymbolLayerOptions().merge(this.options, cloneDeepWith$1(options, SymbolLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            var thisOpts = this.options;
	            var newIconOpts = newOptions.iconOptions;
	            var thisIconOpts = thisOpts.iconOptions;
	            var newTextOpts = newOptions.textOptions;
	            var thisTextOpts = thisOpts.textOptions;
	            // Symbol options.
	            this._updateBaseProperties(newOptions, thisOpts);
	            this._updateLayoutProperty("symbol-spacing", newOptions.lineSpacing, thisOpts.lineSpacing);
	            this._updateLayoutProperty("symbol-placement", newOptions.placement, thisOpts.placement);
	            this._updateLayoutProperty("symbol-sort-key", newOptions.sortKey, thisOpts.sortKey);
	            // REVIEW: @types/maplibregl-js doesn't show "auto" for "symbol-z-order"
	            this._updateLayoutProperty("symbol-z-order", newOptions.zOrder, thisOpts.zOrder);
	            // Icon options.
	            this._updateLayoutProperty("icon-allow-overlap", newIconOpts.allowOverlap, thisIconOpts.allowOverlap);
	            this._updateLayoutProperty("icon-anchor", newIconOpts.anchor, thisIconOpts.anchor);
	            this._updateLayoutProperty("icon-ignore-placement", newIconOpts.ignorePlacement, thisIconOpts.ignorePlacement);
	            this._updateLayoutProperty("icon-image", newIconOpts.image, thisIconOpts.image);
	            this._updateLayoutProperty("icon-offset", newIconOpts.offset, thisIconOpts.offset);
	            this._updatePaintProperty("icon-opacity", newIconOpts.opacity, thisIconOpts.opacity);
	            this._updateLayoutProperty("icon-optional", newIconOpts.optional, thisIconOpts.optional);
	            this._updateLayoutProperty("icon-padding", newIconOpts.padding, thisIconOpts.padding);
	            this._updateLayoutProperty("icon-pitch-alignment", newIconOpts.pitchAlignment, thisIconOpts.pitchAlignment);
	            this._updateLayoutProperty("icon-rotate", newIconOpts.rotation, thisIconOpts.rotation);
	            this._updateLayoutProperty("icon-rotation-alignment", newIconOpts.rotationAlignment, thisIconOpts.rotationAlignment);
	            this._updateLayoutProperty("icon-size", newIconOpts.size, thisIconOpts.size);
	            // Text options.
	            this._updateLayoutProperty("text-allow-overlap", newTextOpts.allowOverlap, thisTextOpts.allowOverlap);
	            this._updateLayoutProperty("text-anchor", newTextOpts.anchor, thisTextOpts.anchor);
	            this._updatePaintProperty("text-color", newTextOpts.color, thisTextOpts.color);
	            this._updateLayoutProperty("text-font", newTextOpts.font, thisTextOpts.font);
	            this._updateLayoutProperty("text-ignore-placement", newTextOpts.ignorePlacement, thisTextOpts.ignorePlacement);
	            this._updateLayoutProperty("text-justify", newTextOpts.justify, thisTextOpts.justify);
	            this._updatePaintProperty("text-halo-blur", newTextOpts.haloBlur, thisTextOpts.haloBlur);
	            this._updatePaintProperty("text-halo-color", newTextOpts.haloColor, thisTextOpts.haloColor);
	            this._updatePaintProperty("text-halo-width", newTextOpts.haloWidth, thisTextOpts.haloWidth);
	            this._updateLayoutProperty("text-offset", newTextOpts.offset, thisTextOpts.offset);
	            this._updatePaintProperty("text-opacity", newTextOpts.opacity, thisTextOpts.opacity);
	            this._updateLayoutProperty("text-optional", newTextOpts.optional, thisTextOpts.optional);
	            this._updateLayoutProperty("text-padding", newTextOpts.padding, thisTextOpts.padding);
	            this._updateLayoutProperty("text-pitch-alignment", newTextOpts.pitchAlignment, thisTextOpts.pitchAlignment);
	            this._updateLayoutProperty("text-radial-offset", newTextOpts.radialOffset, thisTextOpts.radialOffset);
	            this._updateLayoutProperty("text-rotate", newTextOpts.rotation, thisTextOpts.rotation);
	            this._updateLayoutProperty("text-rotation-alignment", newTextOpts.rotationAlignment, thisTextOpts.rotationAlignment);
	            this._updateLayoutProperty("text-size", newTextOpts.size, thisTextOpts.size);
	            this._updateLayoutProperty("text-variable-anchor", newTextOpts.variableAnchor, thisTextOpts.variableAnchor);
	            this._updateLayoutProperty("text-field", newTextOpts.textField, thisTextOpts.textField);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._buildLayers = function () {
	        var layer = __assign$9(__assign$9(__assign$9(__assign$9({ id: this.id, type: "symbol" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: __assign$9(__assign$9({ visibility: this.options.visible ? "visible" : "none", "symbol-placement": this.options.placement, "symbol-spacing": this.options.lineSpacing, "symbol-z-order": this.options.zOrder, 
	                // Text options.
	                "text-allow-overlap": this.options.textOptions.allowOverlap, "text-anchor": this.options.textOptions.anchor }, (this.options.textOptions.textField && { "text-field": this.options.textOptions.textField })), { "text-font": this.options.textOptions.font, "text-ignore-placement": this.options.textOptions.ignorePlacement, "text-justify": this.options.textOptions.justify, "text-offset": this.options.textOptions.offset, "text-optional": this.options.textOptions.optional, "text-padding": this.options.textOptions.padding, "text-pitch-alignment": this.options.textOptions.pitchAlignment, "text-rotate": this.options.textOptions.rotation, "text-rotation-alignment": this.options.textOptions.rotationAlignment, "text-size": this.options.textOptions.size, 
	                // Icon options.
	                "icon-allow-overlap": this.options.iconOptions.allowOverlap, "icon-anchor": this.options.iconOptions.anchor, "icon-ignore-placement": this.options.iconOptions.ignorePlacement, "icon-image": this.options.iconOptions.image, "icon-offset": this.options.iconOptions.offset, "icon-optional": this.options.iconOptions.optional, "icon-padding": this.options.iconOptions.padding, "icon-pitch-alignment": this.options.iconOptions.pitchAlignment, "icon-rotate": this.options.iconOptions.rotation, "icon-rotation-alignment": this.options.iconOptions.rotationAlignment, "icon-size": this.options.iconOptions.size }), paint: {
	                // Text options.
	                "text-color": this.options.textOptions.color,
	                "text-halo-blur": this.options.textOptions.haloBlur,
	                "text-halo-color": this.options.textOptions.haloColor,
	                "text-halo-width": this.options.textOptions.haloWidth,
	                "text-opacity": this.options.textOptions.opacity,
	                // Icon options.
	                "icon-opacity": this.options.iconOptions.opacity,
	            } }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        // REVIEW: MapLibre throws style validation error if optional properties show up in style
	        // with null/undefined as value.
	        if (typeof this.options.sortKey !== "undefined") {
	            layer.layout["symbol-sort-key"] = this.options.sortKey;
	        }
	        if (typeof this.options.textOptions.radialOffset !== "undefined") {
	            layer.layout["text-radial-offset"] = this.options.textOptions.radialOffset;
	        }
	        if (typeof this.options.textOptions.variableAnchor !== "undefined") {
	            layer.layout["text-variable-anchor"] = this.options.textOptions.variableAnchor;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return SymbolLayer;
	}(Layer));

	var __extends$v = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$8 = (window && window.__assign) || function () {
	    __assign$8 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$8.apply(this, arguments);
	};
	/**
	 * Used to represent the fundamental map source.
	 * @private
	 */
	var FundamentalMapSource = /** @class */ (function (_super) {
	    __extends$v(FundamentalMapSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef The sources entry of the resource file.
	     * @param options The query parameters to add to the urls listed in the resource file.
	     */
	    function FundamentalMapSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = _this._modifySource(sourceDef, options);
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    FundamentalMapSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        var baseEqual = source.type === otherSource.type &&
	            source.url === otherSource.url
	            && ((source.tiles === undefined && otherSource.tiles === undefined) ||
	                (source.tiles && otherSource.tiles && source.tiles.length === otherSource.tiles.length && source.tiles.every(function (value, idx) { return value === otherSource.tiles[idx]; })))
	            && source.minzoom === otherSource.minzoom
	            && source.maxzoom === otherSource.maxzoom
	            && source.bounds === otherSource.bounds
	            && source['attribution'] === otherSource['attribution'];
	        var rasterEqual = source.type !== "raster" || (source.type === "raster"
	            && source.type === otherSource.type
	            && source.tileSize === otherSource.tileSize
	            && source.scheme === otherSource.scheme);
	        var rasterDemEqual = source.type !== "raster-dem" || (source.type === "raster-dem"
	            && source.type === otherSource.type
	            && source.tileSize === otherSource.tileSize
	            && source['encoding'] === otherSource['encoding']);
	        var vectorEqual = source.type !== "vector" || (source.type === "vector"
	            && source.type === otherSource.type
	            && source.promoteId === otherSource.promoteId
	            && source.scheme === otherSource.scheme);
	        return baseEqual && rasterEqual && rasterDemEqual && vectorEqual;
	    };
	    /**
	     * Updates the source info to convert the tiles to url strings.
	     * @param sourceDef The original source info.
	     * @param options The query parameters to add to the tile urls.
	     */
	    FundamentalMapSource.prototype._modifySource = function (sourceDef, options) {
	        if ((sourceDef.type === 'raster' || sourceDef.type === 'raster-dem' || sourceDef.type === 'vector') && sourceDef.tiles) {
	            var tileStrings = sourceDef.tiles.map(function (tile) {
	                if (typeof tile === "string") {
	                    return tile;
	                }
	                var tileUrl = new Url({
	                    domain: constants.domainPlaceHolder,
	                    path: tile.path,
	                    queryParams: __assign$8(__assign$8({}, options), tile.queryParams)
	                });
	                return tileUrl.toString();
	            });
	            sourceDef.tiles = tileStrings;
	        }
	        else if ((sourceDef.type === 'raster' || sourceDef.type === 'raster-dem' || sourceDef.type === 'vector') && sourceDef.url) {
	            sourceDef.url = (typeof sourceDef.url === "string") ?
	                sourceDef.url :
	                new Url({
	                    domain: constants.domainPlaceHolder,
	                    path: sourceDef.url.path,
	                    queryParams: __assign$8(__assign$8({}, options), sourceDef.url.queryParams)
	                }).toString();
	        }
	        else {
	            throw new Error("Source definition must define a TileJSON 'url' or a 'tiles' array.");
	        }
	        return sourceDef;
	    };
	    return FundamentalMapSource;
	}(Source));

	var __extends$u = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering raster tiled images in a TileLayer.
	 */
	var TileLayerOptions = /** @class */ (function (_super) {
	    __extends$u(TileLayerOptions, _super);
	    function TileLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         * Default `[-180, -85.0511, 180, 85.0511]`.
	         * @default [-180, -85.0511, 180, 85.0511]
	         */
	        _this.bounds = [-180, -85.0511, 180, 85.0511];
	        /**
	         * An integer specifying the minimum zoom level in which tiles are available from the tile source.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minSourceZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level in which tiles are available from the tile source.
	         * Default `22`.
	         * @default 22
	         */
	        _this.maxSourceZoom = 22;
	        /**
	         * An integer value that specifies the width and height dimensions of the map tiles.
	         * For a seamless experience, the tile size must be a multiplier of 2.
	         * Default `512`.
	         * @default 512
	         */
	        _this.tileSize = 512;
	        /**
	         * Specifies if the tile systems coordinates uses the Tile Map Services specification,
	         * which reverses the Y coordinate axis.
	         * Default `false`.
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of subdomain values to apply to the tile URL.
	         */
	        _this.subdomains = undefined;
	        /**
	         * A http/https URL to a TileJSON resource or a tile URL template that uses the following parameters:
	         * <p>{x}: X position of the tile. Usually also needs {y} and {z}.</p>
	         * <p>{y}: Y position of the tile. Usually also needs {x} and {z}.</p>
	         * <p>{z}: Zoom level of the tile. Usually also needs {x} and {y}.</p>
	         * <p>{quadkey}: Tile quadKey id based on the Bing Maps tile system naming convention.</p>
	         * <p>{bbox-epsg-3857}: A bounding box string with the format {west},{south},{east},{north}
	         * in the EPSG 4325 Spacial Reference System.</p>
	         * <p>{subdomain}: A placeholder where the subdomain values if specified will be added.</p>
	         */
	        _this.tileUrl = undefined;
	        return _this;
	    }
	    return TileLayerOptions;
	}(MediaLayerOptions));

	var __extends$t = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$7 = (window && window.__assign) || function () {
	    __assign$7 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$7.apply(this, arguments);
	};
	var __values$d = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * Renders raster tiled images on top of the map tiles.
	 */
	var TileLayer = /** @class */ (function (_super) {
	    __extends$t(TileLayer, _super);
	    /**
	     * Constructs a new TileLayer.
	     * @param options The options for the tile layer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     */
	    function TileLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        if (options) {
	            _this.setOptions(options);
	        }
	        return _this;
	    }
	    /**
	     * Gets the options of the tile layer.
	     */
	    TileLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, TileLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the tile layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    TileLayer.prototype.setOptions = function (options) {
	        var newOptions = new TileLayerOptions().merge(this.options, cloneDeepWith$1(options, TileLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the bounds, isTMS, max/minSourceZoom, subdomains, tileSize, or tileUrl
	            // options are changed the layer must be re-added to the map entirely.
	            if (!(isEqual$1(newOptions.bounds, this.options.bounds)) ||
	                newOptions.isTMS !== this.options.isTMS ||
	                newOptions.maxSourceZoom !== this.options.maxSourceZoom ||
	                newOptions.minSourceZoom !== this.options.minSourceZoom ||
	                !(isEqual$1(newOptions.subdomains, this.options.subdomains)) ||
	                newOptions.tileSize !== this.options.tileSize ||
	                newOptions.tileUrl !== this.options.tileUrl) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._setOptionsNoUpdate = function (options) {
	        this.options = new TileLayerOptions().merge(this.options, cloneDeepWith$1(options, TileLayerOptions._cloneCustomizer));
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._buildLayers = function () {
	        var layer = __assign$7(__assign$7({ id: this.id, type: "raster", source: this._getSourceId(), layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            }, paint: {
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-opacity": this.options.opacity,
	                "raster-saturation": this.options.saturation
	            } }, (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the raster source to include with the layer.
	     * @internal
	     */
	    TileLayer.prototype._buildSource = function () {
	        var e_1, _a;
	        var tiles;
	        if (this.options.tileUrl) {
	            // If the tileUrl include { assume it is a formatted string and use tiles property.
	            if (this.options.tileUrl.indexOf("{") !== -1) {
	                // If the tileUrl include the subdomain placeholder
	                // we must manually assign an array of urls to the tiles property
	                // because mapbox does not support the subdomain placeholder.
	                if (this.options.tileUrl.indexOf("{subdomain}") !== -1) {
	                    // Throw an error if no subdomains were specified
	                    if (this.options.subdomains && this.options.subdomains.length > 0) {
	                        var urls = [];
	                        try {
	                            for (var _b = __values$d(this.options.subdomains), _c = _b.next(); !_c.done; _c = _b.next()) {
	                                var subdomain = _c.value;
	                                urls.push(this.options.tileUrl.replace(/{subdomain}/g, subdomain));
	                            }
	                        }
	                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                        finally {
	                            try {
	                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                            }
	                            finally { if (e_1) throw e_1.error; }
	                        }
	                        tiles = urls;
	                    }
	                    else {
	                        throw new Error("The {subdomain} placeholder was included in the tileUrl but no subdomains were specified");
	                    }
	                }
	                else {
	                    // Else just provide a single url.
	                    tiles = [this.options.tileUrl];
	                }
	            }
	            else {
	                // Else assume it is just a TileJSON url and use the url property.
	                // For a TileJSON url only the url needs to be specified.
	                return {
	                    type: "raster",
	                    url: this.options.tileUrl
	                };
	            }
	        }
	        return __assign$7({ type: "raster", bounds: this.options.bounds, maxzoom: this.options.maxSourceZoom, minzoom: this.options.minSourceZoom, scheme: this.options.isTMS ? "tms" : "xyz", tileSize: this.options.tileSize }, (tiles && { tiles: tiles }));
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    TileLayer.prototype._getSourceId = function () {
	        return "".concat(this.getId(), "-RasterSource");
	    };
	    TileLayer.prototype._getSourceWrapper = function () {
	        var sourceId = this._getSourceId();
	        var source = this._buildSource();
	        return new FundamentalMapSource(sourceId, {
	            name: sourceId,
	            tiles: source.tiles,
	            type: source.type,
	            url: source.url
	        });
	    };
	    return TileLayer;
	}(SourceBuildingLayer));

	var __extends$s = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used to render graphics in a WebGLLayer.
	 */
	var WebGLLayerOptions = /** @class */ (function (_super) {
	    __extends$s(WebGLLayerOptions, _super);
	    function WebGLLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * An object that contains the rendering logic.
	         */
	        _this.renderer = undefined;
	        return _this;
	    }
	    return WebGLLayerOptions;
	}(LayerOptions$1));

	var __extends$r = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Enables custom rendering logic with access to the WebGL context of the map.
	 */
	var WebGLLayer = /** @class */ (function (_super) {
	    __extends$r(WebGLLayer, _super);
	    /**
	     * Constructs a new WebGLLayer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the WebGL layer.
	     */
	    function WebGLLayer(id, options) {
	        var _this = _super.call(this, id) || this;
	        /**
	         * Make sure the layer is available after a style change.
	         * @internal
	         */
	        _this._onStyleChange = function () {
	            var _a;
	            // Custom layers cannot be serialized and preserved by mapbox.
	            // Add this layer again if the layer was removed by mapbox after a style change.
	            if (!_this.map._getMap().getLayer(_this.id)) {
	                var map = _this.map;
	                var before = (_a = _this.map.layers._getUserLayers().find(function (l) { return l.layer.getId() == _this.id; })) === null || _a === void 0 ? void 0 : _a.before;
	                map.layers.remove(_this);
	                map.layers.add(_this, before);
	            }
	        };
	        _this.options = new WebGLLayerOptions().merge(cloneDeepWith$1(options, WebGLLayerOptions._cloneCustomizer));
	        _this.source = new DataSource();
	        return _this;
	    }
	    /**
	     * Gets the options of the WebGL layer.
	     */
	    WebGLLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, WebGLLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the WebGL layer.
	     * @param options The new options of the WebGL layer.
	     */
	    WebGLLayer.prototype.setOptions = function (options) {
	        var newOptions = new WebGLLayerOptions().merge(this.options, cloneDeepWith$1(options, WebGLLayerOptions._cloneCustomizer));
	        // Trigger a repaint of the map if the layer options have changed.
	        if (this.map) {
	            this.map.triggerRepaint();
	        }
	        this.options = newOptions;
	    };
	    WebGLLayer.prototype.onAdd = function (map) {
	        var _a, _b;
	        _super.prototype.onAdd.call(this, map);
	        // Make sure the layer is available after a style change.
	        this.map.events.add("stylechanged", this._onStyleChange);
	        // Notify the renderer this layer has been added to the map.
	        if (this.options.renderer && this.glContext) {
	            (_b = (_a = this.options.renderer).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, map, this.glContext);
	        }
	    };
	    WebGLLayer.prototype.onRemove = function () {
	        var _a, _b;
	        // Notify the renderer this layer has been removed from the map.
	        if (this.options.renderer && this.glContext) {
	            (_b = (_a = this.options.renderer).onRemove) === null || _b === void 0 ? void 0 : _b.call(_a, this.map, this.glContext);
	        }
	        // Cleanup
	        this.map.events.remove("stylechanged", this._onStyleChange);
	        this.glContext = null;
	        _super.prototype.onRemove.call(this);
	    };
	    /**
	     * @internal
	     */
	    WebGLLayer.prototype._buildLayers = function () {
	        var _this = this;
	        if (!this.options.renderer) {
	            throw new Error("Cannot build the WebGL layer because renderer was not set.");
	        }
	        return [
	            {
	                id: this.id,
	                type: "custom",
	                renderingMode: this.options.renderer.renderingMode,
	                onAdd: function (m, gl) {
	                    // Capture the GL context to reuse it later.
	                    // renderer.onAdd will be called in the onAdd callback of this layer.
	                    _this.glContext = gl;
	                },
	                onRemove: function (m, gl) {
	                    // renderer.onRemove will be called in the onRemove callback of this layer.
	                },
	                prerender: function (gl, matrix) {
	                    var _a, _b;
	                    if (_this._shouldRender()) {
	                        (_b = (_a = _this.options.renderer).prerender) === null || _b === void 0 ? void 0 : _b.call(_a, gl, matrix);
	                    }
	                },
	                render: function (gl, matrix) {
	                    if (_this._shouldRender()) {
	                        _this.options.renderer.render(gl, matrix);
	                    }
	                }
	            }
	        ];
	    };
	    /**
	     * @internal
	     */
	    WebGLLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    WebGLLayer.prototype._getSourceIds = function () {
	        return new Set().add(this.source.getId());
	    };
	    /**
	     * Returns true if the next frame should be rendered
	     * @internal
	     */
	    WebGLLayer.prototype._shouldRender = function () {
	        if (this.map) {
	            var zoom = this.map.getCamera().zoom;
	            return this.options.visible && this.options.minZoom <= zoom && this.options.maxZoom > zoom;
	        }
	        return false;
	    };
	    return WebGLLayer;
	}(Layer));

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BubbleLayer: BubbleLayer,
		HeatMapLayer: HeatMapLayer,
		ImageLayer: ImageLayer,
		Layer: Layer,
		LineLayer: LineLayer,
		PolygonExtrusionLayer: PolygonExtrusionLayer,
		PolygonLayer: PolygonLayer,
		SymbolLayer: SymbolLayer,
		TileLayer: TileLayer,
		WebGLLayer: WebGLLayer
	});

	var Html = /** @class */ (function () {
	    function Html() {
	    }
	    /**
	     * Converts the specified content into a div element.
	     * @param content A string to make the innerHTML of the div element.
	     * If a HTMLElement is provided it is returned unmodified.
	     */
	    Html.convertHtmlString = function (content) {
	        if (typeof content === "string") {
	            var htmlEle = document.createElement("div");
	            htmlEle.innerHTML = content;
	            return htmlEle;
	        }
	        else {
	            return content;
	        }
	    };
	    /**
	     * Parses the html string and filters out DOM nodes according to provided filter
	     * @param content A string containing valid html.
	     * @param filter A filter condition to check if the DOM node is allowed
	     * @param groupingElement An element that will be used as a root element if the content is a flat list of nodes
	     * If plain text is provided, the string will be returned
	     */
	    Html.parseWithFilter = function (content, filter, transformer, groupingElement) {
	        var _this = this;
	        if (filter === void 0) { filter = function (_) { return true; }; }
	        if (transformer === void 0) { transformer = function (elem) { return elem; }; }
	        if (groupingElement === void 0) { groupingElement = function () { return document.createElement('div'); }; }
	        var elem;
	        if (typeof content === 'string') {
	            var body = (new DOMParser()).parseFromString(content, 'text/html').body;
	            if (body.children.length == 0) {
	                return transformer(body.innerHTML);
	            }
	            else if (body.children.length == 1 && body.childNodes.length == 1) {
	                elem = body.children[0];
	            }
	            else {
	                var container_1 = groupingElement();
	                Array.from(body.childNodes).map(function (node) { return container_1.append(node); });
	                elem = container_1;
	            }
	        }
	        else {
	            elem = content;
	        }
	        Array.from(elem.children).forEach(function (elem) { return _this.parseWithFilter(elem, filter, transformer); });
	        if (!filter(elem)) {
	            if (elem.parentNode) {
	                elem.parentNode.removeChild(elem);
	            }
	            return null;
	        }
	        else {
	            return transformer(elem);
	        }
	    };
	    return Html;
	}());

	var isObjectLike = isObjectLike_1,
	    isPlainObject = isPlainObject_1;

	/**
	 * Checks if `value` is likely a DOM element.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	 * @example
	 *
	 * _.isElement(document.body);
	 * // => true
	 *
	 * _.isElement('<body>');
	 * // => false
	 */
	function isElement(value) {
	  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	}

	var isElement_1 = isElement;

	var isElement$1 = /*@__PURE__*/getDefaultExportFromCjs(isElement_1);

	var __extends$q = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a popup.
	 */
	var PopupOptions = /** @class */ (function (_super) {
	    __extends$q(PopupOptions, _super);
	    function PopupOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the popup's location relative to its position on the map.
	         * Optional values: `"none"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * default `"none"`
	         * @default "none"
	         */
	        _this.anchor = "none";
	        /**
	         * Specifies if the popup can be dragged away from its position.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * Specifies if the close button should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.closeButton = true;
	        /**
	         * The content to display within the popup.
	         * default `span`
	         * @default span
	         */
	        _this.content = document.createElement("span");
	        /**
	         * Specifies the fill color of the popup.
	         * default `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.fillColor = "#FFFFFF";
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the anchor of the popup should be
	         * offset. Negative numbers can be used to offset the popup left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position on the map where the popup should be anchored.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * Specifies if the pointer should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.showPointer = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    PopupOptions._cloneCustomizer = function (value) {
	        if (isElement$1(value)) {
	            return value;
	        }
	    };
	    return PopupOptions;
	}(Options));

	var __extends$p = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __read$c = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * An information window anchored at a specified position on a map.
	 */
	var Popup = /** @class */ (function (_super) {
	    __extends$p(Popup, _super);
	    /**
	     * Constructs a Popup object and initializes it with the specified options.
	     * @param options The options for the popup.
	     */
	    function Popup(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Attaches the popup to the HTML document in a hidden state.
	         * @param map The map.
	         */
	        _this.attach = function (map) {
	            // If attaching to a different map, remove popup on current map
	            if (_this.map !== map) {
	                // If map was defined the popup was attached to another map.
	                if (_this.map) {
	                    _this.remove();
	                }
	                // Create the marker before attaching the popup and it to the map.
	                _this.map = map;
	                _this.marker = _this._createMarker(_this.options);
	                // Attach the wrapped mapbox marker to the map.
	                // When the marker is attached to the map it will attach the containerHtml to a default container.
	                // Move the containerHtml to the popup collection container after attaching the marker.
	                _this.marker.addTo(_this.map._getMap());
	                _this.map.popups._getCollectionDiv().appendChild(_this.containerDiv);
	                _this.map.popups.add(_this);
	            }
	        };
	        /**
	         * Opens the popup.
	         * @param map The map to open the popup on.
	         * Optional if already attached to a map.
	         */
	        _this.open = function (map) {
	            if (!map && !_this.map) {
	                throw new Error("Must specify a map to open on or attach to a map in advance");
	            }
	            _this.attach(map || _this.map);
	            _this.containerDiv.classList.remove(Popup.Css.hidden);
	            _this.map.events.add("move", _this._onMove);
	            _this._onMove();
	            _this._invokeEvent("open", { target: _this, type: "open" });
	        };
	        /**
	         * Closes the popup on the map. The popup remains attached to the HTML document.
	         */
	        _this.close = function () {
	            if (_this.map) {
	                _this.map.events.remove("move", _this._onMove);
	            }
	            _this.containerDiv.classList.add(Popup.Css.hidden);
	            _this._invokeEvent("close", { target: _this, type: "close" });
	        };
	        /**
	         * Closes the popup on the map and removes it from the HTML document.
	         */
	        _this.remove = function () {
	            if (_this.map) {
	                _this.marker.remove();
	                _this.containerDiv.classList.remove(_this.autoAnchor || _this.options.anchor);
	                _this.map.events.remove("move", _this._onMove);
	                _this.map.popups.remove(_this);
	                delete _this.map;
	                delete _this.marker;
	                delete _this.autoAnchor;
	            }
	        };
	        /**
	         * Returns true if the popup is currently open, otherwise false.
	         */
	        _this.isOpen = function () {
	            return _this.map && !_this.containerDiv.classList.contains(Popup.Css.hidden);
	        };
	        /**
	         * Callback for the move listener used for auto anchoring.
	         */
	        _this._onMove = function () {
	            var newAutoAnchor = _this._getAutoAnchor(_this.map, _this.options);
	            if (newAutoAnchor !== _this.autoAnchor) {
	                // When we replace the marker it adds a new move listeners.
	                // We want our listener to fire after the marker's, so we add it again.
	                // Adding the listener again means it will fire after all other previously listeners.
	                _this._replaceMarker(_this.map, _this.options, newAutoAnchor);
	                _this.map.events.add("move", _this._onMove);
	            }
	        };
	        /**
	         * Called by a mouse down or touch start event.
	         */
	        _this._onDown = function (event) {
	            var _a;
	            _this.map.popups._addDraggedPopup(_this);
	            var anchorPixel = (_a = __read$c(_this.map.positionsToPixels([_this.options.position]), 1), _a[0]);
	            if (event.type === "mousedown") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.clientX,
	                    anchorPixel[1] - event.clientY
	                ];
	            }
	            else if (event.type === "touchstart") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.touches[0].clientX,
	                    anchorPixel[1] - event.touches[0].clientY
	                ];
	            }
	        };
	        /**
	         * Called by the container's dragstart event.
	         * Used to call preventDefault as a fix for Edge dragging issues.
	         */
	        _this._onDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new PopupOptions().merge(cloneDeepWith$1(options, PopupOptions._cloneCustomizer));
	        // Create full content container
	        _this.containerDiv = _this._createContainerDiv(_this.options);
	        // Create the container for the content specified in the options.
	        _this.contentDiv = _this._createContentDiv(_this.options);
	        _this.containerDiv.appendChild(_this.contentDiv);
	        // Create arrow tip if specified in the options.
	        if (_this.options.showPointer) {
	            _this.arrowDiv = _this._createArrowDiv();
	            _this.containerDiv.appendChild(_this.arrowDiv);
	        }
	        // Create close button if specified in the options.
	        if (_this.options.closeButton) {
	            _this.closeBtn = _this._createCloseButton();
	            _this.contentDiv.appendChild(_this.closeBtn);
	            var tooltip = buildAccessibleTooltip("close");
	            _this.contentDiv.appendChild(tooltip);
	            positionTooltip(tooltip, _this.closeBtn, true);
	        }
	        return _this;
	    }
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     * @deprecated Use setOptions(...) instead.
	     */
	    Popup.prototype.setPopupOptions = function (options) {
	        this.setOptions(options);
	    };
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     */
	    Popup.prototype.setOptions = function (options) {
	        var newOptions = new PopupOptions().merge(this.options, cloneDeepWith$1(options, PopupOptions._cloneCustomizer));
	        if (newOptions.content !== this.options.content) {
	            // If the popup content is changed remove the old content and add the new stuff.
	            // Will also implicitly update draggability.
	            this.htmlContent.remove();
	            this.htmlContent = this._createHtmlContent(newOptions);
	            this.contentDiv.prepend(this.htmlContent);
	        }
	        else if (newOptions.draggable !== this.options.draggable) {
	            // If the content hasn't changed, check if draggable is changed.
	            this._setDraggable(this.htmlContent, newOptions.draggable);
	        }
	        // If a close button should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.closeButton && !this.closeBtn) {
	            this.closeBtn = this._createCloseButton();
	            this.contentDiv.appendChild(this.closeBtn);
	            var tooltip = buildAccessibleTooltip("close");
	            this.contentDiv.appendChild(tooltip);
	            positionTooltip(tooltip, this.closeBtn, true);
	        }
	        else if (!newOptions.closeButton && this.closeBtn) {
	            this.contentDiv.removeChild(this.closeBtn);
	            delete this.closeBtn;
	        }
	        // If a pointer should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.showPointer && !this.arrowDiv) {
	            this.arrowDiv = this._createArrowDiv();
	            this.containerDiv.appendChild(this.arrowDiv);
	        }
	        else if (!newOptions.showPointer && this.arrowDiv) {
	            this.containerDiv.removeChild(this.arrowDiv);
	            delete this.arrowDiv;
	        }
	        // If the fill color is changed update the relavent elements.
	        if (newOptions.fillColor !== this.options.fillColor) {
	            this.containerDiv.style.borderColor = newOptions.fillColor;
	            this.contentDiv.style.backgroundColor = newOptions.fillColor;
	        }
	        if (this.marker) {
	            if (newOptions.anchor !== this.options.anchor) {
	                // If the anchor property has changed we need to build a new marker.
	                if (this.options.anchor === "none") {
	                    if (this.autoAnchor !== newOptions.anchor) {
	                        this._replaceMarker(this.map, newOptions);
	                    }
	                    this.map.events.remove("move", this._onMove);
	                    delete this.autoAnchor;
	                }
	                else {
	                    this._replaceMarker(this.map, newOptions);
	                    if (newOptions.anchor === "none") {
	                        this.map.events.add("move", this._onMove);
	                    }
	                }
	            }
	            else {
	                // Check if the position is changed.
	                if (!isEqual$1(newOptions.position, this.options.position)) {
	                    this.marker.setLngLat(newOptions.position);
	                }
	                // Check if the offset is changed.
	                if (!isEqual$1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                    this.marker.setOffset(newOptions.pixelOffset);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Returns the options for the popup.
	     * @deprecated Use getOptions() instead.
	     */
	    Popup.prototype.getPopupOptions = function () {
	        return this.getOptions();
	    };
	    /**
	     * Returns the options for the popup.
	     */
	    Popup.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, PopupOptions._cloneCustomizer);
	    };
	    /**
	     * Returns popup container element.
	     */
	    Popup.prototype.getPopupContainer = function () {
	        return this.containerDiv;
	    };
	    /**
	     * Drags the popup to the specified pixel.
	     * Accounts for the pixel offset when dragging started.
	     * @internal
	     */
	    Popup.prototype._dragToPixel = function (pixel) {
	        var _a;
	        // Wait until the popup has been dragged the first time to fire th dragstart event.
	        if (!this.dragging) {
	            this.dragging = true;
	            this.contentDiv.style.pointerEvents = "none";
	            this._invokeEvent("dragstart", { type: "dragstart", target: this });
	        }
	        var anchorPixel = [
	            pixel[0] + this.dragOffset[0],
	            pixel[1] + this.dragOffset[1]
	        ];
	        var anchorPos = (_a = __read$c(this.map.pixelsToPositions([anchorPixel]), 1), _a[0]);
	        this.options.position = anchorPos;
	        this.marker.setLngLat(this.options.position);
	        this._invokeEvent("drag", { type: "drag", target: this });
	    };
	    /**
	     * Called by a mouse up or touch end event.
	     * @internal
	     */
	    Popup.prototype._onUp = function () {
	        // Only fire the dragend event if the popup was actually dragged.
	        if (this.dragging) {
	            this.contentDiv.style.pointerEvents = "";
	            this._invokeEvent("dragend", { type: "dragend", target: this });
	            if (this.options.anchor === "none") {
	                // If automatically anchoring the popup check if the anchor should change after done dragging.
	                this._onMove();
	            }
	        }
	        // Clear the drag state tracking variables.
	        delete this.dragOffset;
	        delete this.dragging;
	    };
	    /**
	     * Creates the overall container div.
	     */
	    Popup.prototype._createContainerDiv = function (options) {
	        var _this = this;
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.container);
	        ele.classList.add(Popup.Css.hidden);
	        ele.style.borderColor = options.fillColor;
	        ele.setAttribute("role", "dialog");
	        ele.setAttribute("aria-label", "Map Information Window");
	        // Track if a key which can change the focus has been pressed.
	        var focusKeyDown = false;
	        ele.addEventListener("keydown", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = true;
	            }
	        });
	        // If the keyup event occurs before the focusout then don't close the popup.
	        ele.addEventListener("keyup", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = false;
	            }
	        });
	        // If focus comes in without the popup being open go ahead and open it.
	        ele.addEventListener("focusin", function (e) {
	            if (_this.map && !_this.isOpen()) {
	                _this.open(_this.map);
	                // Focus on the element again because it may have been removed and added back to the DOM
	                if (e.target instanceof HTMLElement) {
	                    e.target.focus();
	                }
	            }
	        });
	        // If the focus is lost after a key was pressed close the popup.
	        ele.addEventListener("focusout", function (e) {
	            if (focusKeyDown && e.relatedTarget instanceof Node && !ele.contains(e.relatedTarget)) {
	                focusKeyDown = false;
	                if (_this.isOpen()) {
	                    _this.close();
	                }
	            }
	        });
	        return ele;
	    };
	    /**
	     * Creates the content container div.
	     */
	    Popup.prototype._createContentDiv = function (options) {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.content);
	        ele.style.backgroundColor = options.fillColor;
	        ele.setAttribute("tabindex", "0");
	        this.htmlContent = this._createHtmlContent(options);
	        ele.appendChild(this.htmlContent);
	        return ele;
	    };
	    /**
	     * Creates an arrow element.
	     */
	    Popup.prototype._createArrowDiv = function () {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.arrow);
	        return ele;
	    };
	    /**
	     * Creates a close button.
	     */
	    Popup.prototype._createCloseButton = function () {
	        var ele = document.createElement("button");
	        ele.addEventListener("click", this.close);
	        ele.classList.add(Popup.Css.close);
	        ele.setAttribute("aria-label", "close");
	        ele.setAttribute("tabindex", "0");
	        ele.innerHTML = "&times;";
	        return ele;
	    };
	    /**
	     * Creates the user content element.
	     */
	    Popup.prototype._createHtmlContent = function (options) {
	        var ele = Html.convertHtmlString(options.content);
	        if (options.draggable) {
	            this._setDraggable(ele, options.draggable);
	        }
	        return ele;
	    };
	    /**
	     * Creates the marker which wraps the popup.
	     */
	    Popup.prototype._createMarker = function (options, autoAnchor) {
	        // If a marker already exists use it's LngLat value for the new marker's position
	        // This prevent the marker from jumping around if world copies are rendered.
	        var position = this.marker ?
	            this.marker.getLngLat() :
	            options.position;
	        // Create the mapbox marker that will hold the popup.
	        var marker;
	        if (options.anchor === "none") {
	            this.autoAnchor = autoAnchor || "bottom";
	            this.containerDiv.classList.add(this.autoAnchor);
	            marker = new maplibregl.Marker({
	                anchor: this.autoAnchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        else {
	            this.containerDiv.classList.add(options.anchor);
	            marker = new maplibregl.Marker({
	                anchor: options.anchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        return marker;
	    };
	    /**
	     * Calculates the auto anchor value for the current marker.
	     */
	    Popup.prototype._getAutoAnchor = function (map, options) {
	        var _a, _b;
	        var width = this.containerDiv.offsetWidth;
	        var height = this.containerDiv.offsetHeight;
	        var posX;
	        var posY;
	        if (this.marker) {
	            var pt = map._getMap().project(this.marker.getLngLat());
	            posX = pt.x;
	            posY = pt.y;
	        }
	        else {
	            var x = (_a = __read$c(map.positionsToPixels([options.position]), 1), _b = __read$c(_a[0], 2), _b[0]), y = _b[1];
	            posX = x;
	            posY = y;
	        }
	        var autoAnchor = [];
	        if (posY < height) {
	            autoAnchor.push("top");
	        }
	        else if (posY > map.getCanvas().offsetHeight - height) {
	            autoAnchor.push("bottom");
	        }
	        if (posX < width / 2) {
	            autoAnchor.push("left");
	        }
	        else if (posX > map.getCanvas().offsetWidth - width / 2) {
	            autoAnchor.push("right");
	        }
	        return autoAnchor.length > 0 ?
	            autoAnchor.join("-") :
	            "bottom";
	    };
	    /**
	     * Replaces the current marker with a new one using the specified options.
	     */
	    Popup.prototype._replaceMarker = function (map, options, autoAnchor) {
	        // Track the next sibling before the marker is removed.
	        var next = this.containerDiv.nextElementSibling;
	        this.marker.remove();
	        this.containerDiv.classList.remove(this.autoAnchor || this.options.anchor);
	        this.marker = this._createMarker(options, autoAnchor);
	        this.marker.addTo(map._getMap());
	        // If the popup was already to the DOM place it back in the original order
	        // This keeps the tab order consistent.
	        map.popups._getCollectionDiv().insertBefore(this.containerDiv, next || null);
	    };
	    /**
	     * Called to setup or remove draggability.
	     */
	    Popup.prototype._setDraggable = function (ele, draggable) {
	        if (draggable) {
	            ele.addEventListener("mousedown", this._onDown);
	            ele.addEventListener("touchstart", this._onDown);
	            ele.addEventListener("dragstart", this._onDragStart);
	        }
	        else {
	            ele.removeEventListener("mousedown", this._onDown);
	            ele.removeEventListener("touchstart", this._onDown);
	            ele.removeEventListener("dragstart", this._onDragStart);
	        }
	    };
	    // CSS class names.
	    Popup.Css = {
	        arrow: "popup-arrow",
	        close: "popup-close",
	        container: "popup-container",
	        content: "popup-content-container",
	        hidden: "hidden-accessible-element"
	    };
	    return Popup;
	}(EventEmitter));

	var __extends$o = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options for rendering an HtmlMarker object
	 */
	var HtmlMarkerOptions = /** @class */ (function (_super) {
	    __extends$o(HtmlMarkerOptions, _super);
	    function HtmlMarkerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the marker's location relative to its position on the map.
	         * Optional values: `"center"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * Default `"bottom"`
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * A color value that replaces any {color} placeholder property that has been included in a string htmlContent.
	         * default `"#1A73AA"`
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * Indicates if the user can drag the position of the marker using the mouse or touch controls.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * The HTML content of the marker. Can be an HTMLElement or HTML string.
	         * Add {text} and {color} to HTML strings as placeholders to make it easy to update
	         * these values in your marker by using the setOptions function of the HtmlMarker class.
	         * This allows you to create a single HTML marker string that can be used as a template for multiple markers.
	         */
	        _this.htmlContent = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24.5 36.5\" id=\"marker_".concat(uuid(), "\" width=\"24.5\" height=\"36.5\" display=\"block\"><path d=\"M12.25.25a12.2543,12.2543,0,0,0-12,12.4937c0,6.4436,6.4879,12.1093,11.059,22.5641.5493,1.2563,1.3327,1.2563,1.882,0C17.7621,24.8529,24.25,19.1857,24.25,12.7437A12.2543,12.2543,0,0,0,12.25.25Z\"   fill=\"{color}\" stroke=\"{secondaryColor}\" stroke-width=\"0.5\"/><text style=\"font-family: Arial, Helvetica, sans-serif; font-size: 14px; fill: white;\" text-anchor=\"middle\" x=\"12\" y=\"18\">{text}</text></svg>");
	        /**
	         * An offset in pixels to move the popup relative to the markers center.
	         * Negatives indicate left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position of the marker.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * A popup that is attached to the marker.
	         */
	        _this.popup = undefined;
	        /**
	         * A color value that replaces any {secondaryColor} placeholder property that has been included in a string htmlContent.
	         * default `"white"`
	         * @default "white"
	         */
	        _this.secondaryColor = "white";
	        /**
	         * A string of text that replaces any {text} placeholder property that has been included in a string htmlContent.
	         */
	        _this.text = undefined;
	        /**
	         * Specifies if the marker is visible or not.
	         * default `true`
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Popups and HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HtmlMarkerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Popup || isElement$1(value)) {
	            return value;
	        }
	    };
	    return HtmlMarkerOptions;
	}(Options));

	var __extends$n = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * This class wraps an HTML element that can be displayed on the map.
	 */
	var HtmlMarker = /** @class */ (function (_super) {
	    __extends$n(HtmlMarker, _super);
	    /**
	     * Constructs a new HtmlMarker.
	     * @param options The options for the HtmlMarker.
	     */
	    function HtmlMarker(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Called by the drag event of the mapbox marker.
	         * @private
	         */
	        _this._onDrag = function () {
	            var lngLat = _this.marker.getLngLat().wrap();
	            _this.options.position = new Position(lngLat.lng, lngLat.lat);
	            _this._invokeEvent("drag", { type: "drag", target: _this });
	        };
	        /**
	         * Called by the dragstart event of the mapbox marker.
	         * @private
	         */
	        _this._onDragStart = function () {
	            _this._invokeEvent("dragstart", { type: "dragstart", target: _this });
	        };
	        /**
	         * Called by the dragend event of the mapbox marker.
	         * @private
	         */
	        _this._onDragEnd = function () {
	            _this._invokeEvent("dragend", { type: "dragend", target: _this });
	        };
	        /**
	         * Called by the events of the marker's element.
	         * @private
	         */
	        _this._bubbleElementEvent = function (event) {
	            _this._invokeEvent(event.type, { type: event.type, target: _this });
	        };
	        /**
	         * Called by the element's dragstart event.
	         * Used to call preventDefault so Edge doesn't break dragging.
	         * @private
	         */
	        _this._onEleDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new HtmlMarkerOptions().merge(cloneDeepWith$1(options, HtmlMarkerOptions._cloneCustomizer));
	        _this._buildMarker(_this.options);
	        return _this;
	    }
	    /**
	     * Gets the HTML marker options.
	     */
	    HtmlMarker.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, HtmlMarkerOptions._cloneCustomizer);
	    };
	    /**
	     * Returns the underlying `Marker`'s HTML element.
	     */
	    HtmlMarker.prototype.getElement = function () {
	        return this.marker.getElement();
	    };
	    /**
	     * Sets the options of the marker.
	     * @param options The options for the marker.
	     */
	    HtmlMarker.prototype.setOptions = function (options) {
	        var newOptions = new HtmlMarkerOptions().merge(this.options, cloneDeepWith$1(options, HtmlMarkerOptions._cloneCustomizer));
	        if (!isEqual$1(newOptions.htmlContent, this.options.htmlContent) ||
	            newOptions.anchor !== this.options.anchor) {
	            // If the htmlContent is new the old marker must be removed and a new one created.
	            this.marker.remove();
	            this._buildMarker(newOptions);
	            // If this marker is attached to a map the new mapbox marker should be added to it.
	            if (this.map) {
	                this.marker.addTo(this.map._getMap());
	                this._getCollectionContainer().appendChild(this.element);
	            }
	        }
	        else {
	            // Check for which options have been updated.
	            // Not necessary if a new marker was created as it will have all the new properties.
	            if (typeof newOptions.htmlContent === "string" &&
	                (newOptions.color !== this.options.color ||
	                    newOptions.text !== this.options.text ||
	                    newOptions.secondaryColor !== this.options.secondaryColor)) {
	                this.element.innerHTML = this._getSubbedHtmlString(newOptions) || "";
	            }
	            if (newOptions.draggable !== this.options.draggable) {
	                this._setDraggable(newOptions.draggable);
	                this.marker.setDraggable(newOptions.draggable);
	            }
	            if (!isEqual$1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                this.marker.setOffset(newOptions.pixelOffset);
	            }
	            if (!isEqual$1(newOptions.position, this.options.position)) {
	                this.marker.setLngLat(newOptions.position);
	            }
	            if (newOptions.visible !== this.options.visible) {
	                if (newOptions.visible) {
	                    this.element.classList.remove(HtmlMarker.hiddenClass);
	                }
	                else {
	                    this.element.classList.add(HtmlMarker.hiddenClass);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Toggles the popup attached to the marker.
	     */
	    HtmlMarker.prototype.togglePopup = function () {
	        if (this.options.popup) {
	            if (this.options.popup.isOpen()) {
	                this.options.popup.close();
	            }
	            else if (this.map) {
	                // Set the popup position to match the marker's.
	                // Same as the mapbox behavior.
	                this.options.popup.setOptions({
	                    position: this.options.position,
	                });
	                this.options.popup.open(this.map);
	            }
	            else {
	                throw new Error("The marker must be added to a map before calling togglePopup().");
	            }
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._addToMap = function (map, position) {
	        // If already added to a different map remove it and add to the new one.
	        if (this.map && this.map !== map) {
	            this._removeFromMap();
	        }
	        if (position) {
	            this.options.position = cloneDeep$1(position);
	            this.marker.setLngLat(this.options.position);
	        }
	        // If the marker is being added to a map it already belongs to this isn't needed.
	        if (this.map !== map) {
	            this.map = map;
	            this.marker.addTo(map._getMap());
	            this._getCollectionContainer().appendChild(this.element);
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._removeFromMap = function () {
	        if (this.map) {
	            this.marker.remove();
	            delete this.map;
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._getId = function () {
	        if (this.element) {
	            if (typeof this.options.htmlContent === "string") {
	                return this.element.firstChild["id"];
	            }
	            else {
	                return this.element.id;
	            }
	        }
	        return undefined;
	    };
	    /**
	     * Builds the Mapbox marker that this HtmlMarker will wrap.
	     * @private
	     */
	    HtmlMarker.prototype._buildMarker = function (options) {
	        // Construct a mapbox marker that this class wraps.
	        // Must converts a HTML string to a HTMLElement (div with innerHTML == htmlContent).
	        // Must also handle the substitution of HTML string placeholders.
	        if (typeof options.htmlContent === "string") {
	            var subbedContent = this._getSubbedHtmlString(options) || "";
	            this.element = Html.convertHtmlString(subbedContent);
	        }
	        else {
	            this.element = options.htmlContent;
	        }
	        this.element.classList.add(HtmlMarker.containerClass);
	        // If draggability is enabled some attributes need updated.
	        if (options.draggable) {
	            this._setDraggable(true);
	        }
	        // If visible is false the marker should still exist on the DOM so it is accessible.
	        if (!options.visible) {
	            this.element.classList.add(HtmlMarker.hiddenClass);
	        }
	        this.marker = new maplibregl.Marker({
	            element: this.element,
	            offset: options.pixelOffset,
	            draggable: options.draggable,
	            anchor: options.anchor
	        }).setLngLat(options.position);
	        // Listen for marker specific events.
	        this.marker.on("drag", this._onDrag);
	        this.marker.on("dragstart", this._onDragStart);
	        this.marker.on("dragend", this._onDragEnd);
	        // Listen for HtmlElement specific events.
	        this.element.addEventListener("click", this._bubbleElementEvent);
	        this.element.addEventListener("dblclick", this._bubbleElementEvent);
	        this.element.addEventListener("contextmenu", this._bubbleElementEvent);
	        this.element.addEventListener("keydown", this._bubbleElementEvent);
	        this.element.addEventListener("keypress", this._bubbleElementEvent);
	        this.element.addEventListener("keyup", this._bubbleElementEvent);
	        this.element.addEventListener("mousedown", this._bubbleElementEvent);
	        this.element.addEventListener("mouseenter", this._bubbleElementEvent);
	        this.element.addEventListener("mouseleave", this._bubbleElementEvent);
	        this.element.addEventListener("mousemove", this._bubbleElementEvent);
	        this.element.addEventListener("mouseout", this._bubbleElementEvent);
	        this.element.addEventListener("mouseover", this._bubbleElementEvent);
	        this.element.addEventListener("mouseup", this._bubbleElementEvent);
	    };
	    /**
	     * Returns a HTML string with all place holders substituted for.
	     * @private
	     */
	    HtmlMarker.prototype._getSubbedHtmlString = function (options) {
	        if (typeof options.htmlContent === "string") {
	            return options.htmlContent
	                .replace(/{color}/ig, options.color || "")
	                .replace(/{secondaryColor}/ig, options.secondaryColor || "")
	                .replace(/{text}/ig, options.text || "");
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * Returns the element that should contain all the markers.
	     * Creates it if it doesn't already exist.
	     * @private
	     */
	    HtmlMarker.prototype._getCollectionContainer = function () {
	        var collectionContainer = this.map.getCanvasContainer()
	            .querySelector(".".concat(HtmlMarker.collectionContainerClass));
	        if (!collectionContainer) {
	            collectionContainer = document.createElement("div");
	            collectionContainer.classList.add(HtmlMarker.collectionContainerClass);
	            this.map.getCanvasContainer().appendChild(collectionContainer);
	        }
	        return collectionContainer;
	    };
	    /**
	     * Called to set the element dragstart listener, needed for proper draggability on Edge.
	     */
	    HtmlMarker.prototype._setDraggable = function (draggable) {
	        if (draggable) {
	            this.element.addEventListener("dragstart", this._onEleDragStart);
	        }
	        else {
	            this.element.removeEventListener("dragstart", this._onEleDragStart);
	        }
	    };
	    HtmlMarker.collectionContainerClass = "marker-collection-container";
	    HtmlMarker.hiddenClass = "hidden-accessible-element";
	    HtmlMarker.containerClass = "marker-container";
	    return HtmlMarker;
	}(EventEmitter));

	var Media = /** @class */ (function () {
	    function Media() {
	    }
	    /**
	     * Returns the current high contrast mode based on media queries.
	     * Can return the following values:
	     * - `"light"`: High contrast using black text on white backgrounds
	     * - `"dark"`: High contrast using white text on black backgrounds
	     * - `"invert"`: Inverting colors, often used for high contrast
	     * - `null`: Not in high contrast mode
	     */
	    Media.getHighContrastMode = function () {
	        if (matchMedia("(-ms-high-contrast: white-on-black)").matches) {
	            return "dark";
	        }
	        else if (matchMedia("(-ms-high-contrast: black-on-white)").matches) {
	            return "light";
	        }
	        else if (matchMedia("(-ms-high-contrast: active)").matches) {
	            return "dark"; // Default to dark if we can't detect a specific style
	        }
	        else if (matchMedia("(inverted-colors: inverted)").matches) {
	            return "invert"; // Inverted colors is specific to macOS
	        }
	        // If nothing matches assume high contrast isn't in use
	        return null;
	    };
	    return Media;
	}());

	var __extends$m = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a CopyrightControl object.
	 */
	var CopyrightControlOptions = /** @class */ (function (_super) {
	    __extends$m(CopyrightControlOptions, _super);
	    function CopyrightControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The copyright plain text message to display. Will be appended to copyright content if provided
	         */
	        _this.copyrightMessage = undefined;
	        /**
	         * The copyright content element containing formatted copyright message
	         * this is the primary way of setting copyright by CopyrightDelegate
	         */
	        _this.copyrightContent = undefined;
	        /**
	         * Additional custom user attribution appended to the end as it is
	         */
	        _this.customAttribution = undefined;
	        /**
	         * If true will show a link to the map feedback page.
	         */
	        _this.showFeedbackLink = true;
	        /**
	         * If true will show the Microsoft logo.
	         */
	        _this.showLogo = true;
	        return _this;
	    }
	    return CopyrightControlOptions;
	}(Options));

	var __extends$l = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * @private
	 */
	var CopyrightControl = /** @class */ (function (_super) {
	    __extends$l(CopyrightControl, _super);
	    function CopyrightControl(options) {
	        var _this = _super.call(this) || this;
	        _this.textAttribution = function (options) {
	            return [_this.options.copyrightMessage, _this.options.customAttribution]
	                .filter(function (message) { return message; })
	                .join("");
	        };
	        // Append latitude, longitude and zoom level to feedback link.
	        _this.updateFeedbackLink = function () {
	            var _a;
	            if (_this.feedbackAnchor && _this.map) {
	                var center = (_a = _this.map.getCamera(), _a.center), zoom = _a.zoom;
	                _this.feedbackAnchor.href = "".concat(CopyrightControl.feedbackLink, "&cp=").concat(center[1], "~").concat(center[0], "&lvl=").concat(zoom + 1);
	            }
	        };
	        _this.options = new CopyrightControlOptions().merge(options);
	        return _this;
	    }
	    CopyrightControl.prototype.onAdd = function (map) {
	        this.map = map;
	        this.container = this.buildContainer(map, exports.ControlStyle.auto);
	        this.container.className = "map-copyright without-bg";
	        this.copyrightDiv = this.buildCopyrightDiv();
	        this.copyrightDiv.className = "azure-map-copyright";
	        this.container.appendChild(this.copyrightDiv);
	        if (this.options.showFeedbackLink) {
	            this.addRemoveFeedbackDiv(true);
	        }
	        return this.container;
	    };
	    CopyrightControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        delete this.container;
	    };
	    CopyrightControl.prototype.setOptions = function (options) {
	        var _this = this;
	        var newOptions = new CopyrightControlOptions().merge(this.options, options);
	        if (newOptions.copyrightMessage !== this.options.copyrightMessage
	            || newOptions.customAttribution !== this.options.customAttribution) {
	            this.copyrightDiv.innerText = this.textAttribution(newOptions);
	        }
	        if (newOptions.copyrightContent !== this.options.copyrightContent) {
	            if (this.options.copyrightContent) {
	                var prev = Array.from(this.copyrightDiv.children).find(function (elem) { return elem === _this.options.copyrightContent; });
	                this.copyrightDiv.removeChild(prev);
	            }
	            if (this.copyrightDiv.childNodes.length > 0) {
	                this.copyrightDiv.insertBefore(newOptions.copyrightContent, this.copyrightDiv.childNodes[0]);
	            }
	            else {
	                this.copyrightDiv.appendChild(newOptions.copyrightContent);
	            }
	            this.options.copyrightContent = newOptions.copyrightContent;
	        }
	        if (!newOptions.showFeedbackLink && this.feedbackAnchor) {
	            this.addRemoveFeedbackDiv(false);
	        }
	        else if (newOptions.showFeedbackLink && !this.feedbackAnchor) {
	            this.addRemoveFeedbackDiv(true);
	        }
	        this.options = newOptions;
	    };
	    CopyrightControl.prototype.getDefaultAttributions = function () {
	        var currentYear = new Date().getFullYear();
	        var copyright = ["\u00A9".concat(currentYear, " TomTom")];
	        if (!this.options.showLogo) {
	            copyright.push("\u00A9".concat(currentYear, " Microsoft"));
	        }
	        return copyright;
	    };
	    CopyrightControl.prototype.buildCopyrightDiv = function () {
	        var copyright = document.createElement("div");
	        copyright.innerText = this.textAttribution(this.options) || "";
	        return copyright;
	    };
	    CopyrightControl.prototype.buildFeedbackLink = function () {
	        var link = document.createElement("a");
	        link.setAttribute("alt", "Provide Map Data Feedback");
	        link.setAttribute("aria-label", "Provide Map Data Feedback");
	        link.innerText = "Feedback";
	        link.href = CopyrightControl.feedbackLink;
	        link.target = "_blank";
	        link.rel = "noopener";
	        link.className = "azure-map-feedback-text";
	        return link;
	    };
	    CopyrightControl.prototype.addRemoveFeedbackDiv = function (add) {
	        var _a, _b, _c, _d;
	        if (add) {
	            this.feedbackAnchor = this.buildFeedbackLink();
	            this.feedbackTooltip = buildAccessibleTooltip("Provide Map Data Feedback");
	            this.container.appendChild(this.feedbackAnchor);
	            this.container.appendChild(this.feedbackTooltip);
	            positionTooltip(this.feedbackTooltip, this.feedbackAnchor);
	            (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.add("moveend", this.updateFeedbackLink);
	        }
	        else {
	            this.feedbackAnchor.remove();
	            this.feedbackTooltip.remove();
	            delete this.feedbackTooltip;
	            delete this.feedbackAnchor;
	            (_d = (_c = this.map) === null || _c === void 0 ? void 0 : _c.events) === null || _d === void 0 ? void 0 : _d.remove("moveend", this.updateFeedbackLink);
	        }
	    };
	    CopyrightControl.feedbackLink = "https://aka.ms/azuremaps-feedback?feedbackep=UrlAzureMapsWebSdk";
	    return CopyrightControl;
	}(ControlBase));

	var __extends$k = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a LogoControl object.
	 */
	var LogoControlOptions = /** @class */ (function (_super) {
	    __extends$k(LogoControlOptions, _super);
	    function LogoControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * If true will show the Microsoft logo.
	         */
	        _this.showLogo = true;
	        return _this;
	    }
	    return LogoControlOptions;
	}(Options));

	var __extends$j = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control that displays the logo on the map.
	 * @private
	 */
	var LogoControl = /** @class */ (function (_super) {
	    __extends$j(LogoControl, _super);
	    /**
	     * Construct a control
	     */
	    function LogoControl(options) {
	        var _this = _super.call(this) || this;
	        _this.map = null;
	        /**
	         * Set visibility of the control based on the container width.
	         */
	        _this._onResize = function () {
	            var _a, _b;
	            var width = ((_b = (_a = _this.map) === null || _a === void 0 ? void 0 : _a.getMapContainer()) === null || _b === void 0 ? void 0 : _b.clientWidth) || 0;
	            _this._setVisiblity(_this.options.showLogo && width >= LogoControl.CONTAINER_MIN_WIDTH);
	        };
	        _this.options = new LogoControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    LogoControl.prototype.onAdd = function (map) {
	        var _a;
	        this.map = map;
	        this.container = this.buildContainer(map, exports.ControlStyle.auto);
	        this.container.className = "map-logo-control";
	        (_a = this.map) === null || _a === void 0 ? void 0 : _a.events.add("resize", this._onResize);
	        this._addRemoveLogo(this.options.showLogo);
	        return this.container;
	    };
	    LogoControl.prototype.onRemove = function () {
	        var _a;
	        _super.prototype.onRemove.call(this);
	        (_a = this.map) === null || _a === void 0 ? void 0 : _a.events.remove("resize", this._onResize);
	        this.map = null;
	        delete this.container;
	    };
	    LogoControl.prototype.setOptions = function (options) {
	        var newOptions = new LogoControlOptions().merge(this.options, options);
	        if (!newOptions.showLogo && this.logoAnchor) {
	            this._addRemoveLogo(false);
	        }
	        else if (newOptions.showLogo && !this.logoAnchor) {
	            this._addRemoveLogo(true);
	        }
	        this.options = newOptions;
	    };
	    LogoControl.prototype._addRemoveLogo = function (add) {
	        var _a, _b;
	        if (add) {
	            this.logoAnchor = document.createElement("a");
	            this.logoAnchor.className = "azure-map-logo";
	            this.logoAnchor.href = "https://aka.ms/azuremaps";
	            this.logoAnchor.setAttribute("aria-label", "Visit azure.microsoft.com");
	            this.logoAnchor.setAttribute("target", "_blank");
	            this.container.appendChild(this.logoAnchor);
	            this.logoTooltip = buildAccessibleTooltip("Visit azure.microsoft.com");
	            this.container.appendChild(this.logoTooltip);
	            positionTooltip(this.logoTooltip, this.logoAnchor);
	            this._setVisiblity(true);
	        }
	        else {
	            (_a = this.logoAnchor) === null || _a === void 0 ? void 0 : _a.remove();
	            (_b = this.logoTooltip) === null || _b === void 0 ? void 0 : _b.remove();
	            delete this.logoAnchor;
	            this._setVisiblity(false);
	        }
	    };
	    /**
	     * Set visibility of the control.
	     */
	    LogoControl.prototype._setVisiblity = function (visible) {
	        if (this.container) {
	            this.container.style.display = visible ? "flex" : "none";
	        }
	    };
	    LogoControl.CONTAINER_MIN_WIDTH = 480; // The minimum width of the container to show the logo, 5 copyright texts, and the feedback link.
	    return LogoControl;
	}(ControlBase));

	/**
	 * Provides some static methods to translate Mapbox's event based errors to try/catch style.
	 */
	var ErrorHandler = /** @class */ (function () {
	    function ErrorHandler() {
	    }
	    /**
	     * Executes the specified function and throws an error if Mapbox fires an error event.
	     * A call to this should be wrapped in a try/catch.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param func The function to execute.
	     * @internal
	     */
	    ErrorHandler.throwOnError = function (map, func) {
	        // Work directly with the Mapbox map.
	        var mbMap = map instanceof Map$1 ? map._getMap() : map;
	        // Listen for the error event and throw if one is seen.
	        var throwError = function (data) {
	            mbMap.off("error", throwError);
	            throw data.error;
	        };
	        mbMap.on("error", throwError);
	        // Execute the specified function and return the result.
	        // Stop the error listener before returning.
	        var result = func();
	        mbMap.off("error", throwError);
	        return result;
	    };
	    /**
	     * Executes the specified function and and throws an error if Mapbox fires an error event.
	     * The call is wrapped in a try/catch.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param tryFunc The function to try executing.
	     * @param catchFunc The function to execute if an error is fired.
	     * @param finallyFunc An optional function to execute in the finally block.
	     */
	    ErrorHandler.tryCatch = function (map, tryFunc, catchFunc, finallyFunc) {
	        try {
	            return this.throwOnError(map, tryFunc);
	        }
	        catch (error) {
	            return catchFunc(error);
	        }
	        finally {
	            if (typeof finallyFunc === "function") {
	                finallyFunc();
	            }
	        }
	    };
	    /**
	     * Executes the specified function and and throws an error if Mapbox fires an error event.
	     * The call is wrapped in a try/finally.
	     * @param map Either our map or the Mapbox map that will be firing the error events.
	     * @param tryFunc The function to try executing.
	     * @param finallyFunc An optional function to execute in the finally block.
	     */
	    ErrorHandler.tryFinally = function (map, tryFunc, finallyFunc) {
	        try {
	            return this.throwOnError(map, tryFunc);
	        }
	        finally {
	            finallyFunc();
	        }
	    };
	    return ErrorHandler;
	}());

	var __assign$6 = (window && window.__assign) || function () {
	    __assign$6 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$6.apply(this, arguments);
	};
	/**
	 * @private
	 */
	var NearbyGeographySearchService = /** @class */ (function () {
	    function NearbyGeographySearchService(map) {
	        this.map = map;
	    }
	    NearbyGeographySearchService.prototype.request = function (options) {
	        var _a;
	        var domain = this.map.getServiceOptions().domain;
	        var urlOptions = {
	            domain: domain,
	            path: "reverseGeocode",
	            queryParams: __assign$6({ "api-version": "2023-06-01", "coordinates": "".concat(normalizeLongitude(options.position[0]), ",").concat(normalizeLatitude(options.position[1])) }, (options.style.view && { view: options.style.view })),
	            headers: {
	                "Accept-Language": options.style.language
	            }
	        };
	        return new Url(((_a = this.map.authentication) === null || _a === void 0 ? void 0 : _a.signRequest(urlOptions)) || urlOptions).get();
	    };
	    return NearbyGeographySearchService;
	}());

	/** A static class that maintains a cache of place labels. */
	var MapLabelCache = /** @class */ (function () {
	    function MapLabelCache() {
	        this._labelCache = {};
	        this._labelIdx = {};
	        this._preloadedCache = new Set();
	    }
	    /**
	     * Adds a label to the cache.
	     * @param label The label to cache.
	     * @param layerInfo The configu info for the label.
	     * @param pos The position of the label.
	     * @param lang The language of the label.
	     */
	    MapLabelCache.prototype.cache = function (name, layerInfo, pos, lang) {
	        var id = "".concat(name, "_").concat(pos[0], "_").concat(pos[1], "_").concat(lang);
	        if (!this._labelIdx[layerInfo.labelType]) {
	            this._labelIdx[layerInfo.labelType] = [];
	            this._labelCache[layerInfo.labelType] = [];
	        }
	        if (this._labelIdx[layerInfo.labelType].indexOf(id) === -1) {
	            // Add label to cache.
	            this._labelCache[layerInfo.labelType].push({
	                name: name,
	                radius: layerInfo.radius,
	                minZoom: layerInfo.minZoom,
	                maxZoom: layerInfo.maxZoom || 24,
	                position: pos
	            });
	            // Add label to index.
	            this._labelIdx[layerInfo.labelType].push(id);
	        }
	    };
	    /**
	     * Calculates the nearest label in the cache.
	     * @param labelType The type/category of the label in which the label is seperated into.
	     * @param pos The position to center the search on.
	     */
	    MapLabelCache.prototype.getNearestLabel = function (labelType, pos, zoom) {
	        var nearest = null;
	        var c = this._labelCache[labelType];
	        if (c) {
	            var minDistance = Infinity;
	            for (var i = 0, len = c.length; i < len; i++) {
	                if (zoom >= c[i].minZoom && zoom <= c[i].maxZoom) {
	                    var d = getDistanceTo(c[i].position, pos);
	                    if (d <= c[i].radius && d <= minDistance) {
	                        minDistance = d;
	                        nearest = c[i];
	                    }
	                }
	            }
	        }
	        return nearest;
	    };
	    /**
	     * This function preloads the cache with major labels for a select few languages
	     * in which these labels are most likely to be used with.
	     * This is to help with identifying these major labels when the user is zoomed in close to the map.
	     * In testing, this has been found to drastically reduce the number of times "unknown" is returned
	     * for locations that border an ocean. Based on Bing Maps usage,
	     * the following languages cover 98% of traffic they recieve.
	     * Limiting the languages to those most likely to be used on the broder with an ocean.
	     * @param lang The language to load into the cache.
	     */
	    MapLabelCache.prototype._preloadCache = function (lang) {
	        // Only load a language once into cache.
	        if (!this._preloadedCache.has(lang)) {
	            // Translations for oceans: https://en.wikipedia.org/wiki/List_of_alternative_names_for_oceans
	            this._preloadedCache.add(lang);
	            var oceanConfig = {
	                source: [],
	                labelType: "water",
	                minZoom: 0,
	                radius: 3950000,
	                polygonSources: [] // doesn't affect the cache key
	            };
	            var shortLang = lang;
	            var index = shortLang.indexOf("-");
	            if (index !== -1) {
	                shortLang = shortLang.substr(0, index);
	            }
	            switch (shortLang) {
	                case "fr":
	                    this.cache("Océan Pacifique", oceanConfig, [-170, 32], lang);
	                    this.cache("Océan Pacifique", oceanConfig, [-138, -27], lang);
	                    this.cache("Océan Atlantique", oceanConfig, [-40, 32], lang);
	                    this.cache("Océan Atlantique", oceanConfig, [-17, -29], lang);
	                    break;
	                case "es":
	                    this.cache("Océan Pacifique", oceanConfig, [-170, 32], lang);
	                    this.cache("Océan Pacifique", oceanConfig, [-138, -27], lang);
	                    this.cache("Océano Atlántico", oceanConfig, [-40, 32], lang);
	                    this.cache("Océano Atlántico", oceanConfig, [-17, -29], lang);
	                    break;
	                case "pt":
	                    this.cache("Oceano Pacífico", oceanConfig, [-170, 32], lang);
	                    this.cache("Oceano Pacífico", oceanConfig, [-138, -27], lang);
	                    this.cache("Oceano Atlântico", oceanConfig, [-40, 32], lang);
	                    this.cache("Oceano Atlântico", oceanConfig, [-17, -29], lang);
	                    break;
	                case "ja":
	                    // Pacific Ocean
	                    this.cache("太平洋", oceanConfig, [-170, 32], lang);
	                    this.cache("太平洋", oceanConfig, [-138, -27], lang);
	                    break;
	                case "en":
	                    this.cache("Pacific Ocean", oceanConfig, [-170, 32], lang);
	                    this.cache("Pacific Ocean", oceanConfig, [-138, -27], lang);
	                    this.cache("Atlantic Ocean", oceanConfig, [-40, 32], lang);
	                    this.cache("Atlantic Ocean", oceanConfig, [-17, -29], lang);
	                    this.cache("Indian Ocean", oceanConfig, [77, -26], lang);
	                    break;
	            }
	        }
	    };
	    return MapLabelCache;
	}());

	var __awaiter$5 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$5 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$b = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$9 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * This class analyizes the current view of a map and provides a description for use by accessibilty tools.
	 * TODO: Use services when in  GeoPol regions. (Kasmir) or when user region sensitive.
	 */
	var MapViewDescriptor = /** @class */ (function () {
	    function MapViewDescriptor(map, descCallback) {
	        var _this = this;
	        // Track if disposed.
	        this._disposed = false;
	        // Track when the last description update occurred due to rotation.
	        this._lastHeadingTime = 0;
	        // A queue of the actions that haven't been described yet.
	        this._actionQueue = [];
	        // Number of milliseconds required for the pointer to be held down to get a description of that location.
	        this._pointerUpdateDelay = 3000;
	        // Number of milliseconds required between move end and the description update.
	        this._camUpdateDelay = 1000;
	        // Number of milliseconds required between heading description updates.
	        this._headUpdateLimit = 1000;
	        // Number of milliseconds to wait before acting on a move event originating from a control element.
	        this._controlEventDelay = 500;
	        // The minium number of pixels the map must move to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._moveThreshold = 25;
	        // The minium number of degrees the map must rotate to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._headingThreshold = 5;
	        // The minium number of degrees the map must pitch to trigger an update.
	        // The larger this number is, the less updates will be triggered, but the less accurate the results will be.
	        this._pitchThreshold = 5;
	        // The number of pixels to search around the center for a road, or major label.
	        this._roadPixelRadius = 120;
	        // Minum distance a road has to be before it can be displayed. Only used when zoomed in close.
	        this._minRoadDistance = 25;
	        // Minium distance in pixels a second road must be in order to be considered an intersection.
	        this._minIntersectionPixelDistance = 50;
	        /*
	         * Show details based on zoom level.
	         *
	         * Country: 1+
	         * Water: 1+
	         * States: 4+
	         * City: 8+
	         * Major POI: 8+  or 12+
	         * Neighborhood: 12+
	         * Poi: 16+
	         * Road: 16+
	         *
	         * The following label types will be cached; Country, State, City, Water, and majorPoi.
	         * The purpose of the cache is to provide a backup if no information is found in the source,
	         * we can do a radial search for appropriate label type.
	         * These often cover large areas and only have a single label.
	         * When zoomed in, no icon is visible, so based on the type of polygon the center intersects with,
	         * we can make an educated guess on what cache to pull a label from.
	         *
	         * Vector Tile source layers: https://developer.tomtom.com/maps-api/maps-api-documentation-vector/tile
	         */
	        // Configuration for label extraction.
	        this._labelConfig = [
	            // Water labels
	            {
	                source: ["Ocean label", "Ocean name"],
	                labelType: "water",
	                minZoom: 0, radius: 3950000,
	                polygonSources: ["Ocean", "Ocean or sea"]
	            },
	            {
	                source: ["Sea label"],
	                labelType: "water",
	                minZoom: 3,
	                radius: 1000000,
	                polygonSources: ["Sea", "Ocean or sea"]
	            },
	            // Country labels
	            {
	                source: ["Country name"],
	                labelType: "country",
	                minZoom: 0,
	                maxZoom: 5,
	                radius: 300000
	            },
	            // State labels
	            {
	                source: ["State name", "State name short"],
	                labelType: "state",
	                minZoom: 4,
	                maxZoom: 7,
	                radius: 300000
	            },
	            // City labels
	            {
	                source: ["Capital city", "Large city"],
	                labelType: "city", minZoom: 8,
	                radius: 40000
	            },
	            {
	                source: ["Medium city"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 30000
	            },
	            {
	                source: ["Small city"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 20000
	            },
	            {
	                source: ["Island label"],
	                labelType: "city",
	                minZoom: 8,
	                radius: 10000
	            },
	            {
	                source: ["Town"],
	                labelType: "city",
	                minZoom: 10,
	                radius: 10000
	            },
	            // Neighbourhood labels
	            {
	                source: ["Village"],
	                labelType: "neighbourhood",
	                minZoom: 12,
	                radius: 6000
	            },
	            // POI labels
	            {
	                source: ["Amusement area label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 2000,
	                polygonSources: ["Amusement park"]
	            },
	            {
	                source: ["Hospital label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Hospital"]
	            },
	            {
	                source: ["Shopping centre label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Shopping"]
	            },
	            {
	                source: ["Stadium label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Stadium"]
	            },
	            {
	                source: ["University/School label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["University"]
	            },
	            {
	                source: ["Zoo label"],
	                labelType: "poi",
	                minZoom: 14,
	                radius: 1000,
	                polygonSources: ["Zoo"]
	            },
	            // Major Poi labels
	            {
	                source: ["Airport Label", "Airport name", "Airport POI"],
	                labelType: "majorPoi",
	                minZoom: 11,
	                radius: 3000,
	                polygonSources: ["Airport", "Runway"]
	            },
	            {
	                source: ["National park label"],
	                labelType: "majorPoi",
	                minZoom: 7,
	                radius: 15000,
	                polygonSources: ["National or state park", "National park", "Forest"]
	            },
	            {
	                source: ["Reservation label"],
	                labelType: "majorPoi",
	                minZoom: 7,
	                radius: 15000,
	                polygonSources: ["Reservation"]
	            }
	        ];
	        // Name of all label types to cache.
	        this._labelCache = new Set(["city", "state", "country", "water", "majorPoi"]);
	        // Name of all road source layers.
	        this._roadLayers = new Set([
	            "Connecting road",
	            "Connecting road tunnel",
	            "International road",
	            "International road tunnel",
	            "Local road",
	            "Local road tunnel",
	            "Major local road",
	            "Major local road tunnel",
	            "Major road",
	            "Major road tunnel",
	            "Minor local road",
	            "Minor local road tunnel",
	            "Motorway",
	            "Motorway tunnel",
	            "Secondary road",
	            "Secondary road tunnel",
	            "Toll connecting road",
	            "Toll connecting road tunnel",
	            "Toll international road",
	            "Toll international road tunnel",
	            "Toll local road",
	            "Toll local road tunnel",
	            "Toll major local road",
	            "Toll major local road tunnel",
	            "Toll major road",
	            "Toll major road tunnel",
	            "Toll minor local road",
	            "Toll minor local road tunnel",
	            "Toll motorway",
	            "Toll motorway tunnel",
	            "Toll secondary road",
	            "Toll secondary road tunnel"
	        ]);
	        // Flag indicating if detailed descriptions which include zoom, lat/lon information should be returned.
	        this._returnDetailedDescriptions = false;
	        /** Event handler for shortcuts. */
	        this._shortcutListener = function (e) { return __awaiter$5(_this, void 0, void 0, function () {
	            var cam, styleOps, lang, style, camDesc;
	            return __generator$5(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!(e.altKey && e.ctrlKey && e.keyCode === 68)) return [3 /*break*/, 2];
	                        this._returnDetailedDescriptions = !this._returnDetailedDescriptions;
	                        cam = this._map.getCamera();
	                        styleOps = this._map.getStyle();
	                        lang = styleOps.language.toLowerCase();
	                        style = styleOps.style.toLowerCase();
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 1:
	                        camDesc = _a.sent();
	                        this._descCallback(camDesc);
	                        _a.label = 2;
	                    case 2: return [2 /*return*/];
	                }
	            });
	        }); };
	        /** Event handler for when the map is actively rotating and should update the heading description. */
	        this._onRotate = function () {
	            if (!_this._rotateTimeout) {
	                if (Date.now() - _this._lastHeadingTime >= _this._headUpdateLimit) {
	                    // If the min required time has already passed just do the update.
	                    // tslint:disable-next-line: no-string-based-set-timeout
	                    _this._rotateTimeout = setTimeout(_this._updateHeading, CompassControl.RotationDuration + 25);
	                }
	                else {
	                    // If the min required time hasn't passed start a timeout if doesn't already exist.
	                    // tslint:disable-next-line: no-string-based-set-timeout
	                    _this._rotateTimeout = setTimeout(_this._updateHeading, _this._headUpdateLimit - (Date.now() - _this._lastHeadingTime));
	                }
	            }
	        };
	        /** Event handler for when the map is actively moving should wait to update the camera description. */
	        this._onMove = function () {
	            // Clear the timeout for updating the map's camera description.
	            if (_this._moveTimeout) {
	                clearTimeout(_this._moveTimeout);
	                delete _this._moveTimeout;
	            }
	            // Clear the timeout for delaying updates originating from control elements.
	            if (_this._controlTimeout) {
	                clearTimeout(_this._controlTimeout);
	                delete _this._controlTimeout;
	            }
	        };
	        /** Event handler for when the mas has stopped moving and thus a new description is needed. */
	        this._onMoveEnd = function (event) {
	            if (event.fromControl) {
	                // If the move end event originated from a control element delay the response to batch control clicks.
	                // tslint:disable-next-line: no-string-based-set-timeout
	                _this._controlTimeout = setTimeout(_this._updateCam, _this._controlEventDelay);
	            }
	            else {
	                // Otherwise start processing a new description immediately.
	                _this._updateCam();
	            }
	        };
	        /** Event handler for when the map has changed styles. */
	        this._onStyleData = function () {
	            // Use setTimeout with no delay to allow mapbox time to
	            // update the value of .loaded() before we check it.
	            // tslint:disable-next-line: no-string-based-set-timeout
	            setTimeout(_this._updateStyle);
	        };
	        /** Event handler for when the mouse or touch goes down */
	        this._onPointerDown = function (event) {
	            _this._lastPointerPos = _this._getEventPos(event);
	            _this._pointerTimeout = setTimeout(function () { return __awaiter$5(_this, void 0, void 0, function () {
	                var styleOps, lang, style, cam, loc;
	                return __generator$5(this, function (_a) {
	                    switch (_a.label) {
	                        case 0:
	                            styleOps = this._map.getStyle();
	                            lang = styleOps.language.toLowerCase();
	                            style = styleOps.style.toLowerCase();
	                            cam = this._map.getCamera();
	                            cam.center = this._map.pixelsToPositions([this._lastPointerPos])[0];
	                            return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                        case 1:
	                            loc = _a.sent();
	                            this._descCallback(loc);
	                            this._onPointerUp();
	                            return [2 /*return*/];
	                    }
	                });
	            }); }, _this._pointerUpdateDelay);
	            // Start listening for the pointer moving in-case it moves far enough to cancel the location update.
	            _this._map.getCanvas().addEventListener("mousemove", _this._onPointerMove);
	            _this._map.getCanvas().addEventListener("touchmove", _this._onPointerMove);
	            // Start listening for the pointer to go up to cancel the location update.
	            _this._map.getCanvas().addEventListener("mouseup", _this._onPointerUp);
	            _this._map.getCanvas().addEventListener("touchend", _this._onPointerUp);
	        };
	        /** Event handler for when the mouse or touch is moved */
	        this._onPointerMove = function (event) {
	            var pos = _this._getEventPos(event);
	            var dx = _this._lastPointerPos[0] - pos[0];
	            var dy = _this._lastPointerPos[1] - pos[1];
	            var dist = Math.sqrt(dx * dx + dy * dy);
	            if (dist > _this._moveThreshold) {
	                _this._onPointerUp();
	            }
	        };
	        /** Event handler for when the mouse or touch goes up */
	        this._onPointerUp = function () {
	            clearTimeout(_this._pointerTimeout);
	            delete _this._pointerTimeout;
	            _this._map.getCanvas().removeEventListener("mousemove", _this._onPointerMove);
	            _this._map.getCanvas().removeEventListener("touchmove", _this._onPointerMove);
	            _this._map.getCanvas().removeEventListener("mouseup", _this._onPointerUp);
	            _this._map.getCanvas().removeEventListener("touchend", _this._onPointerUp);
	        };
	        /** Called when the map is rotating and needs a new description created */
	        this._updateHeading = function () {
	            // Update the heading description.
	            var cam = _this._map.getCamera();
	            if (!_this._lastHead || _this._checkHeadingThreshold(cam.bearing, _this._lastHead)) {
	                // Update the last heading value and update time.
	                var headDesc = _this._getHeadingDesc(cam);
	                _this._lastHead = cam.bearing;
	                _this._descCallback("<p>Map heading ".concat(headDesc, ".</p>"));
	                _this._lastHeadingTime = Date.now();
	            }
	            // Reset for the next rotate.
	            delete _this._rotateTimeout;
	        };
	        /** Called when the map has finished changing styles and is ready to create a new description */
	        this._updateStyle = function () { return __awaiter$5(_this, void 0, void 0, function () {
	            var cam, styleOps, lang, style, camDesc;
	            return __generator$5(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        cam = this._map.getCamera();
	                        styleOps = this._map.getStyle();
	                        lang = styleOps.language.toLowerCase();
	                        style = styleOps.style.toLowerCase();
	                        if (!(this._lastLang !== lang)) return [3 /*break*/, 2];
	                        MapViewDescriptor._labelCache._preloadCache(lang);
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 1:
	                        camDesc = _a.sent();
	                        return [3 /*break*/, 4];
	                    case 2:
	                        if (!(this._lastStyle !== style && this._lastStyle === "blank")) return [3 /*break*/, 4];
	                        return [4 /*yield*/, this._getLocDesc(cam, lang, style)];
	                    case 3:
	                        camDesc = _a.sent();
	                        _a.label = 4;
	                    case 4:
	                        // Update the last lang and style values.
	                        this._lastLang = lang;
	                        this._lastStyle = style;
	                        // Send the new description to the map.
	                        if (camDesc) {
	                            this._descCallback(camDesc);
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        }); };
	        /** Called when the map has finished updating and is ready to create a new description */
	        this._updateCam = function (immediate) {
	            if (immediate === void 0) { immediate = false; }
	            var cam = _this._map.getCamera();
	            if (!_this._lastCam || _this._actionQueue.length > 0 || _this._checkThresholds(cam, _this._lastCam)) {
	                var styleOps = _this._map.getStyle();
	                var lang_1 = styleOps.language.toLowerCase();
	                var style_1 = styleOps.style.toLowerCase();
	                // Update the action queue if an action is provided.
	                var action = _this._getActionDesc(cam);
	                if (action) {
	                    _this._actionQueue.push(action);
	                }
	                // Update the last camera value.
	                _this._lastCam = cam;
	                // Make sure no other timeouts are active.
	                if (_this._moveTimeout) {
	                    clearTimeout(_this._moveTimeout);
	                    delete _this._moveTimeout;
	                }
	                // Send the new description to the map.
	                _this._moveTimeout = setTimeout(function () { return __awaiter$5(_this, void 0, void 0, function () {
	                    var loc;
	                    return __generator$5(this, function (_a) {
	                        switch (_a.label) {
	                            case 0:
	                                // Clear the rotate timeout as the move description will cover rotation.
	                                clearTimeout(this._rotateTimeout);
	                                delete this._rotateTimeout;
	                                return [4 /*yield*/, this._getLocDesc(cam, lang_1, style_1)];
	                            case 1:
	                                loc = _a.sent();
	                                // Build the message from the action queue and current loc description.
	                                if (this._actionQueue.length > 0) {
	                                    this._descCallback("<p>Map ".concat(this._actionQueue.join(", then "), ".</p>").concat(loc));
	                                    this._actionQueue = []; // Reset the queue because all actions have been delivered.
	                                }
	                                else {
	                                    this._descCallback(loc);
	                                }
	                                return [2 /*return*/];
	                        }
	                    });
	                }); }, immediate ? 0 : _this._camUpdateDelay);
	            }
	        };
	        this._map = map;
	        this._restFallback = map.getServiceOptions().enableAccessibilityLocationFallback;
	        this._descCallback = descCallback;
	        this._reverseSearch = new NearbyGeographySearchService(map);
	        if (!MapViewDescriptor._labelCache) {
	            MapViewDescriptor._labelCache = new MapLabelCache();
	        }
	        this._lastLang = this._map.getStyle().language.toLowerCase();
	        MapViewDescriptor._labelCache._preloadCache(this._lastLang);
	        this._map.events.addOnce("idle", function () {
	            if (!_this._disposed) {
	                _this._updateCam(true);
	                // Find the id of the vector tile source being used.
	                _this._baseVectorTileSourceId = MapViewDescriptor._baseVectorTileSourceIds.find(function (id) { return _this._map.sources.getById(id); });
	                // Set the label config based on the vector tile source.
	                if (_this._baseVectorTileSourceId === "bing-mvt") {
	                    _this._labelConfig = MapViewDescriptor._labelConfigBing;
	                    _this._roadLayers = MapViewDescriptor._roadLayersBing;
	                }
	                // Derive polygon layers from the label config.
	                _this._polygonStyleLayer = _this._labelConfig.reduce(function (acc, cur) {
	                    if (cur.polygonSources) {
	                        acc.push.apply(acc, __spreadArray$9([], __read$b(cur.polygonSources), false));
	                    }
	                    return acc;
	                }, []);
	                // Add event listeners directly to mapbox because we will be using custom event data.
	                // We don't automatically forward all properties of a mapbox event, so the custom data would be lost.
	                var baseMap = _this._map._getMap();
	                baseMap.on("move", _this._onMove);
	                baseMap.on("moveend", _this._onMoveEnd);
	                baseMap.on("styledata", _this._onStyleData);
	                baseMap.on("rotate", _this._onRotate);
	                var canvas = _this._map.getCanvas();
	                canvas.addEventListener("mousedown", _this._onPointerDown);
	                canvas.addEventListener("touchstart", _this._onPointerDown);
	            }
	        });
	        this._map.getMapContainer().addEventListener("keydown", this._shortcutListener);
	    }
	    /** Disposes the MapViewDescriptor preventing any further updates */
	    MapViewDescriptor.prototype.dispose = function () {
	        this._disposed = true;
	        // Event listeners were added directly to mapbox.
	        // Remove them directly from there too.
	        var baseMap = this._map._getMap();
	        baseMap.off("move", this._onMove);
	        baseMap.off("moveend", this._onMoveEnd);
	        baseMap.off("styledata", this._onStyleData);
	        baseMap.off("rotate", this._onRotate);
	        var canvas = this._map.getCanvas();
	        canvas.removeEventListener("mousedown", this._onPointerDown);
	        canvas.removeEventListener("touchstart", this._onPointerDown);
	        this._map.getMapContainer().removeEventListener("keydown", this._shortcutListener);
	    };
	    MapViewDescriptor.prototype._getEventPos = function (event) {
	        if ("touches" in event) {
	            var touch = event.touches[0];
	            var rect = event.target.getBoundingClientRect();
	            return [touch.pageX - rect.left, touch.pageY - rect.top];
	        }
	        else {
	            return [event.offsetX, event.offsetY];
	        }
	    };
	    /** Checks if the camera has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkThresholds = function (newCam, lastCam) {
	        return this._checkZoomThreshold(newCam.zoom, lastCam.zoom) ||
	            this._checkPitchThreshold(newCam.pitch, lastCam.pitch) ||
	            this._checkLocThreshold(newCam.center, lastCam.center) ||
	            this._checkHeadingThreshold(newCam.bearing, lastCam.bearing);
	    };
	    /** Checks if the zoom has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkZoomThreshold = function (newZoom, lastZoom) {
	        return this._round(newZoom) !== this._round(lastZoom);
	    };
	    /** Checks if the pitch has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkPitchThreshold = function (newPitch, lastPitch) {
	        return Math.abs(newPitch - lastPitch) >= this._pitchThreshold;
	    };
	    /** Checks if the location has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkLocThreshold = function (newCenter, lastCenter) {
	        var _a;
	        var lastPixel = (_a = __read$b(this._map.positionsToPixels([lastCenter, newCenter]), 2), _a[0]), newPixel = _a[1];
	        return Pixel.getDistance(lastPixel, newPixel) >= this._moveThreshold;
	    };
	    /** Checks if the heading has changed enough to justify a new description */
	    MapViewDescriptor.prototype._checkHeadingThreshold = function (newHeading, lastHeading) {
	        // Modify the heading values to always be positive.
	        if (newHeading < 0) {
	            newHeading += 360;
	        }
	        if (lastHeading < 0) {
	            lastHeading += 360;
	        }
	        // If the heading diff is greater than 180 it is
	        // less difference in the other direction of rotation.
	        var headDiff = Math.abs(newHeading - lastHeading);
	        if (headDiff > 180) {
	            headDiff = 360 - headDiff;
	        }
	        return headDiff >= this._headingThreshold;
	    };
	    /**
	     * Generates the description for the map view around the center of the map.
	     * @param cam The map camera informaiton.
	     */
	    MapViewDescriptor.prototype._getLocDesc = function (cam, lang, style) {
	        return __awaiter$5(this, void 0, void 0, function () {
	            var info_1, cPx_1, intersects_1, intersectingPolygon, intersectingType_1, i, cnt, layerInfo, cl_1;
	            var _this = this;
	            return __generator$5(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!(style !== "blank")) return [3 /*break*/, 3];
	                        if (!!this._map._getMap().loaded()) return [3 /*break*/, 2];
	                        return [4 /*yield*/, new Promise(function (done) { return _this._map._getMap().once("idle", done); })];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        info_1 = {};
	                        cPx_1 = this._map.positionsToPixels([cam.center])[0];
	                        ErrorHandler.tryCatch(this._map, function () {
	                            var map = _this._map._getMap();
	                            intersects_1 = map.queryRenderedFeatures(cPx_1, {
	                                layers: _this._polygonStyleLayer.filter(function (layerId) { return map.getLayer(layerId); }),
	                                filter: ["==", ["geometry-type"], "Polygon"]
	                            });
	                        }, function () { });
	                        intersectingPolygon = null;
	                        if (intersects_1 && intersects_1.length > 0) {
	                            intersectingPolygon = intersects_1[0];
	                        }
	                        intersectingType_1 = null;
	                        // Loop through each label config and try and retireve details about the map view.
	                        for (i = 0, cnt = this._labelConfig.length; i < cnt; i++) {
	                            layerInfo = this._labelConfig[i];
	                            if (cam.zoom >= layerInfo.minZoom) {
	                                // If the layer info has polygons defined, do an intersection test for matching.
	                                if (layerInfo.polygonSources) {
	                                    // Only if a value of the same type hasn't already been captured and the intersection polygon has the same source, retrieve a label.
	                                    if (intersectingPolygon &&
	                                        layerInfo.polygonSources.indexOf(intersectingPolygon.layer["source-layer"]) !== -1) {
	                                        intersectingType_1 = layerInfo.labelType;
	                                        this._getClosestLabel(layerInfo, cam, lang, info_1, false);
	                                    }
	                                    else {
	                                        // If the polygon doesn't intersect, cache labels.
	                                        this._getClosestLabel(layerInfo, cam, lang, info_1, true);
	                                    }
	                                }
	                                else {
	                                    this._getClosestLabel(layerInfo, cam, lang, info_1, false);
	                                }
	                            }
	                            else {
	                                this._getClosestLabel(layerInfo, cam, lang, info_1, true);
	                            }
	                        }
	                        if (cam.zoom >= 8) {
	                            // When zoomed in get all the roads as possible that roads might be only near edge.
	                            // Need road to determine state info when zoomed in.
	                            this._processRoads(info_1, cam, lang);
	                        }
	                        this._labelCache.forEach(function (label) {
	                            if (!info_1[label]) {
	                                cl_1 = null;
	                                if (label === "water" || label === "majorPoi") {
	                                    // Only check cache for water and majorPoi labels if the map is over top of water or a major Poi.
	                                    if (label === intersectingType_1) {
	                                        cl_1 = MapViewDescriptor._labelCache.getNearestLabel(label, cam.center, cam.zoom);
	                                    }
	                                }
	                                else {
	                                    cl_1 = MapViewDescriptor._labelCache.getNearestLabel(label, cam.center, cam.zoom);
	                                }
	                                if (cl_1) {
	                                    info_1[label] = cl_1.name;
	                                }
	                            }
	                        });
	                        return [2 /*return*/, this._processLocInfo(cam, intersectingType_1, info_1, true, this._restFallback)];
	                    case 3: 
	                    // If the style is blank don't provide a label as that would always require a reverse geocode api call.
	                    return [2 /*return*/, this._processLocInfo(cam, null, null, false, false)];
	                }
	            });
	        });
	    };
	    /**
	     * Generates the description for the map view around the center of the map.
	     * @param cam The map camera informaiton.
	     */
	    MapViewDescriptor.prototype._getHeadingDesc = function (cam) {
	        // Use the heading but shift any negative values.
	        var heading = cam.bearing;
	        if (heading < 0) {
	            heading += 360;
	        }
	        // Snap to the nearest 5 degrees.
	        heading = this._round(heading, this._headingThreshold);
	        // Generate a new description.
	        switch (heading) {
	            case 0:
	            case 360:
	                return "north";
	            case 45:
	                return "north east";
	            case 90:
	                return "east";
	            case 135:
	                return "south east";
	            case 180:
	                return "south";
	            case 225:
	                return "south west";
	            case 270:
	                return "west";
	            case 315:
	                return "north west";
	            default:
	                return "".concat(heading, " degrees");
	        }
	    };
	    /**
	     * Gets the closest label to the center of the map.
	     * @param layerInfo The label lauyer information.
	     * @param cam The map camera information.
	     * @param info The result information.
	     * @param cacheOnly Specifies if labels should only be cached and not set on the result.
	     */
	    MapViewDescriptor.prototype._getClosestLabel = function (layerInfo, cam, lang, info, cacheOnly) {
	        var radius = layerInfo.radius;
	        // Loop through the label sources.
	        for (var i = 0, len = layerInfo.source.length; i < len; i++) {
	            var params = {
	                sourceLayer: layerInfo.source[i],
	                filter: ["has", "name"]
	            };
	            var labels = this._map._getMap().querySourceFeatures(this._baseVectorTileSourceId, params);
	            var closest = null;
	            var minDistance = Infinity;
	            var cacheLabels = this._labelCache.has(layerInfo.labelType);
	            if (!cacheOnly || (cacheOnly && cacheLabels)) {
	                for (var j = 0, cnt = labels.length; j < cnt; j++) {
	                    var p = labels[j].geometry.type === "Point" ?
	                        labels[j] :
	                        getClosestPointOnGeometry(cam.center, labels[j].geometry);
	                    if (!cacheOnly) {
	                        // Distance in meters.
	                        var d = labels[j].geometry.type === "Point" ?
	                            getDistanceTo(cam.center, p.geometry.coordinates) :
	                            p.properties.distance;
	                        if (d < minDistance) {
	                            minDistance = d;
	                            closest = labels[j];
	                        }
	                    }
	                    if (cacheLabels) {
	                        MapViewDescriptor._labelCache.cache(labels[j].properties.name, layerInfo, p.geometry.coordinates, lang);
	                    }
	                }
	            }
	            if (!cacheOnly) {
	                var disParam = layerInfo.labelType + "Dis";
	                if (closest && minDistance <= radius &&
	                    (typeof info[disParam] !== "number" || minDistance <= info[disParam])) {
	                    info[layerInfo.labelType] = closest.properties.name;
	                    info[disParam] = minDistance;
	                }
	            }
	        }
	    };
	    /**
	     * Retrieve road information and extracts the closest road (within a threshold), as well as any state/country data that might be on it.
	     * @param info The MapViewInfo object in which the results are added.
	     * @param cam The map camera information.
	     * @param searchArea An optional search area to limit the scope of where roads are extracted from.
	     */
	    MapViewDescriptor.prototype._processRoads = function (info, cam, lang, searchArea) {
	        // Try and get road data. This provides additional country/state info, and also road names.
	        var roads = this._map._getMap().queryRenderedFeatures(searchArea, {
	            filter: ["==", ["geometry-type"], "LineString"]
	        });
	        if (roads) {
	            var closestRoad = void 0;
	            var closestRoad2 = void 0;
	            var cPoint = void 0;
	            var cPoint2 = void 0;
	            // Get the closest road.
	            for (var i = 0, len = roads.length; i < len; i++) {
	                if (this._roadLayers.has(roads[i].layer["source-layer"])) {
	                    if (roads[i].properties.name && roads[i].properties.name !== "") {
	                        var cp = getClosestPointOnGeometry(cam.center, roads[i]);
	                        if (!cPoint || cp.properties.distance < cPoint.properties.distance) {
	                            if (closestRoad && roads[i].properties.name === closestRoad.properties.name) {
	                                cPoint = cp;
	                            }
	                            else if (!closestRoad || roads[i].properties.name !== closestRoad.properties.name) {
	                                cPoint2 = cPoint;
	                                closestRoad2 = closestRoad;
	                                cPoint = cp;
	                                closestRoad = roads[i];
	                            }
	                            else if (!cPoint2 || cp.properties.distance < cPoint2.properties.distance) {
	                                cPoint2 = cp;
	                                closestRoad2 = roads[i];
	                            }
	                        }
	                    }
	                }
	            }
	            if (closestRoad) {
	                // Capture state and country codes from the closest road to ensure we have the most accurate values.
	                // Note: bing tiles do not have country_code and country_subdivision in road features.
	                if (!info.country && closestRoad.properties.country_code) {
	                    info.country = closestRoad.properties.country_code;
	                    info.countryDis = 0;
	                    MapViewDescriptor._labelCache.cache(info.country, {
	                        source: [],
	                        labelType: "country",
	                        radius: 5000,
	                        minZoom: 0
	                    }, cPoint.geometry.coordinates, lang);
	                }
	                if (!info.state && closestRoad.properties.country_subdivision) {
	                    info.state = closestRoad.properties.country_subdivision;
	                    info.stateDis = 0;
	                    MapViewDescriptor._labelCache.cache(info.state, {
	                        source: [],
	                        labelType: "state",
	                        radius: 5000,
	                        minZoom: 4
	                    }, cPoint.geometry.coordinates, lang);
	                }
	                // Only capture road name if zoomed in and close enough to the center of the map.
	                if (cam.zoom >= 15) {
	                    var pixels = this._map.positionsToPixels([cam.center, cPoint.geometry.coordinates]);
	                    var pxDis = Pixel.getDistance(pixels[0], pixels[1]);
	                    if (pxDis < this._roadPixelRadius || cPoint.properties.distance < this._minRoadDistance) {
	                        info.road = closestRoad.properties.name;
	                    }
	                    if (closestRoad2) {
	                        var px = this._map.positionsToPixels([cPoint2.geometry.coordinates]);
	                        pxDis = Pixel.getDistance(pixels[0], px[0]);
	                        if (pxDis < this._minIntersectionPixelDistance || cPoint2.properties.distance < this._minRoadDistance) {
	                            info.secondRoad = closestRoad2.properties.name;
	                            info.secondRoadDis = cPoint2.properties.distance;
	                        }
	                    }
	                }
	            }
	        }
	    };
	    /**
	     * Generates a description of the most recent map actions.
	     * @param cam The map camera information.
	     */
	    MapViewDescriptor.prototype._getActionDesc = function (cam) {
	        if (this._lastCam) {
	            // Build and array of actions that have occurred.
	            // Will be flattened into just a string at the end.
	            var actions = [];
	            // Panning/Center
	            if (this._checkLocThreshold(cam.center, this._lastCam.center)) {
	                // Build the panning message is stages.
	                var msg = ["panned"];
	                var heading = Math.round(getHeading(this._lastCam.center, cam.center));
	                // Assign a cardinal direction for the panning.
	                if (heading === 0 || heading === 360) {
	                    msg.push("north");
	                }
	                else if (heading < 90) {
	                    msg.push("north east");
	                }
	                else if (heading === 90) {
	                    msg.push("east");
	                }
	                else if (heading < 180) {
	                    msg.push("south east");
	                }
	                else if (heading === 180) {
	                    msg.push("south");
	                }
	                else if (heading < 270) {
	                    msg.push("south west");
	                }
	                else if (heading === 270) {
	                    msg.push("west");
	                }
	                else if (heading < 360) {
	                    msg.push("north west");
	                }
	                // If the distance is greater than 1000 use KM instead of meters.
	                var distance = getDistanceTo(this._lastCam.center, cam.center, DistanceUnits.meters);
	                msg.push(distance > 1000 ?
	                    "".concat(_precision(distance / 1000, 2), " kilometers") :
	                    "".concat(_precision(distance, 2), " meters"));
	                // Add the complete message to the actions array.
	                actions.push(msg.join(" "));
	            }
	            // Zoom
	            if (this._checkZoomThreshold(cam.zoom, this._lastCam.zoom)) {
	                // Start with zoom and the direction of change.
	                var msg = ["zoomed"];
	                msg.push(this._lastCam.zoom < cam.zoom ? "in" : "out");
	                // Include the number of levels changed if greater than 1.
	                var diff = Math.abs(this._lastCam.zoom - cam.zoom);
	                if (diff >= 1) {
	                    // Round the zoom level difference to the nearest integer.
	                    diff = Math.ceil(diff);
	                    // Add the number of levels difference.
	                    msg.push(diff > 1 ?
	                        "".concat(diff, " levels") :
	                        "".concat(diff, " level"));
	                }
	                // If the canonical zoom name is different include the new name.
	                if (this._getCanonicalZoom(this._lastCam.zoom) !== this._getCanonicalZoom(cam.zoom)) {
	                    msg.push("to ".concat(this._getCanonicalZoom(cam.zoom), " level"));
	                }
	                // announce maximum zoom reached
	                if (cam.zoom >= cam.maxZoom) {
	                    msg.push("Zoom In button disabled, maximum zoom level reached");
	                }
	                var reachedLatitudeBoundaries = BoundingBox.getSouth(cam.bounds) <= -WEBMERCATOR_MAXLAT
	                    && BoundingBox.getNorth(cam.bounds) >= WEBMERCATOR_MAXLAT;
	                // annouce minimum zoom level reached
	                if (cam.zoom <= cam.minZoom || reachedLatitudeBoundaries) {
	                    msg.push("Zoom Out button disabled, minimum zoom level reached");
	                }
	                // Add the complete message to the actions array.
	                actions.push(msg.join(" "));
	            }
	            // Pitch
	            if (this._checkPitchThreshold(cam.pitch, this._lastCam.pitch)) {
	                // If the pitch has changed enough add the new pitch value to the actions array.
	                var pitch = this._round(cam.pitch, this._pitchThreshold);
	                actions.push("pitched to ".concat(pitch, " degrees"));
	                if (cam.pitch === 60 || cam.pitch === 0) {
	                    var maxOrMim = cam.pitch === 60 ? "maximum" : "minimum";
	                    actions.push("reached ".concat(maxOrMim, " of ").concat(cam.pitch, " degrees"));
	                }
	            }
	            // Heading
	            if (this._checkHeadingThreshold(this._lastCam.bearing, cam.bearing)) {
	                actions.push("rotated to ".concat(this._getHeadingDesc(cam)));
	            }
	            // Return the flattened list of actions as one string.
	            return actions.join(" and ") || null;
	        }
	        return null;
	    };
	    /** Gets the canonical zoom level name, such as world, country, or city level. */
	    MapViewDescriptor.prototype._getCanonicalZoom = function (zoom) {
	        // Determine the canonical name based on the rounded zoom level.
	        zoom = this._round(zoom);
	        // Determine the canonical name.
	        if (zoom < 2) {
	            return "world";
	        }
	        else if (zoom < 5) {
	            return "country";
	        }
	        else if (zoom < 11) {
	            return "state province";
	        }
	        else if (zoom < 15) {
	            return "city";
	        }
	        return "street"; // Zoom 15+ is street level.
	    };
	    /**
	     * Generates a description from extracted location information.
	     * @param cam The map camera information.
	     * @param info The extracted locaiton information.
	     * @returns A string description for the map view.
	     */
	    MapViewDescriptor.prototype._processLocInfo = function (cam, intersectingType, info, location, restFallback) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var html = [];
	            if (location) {
	                /*
	                 * Show details based on zoom level.
	                 *
	                 * Country: 1+
	                 * Water: 1+
	                 * States: 4+
	                 * City: 6+
	                 * Major POI: 8+
	                 * Neighborhood: 12+
	                 * Poi: 14+
	                 * Road: 15+
	                 */
	                var text = [];
	                if (info) {
	                    if (intersectingType) {
	                        if (intersectingType === "water" && info.water) {
	                            text.push(info.water);
	                        }
	                        else if (intersectingType === "majorPoi" && info.majorPoi) {
	                            text.push(info.majorPoi);
	                        }
	                    }
	                    if (text.length === 0) {
	                        if (info.majorPoi && cam.zoom >= 8) {
	                            text.push(info.majorPoi);
	                        }
	                        else {
	                            if (info.poi && cam.zoom >= 14) {
	                                text.push(info.poi);
	                            }
	                            else if (info.road && cam.zoom >= 15) {
	                                if (info.secondRoad) {
	                                    text.push(info.road + " & " + info.secondRoad);
	                                }
	                                else {
	                                    text.push(info.road);
	                                }
	                            }
	                            if (info.neighbourhood && cam.zoom >= 12) {
	                                text.push(info.neighbourhood);
	                            }
	                            if (info.city && cam.zoom >= 6) {
	                                text.push(info.city);
	                            }
	                        }
	                        if (info.state && cam.zoom >= 4) {
	                            text.push(info.state);
	                        }
	                        if (text.length === 0) {
	                            if (info.water) {
	                                text.push(info.water);
	                            }
	                            else if (info.country) {
	                                text.push(info.country);
	                            }
	                        }
	                        else if (text.length === 1 && info.state && cam.zoom >= 4 && info.country) {
	                            text.push(info.country);
	                        }
	                    }
	                }
	                // TODO: need to support localization for these value.
	                if (text.length > 0) {
	                    html.push("<p>Location: ", text.join(", "), ".</p>");
	                }
	                else if (restFallback && intersectingType !== "water") {
	                    // No location text found, so fallback onto REST services, but only if map not over water.
	                    _this._reverseGeocodeDescription(cam).then(function (desc) {
	                        resolve(desc);
	                    }, function () {
	                        reject("<p>Location: unknown</p>");
	                    });
	                    return;
	                }
	            }
	            if (_this._returnDetailedDescriptions) {
	                html.push("<p>Zoom: ", _precision(cam.zoom, 2), ".</p>");
	                html.push("<p>Latitude: ", _precision(cam.center[1], 5), ".</p>");
	                html.push("<p>Longitude: ", _precision(cam.center[0], 5), ".</p>");
	            }
	            resolve(html.join(""));
	        });
	    };
	    /**
	     * Uses the reverse geocoding service to determine the description for the center of the map.
	     * @param cam The map camera information.
	     */
	    MapViewDescriptor.prototype._reverseGeocodeDescription = function (cam) {
	        var _this = this;
	        return new Promise(function (resolve) {
	            var style = _this._map.getStyle();
	            _this._reverseSearch.request({
	                position: cam.center,
	                style: style
	            }).then(function (r) {
	                var _a, _b, _c;
	                var info = {};
	                if (r && r.features && r.features.length > 0) {
	                    if ((_b = (_a = r.features[0]) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.address) {
	                        var a = r.features[0].properties.address;
	                        if (a.countryRegion) {
	                            info.country = a.countryRegion.name;
	                            MapViewDescriptor._labelCache.cache(info.country, {
	                                source: [],
	                                labelType: "country",
	                                radius: 5000,
	                                minZoom: 0
	                            }, cam.center, style.language);
	                        }
	                        if (a.adminDistricts) {
	                            info.state = (_c = a.adminDistricts[0]) === null || _c === void 0 ? void 0 : _c.shortName;
	                            MapViewDescriptor._labelCache.cache(info.state, {
	                                source: [],
	                                labelType: "state",
	                                radius: 5000,
	                                minZoom: 4
	                            }, cam.center, style.language);
	                        }
	                        if (a.locality) {
	                            info.city = a.locality;
	                            MapViewDescriptor._labelCache.cache(info.city, {
	                                source: [],
	                                labelType: "city",
	                                radius: 1000,
	                                minZoom: 10
	                            }, cam.center, style.language);
	                        }
	                        if (a.addressLine) {
	                            info.road = a.addressLine;
	                        }
	                    }
	                }
	                _this._processLocInfo(cam, null, info, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            }, function (error) {
	                _this._processLocInfo(cam, null, null, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            }).catch(function (e) {
	                _this._processLocInfo(cam, null, null, true, false).then(function (desc) {
	                    resolve(desc);
	                });
	            });
	        });
	    };
	    /** Rounds the input value to the nearest multiple of the specified increment value. */
	    MapViewDescriptor.prototype._round = function (val, increment) {
	        if (increment === void 0) { increment = 1; }
	        return Math.round(val / increment) * increment;
	    };
	    // Ids of vector tile sources for different style APIs.
	    MapViewDescriptor._baseVectorTileSourceIds = ["microsoft.base", "vectorTiles", "bing-mvt"];
	    // Configuration for label extraction of Bing tiles.
	    MapViewDescriptor._labelConfigBing = [
	        // Water labels
	        {
	            source: ["water_feature"],
	            labelType: "water",
	            minZoom: 0,
	            radius: 3950000,
	            polygonSources: ["generic_water_fill"]
	        },
	        {
	            source: ["water_feature"],
	            labelType: "water",
	            minZoom: 3,
	            radius: 1000000,
	            polygonSources: ["generic_water_fill"]
	        },
	        // Country labels
	        {
	            source: ["country_region"],
	            labelType: "country",
	            minZoom: 0,
	            maxZoom: 5,
	            radius: 300000
	        },
	        // State labels
	        {
	            source: ["admin_division1"],
	            labelType: "state",
	            minZoom: 4,
	            maxZoom: 7,
	            radius: 300000
	        },
	        // City labels
	        {
	            source: ["populated_place"],
	            labelType: "city",
	            minZoom: 8,
	            radius: 40000
	        },
	        // Neighbourhood labels
	        {
	            source: ["neighborhood"],
	            labelType: "neighbourhood",
	            minZoom: 12,
	            radius: 6000
	        },
	        // POI labels
	        {
	            source: ["amusement_park"],
	            labelType: "poi",
	            minZoom: 14,
	            radius: 2000,
	            polygonSources: ["amusement_park_fill"]
	        },
	        {
	            source: ["hospital"],
	            labelType: "poi",
	            minZoom: 14,
	            radius: 1000,
	            polygonSources: ["hospital_fill"]
	        },
	        {
	            source: ["shopping_center"],
	            labelType: "poi",
	            minZoom: 14,
	            radius: 1000,
	            polygonSources: ["shopping_center_fill"]
	        },
	        {
	            source: ["stadium"],
	            labelType: "poi",
	            minZoom: 14,
	            radius: 1000,
	            polygonSources: ["stadium_fill"]
	        },
	        {
	            source: ["higher_education_facility", "school"],
	            labelType: "poi",
	            minZoom: 14,
	            radius: 1000,
	            polygonSources: ["higher_education_facility_fill", "school_fill"]
	        },
	        {
	            source: ["zoo"],
	            labelType: "poi",
	            minZoom: 14,
	            radius: 1000,
	            polygonSources: ["zoo_fill"]
	        },
	        // Major Poi labels
	        {
	            source: ["airport", "airport_terminal"],
	            labelType: "majorPoi",
	            minZoom: 11,
	            radius: 3000,
	            polygonSources: ["airport_terminal_fill", "airport_fill-merged7", "airport_runway_fill"]
	        },
	        {
	            source: ["reserve"],
	            labelType: "majorPoi",
	            minZoom: 7,
	            radius: 15000,
	            polygonSources: ["generic_reserve_fill", "land_cover_forest_fill"]
	        }
	    ];
	    // Name of all road source layers of Bing tiles.
	    MapViewDescriptor._roadLayersBing = new Set([
	        "road"
	    ]);
	    return MapViewDescriptor;
	}());

	/**
	 * @private
	 */
	var AccessibleMapDelegate = /** @class */ (function () {
	    function AccessibleMapDelegate(map) {
	        var _this = this;
	        this.addToMap = function () {
	            if (_this.mapViewDesc != null) {
	                // AccessibleMapDelegate is already initialized and added to the map.
	                return;
	            }
	            _this.initializeMapLiveStateInfo();
	            _this.initializeMapStyleInfo();
	            _this.createMapKeyBindingInfo();
	            _this.map.getMapContainer().setAttribute("role", "application");
	            _this.map.getMapContainer().setAttribute("aria-label", "Map Application");
	            _this.map.getCanvasContainer().setAttribute("aria-live", "polite");
	            _this.map.getCanvasContainer().setAttribute("aria-describedby", "atlas-map-state atlas-map-style");
	            _this.map.getCanvas().setAttribute("aria-label", "Interactive Map");
	            _this.map.getCanvas().setAttribute("aria-describedby", "atlas-map-shortcuts");
	            _this.map.getCanvas().setAttribute("alt", "Interactive Map");
	        };
	        this.removeFromMap = function () {
	            if (_this.mapViewDesc != null) {
	                _this.mapViewDesc.dispose();
	            }
	            delete _this.mapViewDesc;
	            if (_this.atlasMapKeyBindings != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapKeyBindings);
	            }
	            delete _this.atlasMapKeyBindings;
	            if (_this.atlasMapLiveStateInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapLiveStateInfo);
	            }
	            delete _this.atlasMapLiveStateInfo;
	            if (_this.atlasMapStyleInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapStyleInfo);
	            }
	            delete _this.atlasMapStyleInfo;
	            _this.map.getMapContainer().removeAttribute("role");
	            _this.map.getMapContainer().removeAttribute("aria-label");
	            _this.map.getCanvasContainer().removeAttribute("aria-live");
	            _this.map.getCanvasContainer().removeAttribute("aria-describedby");
	            _this.map.getCanvas().removeAttribute("aria-label");
	            _this.map.getCanvas().removeAttribute("aria-describedby");
	            _this.map.getCanvas().removeAttribute("alt");
	            _this.map.events.remove("stylechanged", _this.updateMapStyle);
	        };
	        this.createMapKeyBindingInfo = function () {
	            _this.atlasMapKeyBindings = document.createElement("div");
	            _this.atlasMapKeyBindings.setAttribute("tabindex", "-1");
	            _this.atlasMapKeyBindings.setAttribute("aria-hidden", "true");
	            _this.atlasMapKeyBindings.id = "atlas-map-shortcuts";
	            _this.atlasMapKeyBindings.classList.add("hidden-accessible-element");
	            _this.atlasMapKeyBindings.innerHTML = [
	                "Map shortcuts:",
	                "Zoom out: hyphen.",
	                "Zoom in: plus.",
	                "Pan right 100 pixels: right arrow.",
	                "Pan left 100 pixels: left arrow.",
	                "Pan up 100 pixels: up arrow.",
	                "Pan down 100 pixels: down arrow.",
	                "Rotate 15 degrees clockwise: shift + right arrow.",
	                "Rotate 15 degrees counter clockwise: shift + left arrow.",
	                "Increase pitch 10 degrees: shift + up arrow.",
	                "Decrease pitch 10 degrees: shift + down arrow.",
	                // Interesting... i'm not sure that verbose map state was ever implemented 
	                // "Toggle verbose map state: control + alt + D.",
	                "Jump focus to the map: Escape."
	            ].join("\n");
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapKeyBindings);
	            var baseShortcutKeyCodes = [
	                // - (zoom out)
	                189,
	                // = (zoom in)
	                187,
	                // arrow up
	                38,
	                // arrow left
	                37,
	                // arrow right
	                39,
	                // arrow down
	                40
	            ];
	            // accessibility recommendation: After using any of the map shortcut keys, NVDA should not read all the shortcut keys again.
	            // // TODO: this should be this.map._getMap().getCanvas
	            var mapCanvas = _this.map._getMap()._canvas;
	            mapCanvas === null || mapCanvas === void 0 ? void 0 : mapCanvas.addEventListener('keyup', function (event) {
	                if (baseShortcutKeyCodes.find(function (code) { return event.keyCode === code; })) {
	                    _this.atlasMapKeyBindings.innerHTML = '';
	                }
	            });
	        };
	        this.initializeMapLiveStateInfo = function () {
	            {
	                _this.mapViewDesc = new MapViewDescriptor(_this.map, _this.updateMapState);
	                _this.atlasMapLiveStateInfo = document.createElement("div");
	                _this.atlasMapLiveStateInfo.setAttribute("tabindex", "-1");
	                _this.atlasMapLiveStateInfo.setAttribute("aria-hidden", "true");
	                _this.atlasMapLiveStateInfo.id = "atlas-map-state";
	                _this.atlasMapLiveStateInfo.classList.add("hidden-accessible-element");
	                _this.map.getCanvasContainer().appendChild(_this.atlasMapLiveStateInfo);
	            }
	        };
	        this.initializeMapStyleInfo = function () {
	            _this.atlasMapStyleInfo = document.createElement("div");
	            _this.atlasMapStyleInfo.setAttribute("tabindex", "-1");
	            _this.atlasMapStyleInfo.setAttribute("aria-hidden", "true");
	            _this.atlasMapStyleInfo.id = "atlas-map-style";
	            _this.atlasMapStyleInfo.classList.add("hidden-accessible-element");
	            _this.map.events.add("stylechanged", _this.updateMapStyle);
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapStyleInfo);
	        };
	        this.updateMapStyle = function () {
	            _this.atlasMapStyleInfo.innerHTML = "<p>Map style: ".concat(_this.map.getStyle().style, ".</p>");
	        };
	        this.updateMapState = function (desc) {
	            _this.atlasMapLiveStateInfo.innerHTML = desc;
	        };
	        this.map = map;
	    }
	    return AccessibleMapDelegate;
	}());

	/**
	 * @private
	 */
	var FlowServiceDelegate = /** @class */ (function () {
	    function FlowServiceDelegate(map) {
	        var _this = this;
	        this.listenerEnabled = false;
	        this.lastFlowMode = "none";
	        this.addToMap = function () {
	            // Check that the map is ready first.
	            if (!_this.map._isReady()) {
	                throw new Error("Traffic flow could not be added to the map because " +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before enabling traffic flow.");
	            }
	            // Enable the styledata listener.
	            // The flowPath may need to change if the style changes.
	            if (!_this.listenerEnabled) {
	                _this.map.events.add("styledata", _this.addToMap);
	                _this.listenerEnabled = true;
	            }
	            var trafficOptions = _this.map.getTraffic();
	            if (trafficOptions.flow !== "none") {
	                var trafficFlowComponent = _this.map.layers.getLayerById("traffic_".concat(trafficOptions.flow));
	                if (trafficFlowComponent) {
	                    _this.lastFlowMode = trafficOptions.flow;
	                    trafficFlowComponent._updateLayoutProperty("visibility", "visible", "none");
	                }
	            }
	        };
	        this.removeFromMap = function () {
	            _this.map.getTraffic();
	            if (_this.lastFlowMode != "none") {
	                var trafficFlowComponent = _this.map.layers.getLayerById("traffic_".concat(_this.lastFlowMode));
	                if (trafficFlowComponent) {
	                    trafficFlowComponent._updateLayoutProperty("visibility", "none", "visible");
	                }
	                _this.lastFlowMode = "none";
	            }
	            // Disable the styledata listener
	            if (_this.listenerEnabled) {
	                _this.map.events.remove("styledata", _this.addToMap);
	                _this.listenerEnabled = false;
	            }
	        };
	        this.map = map;
	    }
	    return FlowServiceDelegate;
	}());

	var __extends$i = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * @private
	 */
	var Incident = /** @class */ (function (_super) {
	    __extends$i(Incident, _super);
	    function Incident(data, point, localizedStrings) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
	        var iconCategory = ((_o = (_m = (_l = (_k = (_j = (_h = (_g = (_f = (_e = (_d = (_c = (_b = (_a = data.icon_category_12) !== null && _a !== void 0 ? _a : data.icon_category_11) !== null && _b !== void 0 ? _b : data.icon_category_10) !== null && _c !== void 0 ? _c : data.icon_category_9) !== null && _d !== void 0 ? _d : data.icon_category_8) !== null && _e !== void 0 ? _e : data.icon_category_7) !== null && _f !== void 0 ? _f : data.icon_category_6) !== null && _g !== void 0 ? _g : data.icon_category_5) !== null && _h !== void 0 ? _h : data.icon_category_4) !== null && _j !== void 0 ? _j : data.icon_category_3) !== null && _k !== void 0 ? _k : data.icon_category_2) !== null && _l !== void 0 ? _l : data.icon_category_1) !== null && _m !== void 0 ? _m : data.icon_category_0) !== null && _o !== void 0 ? _o : data.icon_category);
	        var description = ((_1 = (_0 = (_z = (_y = (_x = (_w = (_v = (_u = (_t = (_s = (_r = (_q = (_p = data.description_12) !== null && _p !== void 0 ? _p : data.description_11) !== null && _q !== void 0 ? _q : data.description_10) !== null && _r !== void 0 ? _r : data.description_9) !== null && _s !== void 0 ? _s : data.description_8) !== null && _t !== void 0 ? _t : data.description_7) !== null && _u !== void 0 ? _u : data.description_6) !== null && _v !== void 0 ? _v : data.description_5) !== null && _w !== void 0 ? _w : data.description_4) !== null && _x !== void 0 ? _x : data.description_3) !== null && _y !== void 0 ? _y : data.description_2) !== null && _z !== void 0 ? _z : data.description_1) !== null && _0 !== void 0 ? _0 : data.description_0) !== null && _1 !== void 0 ? _1 : data.description);
	        var incidentPinProperties = {
	            icon: "".concat(Incident.getSeverityColorName(data.magnitude), "-").concat(Incident.getIncidentTypeIconName(iconCategory)),
	            incidentType: Incident.getIncidentTypeName(iconCategory, localizedStrings),
	            description: description,
	            // "length", "from", and "to" properties are currently not returned by
	            // the incident tile response
	            // length: data.length,
	            // from: data.from,
	            // to: data.to,
	            delay: data.delay,
	            color: Incident.getSeverityColorHexCode(data.magnitude),
	            id: data.id
	        };
	        return _super.call(this, point, incidentPinProperties) || this;
	    }
	    Incident.getIncidentTypeName = function (incidentCategory, localizedStrings) {
	        switch (incidentCategory) {
	            case 0:
	                return localizedStrings.Unknown;
	            case 1:
	                return localizedStrings.Accident;
	            case 2:
	                return localizedStrings.Fog;
	            case 3:
	                return localizedStrings.Danger;
	            case 4:
	                return localizedStrings.Rain;
	            case 5:
	                return localizedStrings.Ice;
	            case 6:
	                return localizedStrings.Jam;
	            case 7:
	                return localizedStrings.LaneClosed;
	            case 8:
	                return localizedStrings.RoadClosed;
	            case 9:
	                return localizedStrings.RoadWorks;
	            case 10:
	                return localizedStrings.Wind;
	            case 11:
	                return localizedStrings.Flood;
	            case 12:
	                return localizedStrings.Detour;
	            default:
	                return localizedStrings.Unknown;
	        }
	    };
	    Incident.getIncidentTypeIconName = function (incidentCategory) {
	        switch (incidentCategory) {
	            case 0:
	                return "unknown";
	            case 1:
	                return "accident";
	            case 2:
	                return "fog";
	            case 3:
	                return "danger";
	            case 4:
	                return "rain";
	            case 5:
	                return "ice";
	            case 6:
	                return "jam";
	            case 7:
	                return "lane-closed";
	            case 8:
	                return "road-closed";
	            case 9:
	                return "road-work";
	            case 10:
	                return "wind";
	            case 11:
	                return "flood";
	            case 12:
	                return "detour";
	            default:
	                return "unknown";
	        }
	    };
	    Incident.getSeverityColorName = function (severity) {
	        switch (severity) {
	            case 0:
	                return "grey";
	            case 1:
	                return "yellow";
	            case 2:
	                return "orange";
	            case 3:
	                return "red";
	            case 4:
	                return "grey";
	            default:
	                return "grey";
	        }
	    };
	    Incident.getSeverityColorHexCode = function (severity) {
	        switch (severity) {
	            case 0:
	                return "#B5B6B7";
	            case 1:
	                return "#F4C951";
	            case 2:
	                return "#F4873F";
	            case 3:
	                return "#F04F4E";
	            case 4:
	                return "#B5B6B7";
	            default:
	                return "#B5B6B7";
	        }
	    };
	    return Incident;
	}(Feature));

	/**
	 * @private
	 */
	var IncidentPopupIconName;
	(function (IncidentPopupIconName) {
	    IncidentPopupIconName["DELAY"] = "delay";
	    IncidentPopupIconName["LENGTH"] = "length";
	    IncidentPopupIconName["FROM"] = "from";
	    IncidentPopupIconName["TO"] = "to";
	})(IncidentPopupIconName || (IncidentPopupIconName = {}));
	/**
	 * @private
	 */
	var IncidentPopupFactory = /** @class */ (function () {
	    function IncidentPopupFactory() {
	    }
	    IncidentPopupFactory.build = function (incident, languageCode) {
	        if (languageCode === void 0) { languageCode = "en-US"; }
	        var titleEl = document.createElement("div");
	        titleEl.classList.add("incident-popup-title");
	        titleEl.classList.add("font-segoeui-b");
	        titleEl.innerText = incident.properties.incidentType;
	        titleEl.setAttribute("aria-label", "Incident Type ".concat(incident.properties.incidentType));
	        var subtitleEl = document.createElement("div");
	        subtitleEl.classList.add("incident-popup-subtitle");
	        subtitleEl.classList.add("font-segoeui-b");
	        subtitleEl.setAttribute("aria-label", "Incident Description ".concat(incident.properties.description));
	        subtitleEl.innerText = incident.properties.description;
	        var headerEl = document.createElement("div");
	        headerEl.classList.add("incident-popup-header");
	        headerEl.style.backgroundColor = incident.properties.color;
	        headerEl.appendChild(titleEl);
	        headerEl.appendChild(subtitleEl);
	        var bodyEl = document.createElement("div");
	        bodyEl.classList.add("incident-popup-body");
	        if (incident.properties.delay) {
	            var delay = "".concat(Math.floor(incident.properties.delay / 60), " min");
	            var delayInfoEl = this.createInfoSection(delay, IncidentPopupIconName.DELAY);
	            bodyEl.appendChild(delayInfoEl);
	        }
	        if (incident.properties.length) {
	            var i18nNumberFormat = new Intl.NumberFormat([languageCode, "en-US"], {
	                maximumFractionDigits: 2
	            });
	            // If the language code is "en-US" it will always match this case
	            // because Localizer controls the final language value.
	            var i18nLength = void 0;
	            if (languageCode === "en-US") {
	                var lengthInMiles = convertDistance(incident.properties.length, "meters", "miles");
	                i18nLength = "".concat(i18nNumberFormat.format(lengthInMiles), " miles");
	            }
	            else {
	                var lengthInKm = convertDistance(incident.properties.length, "meters", "kilometers");
	                i18nLength = "".concat(i18nNumberFormat.format(lengthInKm), " km");
	            }
	            var lengthInfoEl = this.createInfoSection(i18nLength, IncidentPopupIconName.LENGTH);
	            bodyEl.appendChild(lengthInfoEl);
	        }
	        if (incident.properties.from) {
	            var fromInfoEl = this.createInfoSection(incident.properties.from, IncidentPopupIconName.FROM);
	            bodyEl.appendChild(fromInfoEl);
	        }
	        if (incident.properties.to) {
	            var toInfoEl = this.createInfoSection(incident.properties.to, IncidentPopupIconName.TO);
	            bodyEl.appendChild(toInfoEl);
	        }
	        var incidentPopupContentEl = document.createElement("div");
	        incidentPopupContentEl.classList.add("incident-popup-content");
	        incidentPopupContentEl.appendChild(headerEl);
	        incidentPopupContentEl.appendChild(bodyEl);
	        var incidentPopup = new Popup({
	            content: incidentPopupContentEl,
	            position: incident.geometry.coordinates
	        });
	        return incidentPopup;
	    };
	    IncidentPopupFactory.createInfoSection = function (message, iconName) {
	        var infoSectionEl = document.createElement("div");
	        infoSectionEl.classList.add("incident-popup-info");
	        var iconEl = document.createElement("div");
	        iconEl.classList.add("icon");
	        iconEl.classList.add(iconName);
	        var messageEl = document.createElement("span");
	        messageEl.classList.add("message");
	        messageEl.classList.add("font-segoeui");
	        messageEl.setAttribute("aria-label", "Incident ".concat(iconName, " ").concat(message));
	        messageEl.innerText = message;
	        infoSectionEl.appendChild(iconEl);
	        infoSectionEl.appendChild(messageEl);
	        return infoSectionEl;
	    };
	    return IncidentPopupFactory;
	}());

	var __awaiter$4 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$4 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	/**
	 * @private
	 */
	var IncidentServiceDelegate = /** @class */ (function () {
	    function IncidentServiceDelegate(map) {
	        var _this = this;
	        this.incidentLayerName = "incidents";
	        this.incidentSourceName = "mapcontrol_traffic_incident";
	        this.addToMap = function () {
	            if (!_this.map.sources.getById(_this.incidentSourceName)) {
	                _this.map.sources.add(_this.vectorTileSource);
	            }
	            if (!_this.map.layers.getLayerById(_this.incidentLayerName)) {
	                _this.map.layers.add(_this.incidentLayer, "labels");
	            }
	            //Create a popup but leave it closed so we can update it and display it later.
	            _this.clickPopup = new Popup({
	                position: [0, 0],
	                pixelOffset: [0, -18]
	            });
	            _this.map.addEventListener("mouseover", _this.incidentLayerName, _this.cursorToPointer);
	            _this.map.addEventListener("mouseleave", _this.incidentLayerName, _this.cursorToDefault);
	            _this.map.addEventListener("click", _this.incidentLayerName, _this.openIncidentPopup);
	            _this.map.events.addOnce('idle', _this.setAccessiblePopups);
	            _this.map.events.add('moveend', _this.setAccessiblePopups);
	        };
	        this.accessiblePopups = [];
	        this.setAccessiblePopups = function () { return __awaiter$4(_this, void 0, void 0, function () {
	            var features, localizedStrings, createPopup, insertHiddenBefore, insertHiddenInFront, addHidden;
	            var _this = this;
	            return __generator$4(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.accessiblePopups.forEach(function (popup) { return popup.remove(); });
	                        this.accessiblePopups = [];
	                        features = this.map.layers.getRenderedShapes(this.map.getCamera().bounds, this.incidentLayer);
	                        return [4 /*yield*/, this.map._getLocalizedStrings()];
	                    case 1:
	                        localizedStrings = _a.sent();
	                        createPopup = function (features, idx) {
	                            var incidentFeature = features[idx];
	                            var incidentPosition = incidentFeature.geometry.coordinates;
	                            var point = new Point(new Position(incidentPosition[0], incidentPosition[1]));
	                            var incident = new Incident(incidentFeature.properties, point, localizedStrings);
	                            var popup = IncidentPopupFactory.build(incident, _this.incidentLanguage);
	                            var element = popup.getPopupContainer();
	                            element.addEventListener('focusin', function (event) {
	                                // side effects: clear other managed popups 
	                                _this.clickPopup.remove();
	                                _this.accessiblePopups.filter(function (p) { return p !== popup; }).forEach(function (popup) { return popup.remove(); });
	                                // insert previous and next popups
	                                if (idx - 1 >= 0) {
	                                    insertHiddenBefore(popup, createPopup(features, idx - 1));
	                                }
	                                if (idx + 1 < features.length) {
	                                    addHidden(createPopup(features, idx + 1));
	                                }
	                                // if we are on boundaries: add the first / last popup 
	                                // to maintain popups on full page navigation cycle
	                                if (idx >= 2 && idx == features.length - 1) {
	                                    insertHiddenInFront(createPopup(features, 0));
	                                }
	                                if (idx == 0 && features.length >= 2) {
	                                    addHidden(createPopup(features, features.length - 1));
	                                }
	                            });
	                            if (idx == features.length - 1) {
	                                element.addEventListener('focusout', function (event) {
	                                    // close the popup if we detect the focus moving away from the page (relatedTarget === null)
	                                    // (will remain open otherwise)
	                                    if (event.relatedTarget === null) {
	                                        popup.close();
	                                    }
	                                });
	                            }
	                            _this.accessiblePopups.push(popup);
	                            return popup;
	                        };
	                        insertHiddenBefore = function (base, toInsert) {
	                            toInsert.open(_this.map);
	                            toInsert.close();
	                            var containerToSwapIn = toInsert.getPopupContainer();
	                            var baseContainer = base.getPopupContainer();
	                            baseContainer.parentElement.insertBefore(containerToSwapIn, baseContainer);
	                        };
	                        insertHiddenInFront = function (toInsert) {
	                            toInsert.open(_this.map);
	                            toInsert.close();
	                            var containerToSwapIn = toInsert.getPopupContainer();
	                            var parent = containerToSwapIn.parentElement;
	                            parent.insertBefore(containerToSwapIn, parent.firstElementChild);
	                        };
	                        addHidden = function (popup) {
	                            popup.open(_this.map);
	                            popup.close();
	                        };
	                        if (features.length > 0) {
	                            addHidden(createPopup(features, 0));
	                        }
	                        if (features.length > 1) {
	                            addHidden(createPopup(features, features.length - 1));
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        }); };
	        this.removeFromMap = function () {
	            var _a;
	            _this.map.removeEventListener("mouseover", _this.incidentLayerName, _this.cursorToPointer);
	            _this.map.removeEventListener("mouseleave", _this.incidentLayerName, _this.cursorToDefault);
	            _this.map.removeEventListener("click", _this.incidentLayerName, _this.openIncidentPopup);
	            _this.map.events.remove('idle', _this.setAccessiblePopups);
	            _this.map.events.remove('moveend', _this.setAccessiblePopups);
	            _this.accessiblePopups.forEach(function (popup) { return popup.remove(); });
	            _this.accessiblePopups = [];
	            (_a = _this.clickPopup) === null || _a === void 0 ? void 0 : _a.remove();
	            if (_this.map.layers.getLayerById(_this.incidentLayerName) != null) {
	                _this.map.layers.remove(_this.incidentLayerName);
	            }
	            if (_this.map.sources.getById(_this.incidentSourceName) != null) {
	                _this.map.sources.remove(_this.incidentSourceName);
	            }
	        };
	        this.cursorToPointer = function (data) {
	            _this.map.getCanvas().style.cursor = "pointer";
	        };
	        this.cursorToDefault = function (data) {
	            _this.map.getCanvas().style.cursor = "";
	        };
	        this.openIncidentPopup = function (data) {
	            _this.clickPopup.remove();
	            _this.accessiblePopups.forEach(function (popup) { return popup.close(); });
	            var incidentPosition = data.position;
	            var incidentFeature = data.features[0];
	            _this.map._getLocalizedStrings().then(function (localizedStrings) {
	                var point = new Point(new Position(incidentPosition[0], incidentPosition[1]));
	                var incident = new Incident(incidentFeature.properties, point, localizedStrings);
	                _this.clickPopup = IncidentPopupFactory.build(incident, _this.incidentLanguage);
	                _this.clickPopup.open(_this.map);
	                var element = _this.clickPopup.getPopupContainer();
	                // ensures popup is closed on tabbing when the focus is moved away from the window
	                element.addEventListener('focusout', function (event) {
	                    if (event.relatedTarget === null) {
	                        _this.clickPopup.close();
	                    }
	                });
	            });
	        };
	        this.map = map;
	        this.vectorTileSource = new VectorTileSource(this.incidentSourceName, {
	            maxZoom: 22,
	            tiles: [
	                "https://".concat(constants.domainPlaceHolder, "/traffic/incident/tile/pbf?api-version=1.0&zoom={z}&x={x}&y={y}"),
	            ],
	        });
	        var imageExpression = this.getIncidentIconImageExpression();
	        this.incidentLayer = new SymbolLayer(this.incidentSourceName, this.incidentLayerName, {
	            sourceLayer: "Traffic incident POI",
	            iconOptions: {
	                ignorePlacement: true,
	                allowOverlap: true,
	                image: imageExpression,
	                size: 0.75
	            }
	        });
	    }
	    IncidentServiceDelegate.prototype.getIncidentIconImageExpression = function () {
	        // incident icon color expression
	        var iconColorExpression = [
	            "let", "magnitude", ["get", "magnitude"],
	            [
	                "case",
	                ["==", ['var', 'magnitude'], 0],
	                "grey",
	                ["==", ['var', 'magnitude'], 1],
	                "yellow",
	                ["==", ['var', 'magnitude'], 2],
	                "orange",
	                ["==", ['var', 'magnitude'], 3],
	                "red",
	                ["==", ['var', 'magnitude'], 4],
	                "grey",
	                "grey", // default.
	            ],
	        ];
	        // incident icon type name expression
	        var incidentCategoryExpression = [
	            "coalesce",
	            ["get", "icon_category_12"],
	            ["get", "icon_category_11"],
	            ["get", "icon_category_10"],
	            ["get", "icon_category_9"],
	            ["get", "icon_category_8"],
	            ["get", "icon_category_7"],
	            ["get", "icon_category_6"],
	            ["get", "icon_category_5"],
	            ["get", "icon_category_4"],
	            ["get", "icon_category_3"],
	            ["get", "icon_category_2"],
	            ["get", "icon_category_0"],
	            ["get", "icon_category"],
	            0
	        ];
	        var incidentTypeIconNameExpression = [
	            "let", "category", incidentCategoryExpression,
	            [
	                "case",
	                ["==", ["var", "category"], 0],
	                "unknown",
	                ["==", ["var", "category"], 1],
	                "accident",
	                ["==", ["var", "category"], 2],
	                "fog",
	                ["==", ["var", "category"], 3],
	                "danger",
	                ["==", ["var", "category"], 4],
	                "rain",
	                ["==", ["var", "category"], 5],
	                "ice",
	                ["==", ["var", "category"], 6],
	                "jam",
	                ["==", ["var", "category"], 7],
	                "lane-closed",
	                ["==", ["var", "category"], 8],
	                "road-closed",
	                ["==", ["var", "category"], 9],
	                "road-work",
	                ["==", ["var", "category"], 10],
	                "wind",
	                ["==", ["var", "category"], 11],
	                "flood",
	                ["==", ["var", "category"], 12],
	                "detour",
	                "unknown"
	            ]
	        ];
	        var incidentIconNameExpression = [
	            "concat", iconColorExpression, "-", incidentTypeIconNameExpression
	        ];
	        return incidentIconNameExpression;
	    };
	    return IncidentServiceDelegate;
	}());

	var __extends$h = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for enabling/disabling user interaction with the map.
	 */
	var UserInteractionOptions = /** @class */ (function (_super) {
	    __extends$h(UserInteractionOptions, _super);
	    function UserInteractionOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Whether the map is interactive or static. If false, all user interaction is disabled.  If true, only selected
	         * user interactions will enabled.
	         * default `true`
	         * @default true
	         */
	        _this.interactive = true;
	        /**
	         * Whether the map should zoom on scroll input.
	         * default `true`
	         * @default true
	         */
	        _this.scrollZoomInteraction = true;
	        /**
	         * Whether the Shift + left click and drag will draw a zoom box.
	         * default `true`
	         * @default true
	         */
	        _this.boxZoomInteraction = true;
	        /**
	         * Whether right click and drag will rotate and pitch the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragRotateInteraction = true;
	        /**
	         * Whether left click and drag will pan the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragPanInteraction = true;
	        /**
	         * Whether the keyboard interactions are enabled.
	         * <style> .k-key { border: 1px solid grey; border-radius: 6px; background-color: #ccc; line-height: 14px;
	         * font-size: 14px; padding: 2px; } </style>
	         * <p><span class="k-key">Escape</span>: Jump focus to the map.</p>
	         * <p><span class="k-key">+/=</span>: Increase zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">+/=</span>: Increase the zoom level by 2.</p>
	         * <p><span class="k-key">-</span>: Decrease zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">-</span>: Decrease zoom level by 2.</p>
	         * <p><span class="k-key">⇢</span>: Pan right 100 pixels.</p>
	         * <p><span class="k-key">⇠</span>: Pan left 100 pixels.</p>
	         * <p><span class="k-key">⇡</span>: Pan up 100 pixels.</p>
	         * <p><span class="k-key">⇣</span>: Pan down 100 pixels.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇢</span>: Rotate 15 degrees clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇠</span>: Rotate 15 degrees counter-clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇡</span>: Increase pitch by 10 degrees.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇣</span>: Decrease pitch by 10 degrees.</p>
	         * default `true`
	         * @default true
	         */
	        _this.keyboardInteraction = true;
	        /**
	         * Whether double left click will zoom the map inwards.
	         * default `true`
	         * @default true
	         */
	        _this.dblClickZoomInteraction = true;
	        /**
	         * Whether touch interactions are enabled for touch devices.
	         * default `true`
	         * @default true
	         */
	        _this.touchInteraction = true;
	        /**
	         * Whether touch rotation is enabled for touch devices. This option is not applied if touchInteraction is disabled.
	         * default `true`
	         * @default true
	         */
	        _this.touchRotate = true;
	        /**
	         * Sets the zoom rate of the mouse wheel
	         * default `1/450`
	         * @default 1/450
	         */
	        _this.wheelZoomRate = 1 / 450;
	        return _this;
	    }
	    return UserInteractionOptions;
	}(Options));

	/** A handler that adds a shortcut for jumping focus to the top map div. */
	var FocusShortcutHandler = /** @class */ (function () {
	    function FocusShortcutHandler(map) {
	        var _this = this;
	        /** A listener for the shortcut */
	        this._onKeyDown = function (event) {
	            if (event.keyCode === 27 /* Escape */) {
	                _this.map.getCanvas().focus();
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.enable = function () {
	        this.map.getMapContainer().addEventListener("keydown", this._onKeyDown);
	    };
	    /** Disables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.disable = function () {
	        this.map.getMapContainer().removeEventListener("keydown", this._onKeyDown);
	    };
	    return FocusShortcutHandler;
	}());

	/** A handler that adds support for pinch and zoom gestures on devices without touch events. */
	var PinchZoomHandler = /** @class */ (function () {
	    function PinchZoomHandler(map) {
	        var _this = this;
	        this._onGestureStart = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.initZoom = _this.map.getCamera().zoom;
	            }
	        };
	        this._onGestureChange = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.map.setCamera({ zoom: _this.initZoom + e.scale - 1 });
	            }
	        };
	        this._onTouchStart = function (e) {
	            _this.hasTouch = true;
	        };
	        this._onTouchEnd = function (e) {
	            if (e.touches.length === 0) {
	                _this.hasTouch = false;
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.enable = function () {
	        this.map.getCanvasContainer().addEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().addEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().addEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().addEventListener("touchend", this._onTouchEnd);
	    };
	    /** Disables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.disable = function () {
	        this.map.getCanvasContainer().removeEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().removeEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().removeEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().removeEventListener("touchend", this._onTouchEnd);
	    };
	    return PinchZoomHandler;
	}());

	/**
	 * @private
	 */
	var UserInteractionDelegate = /** @class */ (function () {
	    function UserInteractionDelegate(map, options) {
	        this.added = false;
	        this.map = map;
	        this.focusShortcut = new FocusShortcutHandler(map);
	        this.pinchZoom = new PinchZoomHandler(map);
	        this.options = new UserInteractionOptions().merge(options);
	    }
	    UserInteractionDelegate.prototype.addToMap = function () {
	        if (!this.added) {
	            this.added = true;
	            this._setInteractions(this.options);
	        }
	    };
	    UserInteractionDelegate.prototype.removeFromMap = function () {
	        if (this.added) {
	            this.added = false;
	            this._setInteractions({ interactive: false });
	        }
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    UserInteractionDelegate.prototype.setOptions = function (options) {
	        this.options = new UserInteractionOptions().merge(this.options, options);
	        // Only need to actually update things if the delegate has already been added to the map
	        if (this.added) {
	            this._setInteractions(this.options);
	        }
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    UserInteractionDelegate.prototype.getOptions = function () {
	        return Object.assign({}, this.options);
	    };
	    /** Sets the interaction config based on the specified options. */
	    UserInteractionDelegate.prototype._setInteractions = function (options) {
	        if (!options.interactive) {
	            // Disable everything
	            this.map._getMap().boxZoom.disable();
	            this.map._getMap().doubleClickZoom.disable();
	            this.map._getMap().dragPan.disable();
	            this.map._getMap().dragRotate.disable();
	            this.map._getMap().keyboard.disable();
	            this.focusShortcut.disable();
	            this.map._getMap().scrollZoom.disable();
	            this.map._getMap().touchZoomRotate.disable();
	            this.pinchZoom.disable();
	        }
	        else {
	            // Box Zoom
	            if (options.boxZoomInteraction) {
	                this.map._getMap().boxZoom.enable();
	            }
	            else {
	                this.map._getMap().boxZoom.disable();
	            }
	            // Double Click Zoom
	            if (options.dblClickZoomInteraction) {
	                this.map._getMap().doubleClickZoom.enable();
	            }
	            else {
	                this.map._getMap().doubleClickZoom.disable();
	            }
	            // Drag Pan
	            if (options.dragPanInteraction) {
	                this.map._getMap().dragPan.enable();
	            }
	            else {
	                this.map._getMap().dragPan.disable();
	            }
	            // Drag Rotate
	            if (options.dragRotateInteraction) {
	                this.map._getMap().dragRotate.enable();
	            }
	            else {
	                this.map._getMap().dragRotate.disable();
	            }
	            // Keyboard
	            if (options.keyboardInteraction) {
	                this.map._getMap().keyboard.enable();
	                this.focusShortcut.enable();
	            }
	            else {
	                this.map._getMap().keyboard.disable();
	                this.focusShortcut.disable();
	            }
	            // Scroll Zoom
	            if (options.scrollZoomInteraction) {
	                this.map._getMap().scrollZoom.enable();
	                this.map._getMap().scrollZoom.setWheelZoomRate(options.wheelZoomRate);
	            }
	            else {
	                this.map._getMap().scrollZoom.disable();
	            }
	            // Touch
	            var touchZoomRotate = this.map._getMap().touchZoomRotate;
	            if (options.touchInteraction) {
	                touchZoomRotate.enable();
	                if (options.touchRotate) {
	                    touchZoomRotate.enableRotation();
	                }
	                else {
	                    touchZoomRotate.disableRotation();
	                }
	                this.pinchZoom.enable();
	            }
	            else {
	                touchZoomRotate.disable();
	                this.pinchZoom.enable();
	            }
	        }
	    };
	    return UserInteractionDelegate;
	}());

	/**
	 * @module helpers
	 */
	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 *
	 * @memberof helpers
	 * @type {number}
	 */
	/**
	 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
	 *
	 * @name feature
	 * @param {Geometry} geometry input geometry
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature} a GeoJSON Feature
	 * @example
	 * var geometry = {
	 *   "type": "Point",
	 *   "coordinates": [110, 50]
	 * };
	 *
	 * var feature = turf.feature(geometry);
	 *
	 * //=feature
	 */
	function feature(geom, properties, options) {
	    if (options === void 0) { options = {}; }
	    var feat = { type: "Feature" };
	    if (options.id === 0 || options.id) {
	        feat.id = options.id;
	    }
	    if (options.bbox) {
	        feat.bbox = options.bbox;
	    }
	    feat.properties = properties || {};
	    feat.geometry = geom;
	    return feat;
	}
	/**
	 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
	 *
	 * @name polygon
	 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<Polygon>} Polygon Feature
	 * @example
	 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
	 *
	 * //=polygon
	 */
	function polygon(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
	        var ring = coordinates_1[_i];
	        if (ring.length < 4) {
	            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
	        }
	        for (var j = 0; j < ring[ring.length - 1].length; j++) {
	            // Check if first point of Polygon contains two numbers
	            if (ring[ring.length - 1][j] !== ring[0][j]) {
	                throw new Error("First and last Position are not equivalent.");
	            }
	        }
	    }
	    var geom = {
	        type: "Polygon",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}
	/**
	 * Creates a {@link Feature<MultiPolygon>} based on a
	 * coordinate array. Properties can be added optionally.
	 *
	 * @name multiPolygon
	 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
	 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
	 * @param {string|number} [options.id] Identifier associated with the Feature
	 * @returns {Feature<MultiPolygon>} a multipolygon feature
	 * @throws {Error} if no coordinates are passed
	 * @example
	 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
	 *
	 * //=multiPoly
	 *
	 */
	function multiPolygon(coordinates, properties, options) {
	    if (options === void 0) { options = {}; }
	    var geom = {
	        type: "MultiPolygon",
	        coordinates: coordinates,
	    };
	    return feature(geom, properties, options);
	}

	/**
	 * Get Geometry from Feature or Geometry Object
	 *
	 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
	 * @returns {Geometry|null} GeoJSON Geometry Object
	 * @throws {Error} if geojson is not a Feature or Geometry Object
	 * @example
	 * var point = {
	 *   "type": "Feature",
	 *   "properties": {},
	 *   "geometry": {
	 *     "type": "Point",
	 *     "coordinates": [110, 40]
	 *   }
	 * }
	 * var geom = turf.getGeom(point)
	 * //={"type": "Point", "coordinates": [110, 40]}
	 */
	function getGeom(geojson) {
	    if (geojson.type === "Feature") {
	        return geojson.geometry;
	    }
	    return geojson;
	}

	var polygonClipping_umd = {exports: {}};

	(function (module, exports) {
		(function (global, factory) {
		  module.exports = factory() ;
		}(commonjsGlobal, (function () {
		  function _classCallCheck(instance, Constructor) {
		    if (!(instance instanceof Constructor)) {
		      throw new TypeError("Cannot call a class as a function");
		    }
		  }

		  function _defineProperties(target, props) {
		    for (var i = 0; i < props.length; i++) {
		      var descriptor = props[i];
		      descriptor.enumerable = descriptor.enumerable || false;
		      descriptor.configurable = true;
		      if ("value" in descriptor) descriptor.writable = true;
		      Object.defineProperty(target, descriptor.key, descriptor);
		    }
		  }

		  function _createClass(Constructor, protoProps, staticProps) {
		    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
		    if (staticProps) _defineProperties(Constructor, staticProps);
		    return Constructor;
		  }

		  /**
		   * splaytree v3.1.0
		   * Fast Splay tree for Node and browser
		   *
		   * @author Alexander Milevski <info@w8r.name>
		   * @license MIT
		   * @preserve
		   */
		  var Node =
		  /** @class */
		  function () {
		    function Node(key, data) {
		      this.next = null;
		      this.key = key;
		      this.data = data;
		      this.left = null;
		      this.right = null;
		    }

		    return Node;
		  }();
		  /* follows "An implementation of top-down splaying"
		   * by D. Sleator <sleator@cs.cmu.edu> March 1992
		   */


		  function DEFAULT_COMPARE(a, b) {
		    return a > b ? 1 : a < b ? -1 : 0;
		  }
		  /**
		   * Simple top down splay, not requiring i to be in the tree t.
		   */


		  function splay(i, t, comparator) {
		    var N = new Node(null, null);
		    var l = N;
		    var r = N;

		    while (true) {
		      var cmp = comparator(i, t.key); //if (i < t.key) {

		      if (cmp < 0) {
		        if (t.left === null) break; //if (i < t.left.key) {

		        if (comparator(i, t.left.key) < 0) {
		          var y = t.left;
		          /* rotate right */

		          t.left = y.right;
		          y.right = t;
		          t = y;
		          if (t.left === null) break;
		        }

		        r.left = t;
		        /* link right */

		        r = t;
		        t = t.left; //} else if (i > t.key) {
		      } else if (cmp > 0) {
		        if (t.right === null) break; //if (i > t.right.key) {

		        if (comparator(i, t.right.key) > 0) {
		          var y = t.right;
		          /* rotate left */

		          t.right = y.left;
		          y.left = t;
		          t = y;
		          if (t.right === null) break;
		        }

		        l.right = t;
		        /* link left */

		        l = t;
		        t = t.right;
		      } else break;
		    }
		    /* assemble */


		    l.right = t.left;
		    r.left = t.right;
		    t.left = N.right;
		    t.right = N.left;
		    return t;
		  }

		  function insert(i, data, t, comparator) {
		    var node = new Node(i, data);

		    if (t === null) {
		      node.left = node.right = null;
		      return node;
		    }

		    t = splay(i, t, comparator);
		    var cmp = comparator(i, t.key);

		    if (cmp < 0) {
		      node.left = t.left;
		      node.right = t;
		      t.left = null;
		    } else if (cmp >= 0) {
		      node.right = t.right;
		      node.left = t;
		      t.right = null;
		    }

		    return node;
		  }

		  function split(key, v, comparator) {
		    var left = null;
		    var right = null;

		    if (v) {
		      v = splay(key, v, comparator);
		      var cmp = comparator(v.key, key);

		      if (cmp === 0) {
		        left = v.left;
		        right = v.right;
		      } else if (cmp < 0) {
		        right = v.right;
		        v.right = null;
		        left = v;
		      } else {
		        left = v.left;
		        v.left = null;
		        right = v;
		      }
		    }

		    return {
		      left: left,
		      right: right
		    };
		  }

		  function merge(left, right, comparator) {
		    if (right === null) return left;
		    if (left === null) return right;
		    right = splay(left.key, right, comparator);
		    right.left = left;
		    return right;
		  }
		  /**
		   * Prints level of the tree
		   */


		  function printRow(root, prefix, isTail, out, printNode) {
		    if (root) {
		      out("" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + "\n");
		      var indent = prefix + (isTail ? '    ' : '│   ');
		      if (root.left) printRow(root.left, indent, false, out, printNode);
		      if (root.right) printRow(root.right, indent, true, out, printNode);
		    }
		  }

		  var Tree =
		  /** @class */
		  function () {
		    function Tree(comparator) {
		      if (comparator === void 0) {
		        comparator = DEFAULT_COMPARE;
		      }

		      this._root = null;
		      this._size = 0;
		      this._comparator = comparator;
		    }
		    /**
		     * Inserts a key, allows duplicates
		     */


		    Tree.prototype.insert = function (key, data) {
		      this._size++;
		      return this._root = insert(key, data, this._root, this._comparator);
		    };
		    /**
		     * Adds a key, if it is not present in the tree
		     */


		    Tree.prototype.add = function (key, data) {
		      var node = new Node(key, data);

		      if (this._root === null) {
		        node.left = node.right = null;
		        this._size++;
		        this._root = node;
		      }

		      var comparator = this._comparator;
		      var t = splay(key, this._root, comparator);
		      var cmp = comparator(key, t.key);
		      if (cmp === 0) this._root = t;else {
		        if (cmp < 0) {
		          node.left = t.left;
		          node.right = t;
		          t.left = null;
		        } else if (cmp > 0) {
		          node.right = t.right;
		          node.left = t;
		          t.right = null;
		        }

		        this._size++;
		        this._root = node;
		      }
		      return this._root;
		    };
		    /**
		     * @param  {Key} key
		     * @return {Node|null}
		     */


		    Tree.prototype.remove = function (key) {
		      this._root = this._remove(key, this._root, this._comparator);
		    };
		    /**
		     * Deletes i from the tree if it's there
		     */


		    Tree.prototype._remove = function (i, t, comparator) {
		      var x;
		      if (t === null) return null;
		      t = splay(i, t, comparator);
		      var cmp = comparator(i, t.key);

		      if (cmp === 0) {
		        /* found it */
		        if (t.left === null) {
		          x = t.right;
		        } else {
		          x = splay(i, t.left, comparator);
		          x.right = t.right;
		        }

		        this._size--;
		        return x;
		      }

		      return t;
		      /* It wasn't there */
		    };
		    /**
		     * Removes and returns the node with smallest key
		     */


		    Tree.prototype.pop = function () {
		      var node = this._root;

		      if (node) {
		        while (node.left) {
		          node = node.left;
		        }

		        this._root = splay(node.key, this._root, this._comparator);
		        this._root = this._remove(node.key, this._root, this._comparator);
		        return {
		          key: node.key,
		          data: node.data
		        };
		      }

		      return null;
		    };
		    /**
		     * Find without splaying
		     */


		    Tree.prototype.findStatic = function (key) {
		      var current = this._root;
		      var compare = this._comparator;

		      while (current) {
		        var cmp = compare(key, current.key);
		        if (cmp === 0) return current;else if (cmp < 0) current = current.left;else current = current.right;
		      }

		      return null;
		    };

		    Tree.prototype.find = function (key) {
		      if (this._root) {
		        this._root = splay(key, this._root, this._comparator);
		        if (this._comparator(key, this._root.key) !== 0) return null;
		      }

		      return this._root;
		    };

		    Tree.prototype.contains = function (key) {
		      var current = this._root;
		      var compare = this._comparator;

		      while (current) {
		        var cmp = compare(key, current.key);
		        if (cmp === 0) return true;else if (cmp < 0) current = current.left;else current = current.right;
		      }

		      return false;
		    };

		    Tree.prototype.forEach = function (visitor, ctx) {
		      var current = this._root;
		      var Q = [];
		      /* Initialize stack s */

		      var done = false;

		      while (!done) {
		        if (current !== null) {
		          Q.push(current);
		          current = current.left;
		        } else {
		          if (Q.length !== 0) {
		            current = Q.pop();
		            visitor.call(ctx, current);
		            current = current.right;
		          } else done = true;
		        }
		      }

		      return this;
		    };
		    /**
		     * Walk key range from `low` to `high`. Stops if `fn` returns a value.
		     */


		    Tree.prototype.range = function (low, high, fn, ctx) {
		      var Q = [];
		      var compare = this._comparator;
		      var node = this._root;
		      var cmp;

		      while (Q.length !== 0 || node) {
		        if (node) {
		          Q.push(node);
		          node = node.left;
		        } else {
		          node = Q.pop();
		          cmp = compare(node.key, high);

		          if (cmp > 0) {
		            break;
		          } else if (compare(node.key, low) >= 0) {
		            if (fn.call(ctx, node)) return this; // stop if smth is returned
		          }

		          node = node.right;
		        }
		      }

		      return this;
		    };
		    /**
		     * Returns array of keys
		     */


		    Tree.prototype.keys = function () {
		      var keys = [];
		      this.forEach(function (_a) {
		        var key = _a.key;
		        return keys.push(key);
		      });
		      return keys;
		    };
		    /**
		     * Returns array of all the data in the nodes
		     */


		    Tree.prototype.values = function () {
		      var values = [];
		      this.forEach(function (_a) {
		        var data = _a.data;
		        return values.push(data);
		      });
		      return values;
		    };

		    Tree.prototype.min = function () {
		      if (this._root) return this.minNode(this._root).key;
		      return null;
		    };

		    Tree.prototype.max = function () {
		      if (this._root) return this.maxNode(this._root).key;
		      return null;
		    };

		    Tree.prototype.minNode = function (t) {
		      if (t === void 0) {
		        t = this._root;
		      }

		      if (t) while (t.left) {
		        t = t.left;
		      }
		      return t;
		    };

		    Tree.prototype.maxNode = function (t) {
		      if (t === void 0) {
		        t = this._root;
		      }

		      if (t) while (t.right) {
		        t = t.right;
		      }
		      return t;
		    };
		    /**
		     * Returns node at given index
		     */


		    Tree.prototype.at = function (index) {
		      var current = this._root;
		      var done = false;
		      var i = 0;
		      var Q = [];

		      while (!done) {
		        if (current) {
		          Q.push(current);
		          current = current.left;
		        } else {
		          if (Q.length > 0) {
		            current = Q.pop();
		            if (i === index) return current;
		            i++;
		            current = current.right;
		          } else done = true;
		        }
		      }

		      return null;
		    };

		    Tree.prototype.next = function (d) {
		      var root = this._root;
		      var successor = null;

		      if (d.right) {
		        successor = d.right;

		        while (successor.left) {
		          successor = successor.left;
		        }

		        return successor;
		      }

		      var comparator = this._comparator;

		      while (root) {
		        var cmp = comparator(d.key, root.key);
		        if (cmp === 0) break;else if (cmp < 0) {
		          successor = root;
		          root = root.left;
		        } else root = root.right;
		      }

		      return successor;
		    };

		    Tree.prototype.prev = function (d) {
		      var root = this._root;
		      var predecessor = null;

		      if (d.left !== null) {
		        predecessor = d.left;

		        while (predecessor.right) {
		          predecessor = predecessor.right;
		        }

		        return predecessor;
		      }

		      var comparator = this._comparator;

		      while (root) {
		        var cmp = comparator(d.key, root.key);
		        if (cmp === 0) break;else if (cmp < 0) root = root.left;else {
		          predecessor = root;
		          root = root.right;
		        }
		      }

		      return predecessor;
		    };

		    Tree.prototype.clear = function () {
		      this._root = null;
		      this._size = 0;
		      return this;
		    };

		    Tree.prototype.toList = function () {
		      return toList(this._root);
		    };
		    /**
		     * Bulk-load items. Both array have to be same size
		     */


		    Tree.prototype.load = function (keys, values, presort) {
		      if (values === void 0) {
		        values = [];
		      }

		      if (presort === void 0) {
		        presort = false;
		      }

		      var size = keys.length;
		      var comparator = this._comparator; // sort if needed

		      if (presort) sort(keys, values, 0, size - 1, comparator);

		      if (this._root === null) {
		        // empty tree
		        this._root = loadRecursive(keys, values, 0, size);
		        this._size = size;
		      } else {
		        // that re-builds the whole tree from two in-order traversals
		        var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
		        size = this._size + size;
		        this._root = sortedListToBST({
		          head: mergedList
		        }, 0, size);
		      }

		      return this;
		    };

		    Tree.prototype.isEmpty = function () {
		      return this._root === null;
		    };

		    Object.defineProperty(Tree.prototype, "size", {
		      get: function get() {
		        return this._size;
		      },
		      enumerable: true,
		      configurable: true
		    });
		    Object.defineProperty(Tree.prototype, "root", {
		      get: function get() {
		        return this._root;
		      },
		      enumerable: true,
		      configurable: true
		    });

		    Tree.prototype.toString = function (printNode) {
		      if (printNode === void 0) {
		        printNode = function printNode(n) {
		          return String(n.key);
		        };
		      }

		      var out = [];
		      printRow(this._root, '', true, function (v) {
		        return out.push(v);
		      }, printNode);
		      return out.join('');
		    };

		    Tree.prototype.update = function (key, newKey, newData) {
		      var comparator = this._comparator;

		      var _a = split(key, this._root, comparator),
		          left = _a.left,
		          right = _a.right;

		      if (comparator(key, newKey) < 0) {
		        right = insert(newKey, newData, right, comparator);
		      } else {
		        left = insert(newKey, newData, left, comparator);
		      }

		      this._root = merge(left, right, comparator);
		    };

		    Tree.prototype.split = function (key) {
		      return split(key, this._root, this._comparator);
		    };

		    return Tree;
		  }();

		  function loadRecursive(keys, values, start, end) {
		    var size = end - start;

		    if (size > 0) {
		      var middle = start + Math.floor(size / 2);
		      var key = keys[middle];
		      var data = values[middle];
		      var node = new Node(key, data);
		      node.left = loadRecursive(keys, values, start, middle);
		      node.right = loadRecursive(keys, values, middle + 1, end);
		      return node;
		    }

		    return null;
		  }

		  function createList(keys, values) {
		    var head = new Node(null, null);
		    var p = head;

		    for (var i = 0; i < keys.length; i++) {
		      p = p.next = new Node(keys[i], values[i]);
		    }

		    p.next = null;
		    return head.next;
		  }

		  function toList(root) {
		    var current = root;
		    var Q = [];
		    var done = false;
		    var head = new Node(null, null);
		    var p = head;

		    while (!done) {
		      if (current) {
		        Q.push(current);
		        current = current.left;
		      } else {
		        if (Q.length > 0) {
		          current = p = p.next = Q.pop();
		          current = current.right;
		        } else done = true;
		      }
		    }

		    p.next = null; // that'll work even if the tree was empty

		    return head.next;
		  }

		  function sortedListToBST(list, start, end) {
		    var size = end - start;

		    if (size > 0) {
		      var middle = start + Math.floor(size / 2);
		      var left = sortedListToBST(list, start, middle);
		      var root = list.head;
		      root.left = left;
		      list.head = list.head.next;
		      root.right = sortedListToBST(list, middle + 1, end);
		      return root;
		    }

		    return null;
		  }

		  function mergeLists(l1, l2, compare) {
		    var head = new Node(null, null); // dummy

		    var p = head;
		    var p1 = l1;
		    var p2 = l2;

		    while (p1 !== null && p2 !== null) {
		      if (compare(p1.key, p2.key) < 0) {
		        p.next = p1;
		        p1 = p1.next;
		      } else {
		        p.next = p2;
		        p2 = p2.next;
		      }

		      p = p.next;
		    }

		    if (p1 !== null) {
		      p.next = p1;
		    } else if (p2 !== null) {
		      p.next = p2;
		    }

		    return head.next;
		  }

		  function sort(keys, values, left, right, compare) {
		    if (left >= right) return;
		    var pivot = keys[left + right >> 1];
		    var i = left - 1;
		    var j = right + 1;

		    while (true) {
		      do {
		        i++;
		      } while (compare(keys[i], pivot) < 0);

		      do {
		        j--;
		      } while (compare(keys[j], pivot) > 0);

		      if (i >= j) break;
		      var tmp = keys[i];
		      keys[i] = keys[j];
		      keys[j] = tmp;
		      tmp = values[i];
		      values[i] = values[j];
		      values[j] = tmp;
		    }

		    sort(keys, values, left, j, compare);
		    sort(keys, values, j + 1, right, compare);
		  }

		  /**
		   * A bounding box has the format:
		   *
		   *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }
		   *
		   */
		  var isInBbox = function isInBbox(bbox, point) {
		    return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;
		  };
		  /* Returns either null, or a bbox (aka an ordered pair of points)
		   * If there is only one point of overlap, a bbox with identical points
		   * will be returned */

		  var getBboxOverlap = function getBboxOverlap(b1, b2) {
		    // check if the bboxes overlap at all
		    if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values

		    var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
		    var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values

		    var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
		    var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap

		    return {
		      ll: {
		        x: lowerX,
		        y: lowerY
		      },
		      ur: {
		        x: upperX,
		        y: upperY
		      }
		    };
		  };

		  /* Javascript doesn't do integer math. Everything is
		   * floating point with percision Number.EPSILON.
		   *
		   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
		   */
		  var epsilon = Number.EPSILON; // IE Polyfill

		  if (epsilon === undefined) epsilon = Math.pow(2, -52);
		  var EPSILON_SQ = epsilon * epsilon;
		  /* FLP comparator */

		  var cmp = function cmp(a, b) {
		    // check if they're both 0
		    if (-epsilon < a && a < epsilon) {
		      if (-epsilon < b && b < epsilon) {
		        return 0;
		      }
		    } // check if they're flp equal


		    var ab = a - b;

		    if (ab * ab < EPSILON_SQ * a * b) {
		      return 0;
		    } // normal comparison


		    return a < b ? -1 : 1;
		  };

		  /**
		   * This class rounds incoming values sufficiently so that
		   * floating points problems are, for the most part, avoided.
		   *
		   * Incoming points are have their x & y values tested against
		   * all previously seen x & y values. If either is 'too close'
		   * to a previously seen value, it's value is 'snapped' to the
		   * previously seen value.
		   *
		   * All points should be rounded by this class before being
		   * stored in any data structures in the rest of this algorithm.
		   */

		  var PtRounder = /*#__PURE__*/function () {
		    function PtRounder() {
		      _classCallCheck(this, PtRounder);

		      this.reset();
		    }

		    _createClass(PtRounder, [{
		      key: "reset",
		      value: function reset() {
		        this.xRounder = new CoordRounder();
		        this.yRounder = new CoordRounder();
		      }
		    }, {
		      key: "round",
		      value: function round(x, y) {
		        return {
		          x: this.xRounder.round(x),
		          y: this.yRounder.round(y)
		        };
		      }
		    }]);

		    return PtRounder;
		  }();

		  var CoordRounder = /*#__PURE__*/function () {
		    function CoordRounder() {
		      _classCallCheck(this, CoordRounder);

		      this.tree = new Tree(); // preseed with 0 so we don't end up with values < Number.EPSILON

		      this.round(0);
		    } // Note: this can rounds input values backwards or forwards.
		    //       You might ask, why not restrict this to just rounding
		    //       forwards? Wouldn't that allow left endpoints to always
		    //       remain left endpoints during splitting (never change to
		    //       right). No - it wouldn't, because we snap intersections
		    //       to endpoints (to establish independence from the segment
		    //       angle for t-intersections).


		    _createClass(CoordRounder, [{
		      key: "round",
		      value: function round(coord) {
		        var node = this.tree.add(coord);
		        var prevNode = this.tree.prev(node);

		        if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
		          this.tree.remove(coord);
		          return prevNode.key;
		        }

		        var nextNode = this.tree.next(node);

		        if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
		          this.tree.remove(coord);
		          return nextNode.key;
		        }

		        return coord;
		      }
		    }]);

		    return CoordRounder;
		  }(); // singleton available by import


		  var rounder = new PtRounder();

		  /* Cross Product of two vectors with first point at origin */

		  var crossProduct = function crossProduct(a, b) {
		    return a.x * b.y - a.y * b.x;
		  };
		  /* Dot Product of two vectors with first point at origin */

		  var dotProduct = function dotProduct(a, b) {
		    return a.x * b.x + a.y * b.y;
		  };
		  /* Comparator for two vectors with same starting point */

		  var compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {
		    var v1 = {
		      x: endPt1.x - basePt.x,
		      y: endPt1.y - basePt.y
		    };
		    var v2 = {
		      x: endPt2.x - basePt.x,
		      y: endPt2.y - basePt.y
		    };
		    var kross = crossProduct(v1, v2);
		    return cmp(kross, 0);
		  };
		  var length = function length(v) {
		    return Math.sqrt(dotProduct(v, v));
		  };
		  /* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */

		  var sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {
		    var vBase = {
		      x: pBase.x - pShared.x,
		      y: pBase.y - pShared.y
		    };
		    var vAngle = {
		      x: pAngle.x - pShared.x,
		      y: pAngle.y - pShared.y
		    };
		    return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);
		  };
		  /* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */

		  var cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {
		    var vBase = {
		      x: pBase.x - pShared.x,
		      y: pBase.y - pShared.y
		    };
		    var vAngle = {
		      x: pAngle.x - pShared.x,
		      y: pAngle.y - pShared.y
		    };
		    return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);
		  };
		  /* Get the x coordinate where the given line (defined by a point and vector)
		   * crosses the horizontal line with the given y coordiante.
		   * In the case of parrallel lines (including overlapping ones) returns null. */

		  var horizontalIntersection = function horizontalIntersection(pt, v, y) {
		    if (v.y === 0) return null;
		    return {
		      x: pt.x + v.x / v.y * (y - pt.y),
		      y: y
		    };
		  };
		  /* Get the y coordinate where the given line (defined by a point and vector)
		   * crosses the vertical line with the given x coordiante.
		   * In the case of parrallel lines (including overlapping ones) returns null. */

		  var verticalIntersection = function verticalIntersection(pt, v, x) {
		    if (v.x === 0) return null;
		    return {
		      x: x,
		      y: pt.y + v.y / v.x * (x - pt.x)
		    };
		  };
		  /* Get the intersection of two lines, each defined by a base point and a vector.
		   * In the case of parrallel lines (including overlapping ones) returns null. */

		  var intersection = function intersection(pt1, v1, pt2, v2) {
		    // take some shortcuts for vertical and horizontal lines
		    // this also ensures we don't calculate an intersection and then discover
		    // it's actually outside the bounding box of the line
		    if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);
		    if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);
		    if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);
		    if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.
		    // This algorithm is based on Schneider and Eberly.
		    // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244

		    var kross = crossProduct(v1, v2);
		    if (kross == 0) return null;
		    var ve = {
		      x: pt2.x - pt1.x,
		      y: pt2.y - pt1.y
		    };
		    var d1 = crossProduct(ve, v1) / kross;
		    var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error

		    var x1 = pt1.x + d2 * v1.x,
		        x2 = pt2.x + d1 * v2.x;
		    var y1 = pt1.y + d2 * v1.y,
		        y2 = pt2.y + d1 * v2.y;
		    var x = (x1 + x2) / 2;
		    var y = (y1 + y2) / 2;
		    return {
		      x: x,
		      y: y
		    };
		  };

		  var SweepEvent = /*#__PURE__*/function () {
		    _createClass(SweepEvent, null, [{
		      key: "compare",
		      // for ordering sweep events in the sweep event queue
		      value: function compare(a, b) {
		        // favor event with a point that the sweep line hits first
		        var ptCmp = SweepEvent.comparePoints(a.point, b.point);
		        if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed

		        if (a.point !== b.point) a.link(b); // favor right events over left

		        if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints
		        // ordering of this case is the same as for their segments

		        return Segment.compare(a.segment, b.segment);
		      } // for ordering points in sweep line order

		    }, {
		      key: "comparePoints",
		      value: function comparePoints(aPt, bPt) {
		        if (aPt.x < bPt.x) return -1;
		        if (aPt.x > bPt.x) return 1;
		        if (aPt.y < bPt.y) return -1;
		        if (aPt.y > bPt.y) return 1;
		        return 0;
		      } // Warning: 'point' input will be modified and re-used (for performance)

		    }]);

		    function SweepEvent(point, isLeft) {
		      _classCallCheck(this, SweepEvent);

		      if (point.events === undefined) point.events = [this];else point.events.push(this);
		      this.point = point;
		      this.isLeft = isLeft; // this.segment, this.otherSE set by factory
		    }

		    _createClass(SweepEvent, [{
		      key: "link",
		      value: function link(other) {
		        if (other.point === this.point) {
		          throw new Error('Tried to link already linked events');
		        }

		        var otherEvents = other.point.events;

		        for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
		          var evt = otherEvents[i];
		          this.point.events.push(evt);
		          evt.point = this.point;
		        }

		        this.checkForConsuming();
		      }
		      /* Do a pass over our linked events and check to see if any pair
		       * of segments match, and should be consumed. */

		    }, {
		      key: "checkForConsuming",
		      value: function checkForConsuming() {
		        // FIXME: The loops in this method run O(n^2) => no good.
		        //        Maintain little ordered sweep event trees?
		        //        Can we maintaining an ordering that avoids the need
		        //        for the re-sorting with getLeftmostComparator in geom-out?
		        // Compare each pair of events to see if other events also match
		        var numEvents = this.point.events.length;

		        for (var i = 0; i < numEvents; i++) {
		          var evt1 = this.point.events[i];
		          if (evt1.segment.consumedBy !== undefined) continue;

		          for (var j = i + 1; j < numEvents; j++) {
		            var evt2 = this.point.events[j];
		            if (evt2.consumedBy !== undefined) continue;
		            if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;
		            evt1.segment.consume(evt2.segment);
		          }
		        }
		      }
		    }, {
		      key: "getAvailableLinkedEvents",
		      value: function getAvailableLinkedEvents() {
		        // point.events is always of length 2 or greater
		        var events = [];

		        for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
		          var evt = this.point.events[i];

		          if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
		            events.push(evt);
		          }
		        }

		        return events;
		      }
		      /**
		       * Returns a comparator function for sorting linked events that will
		       * favor the event that will give us the smallest left-side angle.
		       * All ring construction starts as low as possible heading to the right,
		       * so by always turning left as sharp as possible we'll get polygons
		       * without uncessary loops & holes.
		       *
		       * The comparator function has a compute cache such that it avoids
		       * re-computing already-computed values.
		       */

		    }, {
		      key: "getLeftmostComparator",
		      value: function getLeftmostComparator(baseEvent) {
		        var _this = this;

		        var cache = new Map();

		        var fillCache = function fillCache(linkedEvent) {
		          var nextEvent = linkedEvent.otherSE;
		          cache.set(linkedEvent, {
		            sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
		            cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
		          });
		        };

		        return function (a, b) {
		          if (!cache.has(a)) fillCache(a);
		          if (!cache.has(b)) fillCache(b);

		          var _cache$get = cache.get(a),
		              asine = _cache$get.sine,
		              acosine = _cache$get.cosine;

		          var _cache$get2 = cache.get(b),
		              bsine = _cache$get2.sine,
		              bcosine = _cache$get2.cosine; // both on or above x-axis


		          if (asine >= 0 && bsine >= 0) {
		            if (acosine < bcosine) return 1;
		            if (acosine > bcosine) return -1;
		            return 0;
		          } // both below x-axis


		          if (asine < 0 && bsine < 0) {
		            if (acosine < bcosine) return -1;
		            if (acosine > bcosine) return 1;
		            return 0;
		          } // one above x-axis, one below


		          if (bsine < asine) return -1;
		          if (bsine > asine) return 1;
		          return 0;
		        };
		      }
		    }]);

		    return SweepEvent;
		  }();

		  // segments and sweep events when all else is identical

		  var segmentId = 0;

		  var Segment = /*#__PURE__*/function () {
		    _createClass(Segment, null, [{
		      key: "compare",

		      /* This compare() function is for ordering segments in the sweep
		       * line tree, and does so according to the following criteria:
		       *
		       * Consider the vertical line that lies an infinestimal step to the
		       * right of the right-more of the two left endpoints of the input
		       * segments. Imagine slowly moving a point up from negative infinity
		       * in the increasing y direction. Which of the two segments will that
		       * point intersect first? That segment comes 'before' the other one.
		       *
		       * If neither segment would be intersected by such a line, (if one
		       * or more of the segments are vertical) then the line to be considered
		       * is directly on the right-more of the two left inputs.
		       */
		      value: function compare(a, b) {
		        var alx = a.leftSE.point.x;
		        var blx = b.leftSE.point.x;
		        var arx = a.rightSE.point.x;
		        var brx = b.rightSE.point.x; // check if they're even in the same vertical plane

		        if (brx < alx) return 1;
		        if (arx < blx) return -1;
		        var aly = a.leftSE.point.y;
		        var bly = b.leftSE.point.y;
		        var ary = a.rightSE.point.y;
		        var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?

		        if (alx < blx) {
		          // are the two segments in the same horizontal plane?
		          if (bly < aly && bly < ary) return 1;
		          if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?

		          var aCmpBLeft = a.comparePoint(b.leftSE.point);
		          if (aCmpBLeft < 0) return 1;
		          if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?

		          var bCmpARight = b.comparePoint(a.rightSE.point);
		          if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more
		          // left endpoint to be first (arbitrary?)

		          return -1;
		        } // is left endpoint of segment A the right-more?


		        if (alx > blx) {
		          if (aly < bly && aly < bry) return -1;
		          if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?

		          var bCmpALeft = b.comparePoint(a.leftSE.point);
		          if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?

		          var aCmpBRight = a.comparePoint(b.rightSE.point);
		          if (aCmpBRight < 0) return 1;
		          if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more
		          // left endpoint to be first (arbitrary?)

		          return 1;
		        } // if we get here, the two left endpoints are in the same
		        // vertical plane, ie alx === blx
		        // consider the lower left-endpoint to come first


		        if (aly < bly) return -1;
		        if (aly > bly) return 1; // left endpoints are identical
		        // check for colinearity by using the left-more right endpoint
		        // is the A right endpoint more left-more?

		        if (arx < brx) {
		          var _bCmpARight = b.comparePoint(a.rightSE.point);

		          if (_bCmpARight !== 0) return _bCmpARight;
		        } // is the B right endpoint more left-more?


		        if (arx > brx) {
		          var _aCmpBRight = a.comparePoint(b.rightSE.point);

		          if (_aCmpBRight < 0) return 1;
		          if (_aCmpBRight > 0) return -1;
		        }

		        if (arx !== brx) {
		          // are these two [almost] vertical segments with opposite orientation?
		          // if so, the one with the lower right endpoint comes first
		          var ay = ary - aly;
		          var ax = arx - alx;
		          var by = bry - bly;
		          var bx = brx - blx;
		          if (ay > ax && by < bx) return 1;
		          if (ay < ax && by > bx) return -1;
		        } // we have colinear segments with matching orientation
		        // consider the one with more left-more right endpoint to be first


		        if (arx > brx) return 1;
		        if (arx < brx) return -1; // if we get here, two two right endpoints are in the same
		        // vertical plane, ie arx === brx
		        // consider the lower right-endpoint to come first

		        if (ary < bry) return -1;
		        if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential
		        // fall back on creation order as consistent tie-breaker

		        if (a.id < b.id) return -1;
		        if (a.id > b.id) return 1; // identical segment, ie a === b

		        return 0;
		      }
		      /* Warning: a reference to ringWindings input will be stored,
		       *  and possibly will be later modified */

		    }]);

		    function Segment(leftSE, rightSE, rings, windings) {
		      _classCallCheck(this, Segment);

		      this.id = ++segmentId;
		      this.leftSE = leftSE;
		      leftSE.segment = this;
		      leftSE.otherSE = rightSE;
		      this.rightSE = rightSE;
		      rightSE.segment = this;
		      rightSE.otherSE = leftSE;
		      this.rings = rings;
		      this.windings = windings; // left unset for performance, set later in algorithm
		      // this.ringOut, this.consumedBy, this.prev
		    }

		    _createClass(Segment, [{
		      key: "replaceRightSE",

		      /* When a segment is split, the rightSE is replaced with a new sweep event */
		      value: function replaceRightSE(newRightSE) {
		        this.rightSE = newRightSE;
		        this.rightSE.segment = this;
		        this.rightSE.otherSE = this.leftSE;
		        this.leftSE.otherSE = this.rightSE;
		      }
		    }, {
		      key: "bbox",
		      value: function bbox() {
		        var y1 = this.leftSE.point.y;
		        var y2 = this.rightSE.point.y;
		        return {
		          ll: {
		            x: this.leftSE.point.x,
		            y: y1 < y2 ? y1 : y2
		          },
		          ur: {
		            x: this.rightSE.point.x,
		            y: y1 > y2 ? y1 : y2
		          }
		        };
		      }
		      /* A vector from the left point to the right */

		    }, {
		      key: "vector",
		      value: function vector() {
		        return {
		          x: this.rightSE.point.x - this.leftSE.point.x,
		          y: this.rightSE.point.y - this.leftSE.point.y
		        };
		      }
		    }, {
		      key: "isAnEndpoint",
		      value: function isAnEndpoint(pt) {
		        return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
		      }
		      /* Compare this segment with a point.
		       *
		       * A point P is considered to be colinear to a segment if there
		       * exists a distance D such that if we travel along the segment
		       * from one * endpoint towards the other a distance D, we find
		       * ourselves at point P.
		       *
		       * Return value indicates:
		       *
		       *   1: point lies above the segment (to the left of vertical)
		       *   0: point is colinear to segment
		       *  -1: point lies below the segment (to the right of vertical)
		       */

		    }, {
		      key: "comparePoint",
		      value: function comparePoint(point) {
		        if (this.isAnEndpoint(point)) return 0;
		        var lPt = this.leftSE.point;
		        var rPt = this.rightSE.point;
		        var v = this.vector(); // Exactly vertical segments.

		        if (lPt.x === rPt.x) {
		          if (point.x === lPt.x) return 0;
		          return point.x < lPt.x ? 1 : -1;
		        } // Nearly vertical segments with an intersection.
		        // Check to see where a point on the line with matching Y coordinate is.


		        var yDist = (point.y - lPt.y) / v.y;
		        var xFromYDist = lPt.x + yDist * v.x;
		        if (point.x === xFromYDist) return 0; // General case.
		        // Check to see where a point on the line with matching X coordinate is.

		        var xDist = (point.x - lPt.x) / v.x;
		        var yFromXDist = lPt.y + xDist * v.y;
		        if (point.y === yFromXDist) return 0;
		        return point.y < yFromXDist ? -1 : 1;
		      }
		      /**
		       * Given another segment, returns the first non-trivial intersection
		       * between the two segments (in terms of sweep line ordering), if it exists.
		       *
		       * A 'non-trivial' intersection is one that will cause one or both of the
		       * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
		       *
		       *   * endpoint of segA with endpoint of segB --> trivial
		       *   * endpoint of segA with point along segB --> non-trivial
		       *   * endpoint of segB with point along segA --> non-trivial
		       *   * point along segA with point along segB --> non-trivial
		       *
		       * If no non-trivial intersection exists, return null
		       * Else, return null.
		       */

		    }, {
		      key: "getIntersection",
		      value: function getIntersection(other) {
		        // If bboxes don't overlap, there can't be any intersections
		        var tBbox = this.bbox();
		        var oBbox = other.bbox();
		        var bboxOverlap = getBboxOverlap(tBbox, oBbox);
		        if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.
		        // This will 'snap' intersections to endpoints if possible, and will
		        // handle cases of colinearity.

		        var tlp = this.leftSE.point;
		        var trp = this.rightSE.point;
		        var olp = other.leftSE.point;
		        var orp = other.rightSE.point; // does each endpoint touch the other segment?
		        // note that we restrict the 'touching' definition to only allow segments
		        // to touch endpoints that lie forward from where we are in the sweep line pass

		        var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
		        var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
		        var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
		        var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?

		        if (touchesThisLSE && touchesOtherLSE) {
		          // these two cases are for colinear segments with matching left
		          // endpoints, and one segment being longer than the other
		          if (touchesThisRSE && !touchesOtherRSE) return trp;
		          if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)
		          // or just on their left endpoint (one trivial intersection

		          return null;
		        } // does this left endpoint matches (other doesn't)


		        if (touchesThisLSE) {
		          // check for segments that just intersect on opposing endpoints
		          if (touchesOtherRSE) {
		            if (tlp.x === orp.x && tlp.y === orp.y) return null;
		          } // t-intersection on left endpoint


		          return tlp;
		        } // does other left endpoint matches (this doesn't)


		        if (touchesOtherLSE) {
		          // check for segments that just intersect on opposing endpoints
		          if (touchesThisRSE) {
		            if (trp.x === olp.x && trp.y === olp.y) return null;
		          } // t-intersection on left endpoint


		          return olp;
		        } // trivial intersection on right endpoints


		        if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint

		        if (touchesThisRSE) return trp;
		        if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between
		        // infinite lines laid over the segments

		        var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,
		        // they would have an endpoint intersection and that case was already handled above

		        if (pt === null) return null; // is the intersection found between the lines not on the segments?

		        if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed

		        return rounder.round(pt.x, pt.y);
		      }
		      /**
		       * Split the given segment into multiple segments on the given points.
		       *  * Each existing segment will retain its leftSE and a new rightSE will be
		       *    generated for it.
		       *  * A new segment will be generated which will adopt the original segment's
		       *    rightSE, and a new leftSE will be generated for it.
		       *  * If there are more than two points given to split on, new segments
		       *    in the middle will be generated with new leftSE and rightSE's.
		       *  * An array of the newly generated SweepEvents will be returned.
		       *
		       * Warning: input array of points is modified
		       */

		    }, {
		      key: "split",
		      value: function split(point) {
		        var newEvents = [];
		        var alreadyLinked = point.events !== undefined;
		        var newLeftSE = new SweepEvent(point, true);
		        var newRightSE = new SweepEvent(point, false);
		        var oldRightSE = this.rightSE;
		        this.replaceRightSE(newRightSE);
		        newEvents.push(newRightSE);
		        newEvents.push(newLeftSE);
		        var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,
		        // sometimes one of the resulting new segments is vertical, in which
		        // case its left and right events may need to be swapped

		        if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
		          newSeg.swapEvents();
		        }

		        if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
		          this.swapEvents();
		        } // in the point we just used to create new sweep events with was already
		        // linked to other events, we need to check if either of the affected
		        // segments should be consumed


		        if (alreadyLinked) {
		          newLeftSE.checkForConsuming();
		          newRightSE.checkForConsuming();
		        }

		        return newEvents;
		      }
		      /* Swap which event is left and right */

		    }, {
		      key: "swapEvents",
		      value: function swapEvents() {
		        var tmpEvt = this.rightSE;
		        this.rightSE = this.leftSE;
		        this.leftSE = tmpEvt;
		        this.leftSE.isLeft = true;
		        this.rightSE.isLeft = false;

		        for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
		          this.windings[i] *= -1;
		        }
		      }
		      /* Consume another segment. We take their rings under our wing
		       * and mark them as consumed. Use for perfectly overlapping segments */

		    }, {
		      key: "consume",
		      value: function consume(other) {
		        var consumer = this;
		        var consumee = other;

		        while (consumer.consumedBy) {
		          consumer = consumer.consumedBy;
		        }

		        while (consumee.consumedBy) {
		          consumee = consumee.consumedBy;
		        }

		        var cmp = Segment.compare(consumer, consumee);
		        if (cmp === 0) return; // already consumed
		        // the winner of the consumption is the earlier segment
		        // according to sweep line ordering

		        if (cmp > 0) {
		          var tmp = consumer;
		          consumer = consumee;
		          consumee = tmp;
		        } // make sure a segment doesn't consume it's prev


		        if (consumer.prev === consumee) {
		          var _tmp = consumer;
		          consumer = consumee;
		          consumee = _tmp;
		        }

		        for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
		          var ring = consumee.rings[i];
		          var winding = consumee.windings[i];
		          var index = consumer.rings.indexOf(ring);

		          if (index === -1) {
		            consumer.rings.push(ring);
		            consumer.windings.push(winding);
		          } else consumer.windings[index] += winding;
		        }

		        consumee.rings = null;
		        consumee.windings = null;
		        consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue

		        consumee.leftSE.consumedBy = consumer.leftSE;
		        consumee.rightSE.consumedBy = consumer.rightSE;
		      }
		      /* The first segment previous segment chain that is in the result */

		    }, {
		      key: "prevInResult",
		      value: function prevInResult() {
		        if (this._prevInResult !== undefined) return this._prevInResult;
		        if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();
		        return this._prevInResult;
		      }
		    }, {
		      key: "beforeState",
		      value: function beforeState() {
		        if (this._beforeState !== undefined) return this._beforeState;
		        if (!this.prev) this._beforeState = {
		          rings: [],
		          windings: [],
		          multiPolys: []
		        };else {
		          var seg = this.prev.consumedBy || this.prev;
		          this._beforeState = seg.afterState();
		        }
		        return this._beforeState;
		      }
		    }, {
		      key: "afterState",
		      value: function afterState() {
		        if (this._afterState !== undefined) return this._afterState;
		        var beforeState = this.beforeState();
		        this._afterState = {
		          rings: beforeState.rings.slice(0),
		          windings: beforeState.windings.slice(0),
		          multiPolys: []
		        };
		        var ringsAfter = this._afterState.rings;
		        var windingsAfter = this._afterState.windings;
		        var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter

		        for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
		          var ring = this.rings[i];
		          var winding = this.windings[i];
		          var index = ringsAfter.indexOf(ring);

		          if (index === -1) {
		            ringsAfter.push(ring);
		            windingsAfter.push(winding);
		          } else windingsAfter[index] += winding;
		        } // calcualte polysAfter


		        var polysAfter = [];
		        var polysExclude = [];

		        for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
		          if (windingsAfter[_i] === 0) continue; // non-zero rule

		          var _ring = ringsAfter[_i];
		          var poly = _ring.poly;
		          if (polysExclude.indexOf(poly) !== -1) continue;
		          if (_ring.isExterior) polysAfter.push(poly);else {
		            if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);

		            var _index = polysAfter.indexOf(_ring.poly);

		            if (_index !== -1) polysAfter.splice(_index, 1);
		          }
		        } // calculate multiPolysAfter


		        for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
		          var mp = polysAfter[_i2].multiPoly;
		          if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);
		        }

		        return this._afterState;
		      }
		      /* Is this segment part of the final result? */

		    }, {
		      key: "isInResult",
		      value: function isInResult() {
		        // if we've been consumed, we're not in the result
		        if (this.consumedBy) return false;
		        if (this._isInResult !== undefined) return this._isInResult;
		        var mpsBefore = this.beforeState().multiPolys;
		        var mpsAfter = this.afterState().multiPolys;

		        switch (operation.type) {
		          case 'union':
		            {
		              // UNION - included iff:
		              //  * On one side of us there is 0 poly interiors AND
		              //  * On the other side there is 1 or more.
		              var noBefores = mpsBefore.length === 0;
		              var noAfters = mpsAfter.length === 0;
		              this._isInResult = noBefores !== noAfters;
		              break;
		            }

		          case 'intersection':
		            {
		              // INTERSECTION - included iff:
		              //  * on one side of us all multipolys are rep. with poly interiors AND
		              //  * on the other side of us, not all multipolys are repsented
		              //    with poly interiors
		              var least;
		              var most;

		              if (mpsBefore.length < mpsAfter.length) {
		                least = mpsBefore.length;
		                most = mpsAfter.length;
		              } else {
		                least = mpsAfter.length;
		                most = mpsBefore.length;
		              }

		              this._isInResult = most === operation.numMultiPolys && least < most;
		              break;
		            }

		          case 'xor':
		            {
		              // XOR - included iff:
		              //  * the difference between the number of multipolys represented
		              //    with poly interiors on our two sides is an odd number
		              var diff = Math.abs(mpsBefore.length - mpsAfter.length);
		              this._isInResult = diff % 2 === 1;
		              break;
		            }

		          case 'difference':
		            {
		              // DIFFERENCE included iff:
		              //  * on exactly one side, we have just the subject
		              var isJustSubject = function isJustSubject(mps) {
		                return mps.length === 1 && mps[0].isSubject;
		              };

		              this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
		              break;
		            }

		          default:
		            throw new Error("Unrecognized operation type found ".concat(operation.type));
		        }

		        return this._isInResult;
		      }
		    }], [{
		      key: "fromRing",
		      value: function fromRing(pt1, pt2, ring) {
		        var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering

		        var cmpPts = SweepEvent.comparePoints(pt1, pt2);

		        if (cmpPts < 0) {
		          leftPt = pt1;
		          rightPt = pt2;
		          winding = 1;
		        } else if (cmpPts > 0) {
		          leftPt = pt2;
		          rightPt = pt1;
		          winding = -1;
		        } else throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));

		        var leftSE = new SweepEvent(leftPt, true);
		        var rightSE = new SweepEvent(rightPt, false);
		        return new Segment(leftSE, rightSE, [ring], [winding]);
		      }
		    }]);

		    return Segment;
		  }();

		  var RingIn = /*#__PURE__*/function () {
		    function RingIn(geomRing, poly, isExterior) {
		      _classCallCheck(this, RingIn);

		      if (!Array.isArray(geomRing) || geomRing.length === 0) {
		        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
		      }

		      this.poly = poly;
		      this.isExterior = isExterior;
		      this.segments = [];

		      if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {
		        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
		      }

		      var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
		      this.bbox = {
		        ll: {
		          x: firstPoint.x,
		          y: firstPoint.y
		        },
		        ur: {
		          x: firstPoint.x,
		          y: firstPoint.y
		        }
		      };
		      var prevPoint = firstPoint;

		      for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
		        if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {
		          throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
		        }

		        var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points

		        if (point.x === prevPoint.x && point.y === prevPoint.y) continue;
		        this.segments.push(Segment.fromRing(prevPoint, point, this));
		        if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;
		        if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;
		        if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;
		        if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;
		        prevPoint = point;
		      } // add segment from last to first if last is not the same as first


		      if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
		        this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
		      }
		    }

		    _createClass(RingIn, [{
		      key: "getSweepEvents",
		      value: function getSweepEvents() {
		        var sweepEvents = [];

		        for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
		          var segment = this.segments[i];
		          sweepEvents.push(segment.leftSE);
		          sweepEvents.push(segment.rightSE);
		        }

		        return sweepEvents;
		      }
		    }]);

		    return RingIn;
		  }();
		  var PolyIn = /*#__PURE__*/function () {
		    function PolyIn(geomPoly, multiPoly) {
		      _classCallCheck(this, PolyIn);

		      if (!Array.isArray(geomPoly)) {
		        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
		      }

		      this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value

		      this.bbox = {
		        ll: {
		          x: this.exteriorRing.bbox.ll.x,
		          y: this.exteriorRing.bbox.ll.y
		        },
		        ur: {
		          x: this.exteriorRing.bbox.ur.x,
		          y: this.exteriorRing.bbox.ur.y
		        }
		      };
		      this.interiorRings = [];

		      for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
		        var ring = new RingIn(geomPoly[i], this, false);
		        if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;
		        if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;
		        if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;
		        if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;
		        this.interiorRings.push(ring);
		      }

		      this.multiPoly = multiPoly;
		    }

		    _createClass(PolyIn, [{
		      key: "getSweepEvents",
		      value: function getSweepEvents() {
		        var sweepEvents = this.exteriorRing.getSweepEvents();

		        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
		          var ringSweepEvents = this.interiorRings[i].getSweepEvents();

		          for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
		            sweepEvents.push(ringSweepEvents[j]);
		          }
		        }

		        return sweepEvents;
		      }
		    }]);

		    return PolyIn;
		  }();
		  var MultiPolyIn = /*#__PURE__*/function () {
		    function MultiPolyIn(geom, isSubject) {
		      _classCallCheck(this, MultiPolyIn);

		      if (!Array.isArray(geom)) {
		        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');
		      }

		      try {
		        // if the input looks like a polygon, convert it to a multipolygon
		        if (typeof geom[0][0][0] === 'number') geom = [geom];
		      } catch (ex) {// The input is either malformed or has empty arrays.
		        // In either case, it will be handled later on.
		      }

		      this.polys = [];
		      this.bbox = {
		        ll: {
		          x: Number.POSITIVE_INFINITY,
		          y: Number.POSITIVE_INFINITY
		        },
		        ur: {
		          x: Number.NEGATIVE_INFINITY,
		          y: Number.NEGATIVE_INFINITY
		        }
		      };

		      for (var i = 0, iMax = geom.length; i < iMax; i++) {
		        var poly = new PolyIn(geom[i], this);
		        if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;
		        if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;
		        if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;
		        if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;
		        this.polys.push(poly);
		      }

		      this.isSubject = isSubject;
		    }

		    _createClass(MultiPolyIn, [{
		      key: "getSweepEvents",
		      value: function getSweepEvents() {
		        var sweepEvents = [];

		        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
		          var polySweepEvents = this.polys[i].getSweepEvents();

		          for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
		            sweepEvents.push(polySweepEvents[j]);
		          }
		        }

		        return sweepEvents;
		      }
		    }]);

		    return MultiPolyIn;
		  }();

		  var RingOut = /*#__PURE__*/function () {
		    _createClass(RingOut, null, [{
		      key: "factory",

		      /* Given the segments from the sweep line pass, compute & return a series
		       * of closed rings from all the segments marked to be part of the result */
		      value: function factory(allSegments) {
		        var ringsOut = [];

		        for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
		          var segment = allSegments[i];
		          if (!segment.isInResult() || segment.ringOut) continue;
		          var prevEvent = null;
		          var event = segment.leftSE;
		          var nextEvent = segment.rightSE;
		          var events = [event];
		          var startingPoint = event.point;
		          var intersectionLEs = [];
		          /* Walk the chain of linked events to form a closed ring */

		          while (true) {
		            prevEvent = event;
		            event = nextEvent;
		            events.push(event);
		            /* Is the ring complete? */

		            if (event.point === startingPoint) break;

		            while (true) {
		              var availableLEs = event.getAvailableLinkedEvents();
		              /* Did we hit a dead end? This shouldn't happen. Indicates some earlier
		               * part of the algorithm malfunctioned... please file a bug report. */

		              if (availableLEs.length === 0) {
		                var firstPt = events[0].point;
		                var lastPt = events[events.length - 1].point;
		                throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
		              }
		              /* Only one way to go, so cotinue on the path */


		              if (availableLEs.length === 1) {
		                nextEvent = availableLEs[0].otherSE;
		                break;
		              }
		              /* We must have an intersection. Check for a completed loop */


		              var indexLE = null;

		              for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
		                if (intersectionLEs[j].point === event.point) {
		                  indexLE = j;
		                  break;
		                }
		              }
		              /* Found a completed loop. Cut that off and make a ring */


		              if (indexLE !== null) {
		                var intersectionLE = intersectionLEs.splice(indexLE)[0];
		                var ringEvents = events.splice(intersectionLE.index);
		                ringEvents.unshift(ringEvents[0].otherSE);
		                ringsOut.push(new RingOut(ringEvents.reverse()));
		                continue;
		              }
		              /* register the intersection */


		              intersectionLEs.push({
		                index: events.length,
		                point: event.point
		              });
		              /* Choose the left-most option to continue the walk */

		              var comparator = event.getLeftmostComparator(prevEvent);
		              nextEvent = availableLEs.sort(comparator)[0].otherSE;
		              break;
		            }
		          }

		          ringsOut.push(new RingOut(events));
		        }

		        return ringsOut;
		      }
		    }]);

		    function RingOut(events) {
		      _classCallCheck(this, RingOut);

		      this.events = events;

		      for (var i = 0, iMax = events.length; i < iMax; i++) {
		        events[i].segment.ringOut = this;
		      }

		      this.poly = null;
		    }

		    _createClass(RingOut, [{
		      key: "getGeom",
		      value: function getGeom() {
		        // Remove superfluous points (ie extra points along a straight line),
		        var prevPt = this.events[0].point;
		        var points = [prevPt];

		        for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
		          var _pt = this.events[i].point;
		          var _nextPt = this.events[i + 1].point;
		          if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;
		          points.push(_pt);
		          prevPt = _pt;
		        } // ring was all (within rounding error of angle calc) colinear points


		        if (points.length === 1) return null; // check if the starting point is necessary

		        var pt = points[0];
		        var nextPt = points[1];
		        if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();
		        points.push(points[0]);
		        var step = this.isExteriorRing() ? 1 : -1;
		        var iStart = this.isExteriorRing() ? 0 : points.length - 1;
		        var iEnd = this.isExteriorRing() ? points.length : -1;
		        var orderedPoints = [];

		        for (var _i = iStart; _i != iEnd; _i += step) {
		          orderedPoints.push([points[_i].x, points[_i].y]);
		        }

		        return orderedPoints;
		      }
		    }, {
		      key: "isExteriorRing",
		      value: function isExteriorRing() {
		        if (this._isExteriorRing === undefined) {
		          var enclosing = this.enclosingRing();
		          this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
		        }

		        return this._isExteriorRing;
		      }
		    }, {
		      key: "enclosingRing",
		      value: function enclosingRing() {
		        if (this._enclosingRing === undefined) {
		          this._enclosingRing = this._calcEnclosingRing();
		        }

		        return this._enclosingRing;
		      }
		      /* Returns the ring that encloses this one, if any */

		    }, {
		      key: "_calcEnclosingRing",
		      value: function _calcEnclosingRing() {
		        // start with the ealier sweep line event so that the prevSeg
		        // chain doesn't lead us inside of a loop of ours
		        var leftMostEvt = this.events[0];

		        for (var i = 1, iMax = this.events.length; i < iMax; i++) {
		          var evt = this.events[i];
		          if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;
		        }

		        var prevSeg = leftMostEvt.segment.prevInResult();
		        var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;

		        while (true) {
		          // no segment found, thus no ring can enclose us
		          if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev
		          // segment must loop back around and enclose us

		          if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev
		          // segment must either loop around us or the ring of the prev prev
		          // seg, which would make us and the ring of the prev peers

		          if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
		            if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
		              return prevSeg.ringOut;
		            } else return prevSeg.ringOut.enclosingRing();
		          } // two segments are from the same ring, so this was a penisula
		          // of that ring. iterate downward, keep searching


		          prevSeg = prevPrevSeg.prevInResult();
		          prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
		        }
		      }
		    }]);

		    return RingOut;
		  }();
		  var PolyOut = /*#__PURE__*/function () {
		    function PolyOut(exteriorRing) {
		      _classCallCheck(this, PolyOut);

		      this.exteriorRing = exteriorRing;
		      exteriorRing.poly = this;
		      this.interiorRings = [];
		    }

		    _createClass(PolyOut, [{
		      key: "addInterior",
		      value: function addInterior(ring) {
		        this.interiorRings.push(ring);
		        ring.poly = this;
		      }
		    }, {
		      key: "getGeom",
		      value: function getGeom() {
		        var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points

		        if (geom[0] === null) return null;

		        for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
		          var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points

		          if (ringGeom === null) continue;
		          geom.push(ringGeom);
		        }

		        return geom;
		      }
		    }]);

		    return PolyOut;
		  }();
		  var MultiPolyOut = /*#__PURE__*/function () {
		    function MultiPolyOut(rings) {
		      _classCallCheck(this, MultiPolyOut);

		      this.rings = rings;
		      this.polys = this._composePolys(rings);
		    }

		    _createClass(MultiPolyOut, [{
		      key: "getGeom",
		      value: function getGeom() {
		        var geom = [];

		        for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
		          var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points

		          if (polyGeom === null) continue;
		          geom.push(polyGeom);
		        }

		        return geom;
		      }
		    }, {
		      key: "_composePolys",
		      value: function _composePolys(rings) {
		        var polys = [];

		        for (var i = 0, iMax = rings.length; i < iMax; i++) {
		          var ring = rings[i];
		          if (ring.poly) continue;
		          if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {
		            var enclosingRing = ring.enclosingRing();
		            if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));
		            enclosingRing.poly.addInterior(ring);
		          }
		        }

		        return polys;
		      }
		    }]);

		    return MultiPolyOut;
		  }();

		  /**
		   * NOTE:  We must be careful not to change any segments while
		   *        they are in the SplayTree. AFAIK, there's no way to tell
		   *        the tree to rebalance itself - thus before splitting
		   *        a segment that's in the tree, we remove it from the tree,
		   *        do the split, then re-insert it. (Even though splitting a
		   *        segment *shouldn't* change its correct position in the
		   *        sweep line tree, the reality is because of rounding errors,
		   *        it sometimes does.)
		   */

		  var SweepLine = /*#__PURE__*/function () {
		    function SweepLine(queue) {
		      var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;

		      _classCallCheck(this, SweepLine);

		      this.queue = queue;
		      this.tree = new Tree(comparator);
		      this.segments = [];
		    }

		    _createClass(SweepLine, [{
		      key: "process",
		      value: function process(event) {
		        var segment = event.segment;
		        var newEvents = []; // if we've already been consumed by another segment,
		        // clean up our body parts and get out

		        if (event.consumedBy) {
		          if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);
		          return newEvents;
		        }

		        var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
		        if (!node) throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + 'in SweepLine tree. Please submit a bug report.');
		        var prevNode = node;
		        var nextNode = node;
		        var prevSeg = undefined;
		        var nextSeg = undefined; // skip consumed segments still in tree

		        while (prevSeg === undefined) {
		          prevNode = this.tree.prev(prevNode);
		          if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;
		        } // skip consumed segments still in tree


		        while (nextSeg === undefined) {
		          nextNode = this.tree.next(nextNode);
		          if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;
		        }

		        if (event.isLeft) {
		          // Check for intersections against the previous segment in the sweep line
		          var prevMySplitter = null;

		          if (prevSeg) {
		            var prevInter = prevSeg.getIntersection(segment);

		            if (prevInter !== null) {
		              if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;

		              if (!prevSeg.isAnEndpoint(prevInter)) {
		                var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);

		                for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
		                  newEvents.push(newEventsFromSplit[i]);
		                }
		              }
		            }
		          } // Check for intersections against the next segment in the sweep line


		          var nextMySplitter = null;

		          if (nextSeg) {
		            var nextInter = nextSeg.getIntersection(segment);

		            if (nextInter !== null) {
		              if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;

		              if (!nextSeg.isAnEndpoint(nextInter)) {
		                var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);

		                for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
		                  newEvents.push(_newEventsFromSplit[_i]);
		                }
		              }
		            }
		          } // For simplicity, even if we find more than one intersection we only
		          // spilt on the 'earliest' (sweep-line style) of the intersections.
		          // The other intersection will be handled in a future process().


		          if (prevMySplitter !== null || nextMySplitter !== null) {
		            var mySplitter = null;
		            if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {
		              var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
		              mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
		            } // Rounding errors can cause changes in ordering,
		            // so remove afected segments and right sweep events before splitting

		            this.queue.remove(segment.rightSE);
		            newEvents.push(segment.rightSE);

		            var _newEventsFromSplit2 = segment.split(mySplitter);

		            for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
		              newEvents.push(_newEventsFromSplit2[_i2]);
		            }
		          }

		          if (newEvents.length > 0) {
		            // We found some intersections, so re-do the current event to
		            // make sure sweep line ordering is totally consistent for later
		            // use with the segment 'prev' pointers
		            this.tree.remove(segment);
		            newEvents.push(event);
		          } else {
		            // done with left event
		            this.segments.push(segment);
		            segment.prev = prevSeg;
		          }
		        } else {
		          // event.isRight
		          // since we're about to be removed from the sweep line, check for
		          // intersections between our previous and next segments
		          if (prevSeg && nextSeg) {
		            var inter = prevSeg.getIntersection(nextSeg);

		            if (inter !== null) {
		              if (!prevSeg.isAnEndpoint(inter)) {
		                var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);

		                for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
		                  newEvents.push(_newEventsFromSplit3[_i3]);
		                }
		              }

		              if (!nextSeg.isAnEndpoint(inter)) {
		                var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);

		                for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
		                  newEvents.push(_newEventsFromSplit4[_i4]);
		                }
		              }
		            }
		          }

		          this.tree.remove(segment);
		        }

		        return newEvents;
		      }
		      /* Safely split a segment that is currently in the datastructures
		       * IE - a segment other than the one that is currently being processed. */

		    }, {
		      key: "_splitSafely",
		      value: function _splitSafely(seg, pt) {
		        // Rounding errors can cause changes in ordering,
		        // so remove afected segments and right sweep events before splitting
		        // removeNode() doesn't work, so have re-find the seg
		        // https://github.com/w8r/splay-tree/pull/5
		        this.tree.remove(seg);
		        var rightSE = seg.rightSE;
		        this.queue.remove(rightSE);
		        var newEvents = seg.split(pt);
		        newEvents.push(rightSE); // splitting can trigger consumption

		        if (seg.consumedBy === undefined) this.tree.insert(seg);
		        return newEvents;
		      }
		    }]);

		    return SweepLine;
		  }();

		  var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;
		  var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;
		  var Operation = /*#__PURE__*/function () {
		    function Operation() {
		      _classCallCheck(this, Operation);
		    }

		    _createClass(Operation, [{
		      key: "run",
		      value: function run(type, geom, moreGeoms) {
		        operation.type = type;
		        rounder.reset();
		        /* Convert inputs to MultiPoly objects */

		        var multipolys = [new MultiPolyIn(geom, true)];

		        for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
		          multipolys.push(new MultiPolyIn(moreGeoms[i], false));
		        }

		        operation.numMultiPolys = multipolys.length;
		        /* BBox optimization for difference operation
		         * If the bbox of a multipolygon that's part of the clipping doesn't
		         * intersect the bbox of the subject at all, we can just drop that
		         * multiploygon. */

		        if (operation.type === 'difference') {
		          // in place removal
		          var subject = multipolys[0];
		          var _i = 1;

		          while (_i < multipolys.length) {
		            if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);
		          }
		        }
		        /* BBox optimization for intersection operation
		         * If we can find any pair of multipolygons whose bbox does not overlap,
		         * then the result will be empty. */


		        if (operation.type === 'intersection') {
		          // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,
		          //       it could be optimized to O(n * ln(n))
		          for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
		            var mpA = multipolys[_i2];

		            for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
		              if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];
		            }
		          }
		        }
		        /* Put segment endpoints in a priority queue */


		        var queue = new Tree(SweepEvent.compare);

		        for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
		          var sweepEvents = multipolys[_i3].getSweepEvents();

		          for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
		            queue.insert(sweepEvents[_j]);

		            if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
		              // prevents an infinite loop, an otherwise common manifestation of bugs
		              throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');
		            }
		          }
		        }
		        /* Pass the sweep line over those endpoints */


		        var sweepLine = new SweepLine(queue);
		        var prevQueueSize = queue.size;
		        var node = queue.pop();

		        while (node) {
		          var evt = node.key;

		          if (queue.size === prevQueueSize) {
		            // prevents an infinite loop, an otherwise common manifestation of bugs
		            var seg = evt.segment;
		            throw new Error("Unable to pop() ".concat(evt.isLeft ? 'left' : 'right', " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + 'Please file a bug report.');
		          }

		          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
		            // prevents an infinite loop, an otherwise common manifestation of bugs
		            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');
		          }

		          if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
		            // prevents an infinite loop, an otherwise common manifestation of bugs
		            throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');
		          }

		          var newEvents = sweepLine.process(evt);

		          for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
		            var _evt = newEvents[_i4];
		            if (_evt.consumedBy === undefined) queue.insert(_evt);
		          }

		          prevQueueSize = queue.size;
		          node = queue.pop();
		        } // free some memory we don't need anymore


		        rounder.reset();
		        /* Collect and compile segments we're keeping into a multipolygon */

		        var ringsOut = RingOut.factory(sweepLine.segments);
		        var result = new MultiPolyOut(ringsOut);
		        return result.getGeom();
		      }
		    }]);

		    return Operation;
		  }(); // singleton available by import

		  var operation = new Operation();

		  var union = function union(geom) {
		    for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		      moreGeoms[_key - 1] = arguments[_key];
		    }

		    return operation.run('union', geom, moreGeoms);
		  };

		  var intersection$1 = function intersection(geom) {
		    for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
		      moreGeoms[_key2 - 1] = arguments[_key2];
		    }

		    return operation.run('intersection', geom, moreGeoms);
		  };

		  var xor = function xor(geom) {
		    for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
		      moreGeoms[_key3 - 1] = arguments[_key3];
		    }

		    return operation.run('xor', geom, moreGeoms);
		  };

		  var difference = function difference(subjectGeom) {
		    for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
		      clippingGeoms[_key4 - 1] = arguments[_key4];
		    }

		    return operation.run('difference', subjectGeom, clippingGeoms);
		  };

		  var index = {
		    union: union,
		    intersection: intersection$1,
		    xor: xor,
		    difference: difference
		  };

		  return index;

		}))); 
	} (polygonClipping_umd));

	var polygonClipping_umdExports = polygonClipping_umd.exports;
	var polygonClipping = /*@__PURE__*/getDefaultExportFromCjs(polygonClipping_umdExports);

	/**
	 * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and
	 * finds their polygonal intersection. If they don't intersect, returns null.
	 *
	 * @name intersect
	 * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon
	 * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon
	 * @param {Object} [options={}] Optional Parameters
	 * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature
	 * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or
	 * {@link MultiPolygon}). If they do not share any area, returns `null`.
	 * @example
	 * var poly1 = turf.polygon([[
	 *   [-122.801742, 45.48565],
	 *   [-122.801742, 45.60491],
	 *   [-122.584762, 45.60491],
	 *   [-122.584762, 45.48565],
	 *   [-122.801742, 45.48565]
	 * ]]);
	 *
	 * var poly2 = turf.polygon([[
	 *   [-122.520217, 45.535693],
	 *   [-122.64038, 45.553967],
	 *   [-122.720031, 45.526554],
	 *   [-122.669906, 45.507309],
	 *   [-122.723464, 45.446643],
	 *   [-122.532577, 45.408574],
	 *   [-122.487258, 45.477466],
	 *   [-122.520217, 45.535693]
	 * ]]);
	 *
	 * var intersection = turf.intersect(poly1, poly2);
	 *
	 * //addToMap
	 * var addToMap = [poly1, poly2, intersection];
	 */
	function intersect(poly1, poly2, options) {
	    if (options === void 0) { options = {}; }
	    var geom1 = getGeom(poly1);
	    var geom2 = getGeom(poly2);
	    var intersection = polygonClipping.intersection(geom1.coordinates, geom2.coordinates);
	    if (intersection.length === 0)
	        return null;
	    if (intersection.length === 1)
	        return polygon(intersection[0], options.properties);
	    return multiPolygon(intersection, options.properties);
	}

	/**
	 * Discard invocations that take less than the specified time between output
	 * (latest invocation is made if duration has been passed and no new invocations made to decorated method)
	 * This mimics the behaviour of rxjs debounceTime: https://www.learnrxjs.io/learn-rxjs/operators/filtering/debouncetime but via decorator
	 *
	 * @param duration debounce time interval duration in milliseconds
	 */
	/**
	 * Emit first value then ignore for specified duration
	 * This mimics the behaviour of rxjs throttleTime: https://www.learnrxjs.io/learn-rxjs/operators/filtering/throttletime but via decorator
	 *
	 * @param duration throttle time interval duration in milliseconds
	 */
	var throttleTime = function (duration) { return function (target, propertyKey, descriptor) {
	    var originalMethod = descriptor.value;
	    var shouldCancel = new Map();
	    descriptor.value = function () {
	        var context = this;
	        var args = arguments;
	        var cancel = shouldCancel.get(context) || false;
	        if (!cancel) {
	            originalMethod.apply(context, args);
	            shouldCancel.set(context, true);
	            // tslint:disable-next-line: no-string-based-set-timeout
	            setTimeout(function () { return shouldCancel.delete(context); }, duration);
	        }
	    };
	    return descriptor;
	}; };

	var __decorate = (window && window.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __read$a = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$8 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var allowedAttributionTags = [
	    'DIV',
	    'SPAN',
	    'A'
	];
	var attributionRuleAttributes = [
	    'data-azure-maps-attribution-minzoom',
	    'data-azure-maps-attribution-maxzoom',
	    'data-azure-maps-attribution-geometry',
	    'data-azure-maps-attribution-tileset',
	    'data-azure-maps-attribution-order',
	    'data-azure-maps-attribution-dynamic'
	];
	var allowedAttributionAttributes = __spreadArray$8([
	    'href'
	], __read$a(attributionRuleAttributes), false);
	var AttributionRuleProxy = /** @class */ (function () {
	    function AttributionRuleProxy(element, attributionChangeCallback) {
	        var _this = this;
	        this.lastFetchState = {
	            bounds: null,
	            zoom: null
	        };
	        this.getElement = function () { return _this.element; };
	        this.element = element;
	        this.attributionChangeCallback = attributionChangeCallback;
	    }
	    /** Whether one rule equals another: this doesn't imply the equivalence in terms of attribution, while rules can be the same, the content inside might differ */
	    AttributionRuleProxy.prototype.equals = function (other) {
	        return this.stringRepresentation === other.stringRepresentation;
	    };
	    Object.defineProperty(AttributionRuleProxy.prototype, "stringRepresentation", {
	        get: function () {
	            // NOTE: order is not included here as it does not affect the attribution rule
	            return [
	                this.minZoom !== undefined ? "minzoom=".concat(this.minZoom) : '',
	                this.maxZoom !== undefined ? "maxzoom=".concat(this.maxZoom) : '',
	                this.geometry !== undefined ? this.element.attributes.getNamedItem('data-azure-maps-attribution-geometry').value : '',
	                this.tilesetId !== undefined ? "tilesetId=".concat(this.tilesetId) : '',
	                this.dynamic ? "dynamic" : ''
	            ].filter(function (comp) { return comp.length > 0; }).join(';');
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /** checks whether attribution rule is used on an element: i.e: whether element contains at least one attribution property */
	    AttributionRuleProxy.applicable = function (element) {
	        return Array.from(element.attributes)
	            .map(function (attr) { return attributionRuleAttributes.includes(attr.name); })
	            .reduce(function (atLeastOneRuleAttribute, includes) { return atLeastOneRuleAttribute || includes; }, false);
	    };
	    Object.defineProperty(AttributionRuleProxy.prototype, "minZoom", {
	        /** The HTML anchor describing an attribution zone that includes minzoom and maxzoom will be scoped to that range */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-minzoom');
	            return attr && !isNaN(attr.value) ? parseInt(attr.value) : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "maxZoom", {
	        /** The HTML anchor describing an attribution zone that includes minzoom and maxzoom will be scoped to that range */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-maxzoom');
	            return attr && !isNaN(attr.value) ? parseInt(attr.value) : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "geometry", {
	        /** The HTML anchor describing an attribution zone that includes a GeoJSON geometry will be scoped to that area. */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-geometry');
	            if (attr && attr.value) {
	                try {
	                    var json = JSON.parse(attr.value);
	                    return json;
	                }
	                catch (e) {
	                    // SyntaxError
	                    return undefined;
	                }
	            }
	            else {
	                return undefined;
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "tilesetId", {
	        /** Attribution associated tilesetId, used for dynamic attribution requests */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-tileset');
	            return attr && attr.value ? attr.value : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "order", {
	        /** the position of attribution message */
	        get: function () {
	            var attr = this.element.attributes.getNamedItem('data-azure-maps-attribution-order');
	            return attr && !isNaN(attr.value) ? parseInt(attr.value) : undefined;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "dynamic", {
	        /**
	         * The HTML anchor text is ignored, instead the tilesetId will be used to call the tile metadata service to determine attribution based on the current map view.
	         * Supplants minzoom, maxzoom, and geometry attributes.
	         */
	        get: function () {
	            return this.element.attributes.getNamedItem('data-azure-maps-attribution-dynamic') !== null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(AttributionRuleProxy.prototype, "hidesElement", {
	        /** whether the underlying element is hidden */
	        get: function () {
	            return this.element.style.display == 'none';
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /** hides the underlying element */
	    AttributionRuleProxy.prototype.forceHide = function () {
	        this.element.style.display = 'none';
	    };
	    /**
	     * Checks whether the provided camera state satisfies this rule
	     *
	     * @param camera current state of map control camera: map.getCamera()
	     * @returns
	     */
	    AttributionRuleProxy.prototype.satisfied = function (camera) {
	        var satisfiesMinZoom = this.minZoom && camera.zoom ? camera.zoom >= this.minZoom : true;
	        var satisfiesMaxZoom = this.maxZoom && camera.zoom ? camera.zoom <= this.maxZoom : true;
	        var satisfiesGeometry = true;
	        if (this.geometry && camera.bounds) {
	            var geometry = {
	                type: 'Feature',
	                geometry: this.geometry,
	                properties: {}
	            };
	            var viewport = {
	                type: 'Feature',
	                geometry: {
	                    type: 'Polygon',
	                    coordinates: [[
	                            BoundingBox.getNorthWest(camera.bounds),
	                            BoundingBox.getNorthEast(camera.bounds),
	                            BoundingBox.getSouthEast(camera.bounds),
	                            BoundingBox.getSouthWest(camera.bounds),
	                            BoundingBox.getNorthWest(camera.bounds)
	                        ]]
	                },
	                properties: {}
	            };
	            satisfiesGeometry = intersect(geometry, viewport) !== null;
	        }
	        return satisfiesMinZoom && satisfiesMaxZoom && satisfiesGeometry;
	    };
	    /**
	     * Applies the rule to the underlying attribution element
	     *
	     * @param map map control
	     * @param event original event that triggered this apply call
	     * returns whether any dom modification were made
	     */
	    AttributionRuleProxy.prototype.apply = function (map, event) {
	        var _this = this;
	        if (event === void 0) { event = null; }
	        var satisfied = this.satisfied(map.getCamera());
	        var willFetch = this.dynamic && this.tilesetId;
	        var hidesElement = this.hidesElement;
	        // wait for map idle event if call was triggered from dragend / zoomend / pitchend
	        var shouldFetchOnMapIdle = event && ['dragend', 'zoomend', 'pitchend'].includes(event.type);
	        if (!satisfied && !hidesElement) {
	            this.element.style.display = 'none';
	        }
	        else if (satisfied && (hidesElement || willFetch)) {
	            if (satisfied && hidesElement) {
	                this.element.style.removeProperty('display');
	            }
	            if (willFetch) {
	                if (shouldFetchOnMapIdle) {
	                    map.events.addOnce('idle', function (event) { return _this.fetchAndApplyDynamicAttribution(map); });
	                }
	                else {
	                    this.fetchAndApplyDynamicAttribution(map);
	                }
	            }
	        }
	        return satisfied === hidesElement;
	    };
	    AttributionRuleProxy.prototype.fetchAndApplyDynamicAttribution = function (map) {
	        var _this = this;
	        var camera = map.getCamera();
	        if (this.lastFetchState && BoundingBox.containsBoundingBox(this.lastFetchState.bounds, camera.bounds) && Math.floor(this.lastFetchState.zoom) == Math.floor(camera.zoom)) {
	            // viewport is fully contained in the area used in previous attribution request, and zoom level hasn't changed, do nothing
	            return;
	        }
	        var attributionEndpointOrigin = 'https://{{azMapsDomain}}';
	        // expand the viewport bounding box and fetch attribution for a larger area, use expanded viewport to filter out subsequent calls if viewport is fully contained 
	        var expSouthWest = interpolate(camera.center, BoundingBox.getSouthWest(camera.bounds), AttributionRuleProxy.viewportBufferExpansionRatio);
	        var expNorthEast = interpolate(camera.center, BoundingBox.getNorthEast(camera.bounds), AttributionRuleProxy.viewportBufferExpansionRatio);
	        var antimeridianAdjusted = (expNorthEast[0] < expSouthWest[0])
	            // west, south, east, north
	            ? [[expSouthWest[0], expSouthWest[1], 180.0, expNorthEast[1]], [-180.0, expSouthWest[1], expNorthEast[0], expNorthEast[1]]]
	            : [[expSouthWest[0], expSouthWest[1], expNorthEast[0], expNorthEast[1]]];
	        var requests = antimeridianAdjusted.map(function (bbox) {
	            var params = new URLSearchParams({
	                'api-version': '2.1',
	                tilesetId: _this.tilesetId,
	                zoom: camera.zoom !== undefined ? "".concat(Math.floor(camera.zoom)) : undefined,
	                bounds: bbox.join(',')
	            });
	            var attributionUrl = "".concat(attributionEndpointOrigin, "/map/attribution");
	            var toReplace = { url: attributionUrl, headers: {} };
	            map._substituteDomainLanguageViewAndSignInRequest(attributionUrl, toReplace);
	            var targetUrl = "".concat(toReplace.url).concat(toReplace.url.includes('?') ? '&' : '?').concat(params.toString());
	            return map._sendRequest(targetUrl, 'Attribution', toReplace.headers).then(function (response) { return response.json(); });
	        });
	        Promise.all(requests).then(function (response) {
	            _this.applyAttributionResponse(response);
	            _this.lastFetchState = {
	                bounds: new BoundingBox([expSouthWest[0], expSouthWest[1], expNorthEast[0], expNorthEast[1]]),
	                zoom: camera.zoom
	            };
	        })
	            // TODO: any specific error formatting here?
	            .catch(function (error) { return console.error(error); });
	    };
	    AttributionRuleProxy.prototype.applyAttributionResponse = function (attributions) {
	        var _this = this;
	        var copyrights = attributions.map(function (resp) { return resp.copyrights || []; }).reduce(function (flat, copyrights) { return __spreadArray$8(__spreadArray$8([], __read$a(flat), false), __read$a(copyrights), false); }, []);
	        if (copyrights.length == 0) {
	            // no attribution for a provided tileset/bbox/z
	            return;
	        }
	        var target = Html.parseWithFilter(copyrights.join(''), function (elem) { return true; }, function (elem) { return elem; }, 
	        // use current element as the grouping element for attribution, drop existing content
	        function () {
	            _this.element.innerHTML = '';
	            return _this.element;
	        });
	        if (target === null) {
	            // attribution was filtered out
	            console.warn('Dynamic attribution is empty after filtering');
	            return;
	        }
	        var newAttribution = typeof target === 'string'
	            ? (function () { var e = document.createElement('span'); e.innerHTML = target; return e; })()
	            : target;
	        var newRuleElement;
	        // handles multiple attributions wrapped into current element
	        if (newAttribution === this.element) {
	            // use a span element to group multiple (likely anchors)
	            // this will replace current rule element to ensure consistent behavior (we don't want to add child nodes to anchors etc)
	            var container_1 = document.createElement('span');
	            Array.from(this.element.childNodes).forEach(function (node) { return container_1.appendChild(node); });
	            newRuleElement = container_1;
	        }
	        else {
	            newRuleElement = newAttribution;
	        }
	        // reassign all rule attributes to preserve state
	        Array.from(this.element.attributes).filter(function (attrib) { return attributionRuleAttributes.includes(attrib.name); }).forEach(function (attrib) {
	            return newRuleElement.attributes.setNamedItem(attrib.cloneNode());
	        });
	        newRuleElement.style.display = this.element.style.display;
	        var parent = this.element.parentElement;
	        this.element.remove();
	        parent.append(newRuleElement);
	        this.element = newRuleElement;
	        this.attributionChangeCallback(this);
	    };
	    AttributionRuleProxy.viewportBufferExpansionRatio = 2;
	    __decorate([
	        throttleTime(1000)
	    ], AttributionRuleProxy.prototype, "fetchAndApplyDynamicAttribution", null);
	    return AttributionRuleProxy;
	}());

	var __read$9 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$7 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	// contains phrases that should be filtered out from all attribution content
	var attributionFilters = [
	    /all rights reserved/gi
	];
	var CopyrightDelegate = /** @class */ (function () {
	    function CopyrightDelegate(map, copyrightControl, options) {
	        var _this = this;
	        this.rules = [];
	        /**
	         * represents the source of truth for parsed aggregated attribution markup without any filtering, text deduplication
	         * this gets hidden/on/off mutated as rules come into play.
	         */
	        this.virtualContext = (function () {
	            var elem = document.createElement('span');
	            elem.className = 'azure-map-copyright-context';
	            return elem;
	        })();
	        /**
	         * represents the actual DOM that gets attached to the copyright control
	         * a clone of virtual context with textual nodes redacted
	         */
	        this.renderContext = this.virtualContext.cloneNode(false);
	        this.addAttributionFromSource = function (source) {
	            //FundamentalMapSources are handled on style.load
	        };
	        this.removeAttributionFromSource = function (source) {
	            //FundamentalMapSources are handled on style.load
	        };
	        this.getMapStyleVisibleSources = function () {
	            var map = _this.map._getMap();
	            var style = map.getStyle();
	            return Object.entries(style.sources)
	                .filter(function (_a) {
	                var _b = __read$9(_a, 1), key = _b[0];
	                return style.layers
	                    .filter(function (layer) { return layer && layer['source'] == key; })
	                    .reduce(function (isVisible, layer) {
	                    var isLayerHidden = (layer["layout"] && layer["layout"].visibility === "none") || layer["paint"] && (layer["paint"]["icon-opacity"] === 0 && layer["paint"]["text-opacity"] === 0);
	                    return !isLayerHidden || isVisible;
	                }, false);
	            }).map(function (_a) {
	                var _b = __read$9(_a, 1), key = _b[0];
	                return map.getSource(key);
	            });
	        };
	        this.loadAttributionOnceSourcesLoaded = function () {
	            var sources = _this.getMapStyleVisibleSources();
	            Promise.all(sources.map(function (source) { return new Promise(function (resolve, reject) {
	                if ('tiles' in source || (source === null || source === void 0 ? void 0 : source.type) === 'geojson') {
	                    resolve(source);
	                    // TileJSON source may yet be unresolved
	                }
	                else {
	                    var unresolved_1 = source;
	                    unresolved_1.on('data', function sourceDataListener(event) {
	                        if (event.sourceDataType == 'metadata') {
	                            unresolved_1.off('data', sourceDataListener);
	                            resolve(source);
	                        }
	                    });
	                    unresolved_1.on('error', function tilejsonLoadError(event) {
	                        unresolved_1.off('error', tilejsonLoadError);
	                        reject(event);
	                    });
	                }
	            })
	                // mimics https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled 
	                // until wider availability (https://caniuse.com/?search=allSettled)
	                .then(function (source) { return ({ status: 'fulfilled', value: source }); })
	                .catch(function (error) { return ({ status: 'rejected', reason: error }); }); })).then(function (loadResults) {
	                // reload attribution no matter tilejson loaded gracefully or errored
	                _this.reloadAttribution();
	            });
	        };
	        /**
	         * @internal
	         */
	        this.reloadAttribution = function () {
	            var sources = _this.getMapStyleVisibleSources();
	            // keep track of all rules as well as registered to determine redundant rules that won't get applied.
	            // a rule is considered redundant when it is has same rule attributes(excluding order) as well as endpoints
	            // a rule with the minimum order will be picked 
	            var allRules = new Set();
	            var registeredRules = {};
	            var attributions = sources
	                // also ignore sources that don't specify tile endpoints
	                .filter(function (source) { return 'attribution' in source && source.attribution && 'tiles' in source && source['tiles'] instanceof Array && source['tiles'].length > 0; })
	                .map(function (source) {
	                var _a;
	                return Html.parseWithFilter((_a = source.attribution) !== null && _a !== void 0 ? _a : "", function (elem) { return allowedAttributionTags.includes(elem.tagName)
	                    && Array.from(elem.attributes).map(function (attr) { return allowedAttributionAttributes.includes(attr.name); }).reduce(function (allAllowed, inclAllowed) { return allAllowed && inclAllowed; }, true); }, function (elem) {
	                    // effect: register rules for elements with at least one rule attribute 
	                    // and add flexbox order attribute if order is set
	                    var rule = null;
	                    if (elem instanceof HTMLElement && AttributionRuleProxy.applicable(elem)) {
	                        // NOTE: the first tile endpoint will be used to derive the base url for dynamic attribution requests
	                        rule = new AttributionRuleProxy(elem, function () { return _this.renderAttribution(); });
	                        allRules.add(rule);
	                        if (rule.order !== undefined) {
	                            elem.style.order = "".concat(rule.order);
	                        }
	                    }
	                    if (rule && elem instanceof HTMLElement) {
	                        var ruleKey = rule.stringRepresentation;
	                        if (!(ruleKey in registeredRules)) {
	                            registeredRules[ruleKey] = rule;
	                            // equivalent rules: prefer the lowest order rule
	                        }
	                        else if ((rule.order !== undefined && registeredRules[ruleKey].order !== undefined && rule.order < registeredRules[ruleKey].order ||
	                            rule.order !== undefined && registeredRules[ruleKey].order === undefined)) {
	                            registeredRules[ruleKey] = rule;
	                        }
	                    }
	                    return elem;
	                }, function () { return document.createElement('span'); });
	            });
	            var registeredRuleSet = new Set(Object.values(registeredRules));
	            var redundantRules = new Set(__spreadArray$7([], __read$9(allRules), false).filter(function (rule) { return !registeredRuleSet.has(rule); }));
	            var redundantElements = new Set(__spreadArray$7([], __read$9(redundantRules), false).map(function (rule) { return rule.getElement(); }));
	            // eject redundant rules associated elements altogether
	            __spreadArray$7([], __read$9(redundantElements), false).filter(function (elem) { return elem.parentElement !== null; })
	                .forEach(function (elem) { return elem.parentElement.removeChild(elem); });
	            _this.rules = Object.values(registeredRules);
	            var attributionsToApply = attributions
	                .filter(function (attribution) { return typeof attribution === 'string' || !redundantElements.has(attribution); })
	                .map(function (attribution) { return typeof (attribution) === 'string' ? new Text(attribution) : attribution; });
	            var virtualContext = document.createElement('span');
	            if (attributionsToApply.length > 0) {
	                attributionsToApply.forEach(function (attribution) { return virtualContext.appendChild(attribution); });
	            }
	            else {
	                _this.getDefaultAttribution().forEach(function (attribution) { return virtualContext.appendChild(attribution); });
	            }
	            _this.virtualContext = virtualContext;
	            _this.copyrightControl.setOptions({
	                copyrightContent: _this.renderContext
	            });
	            _this.applyRules();
	            _this.renderAttribution();
	        };
	        this.applyRules = function (mapEvent) {
	            if (mapEvent === void 0) { mapEvent = null; }
	            var hasDOMChanges = _this.rules.reduce(function (hasDomChanges, rule) {
	                var ruleChangedDOM = rule.apply(_this.map, mapEvent);
	                return hasDomChanges || ruleChangedDOM;
	            }, false);
	            if (hasDOMChanges)
	                (_this.renderAttribution());
	        };
	        /**
	         * clones virtual context, reduces textual nodes for visual purposes (dedups years, common phrases) and sets the actual rendered context
	         */
	        this.renderAttribution = function () {
	            var visibleTextNodes = function (elem) {
	                return Array.from(elem.style.display != 'none' ? elem.children : [])
	                    .map(function (elem) { return visibleTextNodes(elem); })
	                    .reduce(function (flattened, nodes) { return __spreadArray$7(__spreadArray$7([], __read$9(flattened), false), __read$9(nodes), false); }, Array.from(elem.style.display != 'none' ? elem.childNodes : []).filter(function (node) { return node.nodeType == node.TEXT_NODE; }));
	            };
	            var newRenderContext = _this.virtualContext.cloneNode(true);
	            var visibleNodes = visibleTextNodes(newRenderContext);
	            // Do not extract years for now
	            // Just deduplicate full matches
	            //
	            // const years = new Set<number>();
	            // visibleNodes.forEach(node => { 
	            //     let match: RegExpExecArray | null = null
	            //     while((match = copyrightYearPattern.exec(node.textContent)) != null){
	            //         years.add(parseInt(match[1])) 
	            //     }
	            // });
	            // strip all predefined keywords 
	            visibleNodes.forEach(function (node) { return node.textContent = __spreadArray$7([], __read$9(attributionFilters), false).reduce(function (target, filter) { return target.replace(filter, '').trim(); }, node.textContent); });
	            // strip year from each node
	            // visibleNodes.forEach(node => node.textContent = node.textContent.replace(copyrightYearPattern, '').trim());
	            // deduplicate attribution text
	            visibleNodes.reduce(function (attributions, node) {
	                if (attributions.has(node.textContent)) {
	                    node.textContent = '';
	                    if (node.parentElement) {
	                        node.parentElement.removeChild(node);
	                    }
	                }
	                else {
	                    attributions.add(node.textContent);
	                }
	                return attributions;
	            }, new Set());
	            _this.renderContext.innerHTML = '';
	            // don't use this.renderContext.innerHTML = newRenderContext.innerHTML
	            // as original dom structure might be changed
	            Array.from(newRenderContext.childNodes).forEach(function (node) { return _this.renderContext.appendChild(node); });
	            // add years text node as the first text node in render context 
	            // to make sure flexbox order has no effect on where copyright years will appear
	            // if(years.size > 0){
	            //     const yearsNode = new Text(`©${[...years].sort((lhs, rhs) => lhs - rhs).join(',')}`);
	            //     if(this.renderContext.children.length > 0){
	            //         this.renderContext.insertBefore(yearsNode, this.renderContext.children[0])
	            //     } else {
	            //         this.renderContext.appendChild(yearsNode);
	            //     }
	            // }
	        };
	        this.map = map;
	        this.copyrightControl = copyrightControl;
	        this.options = options;
	    }
	    CopyrightDelegate.prototype.addToMap = function () {
	        this.map.events.add('stylechanged', this.loadAttributionOnceSourcesLoaded);
	        // this.map.events.add('sourceadded', this.addAttributionFromSource);
	        // this.map.events.add('sourceremoved', this.removeAttributionFromSource);
	        this.map.events.add('dragend', this.applyRules);
	        this.map.events.add('zoomend', this.applyRules);
	        this.map.events.add('pitchend', this.applyRules);
	    };
	    CopyrightDelegate.prototype.removeFromMap = function () {
	        this.map.events.remove('stylechanged', this.loadAttributionOnceSourcesLoaded);
	        // this.map.events.remove('sourceadded', this.addAttributionFromSource);
	        // this.map.events.remove('sourceremoved', this.removeAttributionFromSource);
	        this.map.events.remove('dragend', this.applyRules);
	        this.map.events.remove('zoomend', this.applyRules);
	        this.map.events.remove('pitchend', this.applyRules);
	    };
	    /**
	     * Gets the default fallback copyright caption
	     */
	    CopyrightDelegate.prototype.getDefaultAttribution = function () {
	        var anchor = function (content) {
	            var elem = document.createElement('a');
	            elem.textContent = content;
	            return elem;
	        };
	        return this.copyrightControl.getDefaultAttributions().map(function (copyright) { return anchor(copyright); });
	    };
	    return CopyrightDelegate;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */
	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$1 = function(d, b) {
	    extendStatics$1 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	    return extendStatics$1(d, b);
	};

	function __extends$g(d, b) {
	    extendStatics$1(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$5 = function() {
	    __assign$5 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$5.apply(this, arguments);
	};

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	}

	function __awaiter$3(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator$3(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __read$8(o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	}

	function __spread() {
	    for (var ar = [], i = 0; i < arguments.length; i++)
	        ar = ar.concat(__read$8(arguments[i]));
	    return ar;
	}

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends$f(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$4 = function() {
	    __assign$4 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$4.apply(this, arguments);
	};

	function __awaiter$2(thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	}

	function __generator$2(thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	}

	function __spreadArrays() {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	}

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var Constants = {
	    LIBRARY_NAME: "MSAL.JS",
	    SKU: "msal.js.common",
	    // Prefix for all library cache entries
	    CACHE_PREFIX: "msal",
	    // default authority
	    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
	    DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
	    DEFAULT_COMMON_TENANT: "common",
	    // ADFS String
	    ADFS: "adfs",
	    DSTS: "dstsv2",
	    // Default AAD Instance Discovery Endpoint
	    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
	    // CIAM URL
	    CIAM_AUTH_URL: ".ciamlogin.com",
	    AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
	    // Resource delimiter - used for certain cache entries
	    RESOURCE_DELIM: "|",
	    // Placeholder for non-existent account ids/objects
	    NO_ACCOUNT: "NO_ACCOUNT",
	    // Claims
	    CLAIMS: "claims",
	    // Consumer UTID
	    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
	    // Default scopes
	    OPENID_SCOPE: "openid",
	    PROFILE_SCOPE: "profile",
	    OFFLINE_ACCESS_SCOPE: "offline_access",
	    EMAIL_SCOPE: "email",
	    // Default response type for authorization code flow
	    CODE_RESPONSE_TYPE: "code",
	    CODE_GRANT_TYPE: "authorization_code",
	    RT_GRANT_TYPE: "refresh_token",
	    FRAGMENT_RESPONSE_MODE: "fragment",
	    S256_CODE_CHALLENGE_METHOD: "S256",
	    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
	    AUTHORIZATION_PENDING: "authorization_pending",
	    NOT_DEFINED: "not_defined",
	    EMPTY_STRING: "",
	    NOT_APPLICABLE: "N/A",
	    FORWARD_SLASH: "/",
	    IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
	    IMDS_VERSION: "2020-06-01",
	    IMDS_TIMEOUT: 2000,
	    AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
	    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
	    REGIONAL_AUTH_NON_MSI_QUERY_STRING: "allowestsrnonmsi=true",
	    KNOWN_PUBLIC_CLOUDS: ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"],
	    TOKEN_RESPONSE_TYPE: "token",
	    ID_TOKEN_RESPONSE_TYPE: "id_token",
	    SHR_NONCE_VALIDITY: 240,
	    INVALID_INSTANCE: "invalid_instance",
	};
	var OIDC_DEFAULT_SCOPES = [
	    Constants.OPENID_SCOPE,
	    Constants.PROFILE_SCOPE,
	    Constants.OFFLINE_ACCESS_SCOPE
	];
	var OIDC_SCOPES = __spreadArrays(OIDC_DEFAULT_SCOPES, [
	    Constants.EMAIL_SCOPE
	]);
	/**
	 * Request header names
	 */
	var HeaderNames;
	(function (HeaderNames) {
	    HeaderNames["CONTENT_TYPE"] = "Content-Type";
	    HeaderNames["RETRY_AFTER"] = "Retry-After";
	    HeaderNames["CCS_HEADER"] = "X-AnchorMailbox";
	    HeaderNames["WWWAuthenticate"] = "WWW-Authenticate";
	    HeaderNames["AuthenticationInfo"] = "Authentication-Info";
	    HeaderNames["X_MS_REQUEST_ID"] = "x-ms-request-id";
	    HeaderNames["X_MS_HTTP_VERSION"] = "x-ms-httpver";
	})(HeaderNames || (HeaderNames = {}));
	/**
	 * Persistent cache keys MSAL which stay while user is logged in.
	 */
	var PersistentCacheKeys;
	(function (PersistentCacheKeys) {
	    PersistentCacheKeys["ID_TOKEN"] = "idtoken";
	    PersistentCacheKeys["CLIENT_INFO"] = "client.info";
	    PersistentCacheKeys["ADAL_ID_TOKEN"] = "adal.idtoken";
	    PersistentCacheKeys["ERROR"] = "error";
	    PersistentCacheKeys["ERROR_DESC"] = "error.description";
	    PersistentCacheKeys["ACTIVE_ACCOUNT"] = "active-account";
	    PersistentCacheKeys["ACTIVE_ACCOUNT_FILTERS"] = "active-account-filters"; // new cache entry for active_account for a more robust version for browser
	})(PersistentCacheKeys || (PersistentCacheKeys = {}));
	/**
	 * String constants related to AAD Authority
	 */
	var AADAuthorityConstants;
	(function (AADAuthorityConstants) {
	    AADAuthorityConstants["COMMON"] = "common";
	    AADAuthorityConstants["ORGANIZATIONS"] = "organizations";
	    AADAuthorityConstants["CONSUMERS"] = "consumers";
	})(AADAuthorityConstants || (AADAuthorityConstants = {}));
	/**
	 * Keys in the hashParams sent by AAD Server
	 */
	var AADServerParamKeys;
	(function (AADServerParamKeys) {
	    AADServerParamKeys["CLIENT_ID"] = "client_id";
	    AADServerParamKeys["REDIRECT_URI"] = "redirect_uri";
	    AADServerParamKeys["RESPONSE_TYPE"] = "response_type";
	    AADServerParamKeys["RESPONSE_MODE"] = "response_mode";
	    AADServerParamKeys["GRANT_TYPE"] = "grant_type";
	    AADServerParamKeys["CLAIMS"] = "claims";
	    AADServerParamKeys["SCOPE"] = "scope";
	    AADServerParamKeys["ERROR"] = "error";
	    AADServerParamKeys["ERROR_DESCRIPTION"] = "error_description";
	    AADServerParamKeys["ACCESS_TOKEN"] = "access_token";
	    AADServerParamKeys["ID_TOKEN"] = "id_token";
	    AADServerParamKeys["REFRESH_TOKEN"] = "refresh_token";
	    AADServerParamKeys["EXPIRES_IN"] = "expires_in";
	    AADServerParamKeys["STATE"] = "state";
	    AADServerParamKeys["NONCE"] = "nonce";
	    AADServerParamKeys["PROMPT"] = "prompt";
	    AADServerParamKeys["SESSION_STATE"] = "session_state";
	    AADServerParamKeys["CLIENT_INFO"] = "client_info";
	    AADServerParamKeys["CODE"] = "code";
	    AADServerParamKeys["CODE_CHALLENGE"] = "code_challenge";
	    AADServerParamKeys["CODE_CHALLENGE_METHOD"] = "code_challenge_method";
	    AADServerParamKeys["CODE_VERIFIER"] = "code_verifier";
	    AADServerParamKeys["CLIENT_REQUEST_ID"] = "client-request-id";
	    AADServerParamKeys["X_CLIENT_SKU"] = "x-client-SKU";
	    AADServerParamKeys["X_CLIENT_VER"] = "x-client-VER";
	    AADServerParamKeys["X_CLIENT_OS"] = "x-client-OS";
	    AADServerParamKeys["X_CLIENT_CPU"] = "x-client-CPU";
	    AADServerParamKeys["X_CLIENT_CURR_TELEM"] = "x-client-current-telemetry";
	    AADServerParamKeys["X_CLIENT_LAST_TELEM"] = "x-client-last-telemetry";
	    AADServerParamKeys["X_MS_LIB_CAPABILITY"] = "x-ms-lib-capability";
	    AADServerParamKeys["X_APP_NAME"] = "x-app-name";
	    AADServerParamKeys["X_APP_VER"] = "x-app-ver";
	    AADServerParamKeys["POST_LOGOUT_URI"] = "post_logout_redirect_uri";
	    AADServerParamKeys["ID_TOKEN_HINT"] = "id_token_hint";
	    AADServerParamKeys["DEVICE_CODE"] = "device_code";
	    AADServerParamKeys["CLIENT_SECRET"] = "client_secret";
	    AADServerParamKeys["CLIENT_ASSERTION"] = "client_assertion";
	    AADServerParamKeys["CLIENT_ASSERTION_TYPE"] = "client_assertion_type";
	    AADServerParamKeys["TOKEN_TYPE"] = "token_type";
	    AADServerParamKeys["REQ_CNF"] = "req_cnf";
	    AADServerParamKeys["OBO_ASSERTION"] = "assertion";
	    AADServerParamKeys["REQUESTED_TOKEN_USE"] = "requested_token_use";
	    AADServerParamKeys["ON_BEHALF_OF"] = "on_behalf_of";
	    AADServerParamKeys["FOCI"] = "foci";
	    AADServerParamKeys["CCS_HEADER"] = "X-AnchorMailbox";
	    AADServerParamKeys["RETURN_SPA_CODE"] = "return_spa_code";
	    AADServerParamKeys["NATIVE_BROKER"] = "nativebroker";
	    AADServerParamKeys["LOGOUT_HINT"] = "logout_hint";
	})(AADServerParamKeys || (AADServerParamKeys = {}));
	/**
	 * Claims request keys
	 */
	var ClaimsRequestKeys;
	(function (ClaimsRequestKeys) {
	    ClaimsRequestKeys["ACCESS_TOKEN"] = "access_token";
	    ClaimsRequestKeys["XMS_CC"] = "xms_cc";
	})(ClaimsRequestKeys || (ClaimsRequestKeys = {}));
	/**
	 * we considered making this "enum" in the request instead of string, however it looks like the allowed list of
	 * prompt values kept changing over past couple of years. There are some undocumented prompt values for some
	 * internal partners too, hence the choice of generic "string" type instead of the "enum"
	 */
	var PromptValue = {
	    LOGIN: "login",
	    SELECT_ACCOUNT: "select_account",
	    CONSENT: "consent",
	    NONE: "none",
	    CREATE: "create",
	    NO_SESSION: "no_session"
	};
	/**
	 * SSO Types - generated to populate hints
	 */
	var SSOTypes;
	(function (SSOTypes) {
	    SSOTypes["ACCOUNT"] = "account";
	    SSOTypes["SID"] = "sid";
	    SSOTypes["LOGIN_HINT"] = "login_hint";
	    SSOTypes["ID_TOKEN"] = "id_token";
	    SSOTypes["DOMAIN_HINT"] = "domain_hint";
	    SSOTypes["ORGANIZATIONS"] = "organizations";
	    SSOTypes["CONSUMERS"] = "consumers";
	    SSOTypes["ACCOUNT_ID"] = "accountIdentifier";
	    SSOTypes["HOMEACCOUNT_ID"] = "homeAccountIdentifier";
	})(SSOTypes || (SSOTypes = {}));
	/**
	 * allowed values for codeVerifier
	 */
	var CodeChallengeMethodValues = {
	    PLAIN: "plain",
	    S256: "S256"
	};
	/**
	 * allowed values for response_mode
	 */
	var ResponseMode;
	(function (ResponseMode) {
	    ResponseMode["QUERY"] = "query";
	    ResponseMode["FRAGMENT"] = "fragment";
	    ResponseMode["FORM_POST"] = "form_post";
	})(ResponseMode || (ResponseMode = {}));
	/**
	 * allowed grant_type
	 */
	var GrantType;
	(function (GrantType) {
	    GrantType["IMPLICIT_GRANT"] = "implicit";
	    GrantType["AUTHORIZATION_CODE_GRANT"] = "authorization_code";
	    GrantType["CLIENT_CREDENTIALS_GRANT"] = "client_credentials";
	    GrantType["RESOURCE_OWNER_PASSWORD_GRANT"] = "password";
	    GrantType["REFRESH_TOKEN_GRANT"] = "refresh_token";
	    GrantType["DEVICE_CODE_GRANT"] = "device_code";
	    GrantType["JWT_BEARER"] = "urn:ietf:params:oauth:grant-type:jwt-bearer";
	})(GrantType || (GrantType = {}));
	/**
	 * Account types in Cache
	 */
	var CacheAccountType;
	(function (CacheAccountType) {
	    CacheAccountType["MSSTS_ACCOUNT_TYPE"] = "MSSTS";
	    CacheAccountType["ADFS_ACCOUNT_TYPE"] = "ADFS";
	    CacheAccountType["MSAV1_ACCOUNT_TYPE"] = "MSA";
	    CacheAccountType["GENERIC_ACCOUNT_TYPE"] = "Generic"; // NTLM, Kerberos, FBA, Basic etc
	})(CacheAccountType || (CacheAccountType = {}));
	/**
	 * Separators used in cache
	 */
	var Separators;
	(function (Separators) {
	    Separators["CACHE_KEY_SEPARATOR"] = "-";
	    Separators["CLIENT_INFO_SEPARATOR"] = ".";
	})(Separators || (Separators = {}));
	/**
	 * Credential Type stored in the cache
	 */
	var CredentialType;
	(function (CredentialType) {
	    CredentialType["ID_TOKEN"] = "IdToken";
	    CredentialType["ACCESS_TOKEN"] = "AccessToken";
	    CredentialType["ACCESS_TOKEN_WITH_AUTH_SCHEME"] = "AccessToken_With_AuthScheme";
	    CredentialType["REFRESH_TOKEN"] = "RefreshToken";
	})(CredentialType || (CredentialType = {}));
	/**
	 * Combine all cache types
	 */
	var CacheType;
	(function (CacheType) {
	    CacheType[CacheType["ADFS"] = 1001] = "ADFS";
	    CacheType[CacheType["MSA"] = 1002] = "MSA";
	    CacheType[CacheType["MSSTS"] = 1003] = "MSSTS";
	    CacheType[CacheType["GENERIC"] = 1004] = "GENERIC";
	    CacheType[CacheType["ACCESS_TOKEN"] = 2001] = "ACCESS_TOKEN";
	    CacheType[CacheType["REFRESH_TOKEN"] = 2002] = "REFRESH_TOKEN";
	    CacheType[CacheType["ID_TOKEN"] = 2003] = "ID_TOKEN";
	    CacheType[CacheType["APP_METADATA"] = 3001] = "APP_METADATA";
	    CacheType[CacheType["UNDEFINED"] = 9999] = "UNDEFINED";
	})(CacheType || (CacheType = {}));
	/**
	 * More Cache related constants
	 */
	var APP_METADATA = "appmetadata";
	var CLIENT_INFO = "client_info";
	var THE_FAMILY_ID = "1";
	var AUTHORITY_METADATA_CONSTANTS = {
	    CACHE_KEY: "authority-metadata",
	    REFRESH_TIME_SECONDS: 3600 * 24 // 24 Hours
	};
	var AuthorityMetadataSource;
	(function (AuthorityMetadataSource) {
	    AuthorityMetadataSource["CONFIG"] = "config";
	    AuthorityMetadataSource["CACHE"] = "cache";
	    AuthorityMetadataSource["NETWORK"] = "network";
	    AuthorityMetadataSource["HARDCODED_VALUES"] = "hardcoded_values";
	})(AuthorityMetadataSource || (AuthorityMetadataSource = {}));
	var SERVER_TELEM_CONSTANTS = {
	    SCHEMA_VERSION: 5,
	    MAX_CUR_HEADER_BYTES: 80,
	    MAX_LAST_HEADER_BYTES: 330,
	    MAX_CACHED_ERRORS: 50,
	    CACHE_KEY: "server-telemetry",
	    CATEGORY_SEPARATOR: "|",
	    VALUE_SEPARATOR: ",",
	    OVERFLOW_TRUE: "1",
	    OVERFLOW_FALSE: "0",
	    UNKNOWN_ERROR: "unknown_error"
	};
	/**
	 * Type of the authentication request
	 */
	var AuthenticationScheme;
	(function (AuthenticationScheme) {
	    AuthenticationScheme["BEARER"] = "Bearer";
	    AuthenticationScheme["POP"] = "pop";
	    AuthenticationScheme["SSH"] = "ssh-cert";
	})(AuthenticationScheme || (AuthenticationScheme = {}));
	/**
	 * Constants related to throttling
	 */
	var ThrottlingConstants = {
	    // Default time to throttle RequestThumbprint in seconds
	    DEFAULT_THROTTLE_TIME_SECONDS: 60,
	    // Default maximum time to throttle in seconds, overrides what the server sends back
	    DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
	    // Prefix for storing throttling entries
	    THROTTLING_PREFIX: "throttling",
	    // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
	    X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429"
	};
	var Errors = {
	    INVALID_GRANT_ERROR: "invalid_grant",
	    CLIENT_MISMATCH_ERROR: "client_mismatch",
	};
	/**
	 * Password grant parameters
	 */
	var PasswordGrantConstants;
	(function (PasswordGrantConstants) {
	    PasswordGrantConstants["username"] = "username";
	    PasswordGrantConstants["password"] = "password";
	})(PasswordGrantConstants || (PasswordGrantConstants = {}));
	/**
	 * Response codes
	 */
	var ResponseCodes;
	(function (ResponseCodes) {
	    ResponseCodes[ResponseCodes["httpSuccess"] = 200] = "httpSuccess";
	    ResponseCodes[ResponseCodes["httpBadRequest"] = 400] = "httpBadRequest";
	})(ResponseCodes || (ResponseCodes = {}));
	/**
	 * Region Discovery Sources
	 */
	var RegionDiscoverySources;
	(function (RegionDiscoverySources) {
	    RegionDiscoverySources["FAILED_AUTO_DETECTION"] = "1";
	    RegionDiscoverySources["INTERNAL_CACHE"] = "2";
	    RegionDiscoverySources["ENVIRONMENT_VARIABLE"] = "3";
	    RegionDiscoverySources["IMDS"] = "4";
	})(RegionDiscoverySources || (RegionDiscoverySources = {}));
	/**
	 * Region Discovery Outcomes
	 */
	var RegionDiscoveryOutcomes;
	(function (RegionDiscoveryOutcomes) {
	    RegionDiscoveryOutcomes["CONFIGURED_MATCHES_DETECTED"] = "1";
	    RegionDiscoveryOutcomes["CONFIGURED_NO_AUTO_DETECTION"] = "2";
	    RegionDiscoveryOutcomes["CONFIGURED_NOT_DETECTED"] = "3";
	    RegionDiscoveryOutcomes["AUTO_DETECTION_REQUESTED_SUCCESSFUL"] = "4";
	    RegionDiscoveryOutcomes["AUTO_DETECTION_REQUESTED_FAILED"] = "5";
	})(RegionDiscoveryOutcomes || (RegionDiscoveryOutcomes = {}));
	var CacheOutcome;
	(function (CacheOutcome) {
	    CacheOutcome["NO_CACHE_HIT"] = "0";
	    CacheOutcome["FORCE_REFRESH"] = "1";
	    CacheOutcome["NO_CACHED_ACCESS_TOKEN"] = "2";
	    CacheOutcome["CACHED_ACCESS_TOKEN_EXPIRED"] = "3";
	    CacheOutcome["REFRESH_CACHED_ACCESS_TOKEN"] = "4";
	    CacheOutcome["CLAIMS_REQUESTED_CACHE_SKIPPED"] = "5";
	})(CacheOutcome || (CacheOutcome = {}));
	var JsonTypes;
	(function (JsonTypes) {
	    JsonTypes["Jwt"] = "JWT";
	    JsonTypes["Jwk"] = "JWK";
	    JsonTypes["Pop"] = "pop";
	})(JsonTypes || (JsonTypes = {}));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * AuthErrorMessage class containing string constants used by error codes and messages.
	 */
	var AuthErrorMessage = {
	    unexpectedError: {
	        code: "unexpected_error",
	        desc: "Unexpected error in authentication."
	    },
	    postRequestFailed: {
	        code: "post_request_failed",
	        desc: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details."
	    }
	};
	/**
	 * General error class thrown by the MSAL.js library.
	 */
	var AuthError = /** @class */ (function (_super) {
	    __extends$f(AuthError, _super);
	    function AuthError(errorCode, errorMessage, suberror) {
	        var _this = this;
	        var errorString = errorMessage ? errorCode + ": " + errorMessage : errorCode;
	        _this = _super.call(this, errorString) || this;
	        Object.setPrototypeOf(_this, AuthError.prototype);
	        _this.errorCode = errorCode || Constants.EMPTY_STRING;
	        _this.errorMessage = errorMessage || Constants.EMPTY_STRING;
	        _this.subError = suberror || Constants.EMPTY_STRING;
	        _this.name = "AuthError";
	        return _this;
	    }
	    AuthError.prototype.setCorrelationId = function (correlationId) {
	        this.correlationId = correlationId;
	    };
	    /**
	     * Creates an error that is thrown when something unexpected happens in the library.
	     * @param errDesc
	     */
	    AuthError.createUnexpectedError = function (errDesc) {
	        return new AuthError(AuthErrorMessage.unexpectedError.code, AuthErrorMessage.unexpectedError.desc + ": " + errDesc);
	    };
	    /**
	     * Creates an error for post request failures.
	     * @param errDesc
	     * @returns
	     */
	    AuthError.createPostRequestFailed = function (errDesc) {
	        return new AuthError(AuthErrorMessage.postRequestFailed.code, AuthErrorMessage.postRequestFailed.desc + ": " + errDesc);
	    };
	    return AuthError;
	}(Error));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var DEFAULT_CRYPTO_IMPLEMENTATION = {
	    createNewGuid: function () {
	        var notImplErr = "Crypto interface - createNewGuid() has not been implemented";
	        throw AuthError.createUnexpectedError(notImplErr);
	    },
	    base64Decode: function () {
	        var notImplErr = "Crypto interface - base64Decode() has not been implemented";
	        throw AuthError.createUnexpectedError(notImplErr);
	    },
	    base64Encode: function () {
	        var notImplErr = "Crypto interface - base64Encode() has not been implemented";
	        throw AuthError.createUnexpectedError(notImplErr);
	    },
	    generatePkceCodes: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Crypto interface - generatePkceCodes() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    },
	    getPublicKeyThumbprint: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Crypto interface - getPublicKeyThumbprint() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    },
	    removeTokenBindingKey: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Crypto interface - removeTokenBindingKey() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    },
	    clearKeystore: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Crypto interface - clearKeystore() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    },
	    signJwt: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Crypto interface - signJwt() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    },
	    hashString: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Crypto interface - hashString() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    }
	};

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * ClientAuthErrorMessage class containing string constants used by error codes and messages.
	 */
	var ClientAuthErrorMessage = {
	    clientInfoDecodingError: {
	        code: "client_info_decoding_error",
	        desc: "The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause."
	    },
	    clientInfoEmptyError: {
	        code: "client_info_empty_error",
	        desc: "The client info was empty. Please review the trace to determine the root cause."
	    },
	    tokenParsingError: {
	        code: "token_parsing_error",
	        desc: "Token cannot be parsed. Please review stack trace to determine root cause."
	    },
	    nullOrEmptyToken: {
	        code: "null_or_empty_token",
	        desc: "The token is null or empty. Please review the trace to determine the root cause."
	    },
	    endpointResolutionError: {
	        code: "endpoints_resolution_error",
	        desc: "Error: could not resolve endpoints. Please check network and try again."
	    },
	    networkError: {
	        code: "network_error",
	        desc: "Network request failed. Please check network trace to determine root cause."
	    },
	    unableToGetOpenidConfigError: {
	        code: "openid_config_error",
	        desc: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints."
	    },
	    hashNotDeserialized: {
	        code: "hash_not_deserialized",
	        desc: "The hash parameters could not be deserialized. Please review the trace to determine the root cause."
	    },
	    blankGuidGenerated: {
	        code: "blank_guid_generated",
	        desc: "The guid generated was blank. Please review the trace to determine the root cause."
	    },
	    invalidStateError: {
	        code: "invalid_state",
	        desc: "State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState()."
	    },
	    stateMismatchError: {
	        code: "state_mismatch",
	        desc: "State mismatch error. Please check your network. Continued requests may cause cache overflow."
	    },
	    stateNotFoundError: {
	        code: "state_not_found",
	        desc: "State not found"
	    },
	    nonceMismatchError: {
	        code: "nonce_mismatch",
	        desc: "Nonce mismatch error. This may be caused by a race condition in concurrent requests."
	    },
	    nonceNotFoundError: {
	        code: "nonce_not_found",
	        desc: "nonce not found"
	    },
	    authTimeNotFoundError: {
	        code: "auth_time_not_found",
	        desc: "Max Age was requested and the ID token is missing the auth_time variable." +
	            " auth_time is an optional claim and is not enabled by default - it must be enabled." +
	            " See https://aka.ms/msaljs/optional-claims for more information."
	    },
	    maxAgeTranspiredError: {
	        code: "max_age_transpired",
	        desc: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication."
	    },
	    noTokensFoundError: {
	        code: "no_tokens_found",
	        desc: "No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken()."
	    },
	    multipleMatchingTokens: {
	        code: "multiple_matching_tokens",
	        desc: "The cache contains multiple tokens satisfying the requirements. " +
	            "Call AcquireToken again providing more requirements such as authority or account."
	    },
	    multipleMatchingAccounts: {
	        code: "multiple_matching_accounts",
	        desc: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account"
	    },
	    multipleMatchingAppMetadata: {
	        code: "multiple_matching_appMetadata",
	        desc: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata"
	    },
	    tokenRequestCannotBeMade: {
	        code: "request_cannot_be_made",
	        desc: "Token request cannot be made without authorization code or refresh token."
	    },
	    appendEmptyScopeError: {
	        code: "cannot_append_empty_scope",
	        desc: "Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info."
	    },
	    removeEmptyScopeError: {
	        code: "cannot_remove_empty_scope",
	        desc: "Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info."
	    },
	    appendScopeSetError: {
	        code: "cannot_append_scopeset",
	        desc: "Cannot append ScopeSet due to error."
	    },
	    emptyInputScopeSetError: {
	        code: "empty_input_scopeset",
	        desc: "Empty input ScopeSet cannot be processed."
	    },
	    DeviceCodePollingCancelled: {
	        code: "device_code_polling_cancelled",
	        desc: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true."
	    },
	    DeviceCodeExpired: {
	        code: "device_code_expired",
	        desc: "Device code is expired."
	    },
	    DeviceCodeUnknownError: {
	        code: "device_code_unknown_error",
	        desc: "Device code stopped polling for unknown reasons."
	    },
	    NoAccountInSilentRequest: {
	        code: "no_account_in_silent_request",
	        desc: "Please pass an account object, silent flow is not supported without account information"
	    },
	    invalidCacheRecord: {
	        code: "invalid_cache_record",
	        desc: "Cache record object was null or undefined."
	    },
	    invalidCacheEnvironment: {
	        code: "invalid_cache_environment",
	        desc: "Invalid environment when attempting to create cache entry"
	    },
	    noAccountFound: {
	        code: "no_account_found",
	        desc: "No account found in cache for given key."
	    },
	    CachePluginError: {
	        code: "no cache plugin set on CacheManager",
	        desc: "ICachePlugin needs to be set before using readFromStorage or writeFromStorage"
	    },
	    noCryptoObj: {
	        code: "no_crypto_object",
	        desc: "No crypto object detected. This is required for the following operation: "
	    },
	    invalidCacheType: {
	        code: "invalid_cache_type",
	        desc: "Invalid cache type"
	    },
	    unexpectedAccountType: {
	        code: "unexpected_account_type",
	        desc: "Unexpected account type."
	    },
	    unexpectedCredentialType: {
	        code: "unexpected_credential_type",
	        desc: "Unexpected credential type."
	    },
	    invalidAssertion: {
	        code: "invalid_assertion",
	        desc: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515"
	    },
	    invalidClientCredential: {
	        code: "invalid_client_credential",
	        desc: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential"
	    },
	    tokenRefreshRequired: {
	        code: "token_refresh_required",
	        desc: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired."
	    },
	    userTimeoutReached: {
	        code: "user_timeout_reached",
	        desc: "User defined timeout for device code polling reached",
	    },
	    tokenClaimsRequired: {
	        code: "token_claims_cnf_required_for_signedjwt",
	        desc: "Cannot generate a POP jwt if the token_claims are not populated"
	    },
	    noAuthorizationCodeFromServer: {
	        code: "authorization_code_missing_from_server_response",
	        desc: "Server response does not contain an authorization code to proceed"
	    },
	    noAzureRegionDetected: {
	        code: "no_azure_region_detected",
	        desc: "No azure region was detected and no fallback was made available"
	    },
	    accessTokenEntityNullError: {
	        code: "access_token_entity_null",
	        desc: "Access token entity is null, please check logs and cache to ensure a valid access token is present."
	    },
	    bindingKeyNotRemovedError: {
	        code: "binding_key_not_removed",
	        desc: "Could not remove the credential's binding key from storage."
	    },
	    logoutNotSupported: {
	        code: "end_session_endpoint_not_supported",
	        desc: "Provided authority does not support logout."
	    },
	    keyIdMissing: {
	        code: "key_id_missing",
	        desc: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key."
	    },
	    noNetworkConnectivity: {
	        code: "no_network_connectivity",
	        desc: "No network connectivity. Check your internet connection."
	    },
	    userCanceledError: {
	        code: "user_canceled",
	        desc: "User canceled the flow."
	    }
	};
	/**
	 * Error thrown when there is an error in the client code running on the browser.
	 */
	var ClientAuthError = /** @class */ (function (_super) {
	    __extends$f(ClientAuthError, _super);
	    function ClientAuthError(errorCode, errorMessage) {
	        var _this = _super.call(this, errorCode, errorMessage) || this;
	        _this.name = "ClientAuthError";
	        Object.setPrototypeOf(_this, ClientAuthError.prototype);
	        return _this;
	    }
	    /**
	     * Creates an error thrown when client info object doesn't decode correctly.
	     * @param caughtError
	     */
	    ClientAuthError.createClientInfoDecodingError = function (caughtError) {
	        return new ClientAuthError(ClientAuthErrorMessage.clientInfoDecodingError.code, ClientAuthErrorMessage.clientInfoDecodingError.desc + " Failed with error: " + caughtError);
	    };
	    /**
	     * Creates an error thrown if the client info is empty.
	     * @param rawClientInfo
	     */
	    ClientAuthError.createClientInfoEmptyError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.clientInfoEmptyError.code, "" + ClientAuthErrorMessage.clientInfoEmptyError.desc);
	    };
	    /**
	     * Creates an error thrown when the id token extraction errors out.
	     * @param err
	     */
	    ClientAuthError.createTokenParsingError = function (caughtExtractionError) {
	        return new ClientAuthError(ClientAuthErrorMessage.tokenParsingError.code, ClientAuthErrorMessage.tokenParsingError.desc + " Failed with error: " + caughtExtractionError);
	    };
	    /**
	     * Creates an error thrown when the id token string is null or empty.
	     * @param invalidRawTokenString
	     */
	    ClientAuthError.createTokenNullOrEmptyError = function (invalidRawTokenString) {
	        return new ClientAuthError(ClientAuthErrorMessage.nullOrEmptyToken.code, ClientAuthErrorMessage.nullOrEmptyToken.desc + " Raw Token Value: " + invalidRawTokenString);
	    };
	    /**
	     * Creates an error thrown when the endpoint discovery doesn't complete correctly.
	     */
	    ClientAuthError.createEndpointDiscoveryIncompleteError = function (errDetail) {
	        return new ClientAuthError(ClientAuthErrorMessage.endpointResolutionError.code, ClientAuthErrorMessage.endpointResolutionError.desc + " Detail: " + errDetail);
	    };
	    /**
	     * Creates an error thrown when the fetch client throws
	     */
	    ClientAuthError.createNetworkError = function (endpoint, errDetail) {
	        return new ClientAuthError(ClientAuthErrorMessage.networkError.code, ClientAuthErrorMessage.networkError.desc + " | Fetch client threw: " + errDetail + " | Attempted to reach: " + endpoint.split("?")[0]);
	    };
	    /**
	     * Creates an error thrown when the openid-configuration endpoint cannot be reached or does not contain the required data
	     */
	    ClientAuthError.createUnableToGetOpenidConfigError = function (errDetail) {
	        return new ClientAuthError(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, ClientAuthErrorMessage.unableToGetOpenidConfigError.desc + " Attempted to retrieve endpoints from: " + errDetail);
	    };
	    /**
	     * Creates an error thrown when the hash cannot be deserialized.
	     * @param hashParamObj
	     */
	    ClientAuthError.createHashNotDeserializedError = function (hashParamObj) {
	        return new ClientAuthError(ClientAuthErrorMessage.hashNotDeserialized.code, ClientAuthErrorMessage.hashNotDeserialized.desc + " Given Object: " + hashParamObj);
	    };
	    /**
	     * Creates an error thrown when the state cannot be parsed.
	     * @param invalidState
	     */
	    ClientAuthError.createInvalidStateError = function (invalidState, errorString) {
	        return new ClientAuthError(ClientAuthErrorMessage.invalidStateError.code, ClientAuthErrorMessage.invalidStateError.desc + " Invalid State: " + invalidState + ", Root Err: " + errorString);
	    };
	    /**
	     * Creates an error thrown when two states do not match.
	     */
	    ClientAuthError.createStateMismatchError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);
	    };
	    /**
	     * Creates an error thrown when the state is not present
	     * @param missingState
	     */
	    ClientAuthError.createStateNotFoundError = function (missingState) {
	        return new ClientAuthError(ClientAuthErrorMessage.stateNotFoundError.code, ClientAuthErrorMessage.stateNotFoundError.desc + ":  " + missingState);
	    };
	    /**
	     * Creates an error thrown when the nonce does not match.
	     */
	    ClientAuthError.createNonceMismatchError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);
	    };
	    /**
	     * Creates an error thrown when max_age was provided in the request, but auth_time is not in the token claims
	     * @param missingNonce
	     */
	    ClientAuthError.createAuthTimeNotFoundError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.authTimeNotFoundError.code, ClientAuthErrorMessage.authTimeNotFoundError.desc);
	    };
	    /**
	     * Creates an error thrown when too much time has elapsed since the last end-user authentication
	     */
	    ClientAuthError.createMaxAgeTranspiredError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.maxAgeTranspiredError.code, ClientAuthErrorMessage.maxAgeTranspiredError.desc);
	    };
	    /**
	     * Creates an error thrown when the mnonce is not present
	     * @param missingNonce
	     */
	    ClientAuthError.createNonceNotFoundError = function (missingNonce) {
	        return new ClientAuthError(ClientAuthErrorMessage.nonceNotFoundError.code, ClientAuthErrorMessage.nonceNotFoundError.desc + ":  " + missingNonce);
	    };
	    /**
	     * Throws error when multiple tokens are in cache.
	     */
	    ClientAuthError.createMultipleMatchingTokensInCacheError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingTokens.code, ClientAuthErrorMessage.multipleMatchingTokens.desc + ".");
	    };
	    /**
	     * Throws error when multiple accounts are in cache for the given params
	     */
	    ClientAuthError.createMultipleMatchingAccountsInCacheError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);
	    };
	    /**
	     * Throws error when multiple appMetada are in cache for the given clientId.
	     */
	    ClientAuthError.createMultipleMatchingAppMetadataInCacheError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);
	    };
	    /**
	     * Throws error when no auth code or refresh token is given to ServerTokenRequestParameters.
	     */
	    ClientAuthError.createTokenRequestCannotBeMadeError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);
	    };
	    /**
	     * Throws error when attempting to append a null, undefined or empty scope to a set
	     * @param givenScope
	     */
	    ClientAuthError.createAppendEmptyScopeToSetError = function (givenScope) {
	        return new ClientAuthError(ClientAuthErrorMessage.appendEmptyScopeError.code, ClientAuthErrorMessage.appendEmptyScopeError.desc + " Given Scope: " + givenScope);
	    };
	    /**
	     * Throws error when attempting to append a null, undefined or empty scope to a set
	     * @param givenScope
	     */
	    ClientAuthError.createRemoveEmptyScopeFromSetError = function (givenScope) {
	        return new ClientAuthError(ClientAuthErrorMessage.removeEmptyScopeError.code, ClientAuthErrorMessage.removeEmptyScopeError.desc + " Given Scope: " + givenScope);
	    };
	    /**
	     * Throws error when attempting to append null or empty ScopeSet.
	     * @param appendError
	     */
	    ClientAuthError.createAppendScopeSetError = function (appendError) {
	        return new ClientAuthError(ClientAuthErrorMessage.appendScopeSetError.code, ClientAuthErrorMessage.appendScopeSetError.desc + " Detail Error: " + appendError);
	    };
	    /**
	     * Throws error if ScopeSet is null or undefined.
	     * @param givenScopeSet
	     */
	    ClientAuthError.createEmptyInputScopeSetError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.emptyInputScopeSetError.code, "" + ClientAuthErrorMessage.emptyInputScopeSetError.desc);
	    };
	    /**
	     * Throws error if user sets CancellationToken.cancel = true during polling of token endpoint during device code flow
	     */
	    ClientAuthError.createDeviceCodeCancelledError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, "" + ClientAuthErrorMessage.DeviceCodePollingCancelled.desc);
	    };
	    /**
	     * Throws error if device code is expired
	     */
	    ClientAuthError.createDeviceCodeExpiredError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeExpired.code, "" + ClientAuthErrorMessage.DeviceCodeExpired.desc);
	    };
	    /**
	     * Throws error if device code is expired
	     */
	    ClientAuthError.createDeviceCodeUnknownError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeUnknownError.code, "" + ClientAuthErrorMessage.DeviceCodeUnknownError.desc);
	    };
	    /**
	     * Throws error when silent requests are made without an account object
	     */
	    ClientAuthError.createNoAccountInSilentRequestError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.NoAccountInSilentRequest.code, "" + ClientAuthErrorMessage.NoAccountInSilentRequest.desc);
	    };
	    /**
	     * Throws error when cache record is null or undefined.
	     */
	    ClientAuthError.createNullOrUndefinedCacheRecord = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);
	    };
	    /**
	     * Throws error when provided environment is not part of the CloudDiscoveryMetadata object
	     */
	    ClientAuthError.createInvalidCacheEnvironmentError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);
	    };
	    /**
	     * Throws error when account is not found in cache.
	     */
	    ClientAuthError.createNoAccountFoundError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);
	    };
	    /**
	     * Throws error if ICachePlugin not set on CacheManager.
	     */
	    ClientAuthError.createCachePluginError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.CachePluginError.code, "" + ClientAuthErrorMessage.CachePluginError.desc);
	    };
	    /**
	     * Throws error if crypto object not found.
	     * @param operationName
	     */
	    ClientAuthError.createNoCryptoObjectError = function (operationName) {
	        return new ClientAuthError(ClientAuthErrorMessage.noCryptoObj.code, "" + ClientAuthErrorMessage.noCryptoObj.desc + operationName);
	    };
	    /**
	     * Throws error if cache type is invalid.
	     */
	    ClientAuthError.createInvalidCacheTypeError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.invalidCacheType.code, "" + ClientAuthErrorMessage.invalidCacheType.desc);
	    };
	    /**
	     * Throws error if unexpected account type.
	     */
	    ClientAuthError.createUnexpectedAccountTypeError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.unexpectedAccountType.code, "" + ClientAuthErrorMessage.unexpectedAccountType.desc);
	    };
	    /**
	     * Throws error if unexpected credential type.
	     */
	    ClientAuthError.createUnexpectedCredentialTypeError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.unexpectedCredentialType.code, "" + ClientAuthErrorMessage.unexpectedCredentialType.desc);
	    };
	    /**
	     * Throws error if client assertion is not valid.
	     */
	    ClientAuthError.createInvalidAssertionError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.invalidAssertion.code, "" + ClientAuthErrorMessage.invalidAssertion.desc);
	    };
	    /**
	     * Throws error if client assertion is not valid.
	     */
	    ClientAuthError.createInvalidCredentialError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.invalidClientCredential.code, "" + ClientAuthErrorMessage.invalidClientCredential.desc);
	    };
	    /**
	     * Throws error if token cannot be retrieved from cache due to refresh being required.
	     */
	    ClientAuthError.createRefreshRequiredError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);
	    };
	    /**
	     * Throws error if the user defined timeout is reached.
	     */
	    ClientAuthError.createUserTimeoutReachedError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);
	    };
	    /*
	     * Throws error if token claims are not populated for a signed jwt generation
	     */
	    ClientAuthError.createTokenClaimsRequiredError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);
	    };
	    /**
	     * Throws error when the authorization code is missing from the server response
	     */
	    ClientAuthError.createNoAuthCodeInServerResponseError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);
	    };
	    ClientAuthError.createBindingKeyNotRemovedError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);
	    };
	    /**
	     * Thrown when logout is attempted for an authority that doesnt have an end_session_endpoint
	     */
	    ClientAuthError.createLogoutNotSupportedError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);
	    };
	    /**
	     * Create an error when kid attribute is missing from a PoP token's cache record
	     */
	    ClientAuthError.createKeyIdMissingError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);
	    };
	    /**
	     * Create an error when the client does not have network connectivity
	     */
	    ClientAuthError.createNoNetworkConnectivityError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.noNetworkConnectivity.code, ClientAuthErrorMessage.noNetworkConnectivity.desc);
	    };
	    /**
	     * Create an error when the user cancels the flow
	     */
	    ClientAuthError.createUserCanceledError = function () {
	        return new ClientAuthError(ClientAuthErrorMessage.userCanceledError.code, ClientAuthErrorMessage.userCanceledError.desc);
	    };
	    return ClientAuthError;
	}(AuthError));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * @hidden
	 */
	var StringUtils = /** @class */ (function () {
	    function StringUtils() {
	    }
	    /**
	     * decode a JWT
	     *
	     * @param authToken
	     */
	    StringUtils.decodeAuthToken = function (authToken) {
	        if (StringUtils.isEmpty(authToken)) {
	            throw ClientAuthError.createTokenNullOrEmptyError(authToken);
	        }
	        var tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
	        var matches = tokenPartsRegex.exec(authToken);
	        if (!matches || matches.length < 4) {
	            throw ClientAuthError.createTokenParsingError("Given token is malformed: " + JSON.stringify(authToken));
	        }
	        var crackedToken = {
	            header: matches[1],
	            JWSPayload: matches[2],
	            JWSSig: matches[3]
	        };
	        return crackedToken;
	    };
	    /**
	     * Check if a string is empty.
	     *
	     * @param str
	     */
	    StringUtils.isEmpty = function (str) {
	        return (typeof str === "undefined" || !str || 0 === str.length);
	    };
	    /**
	     * Check if stringified object is empty
	     * @param strObj
	     */
	    StringUtils.isEmptyObj = function (strObj) {
	        if (strObj && !StringUtils.isEmpty(strObj)) {
	            try {
	                var obj = JSON.parse(strObj);
	                return Object.keys(obj).length === 0;
	            }
	            catch (e) { }
	        }
	        return true;
	    };
	    StringUtils.startsWith = function (str, search) {
	        return str.indexOf(search) === 0;
	    };
	    StringUtils.endsWith = function (str, search) {
	        return (str.length >= search.length) && (str.lastIndexOf(search) === (str.length - search.length));
	    };
	    /**
	     * Parses string into an object.
	     *
	     * @param query
	     */
	    StringUtils.queryStringToObject = function (query) {
	        var obj = {};
	        var params = query.split("&");
	        var decode = function (s) { return decodeURIComponent(s.replace(/\+/g, " ")); };
	        params.forEach(function (pair) {
	            if (pair.trim()) {
	                var _a = pair.split(/=(.+)/g, 2), key = _a[0], value = _a[1]; // Split on the first occurence of the '=' character
	                if (key && value) {
	                    obj[decode(key)] = decode(value);
	                }
	            }
	        });
	        return obj;
	    };
	    /**
	     * Trims entries in an array.
	     *
	     * @param arr
	     */
	    StringUtils.trimArrayEntries = function (arr) {
	        return arr.map(function (entry) { return entry.trim(); });
	    };
	    /**
	     * Removes empty strings from array
	     * @param arr
	     */
	    StringUtils.removeEmptyStringsFromArray = function (arr) {
	        return arr.filter(function (entry) {
	            return !StringUtils.isEmpty(entry);
	        });
	    };
	    /**
	     * Attempts to parse a string into JSON
	     * @param str
	     */
	    StringUtils.jsonParseHelper = function (str) {
	        try {
	            return JSON.parse(str);
	        }
	        catch (e) {
	            return null;
	        }
	    };
	    /**
	     * Tests if a given string matches a given pattern, with support for wildcards and queries.
	     * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
	     * @param input String to match against
	     */
	    StringUtils.matchPattern = function (pattern, input) {
	        /**
	         * Wildcard support: https://stackoverflow.com/a/3117248/4888559
	         * Queries: replaces "?" in string with escaped "\?" for regex test
	         */
	        var regex = new RegExp(pattern.replace(/\\/g, "\\\\").replace(/\*/g, "[^ ]*").replace(/\?/g, "\\\?")); // eslint-disable-line security/detect-non-literal-regexp
	        return regex.test(input);
	    };
	    return StringUtils;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Log message level.
	 */
	var LogLevel;
	(function (LogLevel) {
	    LogLevel[LogLevel["Error"] = 0] = "Error";
	    LogLevel[LogLevel["Warning"] = 1] = "Warning";
	    LogLevel[LogLevel["Info"] = 2] = "Info";
	    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
	    LogLevel[LogLevel["Trace"] = 4] = "Trace";
	})(LogLevel || (LogLevel = {}));
	/**
	 * Class which facilitates logging of messages to a specific place.
	 */
	var Logger = /** @class */ (function () {
	    function Logger(loggerOptions, packageName, packageVersion) {
	        // Current log level, defaults to info.
	        this.level = LogLevel.Info;
	        var defaultLoggerCallback = function () {
	            return;
	        };
	        var setLoggerOptions = loggerOptions || Logger.createDefaultLoggerOptions();
	        this.localCallback = setLoggerOptions.loggerCallback || defaultLoggerCallback;
	        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
	        this.level = typeof (setLoggerOptions.logLevel) === "number" ? setLoggerOptions.logLevel : LogLevel.Info;
	        this.correlationId = setLoggerOptions.correlationId || Constants.EMPTY_STRING;
	        this.packageName = packageName || Constants.EMPTY_STRING;
	        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
	    }
	    Logger.createDefaultLoggerOptions = function () {
	        return {
	            loggerCallback: function () {
	                // allow users to not set loggerCallback
	            },
	            piiLoggingEnabled: false,
	            logLevel: LogLevel.Info
	        };
	    };
	    /**
	     * Create new Logger with existing configurations.
	     */
	    Logger.prototype.clone = function (packageName, packageVersion, correlationId) {
	        return new Logger({ loggerCallback: this.localCallback, piiLoggingEnabled: this.piiLoggingEnabled, logLevel: this.level, correlationId: correlationId || this.correlationId }, packageName, packageVersion);
	    };
	    /**
	     * Log message with required options.
	     */
	    Logger.prototype.logMessage = function (logMessage, options) {
	        if ((options.logLevel > this.level) || (!this.piiLoggingEnabled && options.containsPii)) {
	            return;
	        }
	        var timestamp = new Date().toUTCString();
	        // Add correlationId to logs if set, correlationId provided on log messages take precedence
	        var logHeader;
	        if (!StringUtils.isEmpty(options.correlationId)) {
	            logHeader = "[" + timestamp + "] : [" + options.correlationId + "]";
	        }
	        else if (!StringUtils.isEmpty(this.correlationId)) {
	            logHeader = "[" + timestamp + "] : [" + this.correlationId + "]";
	        }
	        else {
	            logHeader = "[" + timestamp + "]";
	        }
	        var log = logHeader + " : " + this.packageName + "@" + this.packageVersion + " : " + LogLevel[options.logLevel] + " - " + logMessage;
	        // debug(`msal:${LogLevel[options.logLevel]}${options.containsPii ? "-Pii": Constants.EMPTY_STRING}${options.context ? `:${options.context}` : Constants.EMPTY_STRING}`)(logMessage);
	        this.executeCallback(options.logLevel, log, options.containsPii || false);
	    };
	    /**
	     * Execute callback with message.
	     */
	    Logger.prototype.executeCallback = function (level, message, containsPii) {
	        if (this.localCallback) {
	            this.localCallback(level, message, containsPii);
	        }
	    };
	    /**
	     * Logs error messages.
	     */
	    Logger.prototype.error = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Error,
	            containsPii: false,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs error messages with PII.
	     */
	    Logger.prototype.errorPii = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Error,
	            containsPii: true,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs warning messages.
	     */
	    Logger.prototype.warning = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Warning,
	            containsPii: false,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs warning messages with PII.
	     */
	    Logger.prototype.warningPii = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Warning,
	            containsPii: true,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs info messages.
	     */
	    Logger.prototype.info = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Info,
	            containsPii: false,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs info messages with PII.
	     */
	    Logger.prototype.infoPii = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Info,
	            containsPii: true,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs verbose messages.
	     */
	    Logger.prototype.verbose = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Verbose,
	            containsPii: false,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs verbose messages with PII.
	     */
	    Logger.prototype.verbosePii = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Verbose,
	            containsPii: true,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs trace messages.
	     */
	    Logger.prototype.trace = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Trace,
	            containsPii: false,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Logs trace messages with PII.
	     */
	    Logger.prototype.tracePii = function (message, correlationId) {
	        this.logMessage(message, {
	            logLevel: LogLevel.Trace,
	            containsPii: true,
	            correlationId: correlationId || Constants.EMPTY_STRING
	        });
	    };
	    /**
	     * Returns whether PII Logging is enabled or not.
	     */
	    Logger.prototype.isPiiLoggingEnabled = function () {
	        return this.piiLoggingEnabled || false;
	    };
	    return Logger;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/* eslint-disable header/header */
	var name$1 = "@azure/msal-common";
	var version$1 = "13.3.1";

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var AzureCloudInstance;
	(function (AzureCloudInstance) {
	    // AzureCloudInstance is not specified.
	    AzureCloudInstance[AzureCloudInstance["None"] = 0] = "None";
	    // Microsoft Azure public cloud
	    AzureCloudInstance["AzurePublic"] = "https://login.microsoftonline.com";
	    // Microsoft PPE
	    AzureCloudInstance["AzurePpe"] = "https://login.windows-ppe.net";
	    // Microsoft Chinese national cloud
	    AzureCloudInstance["AzureChina"] = "https://login.chinacloudapi.cn";
	    // Microsoft German national cloud ("Black Forest")
	    AzureCloudInstance["AzureGermany"] = "https://login.microsoftonline.de";
	    // US Government cloud
	    AzureCloudInstance["AzureUsGovernment"] = "https://login.microsoftonline.us";
	})(AzureCloudInstance || (AzureCloudInstance = {}));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * ClientConfigurationErrorMessage class containing string constants used by error codes and messages.
	 */
	var ClientConfigurationErrorMessage = {
	    redirectUriNotSet: {
	        code: "redirect_uri_empty",
	        desc: "A redirect URI is required for all calls, and none has been set."
	    },
	    postLogoutUriNotSet: {
	        code: "post_logout_uri_empty",
	        desc: "A post logout redirect has not been set."
	    },
	    claimsRequestParsingError: {
	        code: "claims_request_parsing_error",
	        desc: "Could not parse the given claims request object."
	    },
	    authorityUriInsecure: {
	        code: "authority_uri_insecure",
	        desc: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options"
	    },
	    urlParseError: {
	        code: "url_parse_error",
	        desc: "URL could not be parsed into appropriate segments."
	    },
	    urlEmptyError: {
	        code: "empty_url_error",
	        desc: "URL was empty or null."
	    },
	    emptyScopesError: {
	        code: "empty_input_scopes_error",
	        desc: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token."
	    },
	    nonArrayScopesError: {
	        code: "nonarray_input_scopes_error",
	        desc: "Scopes cannot be passed as non-array."
	    },
	    clientIdSingleScopeError: {
	        code: "clientid_input_scopes_error",
	        desc: "Client ID can only be provided as a single scope."
	    },
	    invalidPrompt: {
	        code: "invalid_prompt_value",
	        desc: "Supported prompt values are 'login', 'select_account', 'consent', 'create', 'none' and 'no_session'.  Please see here for valid configuration options: https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal_common.html#commonauthorizationurlrequest",
	    },
	    invalidClaimsRequest: {
	        code: "invalid_claims",
	        desc: "Given claims parameter must be a stringified JSON object."
	    },
	    tokenRequestEmptyError: {
	        code: "token_request_empty",
	        desc: "Token request was empty and not found in cache."
	    },
	    logoutRequestEmptyError: {
	        code: "logout_request_empty",
	        desc: "The logout request was null or undefined."
	    },
	    invalidCodeChallengeMethod: {
	        code: "invalid_code_challenge_method",
	        desc: "code_challenge_method passed is invalid. Valid values are \"plain\" and \"S256\"."
	    },
	    invalidCodeChallengeParams: {
	        code: "pkce_params_missing",
	        desc: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request"
	    },
	    invalidCloudDiscoveryMetadata: {
	        code: "invalid_cloud_discovery_metadata",
	        desc: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields"
	    },
	    invalidAuthorityMetadata: {
	        code: "invalid_authority_metadata",
	        desc: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields."
	    },
	    untrustedAuthority: {
	        code: "untrusted_authority",
	        desc: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter."
	    },
	    invalidAzureCloudInstance: {
	        code: "invalid_azure_cloud_instance",
	        desc: "Invalid AzureCloudInstance provided. Please refer MSAL JS docs: aks.ms/msaljs/azure_cloud_instance for valid values"
	    },
	    missingSshJwk: {
	        code: "missing_ssh_jwk",
	        desc: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme."
	    },
	    missingSshKid: {
	        code: "missing_ssh_kid",
	        desc: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme."
	    },
	    missingNonceAuthenticationHeader: {
	        code: "missing_nonce_authentication_header",
	        desc: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce."
	    },
	    invalidAuthenticationHeader: {
	        code: "invalid_authentication_header",
	        desc: "Invalid authentication header provided"
	    },
	    authorityMismatch: {
	        code: "authority_mismatch",
	        desc: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority."
	    }
	};
	/**
	 * Error thrown when there is an error in configuration of the MSAL.js library.
	 */
	var ClientConfigurationError = /** @class */ (function (_super) {
	    __extends$f(ClientConfigurationError, _super);
	    function ClientConfigurationError(errorCode, errorMessage) {
	        var _this = _super.call(this, errorCode, errorMessage) || this;
	        _this.name = "ClientConfigurationError";
	        Object.setPrototypeOf(_this, ClientConfigurationError.prototype);
	        return _this;
	    }
	    /**
	     * Creates an error thrown when the redirect uri is empty (not set by caller)
	     */
	    ClientConfigurationError.createRedirectUriEmptyError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.redirectUriNotSet.code, ClientConfigurationErrorMessage.redirectUriNotSet.desc);
	    };
	    /**
	     * Creates an error thrown when the post-logout redirect uri is empty (not set by caller)
	     */
	    ClientConfigurationError.createPostLogoutRedirectUriEmptyError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.postLogoutUriNotSet.code, ClientConfigurationErrorMessage.postLogoutUriNotSet.desc);
	    };
	    /**
	     * Creates an error thrown when the claims request could not be successfully parsed
	     */
	    ClientConfigurationError.createClaimsRequestParsingError = function (claimsRequestParseError) {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.claimsRequestParsingError.code, ClientConfigurationErrorMessage.claimsRequestParsingError.desc + " Given value: " + claimsRequestParseError);
	    };
	    /**
	     * Creates an error thrown if authority uri is given an insecure protocol.
	     * @param urlString
	     */
	    ClientConfigurationError.createInsecureAuthorityUriError = function (urlString) {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.authorityUriInsecure.code, ClientConfigurationErrorMessage.authorityUriInsecure.desc + " Given URI: " + urlString);
	    };
	    /**
	     * Creates an error thrown if URL string does not parse into separate segments.
	     * @param urlString
	     */
	    ClientConfigurationError.createUrlParseError = function (urlParseError) {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlParseError.code, ClientConfigurationErrorMessage.urlParseError.desc + " Given Error: " + urlParseError);
	    };
	    /**
	     * Creates an error thrown if URL string is empty or null.
	     * @param urlString
	     */
	    ClientConfigurationError.createUrlEmptyError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.urlEmptyError.code, ClientConfigurationErrorMessage.urlEmptyError.desc);
	    };
	    /**
	     * Error thrown when scopes are empty.
	     * @param scopesValue
	     */
	    ClientConfigurationError.createEmptyScopesArrayError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.emptyScopesError.code, "" + ClientConfigurationErrorMessage.emptyScopesError.desc);
	    };
	    /**
	     * Error thrown when client id scope is not provided as single scope.
	     * @param inputScopes
	     */
	    ClientConfigurationError.createClientIdSingleScopeError = function (inputScopes) {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.clientIdSingleScopeError.code, ClientConfigurationErrorMessage.clientIdSingleScopeError.desc + " Given Scopes: " + inputScopes);
	    };
	    /**
	     * Error thrown when prompt is not an allowed type.
	     * @param promptValue
	     */
	    ClientConfigurationError.createInvalidPromptError = function (promptValue) {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidPrompt.code, ClientConfigurationErrorMessage.invalidPrompt.desc + " Given value: " + promptValue);
	    };
	    /**
	     * Creates error thrown when claims parameter is not a stringified JSON object
	     */
	    ClientConfigurationError.createInvalidClaimsRequestError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidClaimsRequest.code, ClientConfigurationErrorMessage.invalidClaimsRequest.desc);
	    };
	    /**
	     * Throws error when token request is empty and nothing cached in storage.
	     */
	    ClientConfigurationError.createEmptyLogoutRequestError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.logoutRequestEmptyError.code, ClientConfigurationErrorMessage.logoutRequestEmptyError.desc);
	    };
	    /**
	     * Throws error when token request is empty and nothing cached in storage.
	     */
	    ClientConfigurationError.createEmptyTokenRequestError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.tokenRequestEmptyError.code, ClientConfigurationErrorMessage.tokenRequestEmptyError.desc);
	    };
	    /**
	     * Throws error when an invalid code_challenge_method is passed by the user
	     */
	    ClientConfigurationError.createInvalidCodeChallengeMethodError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCodeChallengeMethod.code, ClientConfigurationErrorMessage.invalidCodeChallengeMethod.desc);
	    };
	    /**
	     * Throws error when both params: code_challenge and code_challenge_method are not passed together
	     */
	    ClientConfigurationError.createInvalidCodeChallengeParamsError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCodeChallengeParams.code, ClientConfigurationErrorMessage.invalidCodeChallengeParams.desc);
	    };
	    /**
	     * Throws an error when the user passes invalid cloudDiscoveryMetadata
	     */
	    ClientConfigurationError.createInvalidCloudDiscoveryMetadataError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.code, ClientConfigurationErrorMessage.invalidCloudDiscoveryMetadata.desc);
	    };
	    /**
	     * Throws an error when the user passes invalid cloudDiscoveryMetadata
	     */
	    ClientConfigurationError.createInvalidAuthorityMetadataError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAuthorityMetadata.code, ClientConfigurationErrorMessage.invalidAuthorityMetadata.desc);
	    };
	    /**
	     * Throws error when provided authority is not a member of the trusted host list
	     */
	    ClientConfigurationError.createUntrustedAuthorityError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.untrustedAuthority.code, ClientConfigurationErrorMessage.untrustedAuthority.desc);
	    };
	    /**
	     * Throws error when the AzureCloudInstance is set to an invalid value
	     */
	    ClientConfigurationError.createInvalidAzureCloudInstanceError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAzureCloudInstance.code, ClientConfigurationErrorMessage.invalidAzureCloudInstance.desc);
	    };
	    /**
	     * Throws an error when the authentication scheme is set to SSH but the SSH public key is omitted from the request
	     */
	    ClientConfigurationError.createMissingSshJwkError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingSshJwk.code, ClientConfigurationErrorMessage.missingSshJwk.desc);
	    };
	    /**
	     * Throws an error when the authentication scheme is set to SSH but the SSH public key ID is omitted from the request
	     */
	    ClientConfigurationError.createMissingSshKidError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingSshKid.code, ClientConfigurationErrorMessage.missingSshKid.desc);
	    };
	    /**
	     * Throws error when provided headers don't contain a header that a server nonce can be extracted from
	     */
	    ClientConfigurationError.createMissingNonceAuthenticationHeadersError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.code, ClientConfigurationErrorMessage.missingNonceAuthenticationHeader.desc);
	    };
	    /**
	     * Throws error when a provided header is invalid in any way
	     */
	    ClientConfigurationError.createInvalidAuthenticationHeaderError = function (invalidHeaderName, details) {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.invalidAuthenticationHeader.code, ClientConfigurationErrorMessage.invalidAuthenticationHeader.desc + ". Invalid header: " + invalidHeaderName + ". Details: " + details);
	    };
	    /**
	     * Create an error when the authority provided in request does not match authority provided in account or MSAL.js configuration.
	     */
	    ClientConfigurationError.createAuthorityMismatchError = function () {
	        return new ClientConfigurationError(ClientConfigurationErrorMessage.authorityMismatch.code, ClientConfigurationErrorMessage.authorityMismatch.desc);
	    };
	    return ClientConfigurationError;
	}(ClientAuthError));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes
	 * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings in intersection and union functions
	 * to ensure uniqueness of strings.
	 */
	var ScopeSet = /** @class */ (function () {
	    function ScopeSet(inputScopes) {
	        var _this = this;
	        // Filter empty string and null/undefined array items
	        var scopeArr = inputScopes ? StringUtils.trimArrayEntries(__spreadArrays(inputScopes)) : [];
	        var filteredInput = scopeArr ? StringUtils.removeEmptyStringsFromArray(scopeArr) : [];
	        // Validate and filter scopes (validate function throws if validation fails)
	        this.validateInputScopes(filteredInput);
	        this.scopes = new Set(); // Iterator in constructor not supported by IE11
	        filteredInput.forEach(function (scope) { return _this.scopes.add(scope); });
	    }
	    /**
	     * Factory method to create ScopeSet from space-delimited string
	     * @param inputScopeString
	     * @param appClientId
	     * @param scopesRequired
	     */
	    ScopeSet.fromString = function (inputScopeString) {
	        var scopeString = inputScopeString || Constants.EMPTY_STRING;
	        var inputScopes = scopeString.split(" ");
	        return new ScopeSet(inputScopes);
	    };
	    /**
	     * Creates the set of scopes to search for in cache lookups
	     * @param inputScopeString
	     * @returns
	     */
	    ScopeSet.createSearchScopes = function (inputScopeString) {
	        var scopeSet = new ScopeSet(inputScopeString);
	        if (!scopeSet.containsOnlyOIDCScopes()) {
	            scopeSet.removeOIDCScopes();
	        }
	        else {
	            scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
	        }
	        return scopeSet;
	    };
	    /**
	     * Used to validate the scopes input parameter requested  by the developer.
	     * @param {Array<string>} inputScopes - Developer requested permissions. Not all scopes are guaranteed to be included in the access token returned.
	     * @param {boolean} scopesRequired - Boolean indicating whether the scopes array is required or not
	     */
	    ScopeSet.prototype.validateInputScopes = function (inputScopes) {
	        // Check if scopes are required but not given or is an empty array
	        if (!inputScopes || inputScopes.length < 1) {
	            throw ClientConfigurationError.createEmptyScopesArrayError();
	        }
	    };
	    /**
	     * Check if a given scope is present in this set of scopes.
	     * @param scope
	     */
	    ScopeSet.prototype.containsScope = function (scope) {
	        var lowerCaseScopes = this.printScopesLowerCase().split(" ");
	        var lowerCaseScopesSet = new ScopeSet(lowerCaseScopes);
	        // compare lowercase scopes
	        return !StringUtils.isEmpty(scope) ? lowerCaseScopesSet.scopes.has(scope.toLowerCase()) : false;
	    };
	    /**
	     * Check if a set of scopes is present in this set of scopes.
	     * @param scopeSet
	     */
	    ScopeSet.prototype.containsScopeSet = function (scopeSet) {
	        var _this = this;
	        if (!scopeSet || scopeSet.scopes.size <= 0) {
	            return false;
	        }
	        return (this.scopes.size >= scopeSet.scopes.size && scopeSet.asArray().every(function (scope) { return _this.containsScope(scope); }));
	    };
	    /**
	     * Check if set of scopes contains only the defaults
	     */
	    ScopeSet.prototype.containsOnlyOIDCScopes = function () {
	        var _this = this;
	        var defaultScopeCount = 0;
	        OIDC_SCOPES.forEach(function (defaultScope) {
	            if (_this.containsScope(defaultScope)) {
	                defaultScopeCount += 1;
	            }
	        });
	        return this.scopes.size === defaultScopeCount;
	    };
	    /**
	     * Appends single scope if passed
	     * @param newScope
	     */
	    ScopeSet.prototype.appendScope = function (newScope) {
	        if (!StringUtils.isEmpty(newScope)) {
	            this.scopes.add(newScope.trim());
	        }
	    };
	    /**
	     * Appends multiple scopes if passed
	     * @param newScopes
	     */
	    ScopeSet.prototype.appendScopes = function (newScopes) {
	        var _this = this;
	        try {
	            newScopes.forEach(function (newScope) { return _this.appendScope(newScope); });
	        }
	        catch (e) {
	            throw ClientAuthError.createAppendScopeSetError(e);
	        }
	    };
	    /**
	     * Removes element from set of scopes.
	     * @param scope
	     */
	    ScopeSet.prototype.removeScope = function (scope) {
	        if (StringUtils.isEmpty(scope)) {
	            throw ClientAuthError.createRemoveEmptyScopeFromSetError(scope);
	        }
	        this.scopes.delete(scope.trim());
	    };
	    /**
	     * Removes default scopes from set of scopes
	     * Primarily used to prevent cache misses if the default scopes are not returned from the server
	     */
	    ScopeSet.prototype.removeOIDCScopes = function () {
	        var _this = this;
	        OIDC_SCOPES.forEach(function (defaultScope) {
	            _this.scopes.delete(defaultScope);
	        });
	    };
	    /**
	     * Combines an array of scopes with the current set of scopes.
	     * @param otherScopes
	     */
	    ScopeSet.prototype.unionScopeSets = function (otherScopes) {
	        if (!otherScopes) {
	            throw ClientAuthError.createEmptyInputScopeSetError();
	        }
	        var unionScopes = new Set(); // Iterator in constructor not supported in IE11
	        otherScopes.scopes.forEach(function (scope) { return unionScopes.add(scope.toLowerCase()); });
	        this.scopes.forEach(function (scope) { return unionScopes.add(scope.toLowerCase()); });
	        return unionScopes;
	    };
	    /**
	     * Check if scopes intersect between this set and another.
	     * @param otherScopes
	     */
	    ScopeSet.prototype.intersectingScopeSets = function (otherScopes) {
	        if (!otherScopes) {
	            throw ClientAuthError.createEmptyInputScopeSetError();
	        }
	        // Do not allow OIDC scopes to be the only intersecting scopes
	        if (!otherScopes.containsOnlyOIDCScopes()) {
	            otherScopes.removeOIDCScopes();
	        }
	        var unionScopes = this.unionScopeSets(otherScopes);
	        var sizeOtherScopes = otherScopes.getScopeCount();
	        var sizeThisScopes = this.getScopeCount();
	        var sizeUnionScopes = unionScopes.size;
	        return sizeUnionScopes < (sizeThisScopes + sizeOtherScopes);
	    };
	    /**
	     * Returns size of set of scopes.
	     */
	    ScopeSet.prototype.getScopeCount = function () {
	        return this.scopes.size;
	    };
	    /**
	     * Returns the scopes as an array of string values
	     */
	    ScopeSet.prototype.asArray = function () {
	        var array = [];
	        this.scopes.forEach(function (val) { return array.push(val); });
	        return array;
	    };
	    /**
	     * Prints scopes into a space-delimited string
	     */
	    ScopeSet.prototype.printScopes = function () {
	        if (this.scopes) {
	            var scopeArr = this.asArray();
	            return scopeArr.join(" ");
	        }
	        return Constants.EMPTY_STRING;
	    };
	    /**
	     * Prints scopes into a space-delimited lower-case string (used for caching)
	     */
	    ScopeSet.prototype.printScopesLowerCase = function () {
	        return this.printScopes().toLowerCase();
	    };
	    return ScopeSet;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Function to build a client info object from server clientInfo string
	 * @param rawClientInfo
	 * @param crypto
	 */
	function buildClientInfo(rawClientInfo, crypto) {
	    if (StringUtils.isEmpty(rawClientInfo)) {
	        throw ClientAuthError.createClientInfoEmptyError();
	    }
	    try {
	        var decodedClientInfo = crypto.base64Decode(rawClientInfo);
	        return JSON.parse(decodedClientInfo);
	    }
	    catch (e) {
	        throw ClientAuthError.createClientInfoDecodingError(e.message);
	    }
	}
	/**
	 * Function to build a client info object from cached homeAccountId string
	 * @param homeAccountId
	 */
	function buildClientInfoFromHomeAccountId(homeAccountId) {
	    if (StringUtils.isEmpty(homeAccountId)) {
	        throw ClientAuthError.createClientInfoDecodingError("Home account ID was empty.");
	    }
	    var clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
	    return {
	        uid: clientInfoParts[0],
	        utid: clientInfoParts.length < 2 ? Constants.EMPTY_STRING : clientInfoParts[1]
	    };
	}

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Authority types supported by MSAL.
	 */
	var AuthorityType;
	(function (AuthorityType) {
	    AuthorityType[AuthorityType["Default"] = 0] = "Default";
	    AuthorityType[AuthorityType["Adfs"] = 1] = "Adfs";
	    AuthorityType[AuthorityType["Dsts"] = 2] = "Dsts";
	    AuthorityType[AuthorityType["Ciam"] = 3] = "Ciam";
	})(AuthorityType || (AuthorityType = {}));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).
	 *
	 * Key : Value Schema
	 *
	 * Key: <home_account_id>-<environment>-<realm*>
	 *
	 * Value Schema:
	 * {
	 *      homeAccountId: home account identifier for the auth scheme,
	 *      environment: entity that issued the token, represented as a full host
	 *      realm: Full tenant or organizational identifier that the account belongs to
	 *      localAccountId: Original tenant-specific accountID, usually used for legacy cases
	 *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt
	 *      authorityType: Accounts authority type as a string
	 *      name: Full name for the account, including given name and family name,
	 *      clientInfo: Full base64 encoded client info received from ESTS
	 *      lastModificationTime: last time this entity was modified in the cache
	 *      lastModificationApp:
	 *      idTokenClaims: Object containing claims parsed from ID token
	 *      nativeAccountId: Account identifier on the native device
	 * }
	 */
	var AccountEntity = /** @class */ (function () {
	    function AccountEntity() {
	    }
	    /**
	     * Generate Account Id key component as per the schema: <home_account_id>-<environment>
	     */
	    AccountEntity.prototype.generateAccountId = function () {
	        var accountId = [this.homeAccountId, this.environment];
	        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
	    };
	    /**
	     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>
	     */
	    AccountEntity.prototype.generateAccountKey = function () {
	        return AccountEntity.generateAccountCacheKey({
	            homeAccountId: this.homeAccountId,
	            environment: this.environment,
	            tenantId: this.realm,
	            username: this.username,
	            localAccountId: this.localAccountId
	        });
	    };
	    /**
	     * returns the type of the cache (in this case account)
	     */
	    AccountEntity.prototype.generateType = function () {
	        switch (this.authorityType) {
	            case CacheAccountType.ADFS_ACCOUNT_TYPE:
	                return CacheType.ADFS;
	            case CacheAccountType.MSAV1_ACCOUNT_TYPE:
	                return CacheType.MSA;
	            case CacheAccountType.MSSTS_ACCOUNT_TYPE:
	                return CacheType.MSSTS;
	            case CacheAccountType.GENERIC_ACCOUNT_TYPE:
	                return CacheType.GENERIC;
	            default: {
	                throw ClientAuthError.createUnexpectedAccountTypeError();
	            }
	        }
	    };
	    /**
	     * Returns the AccountInfo interface for this account.
	     */
	    AccountEntity.prototype.getAccountInfo = function () {
	        return {
	            homeAccountId: this.homeAccountId,
	            environment: this.environment,
	            tenantId: this.realm,
	            username: this.username,
	            localAccountId: this.localAccountId,
	            name: this.name,
	            idTokenClaims: this.idTokenClaims,
	            nativeAccountId: this.nativeAccountId
	        };
	    };
	    /**
	     * Generates account key from interface
	     * @param accountInterface
	     */
	    AccountEntity.generateAccountCacheKey = function (accountInterface) {
	        var accountKey = [
	            accountInterface.homeAccountId,
	            accountInterface.environment || Constants.EMPTY_STRING,
	            accountInterface.tenantId || Constants.EMPTY_STRING,
	        ];
	        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
	    };
	    /**
	     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
	     * @param clientInfo
	     * @param authority
	     * @param idToken
	     * @param policy
	     */
	    AccountEntity.createAccount = function (clientInfo, homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {
	        var _a, _b, _c, _d, _e, _f;
	        var account = new AccountEntity();
	        account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
	        account.clientInfo = clientInfo;
	        account.homeAccountId = homeAccountId;
	        account.nativeAccountId = nativeAccountId;
	        var env = environment || (authority && authority.getPreferredCache());
	        if (!env) {
	            throw ClientAuthError.createInvalidCacheEnvironmentError();
	        }
	        account.environment = env;
	        // non AAD scenarios can have empty realm
	        account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || Constants.EMPTY_STRING;
	        if (idToken) {
	            account.idTokenClaims = idToken.claims;
	            // How do you account for MSA CID here?
	            account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants.EMPTY_STRING;
	            /*
	             * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.
	             * In most cases it will contain a single email. This field should not be relied upon if a custom
	             * policy is configured to return more than 1 email.
	             */
	            var preferredUsername = (_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username;
	            var email = ((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : null;
	            account.username = preferredUsername || email || Constants.EMPTY_STRING;
	            account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;
	        }
	        account.cloudGraphHostName = cloudGraphHostName;
	        account.msGraphHost = msGraphHost;
	        return account;
	    };
	    /**
	     * Builds non-AAD/ADFS account.
	     * @param authority
	     * @param idToken
	     */
	    AccountEntity.createGenericAccount = function (homeAccountId, idToken, authority, cloudGraphHostName, msGraphHost, environment) {
	        var _a, _b, _c, _d;
	        var account = new AccountEntity();
	        account.authorityType = (authority &&
	            authority.authorityType === AuthorityType.Adfs) ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;
	        account.homeAccountId = homeAccountId;
	        // non AAD scenarios can have empty realm
	        account.realm = Constants.EMPTY_STRING;
	        var env = environment || authority && authority.getPreferredCache();
	        if (!env) {
	            throw ClientAuthError.createInvalidCacheEnvironmentError();
	        }
	        if (idToken) {
	            // How do you account for MSA CID here?
	            account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || Constants.EMPTY_STRING;
	            // upn claim for most ADFS scenarios
	            account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants.EMPTY_STRING;
	            account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants.EMPTY_STRING;
	            account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;
	        }
	        account.environment = env;
	        account.cloudGraphHostName = cloudGraphHostName;
	        account.msGraphHost = msGraphHost;
	        /*
	         * add uniqueName to claims
	         * account.name = idToken.claims.uniqueName;
	         */
	        return account;
	    };
	    /**
	     * Generate HomeAccountId from server response
	     * @param serverClientInfo
	     * @param authType
	     */
	    AccountEntity.generateHomeAccountId = function (serverClientInfo, authType, logger, cryptoObj, idToken) {
	        var _a;
	        var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING;
	        // since ADFS does not have tid and does not set client_info
	        if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {
	            return accountId;
	        }
	        // for cases where there is clientInfo
	        if (serverClientInfo) {
	            try {
	                var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);
	                if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {
	                    return "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;
	                }
	            }
	            catch (e) { }
	        }
	        // default to "sub" claim
	        logger.verbose("No client info in response");
	        return accountId;
	    };
	    /**
	     * Validates an entity: checks for all expected params
	     * @param entity
	     */
	    AccountEntity.isAccountEntity = function (entity) {
	        if (!entity) {
	            return false;
	        }
	        return (entity.hasOwnProperty("homeAccountId") &&
	            entity.hasOwnProperty("environment") &&
	            entity.hasOwnProperty("realm") &&
	            entity.hasOwnProperty("localAccountId") &&
	            entity.hasOwnProperty("username") &&
	            entity.hasOwnProperty("authorityType"));
	    };
	    /**
	     * Helper function to determine whether 2 accountInfo objects represent the same account
	     * @param accountA
	     * @param accountB
	     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
	     */
	    AccountEntity.accountInfoIsEqual = function (accountA, accountB, compareClaims) {
	        if (!accountA || !accountB) {
	            return false;
	        }
	        var claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false
	        if (compareClaims) {
	            var accountAClaims = (accountA.idTokenClaims || {});
	            var accountBClaims = (accountB.idTokenClaims || {});
	            // issued at timestamp and nonce are expected to change each time a new id token is acquired
	            claimsMatch = (accountAClaims.iat === accountBClaims.iat) &&
	                (accountAClaims.nonce === accountBClaims.nonce);
	        }
	        return (accountA.homeAccountId === accountB.homeAccountId) &&
	            (accountA.localAccountId === accountB.localAccountId) &&
	            (accountA.username === accountB.username) &&
	            (accountA.tenantId === accountB.tenantId) &&
	            (accountA.environment === accountB.environment) &&
	            (accountA.nativeAccountId === accountB.nativeAccountId) &&
	            claimsMatch;
	    };
	    return AccountEntity;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * JWT Token representation class. Parses token string and generates claims object.
	 */
	var AuthToken = /** @class */ (function () {
	    function AuthToken(rawToken, crypto) {
	        if (StringUtils.isEmpty(rawToken)) {
	            throw ClientAuthError.createTokenNullOrEmptyError(rawToken);
	        }
	        this.rawToken = rawToken;
	        this.claims = AuthToken.extractTokenClaims(rawToken, crypto);
	    }
	    /**
	     * Extract token by decoding the rawToken
	     *
	     * @param encodedToken
	     */
	    AuthToken.extractTokenClaims = function (encodedToken, crypto) {
	        var decodedToken = StringUtils.decodeAuthToken(encodedToken);
	        // token will be decoded to get the username
	        try {
	            var base64TokenPayload = decodedToken.JWSPayload;
	            // base64Decode() should throw an error if there is an issue
	            var base64Decoded = crypto.base64Decode(base64TokenPayload);
	            return JSON.parse(base64Decoded);
	        }
	        catch (err) {
	            throw ClientAuthError.createTokenParsingError(err);
	        }
	    };
	    /**
	     * Determine if the token's max_age has transpired
	     */
	    AuthToken.checkMaxAge = function (authTime, maxAge) {
	        /*
	         * per https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
	         * To force an immediate re-authentication: If an app requires that a user re-authenticate prior to access,
	         * provide a value of 0 for the max_age parameter and the AS will force a fresh login.
	         */
	        var fiveMinuteSkew = 300000; // five minutes in milliseconds
	        if ((maxAge === 0) || ((Date.now() - fiveMinuteSkew) > (authTime + maxAge))) {
	            throw ClientAuthError.createMaxAgeTranspiredError();
	        }
	    };
	    return AuthToken;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.
	 */
	var CacheManager = /** @class */ (function () {
	    function CacheManager(clientId, cryptoImpl, logger) {
	        this.clientId = clientId;
	        this.cryptoImpl = cryptoImpl;
	        this.commonLogger = logger.clone(name$1, version$1);
	    }
	    /**
	     * Returns all accounts in cache
	     */
	    CacheManager.prototype.getAllAccounts = function () {
	        var _this = this;
	        var allAccountKeys = this.getAccountKeys();
	        if (allAccountKeys.length < 1) {
	            return [];
	        }
	        var accountEntities = allAccountKeys.reduce(function (accounts, key) {
	            var entity = _this.getAccount(key);
	            if (!entity) {
	                return accounts;
	            }
	            accounts.push(entity);
	            return accounts;
	        }, []);
	        if (accountEntities.length < 1) {
	            return [];
	        }
	        else {
	            var allAccounts = accountEntities.map(function (accountEntity) {
	                return _this.getAccountInfoFromEntity(accountEntity);
	            });
	            return allAccounts;
	        }
	    };
	    /**
	     * Gets accountInfo object based on provided filters
	     */
	    CacheManager.prototype.getAccountInfoFilteredBy = function (accountFilter) {
	        var allAccounts = this.getAccountsFilteredBy(accountFilter);
	        if (allAccounts.length > 0) {
	            return this.getAccountInfoFromEntity(allAccounts[0]);
	        }
	        else {
	            return null;
	        }
	    };
	    CacheManager.prototype.getAccountInfoFromEntity = function (accountEntity) {
	        var accountInfo = accountEntity.getAccountInfo();
	        var idToken = this.getIdToken(accountInfo);
	        if (idToken) {
	            accountInfo.idToken = idToken.secret;
	            accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;
	        }
	        return accountInfo;
	    };
	    /**
	     * saves a cache record
	     * @param cacheRecord
	     */
	    CacheManager.prototype.saveCacheRecord = function (cacheRecord) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!cacheRecord) {
	                            throw ClientAuthError.createNullOrUndefinedCacheRecord();
	                        }
	                        if (!!cacheRecord.account) {
	                            this.setAccount(cacheRecord.account);
	                        }
	                        if (!!cacheRecord.idToken) {
	                            this.setIdTokenCredential(cacheRecord.idToken);
	                        }
	                        if (!!!cacheRecord.accessToken) return [3 /*break*/, 2];
	                        return [4 /*yield*/, this.saveAccessToken(cacheRecord.accessToken)];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        if (!!cacheRecord.refreshToken) {
	                            this.setRefreshTokenCredential(cacheRecord.refreshToken);
	                        }
	                        if (!!cacheRecord.appMetadata) {
	                            this.setAppMetadata(cacheRecord.appMetadata);
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * saves access token credential
	     * @param credential
	     */
	    CacheManager.prototype.saveAccessToken = function (credential) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var accessTokenFilter, tokenKeys, currentScopes, removedAccessTokens;
	            var _this = this;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        accessTokenFilter = {
	                            clientId: credential.clientId,
	                            credentialType: credential.credentialType,
	                            environment: credential.environment,
	                            homeAccountId: credential.homeAccountId,
	                            realm: credential.realm,
	                            tokenType: credential.tokenType,
	                            requestedClaimsHash: credential.requestedClaimsHash
	                        };
	                        tokenKeys = this.getTokenKeys();
	                        currentScopes = ScopeSet.fromString(credential.target);
	                        removedAccessTokens = [];
	                        tokenKeys.accessToken.forEach(function (key) {
	                            if (!_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
	                                return;
	                            }
	                            var tokenEntity = _this.getAccessTokenCredential(key);
	                            if (tokenEntity && _this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
	                                var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
	                                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
	                                    removedAccessTokens.push(_this.removeAccessToken(key));
	                                }
	                            }
	                        });
	                        return [4 /*yield*/, Promise.all(removedAccessTokens)];
	                    case 1:
	                        _a.sent();
	                        this.setAccessTokenCredential(credential);
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * retrieve accounts matching all provided filters; if no filter is set, get all accounts
	     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
	     * @param homeAccountId
	     * @param environment
	     * @param realm
	     */
	    CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {
	        var _this = this;
	        var allAccountKeys = this.getAccountKeys();
	        var matchingAccounts = [];
	        allAccountKeys.forEach(function (cacheKey) {
	            if (!_this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.realm)) {
	                // Don't parse value if the key doesn't match the account filters
	                return;
	            }
	            var entity = _this.getAccount(cacheKey);
	            if (!entity) {
	                return;
	            }
	            if (!!accountFilter.homeAccountId && !_this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
	                return;
	            }
	            if (!!accountFilter.localAccountId && !_this.matchLocalAccountId(entity, accountFilter.localAccountId)) {
	                return;
	            }
	            if (!!accountFilter.username && !_this.matchUsername(entity, accountFilter.username)) {
	                return;
	            }
	            if (!!accountFilter.environment && !_this.matchEnvironment(entity, accountFilter.environment)) {
	                return;
	            }
	            if (!!accountFilter.realm && !_this.matchRealm(entity, accountFilter.realm)) {
	                return;
	            }
	            if (!!accountFilter.nativeAccountId && !_this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
	                return;
	            }
	            matchingAccounts.push(entity);
	        });
	        return matchingAccounts;
	    };
	    /**
	     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided
	     * @param key
	     * @param homeAccountId
	     * @param tenantId
	     * @returns
	     */
	    CacheManager.prototype.isAccountKey = function (key, homeAccountId, tenantId) {
	        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {
	            // Account cache keys contain 3 items separated by '-' (each item may also contain '-')
	            return false;
	        }
	        if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {
	            return false;
	        }
	        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {
	            return false;
	        }
	        // Do not check environment as aliasing can cause false negatives
	        return true;
	    };
	    /**
	     * Returns true if the given key matches our credential key schema.
	     * @param key
	     */
	    CacheManager.prototype.isCredentialKey = function (key) {
	        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {
	            // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')
	            return false;
	        }
	        var lowerCaseKey = key.toLowerCase();
	        // Credential keys must indicate what credential type they represent
	        if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 &&
	            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 &&
	            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 &&
	            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {
	            return false;
	        }
	        if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {
	            // Refresh tokens must contain the client id or family id
	            var clientIdValidation = "" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + this.clientId + Separators.CACHE_KEY_SEPARATOR;
	            var familyIdValidation = "" + CredentialType.REFRESH_TOKEN + Separators.CACHE_KEY_SEPARATOR + THE_FAMILY_ID + Separators.CACHE_KEY_SEPARATOR;
	            if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {
	                return false;
	            }
	        }
	        else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {
	            // Tokens must contain the clientId
	            return false;
	        }
	        return true;
	    };
	    /**
	     * Returns whether or not the given credential entity matches the filter
	     * @param entity
	     * @param filter
	     * @returns
	     */
	    CacheManager.prototype.credentialMatchesFilter = function (entity, filter) {
	        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
	            return false;
	        }
	        if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
	            return false;
	        }
	        /*
	         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of ""
	         * because we don't want a client_credential request to return a cached token that has a homeAccountId
	         */
	        if ((typeof filter.homeAccountId === "string") && !this.matchHomeAccountId(entity, filter.homeAccountId)) {
	            return false;
	        }
	        if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {
	            return false;
	        }
	        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
	            return false;
	        }
	        if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {
	            return false;
	        }
	        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
	            return false;
	        }
	        /*
	         * idTokens do not have "target", target specific refreshTokens do exist for some types of authentication
	         * Resource specific refresh tokens case will be added when the support is deemed necessary
	         */
	        if (!!filter.target && !this.matchTarget(entity, filter.target)) {
	            return false;
	        }
	        // If request OR cached entity has requested Claims Hash, check if they match
	        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
	            // Don't match if either is undefined or they are different
	            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
	                return false;
	            }
	        }
	        // Access Token with Auth Scheme specific matching
	        if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
	            if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {
	                return false;
	            }
	            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key
	            if (filter.tokenType === AuthenticationScheme.SSH) {
	                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    };
	    /**
	     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
	     * @param filter
	     */
	    CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {
	        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);
	    };
	    /**
	     * Support function to help match appMetadata
	     * @param environment
	     * @param clientId
	     */
	    CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {
	        var _this = this;
	        var allCacheKeys = this.getKeys();
	        var matchingAppMetadata = {};
	        allCacheKeys.forEach(function (cacheKey) {
	            // don't parse any non-appMetadata type cache entities
	            if (!_this.isAppMetadata(cacheKey)) {
	                return;
	            }
	            // Attempt retrieval
	            var entity = _this.getAppMetadata(cacheKey);
	            if (!entity) {
	                return;
	            }
	            if (!!environment && !_this.matchEnvironment(entity, environment)) {
	                return;
	            }
	            if (!!clientId && !_this.matchClientId(entity, clientId)) {
	                return;
	            }
	            matchingAppMetadata[cacheKey] = entity;
	        });
	        return matchingAppMetadata;
	    };
	    /**
	     * retrieve authorityMetadata that contains a matching alias
	     * @param filter
	     */
	    CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {
	        var _this = this;
	        var allCacheKeys = this.getAuthorityMetadataKeys();
	        var matchedEntity = null;
	        allCacheKeys.forEach(function (cacheKey) {
	            // don't parse any non-authorityMetadata type cache entities
	            if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {
	                return;
	            }
	            // Attempt retrieval
	            var entity = _this.getAuthorityMetadata(cacheKey);
	            if (!entity) {
	                return;
	            }
	            if (entity.aliases.indexOf(host) === -1) {
	                return;
	            }
	            matchedEntity = entity;
	        });
	        return matchedEntity;
	    };
	    /**
	     * Removes all accounts and related tokens from cache.
	     */
	    CacheManager.prototype.removeAllAccounts = function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var allAccountKeys, removedAccounts;
	            var _this = this;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        allAccountKeys = this.getAccountKeys();
	                        removedAccounts = [];
	                        allAccountKeys.forEach(function (cacheKey) {
	                            removedAccounts.push(_this.removeAccount(cacheKey));
	                        });
	                        return [4 /*yield*/, Promise.all(removedAccounts)];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Removes the account and related tokens for a given account key
	     * @param account
	     */
	    CacheManager.prototype.removeAccount = function (accountKey) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var account;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        account = this.getAccount(accountKey);
	                        if (!account) {
	                            throw ClientAuthError.createNoAccountFoundError();
	                        }
	                        return [4 /*yield*/, this.removeAccountContext(account)];
	                    case 1:
	                        _a.sent();
	                        this.removeItem(accountKey);
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Removes credentials associated with the provided account
	     * @param account
	     */
	    CacheManager.prototype.removeAccountContext = function (account) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var allTokenKeys, accountId, removedCredentials;
	            var _this = this;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        allTokenKeys = this.getTokenKeys();
	                        accountId = account.generateAccountId();
	                        removedCredentials = [];
	                        allTokenKeys.idToken.forEach(function (key) {
	                            if (key.indexOf(accountId) === 0) {
	                                _this.removeIdToken(key);
	                            }
	                        });
	                        allTokenKeys.accessToken.forEach(function (key) {
	                            if (key.indexOf(accountId) === 0) {
	                                removedCredentials.push(_this.removeAccessToken(key));
	                            }
	                        });
	                        allTokenKeys.refreshToken.forEach(function (key) {
	                            if (key.indexOf(accountId) === 0) {
	                                _this.removeRefreshToken(key);
	                            }
	                        });
	                        return [4 /*yield*/, Promise.all(removedCredentials)];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * returns a boolean if the given credential is removed
	     * @param credential
	     */
	    CacheManager.prototype.removeAccessToken = function (key) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var credential, accessTokenWithAuthSchemeEntity, kid;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        credential = this.getAccessTokenCredential(key);
	                        if (!credential) {
	                            return [2 /*return*/];
	                        }
	                        if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3 /*break*/, 4];
	                        if (!(credential.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 4];
	                        accessTokenWithAuthSchemeEntity = credential;
	                        kid = accessTokenWithAuthSchemeEntity.keyId;
	                        if (!kid) return [3 /*break*/, 4];
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.cryptoImpl.removeTokenBindingKey(kid)];
	                    case 2:
	                        _a.sent();
	                        return [3 /*break*/, 4];
	                    case 3:
	                        _a.sent();
	                        throw ClientAuthError.createBindingKeyNotRemovedError();
	                    case 4: return [2 /*return*/, this.removeItem(key)];
	                }
	            });
	        });
	    };
	    /**
	     * Removes all app metadata objects from cache.
	     */
	    CacheManager.prototype.removeAppMetadata = function () {
	        var _this = this;
	        var allCacheKeys = this.getKeys();
	        allCacheKeys.forEach(function (cacheKey) {
	            if (_this.isAppMetadata(cacheKey)) {
	                _this.removeItem(cacheKey);
	            }
	        });
	        return true;
	    };
	    /**
	     * Retrieve the cached credentials into a cacherecord
	     * @param account
	     * @param clientId
	     * @param scopes
	     * @param environment
	     * @param authScheme
	     */
	    CacheManager.prototype.readCacheRecord = function (account, request, environment) {
	        var tokenKeys = this.getTokenKeys();
	        var cachedAccount = this.readAccountFromCache(account);
	        var cachedIdToken = this.getIdToken(account, tokenKeys);
	        var cachedAccessToken = this.getAccessToken(account, request, tokenKeys);
	        var cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys);
	        var cachedAppMetadata = this.readAppMetadataFromCache(environment);
	        if (cachedAccount && cachedIdToken) {
	            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;
	        }
	        return {
	            account: cachedAccount,
	            idToken: cachedIdToken,
	            accessToken: cachedAccessToken,
	            refreshToken: cachedRefreshToken,
	            appMetadata: cachedAppMetadata,
	        };
	    };
	    /**
	     * Retrieve AccountEntity from cache
	     * @param account
	     */
	    CacheManager.prototype.readAccountFromCache = function (account) {
	        var accountKey = AccountEntity.generateAccountCacheKey(account);
	        return this.getAccount(accountKey);
	    };
	    /**
	     * Retrieve IdTokenEntity from cache
	     * @param clientId
	     * @param account
	     * @param inputRealm
	     */
	    CacheManager.prototype.getIdToken = function (account, tokenKeys) {
	        var _this = this;
	        this.commonLogger.trace("CacheManager - getIdToken called");
	        var idTokenFilter = {
	            homeAccountId: account.homeAccountId,
	            environment: account.environment,
	            credentialType: CredentialType.ID_TOKEN,
	            clientId: this.clientId,
	            realm: account.tenantId,
	        };
	        var idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);
	        var numIdTokens = idTokens.length;
	        if (numIdTokens < 1) {
	            this.commonLogger.info("CacheManager:getIdToken - No token found");
	            return null;
	        }
	        else if (numIdTokens > 1) {
	            this.commonLogger.info("CacheManager:getIdToken - Multiple id tokens found, clearing them");
	            idTokens.forEach(function (idToken) {
	                _this.removeIdToken(idToken.generateCredentialKey());
	            });
	            return null;
	        }
	        this.commonLogger.info("CacheManager:getIdToken - Returning id token");
	        return idTokens[0];
	    };
	    /**
	     * Gets all idTokens matching the given filter
	     * @param filter
	     * @returns
	     */
	    CacheManager.prototype.getIdTokensByFilter = function (filter, tokenKeys) {
	        var _this = this;
	        var idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;
	        var idTokens = [];
	        idTokenKeys.forEach(function (key) {
	            if (!_this.idTokenKeyMatchesFilter(key, __assign$4({ clientId: _this.clientId }, filter))) {
	                return;
	            }
	            var idToken = _this.getIdTokenCredential(key);
	            if (idToken && _this.credentialMatchesFilter(idToken, filter)) {
	                idTokens.push(idToken);
	            }
	        });
	        return idTokens;
	    };
	    /**
	     * Validate the cache key against filter before retrieving and parsing cache value
	     * @param key
	     * @param filter
	     * @returns
	     */
	    CacheManager.prototype.idTokenKeyMatchesFilter = function (inputKey, filter) {
	        var key = inputKey.toLowerCase();
	        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
	            return false;
	        }
	        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
	            return false;
	        }
	        return true;
	    };
	    /**
	     * Removes idToken from the cache
	     * @param key
	     */
	    CacheManager.prototype.removeIdToken = function (key) {
	        this.removeItem(key);
	    };
	    /**
	     * Removes refresh token from the cache
	     * @param key
	     */
	    CacheManager.prototype.removeRefreshToken = function (key) {
	        this.removeItem(key);
	    };
	    /**
	     * Retrieve AccessTokenEntity from cache
	     * @param clientId
	     * @param account
	     * @param scopes
	     * @param authScheme
	     */
	    CacheManager.prototype.getAccessToken = function (account, request, tokenKeys) {
	        var _this = this;
	        this.commonLogger.trace("CacheManager - getAccessToken called");
	        var scopes = ScopeSet.createSearchScopes(request.scopes);
	        var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
	        /*
	         * Distinguish between Bearer and PoP/SSH token cache types
	         * Cast to lowercase to handle "bearer" from ADFS
	         */
	        var credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;
	        var accessTokenFilter = {
	            homeAccountId: account.homeAccountId,
	            environment: account.environment,
	            credentialType: credentialType,
	            clientId: this.clientId,
	            realm: account.tenantId,
	            target: scopes,
	            tokenType: authScheme,
	            keyId: request.sshKid,
	            requestedClaimsHash: request.requestedClaimsHash,
	        };
	        var accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;
	        var accessTokens = [];
	        accessTokenKeys.forEach(function (key) {
	            // Validate key
	            if (_this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
	                var accessToken = _this.getAccessTokenCredential(key);
	                // Validate value
	                if (accessToken && _this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
	                    accessTokens.push(accessToken);
	                }
	            }
	        });
	        var numAccessTokens = accessTokens.length;
	        if (numAccessTokens < 1) {
	            this.commonLogger.info("CacheManager:getAccessToken - No token found");
	            return null;
	        }
	        else if (numAccessTokens > 1) {
	            this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them");
	            accessTokens.forEach(function (accessToken) {
	                _this.removeAccessToken(accessToken.generateCredentialKey());
	            });
	            return null;
	        }
	        this.commonLogger.info("CacheManager:getAccessToken - Returning access token");
	        return accessTokens[0];
	    };
	    /**
	     * Validate the cache key against filter before retrieving and parsing cache value
	     * @param key
	     * @param filter
	     * @param keyMustContainAllScopes
	     * @returns
	     */
	    CacheManager.prototype.accessTokenKeyMatchesFilter = function (inputKey, filter, keyMustContainAllScopes) {
	        var key = inputKey.toLowerCase();
	        if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
	            return false;
	        }
	        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
	            return false;
	        }
	        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
	            return false;
	        }
	        if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
	            return false;
	        }
	        if (filter.target) {
	            var scopes = filter.target.asArray();
	            for (var i = 0; i < scopes.length; i++) {
	                if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {
	                    // When performing a cache lookup a missing scope would be a cache miss
	                    return false;
	                }
	                else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {
	                    // When performing a cache write, any token with a subset of requested scopes should be replaced
	                    return true;
	                }
	            }
	        }
	        return true;
	    };
	    /**
	     * Gets all access tokens matching the filter
	     * @param filter
	     * @returns
	     */
	    CacheManager.prototype.getAccessTokensByFilter = function (filter) {
	        var _this = this;
	        var tokenKeys = this.getTokenKeys();
	        var accessTokens = [];
	        tokenKeys.accessToken.forEach(function (key) {
	            if (!_this.accessTokenKeyMatchesFilter(key, filter, true)) {
	                return;
	            }
	            var accessToken = _this.getAccessTokenCredential(key);
	            if (accessToken && _this.credentialMatchesFilter(accessToken, filter)) {
	                accessTokens.push(accessToken);
	            }
	        });
	        return accessTokens;
	    };
	    /**
	     * Helper to retrieve the appropriate refresh token from cache
	     * @param clientId
	     * @param account
	     * @param familyRT
	     */
	    CacheManager.prototype.getRefreshToken = function (account, familyRT, tokenKeys) {
	        var _this = this;
	        this.commonLogger.trace("CacheManager - getRefreshToken called");
	        var id = familyRT ? THE_FAMILY_ID : undefined;
	        var refreshTokenFilter = {
	            homeAccountId: account.homeAccountId,
	            environment: account.environment,
	            credentialType: CredentialType.REFRESH_TOKEN,
	            clientId: this.clientId,
	            familyId: id,
	        };
	        var refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;
	        var refreshTokens = [];
	        refreshTokenKeys.forEach(function (key) {
	            // Validate key
	            if (_this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
	                var refreshToken = _this.getRefreshTokenCredential(key);
	                // Validate value
	                if (refreshToken && _this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
	                    refreshTokens.push(refreshToken);
	                }
	            }
	        });
	        var numRefreshTokens = refreshTokens.length;
	        if (numRefreshTokens < 1) {
	            this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
	            return null;
	        }
	        // address the else case after remove functions address environment aliases
	        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
	        return refreshTokens[0];
	    };
	    /**
	     * Validate the cache key against filter before retrieving and parsing cache value
	     * @param key
	     * @param filter
	     */
	    CacheManager.prototype.refreshTokenKeyMatchesFilter = function (inputKey, filter) {
	        var key = inputKey.toLowerCase();
	        if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {
	            return false;
	        }
	        // If familyId is used, clientId is not in the key
	        if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {
	            return false;
	        }
	        if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
	            return false;
	        }
	        return true;
	    };
	    /**
	     * Retrieve AppMetadataEntity from cache
	     */
	    CacheManager.prototype.readAppMetadataFromCache = function (environment) {
	        var appMetadataFilter = {
	            environment: environment,
	            clientId: this.clientId,
	        };
	        var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
	        var appMetadataEntries = Object.keys(appMetadata).map(function (key) { return appMetadata[key]; });
	        var numAppMetadata = appMetadataEntries.length;
	        if (numAppMetadata < 1) {
	            return null;
	        }
	        else if (numAppMetadata > 1) {
	            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();
	        }
	        return appMetadataEntries[0];
	    };
	    /**
	     * Return the family_id value associated  with FOCI
	     * @param environment
	     * @param clientId
	     */
	    CacheManager.prototype.isAppMetadataFOCI = function (environment) {
	        var appMetadata = this.readAppMetadataFromCache(environment);
	        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
	    };
	    /**
	     * helper to match account ids
	     * @param value
	     * @param homeAccountId
	     */
	    CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {
	        return !!((typeof entity.homeAccountId === "string") && (homeAccountId === entity.homeAccountId));
	    };
	    /**
	     * helper to match account ids
	     * @param entity
	     * @param localAccountId
	     * @returns
	     */
	    CacheManager.prototype.matchLocalAccountId = function (entity, localAccountId) {
	        return !!((typeof entity.localAccountId === "string") && (localAccountId === entity.localAccountId));
	    };
	    /**
	     * helper to match usernames
	     * @param entity
	     * @param username
	     * @returns
	     */
	    CacheManager.prototype.matchUsername = function (entity, username) {
	        return !!((typeof entity.username === "string") && (username.toLowerCase() === entity.username.toLowerCase()));
	    };
	    /**
	     * helper to match assertion
	     * @param value
	     * @param oboAssertion
	     */
	    CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {
	        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);
	    };
	    /**
	     * helper to match environment
	     * @param value
	     * @param environment
	     */
	    CacheManager.prototype.matchEnvironment = function (entity, environment) {
	        var cloudMetadata = this.getAuthorityMetadataByAlias(environment);
	        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {
	            return true;
	        }
	        return false;
	    };
	    /**
	     * helper to match credential type
	     * @param entity
	     * @param credentialType
	     */
	    CacheManager.prototype.matchCredentialType = function (entity, credentialType) {
	        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());
	    };
	    /**
	     * helper to match client ids
	     * @param entity
	     * @param clientId
	     */
	    CacheManager.prototype.matchClientId = function (entity, clientId) {
	        return !!(entity.clientId && clientId === entity.clientId);
	    };
	    /**
	     * helper to match family ids
	     * @param entity
	     * @param familyId
	     */
	    CacheManager.prototype.matchFamilyId = function (entity, familyId) {
	        return !!(entity.familyId && familyId === entity.familyId);
	    };
	    /**
	     * helper to match realm
	     * @param entity
	     * @param realm
	     */
	    CacheManager.prototype.matchRealm = function (entity, realm) {
	        return !!(entity.realm && realm === entity.realm);
	    };
	    /**
	     * helper to match nativeAccountId
	     * @param entity
	     * @param nativeAccountId
	     * @returns boolean indicating the match result
	     */
	    CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {
	        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
	    };
	    /**
	     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
	     * @param entity
	     * @param target
	     */
	    CacheManager.prototype.matchTarget = function (entity, target) {
	        var isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);
	        if (isNotAccessTokenCredential || !entity.target) {
	            return false;
	        }
	        var entityScopeSet = ScopeSet.fromString(entity.target);
	        return entityScopeSet.containsScopeSet(target);
	    };
	    /**
	     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
	     * @param entity
	     * @param tokenType
	     */
	    CacheManager.prototype.matchTokenType = function (entity, tokenType) {
	        return !!(entity.tokenType && entity.tokenType === tokenType);
	    };
	    /**
	     * Returns true if the credential's keyId matches the one in the request, false otherwise
	     * @param entity
	     * @param tokenType
	     */
	    CacheManager.prototype.matchKeyId = function (entity, keyId) {
	        return !!(entity.keyId && entity.keyId === keyId);
	    };
	    /**
	     * returns if a given cache entity is of the type appmetadata
	     * @param key
	     */
	    CacheManager.prototype.isAppMetadata = function (key) {
	        return key.indexOf(APP_METADATA) !== -1;
	    };
	    /**
	     * returns if a given cache entity is of the type authoritymetadata
	     * @param key
	     */
	    CacheManager.prototype.isAuthorityMetadata = function (key) {
	        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
	    };
	    /**
	     * returns cache key used for cloud instance metadata
	     */
	    CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {
	        return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + "-" + this.clientId + "-" + authority;
	    };
	    /**
	     * Helper to convert serialized data to object
	     * @param obj
	     * @param json
	     */
	    CacheManager.toObject = function (obj, json) {
	        for (var propertyName in json) {
	            obj[propertyName] = json[propertyName];
	        }
	        return obj;
	    };
	    return CacheManager;
	}());
	var DefaultStorageClass = /** @class */ (function (_super) {
	    __extends$f(DefaultStorageClass, _super);
	    function DefaultStorageClass() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    DefaultStorageClass.prototype.setAccount = function () {
	        var notImplErr = "Storage interface - setAccount() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getAccount = function () {
	        var notImplErr = "Storage interface - getAccount() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.setIdTokenCredential = function () {
	        var notImplErr = "Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getIdTokenCredential = function () {
	        var notImplErr = "Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.setAccessTokenCredential = function () {
	        var notImplErr = "Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getAccessTokenCredential = function () {
	        var notImplErr = "Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.setRefreshTokenCredential = function () {
	        var notImplErr = "Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getRefreshTokenCredential = function () {
	        var notImplErr = "Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.setAppMetadata = function () {
	        var notImplErr = "Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getAppMetadata = function () {
	        var notImplErr = "Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.setServerTelemetry = function () {
	        var notImplErr = "Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getServerTelemetry = function () {
	        var notImplErr = "Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.setAuthorityMetadata = function () {
	        var notImplErr = "Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getAuthorityMetadata = function () {
	        var notImplErr = "Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {
	        var notImplErr = "Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.setThrottlingCache = function () {
	        var notImplErr = "Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getThrottlingCache = function () {
	        var notImplErr = "Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.removeItem = function () {
	        var notImplErr = "Storage interface - removeItem() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.containsKey = function () {
	        var notImplErr = "Storage interface - containsKey() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getKeys = function () {
	        var notImplErr = "Storage interface - getKeys() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getAccountKeys = function () {
	        var notImplErr = "Storage interface - getAccountKeys() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.getTokenKeys = function () {
	        var notImplErr = "Storage interface - getTokenKeys() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    DefaultStorageClass.prototype.clear = function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Storage interface - clear() has not been implemented for the cacheStorage interface.";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    };
	    DefaultStorageClass.prototype.updateCredentialCacheKey = function () {
	        var notImplErr = "Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.";
	        throw AuthError.createUnexpectedError(notImplErr);
	    };
	    return DefaultStorageClass;
	}(CacheManager));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	// Token renewal offset default in seconds
	var DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
	var DEFAULT_SYSTEM_OPTIONS = {
	    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
	    preventCorsPreflight: false
	};
	var DEFAULT_LOGGER_IMPLEMENTATION = {
	    loggerCallback: function () {
	        // allow users to not set loggerCallback
	    },
	    piiLoggingEnabled: false,
	    logLevel: LogLevel.Info,
	    correlationId: Constants.EMPTY_STRING
	};
	var DEFAULT_CACHE_OPTIONS = {
	    claimsBasedCachingEnabled: true
	};
	var DEFAULT_NETWORK_IMPLEMENTATION = {
	    sendGetRequestAsync: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Network interface - sendGetRequestAsync() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    },
	    sendPostRequestAsync: function () {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var notImplErr;
	            return __generator$2(this, function (_a) {
	                notImplErr = "Network interface - sendPostRequestAsync() has not been implemented";
	                throw AuthError.createUnexpectedError(notImplErr);
	            });
	        });
	    }
	};
	var DEFAULT_LIBRARY_INFO = {
	    sku: Constants.SKU,
	    version: version$1,
	    cpu: Constants.EMPTY_STRING,
	    os: Constants.EMPTY_STRING
	};
	var DEFAULT_CLIENT_CREDENTIALS = {
	    clientSecret: Constants.EMPTY_STRING,
	    clientAssertion: undefined
	};
	var DEFAULT_AZURE_CLOUD_OPTIONS = {
	    azureCloudInstance: AzureCloudInstance.None,
	    tenant: "" + Constants.DEFAULT_COMMON_TENANT
	};
	var DEFAULT_TELEMETRY_OPTIONS = {
	    application: {
	        appName: "",
	        appVersion: ""
	    }
	};
	/**
	 * Function that sets the default options when not explicitly configured from app developer
	 *
	 * @param Configuration
	 *
	 * @returns Configuration
	 */
	function buildClientConfiguration(_a) {
	    var userAuthOptions = _a.authOptions, userSystemOptions = _a.systemOptions, userLoggerOption = _a.loggerOptions, userCacheOptions = _a.cacheOptions, storageImplementation = _a.storageInterface, networkImplementation = _a.networkInterface, cryptoImplementation = _a.cryptoInterface, clientCredentials = _a.clientCredentials, libraryInfo = _a.libraryInfo, telemetry = _a.telemetry, serverTelemetryManager = _a.serverTelemetryManager, persistencePlugin = _a.persistencePlugin, serializableCache = _a.serializableCache;
	    var loggerOptions = __assign$4(__assign$4({}, DEFAULT_LOGGER_IMPLEMENTATION), userLoggerOption);
	    return {
	        authOptions: buildAuthOptions(userAuthOptions),
	        systemOptions: __assign$4(__assign$4({}, DEFAULT_SYSTEM_OPTIONS), userSystemOptions),
	        loggerOptions: loggerOptions,
	        cacheOptions: __assign$4(__assign$4({}, DEFAULT_CACHE_OPTIONS), userCacheOptions),
	        storageInterface: storageImplementation || new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions)),
	        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
	        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
	        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
	        libraryInfo: __assign$4(__assign$4({}, DEFAULT_LIBRARY_INFO), libraryInfo),
	        telemetry: __assign$4(__assign$4({}, DEFAULT_TELEMETRY_OPTIONS), telemetry),
	        serverTelemetryManager: serverTelemetryManager || null,
	        persistencePlugin: persistencePlugin || null,
	        serializableCache: serializableCache || null,
	    };
	}
	/**
	 * Construct authoptions from the client and platform passed values
	 * @param authOptions
	 */
	function buildAuthOptions(authOptions) {
	    return __assign$4({ clientCapabilities: [], azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS, skipAuthorityMetadataCache: false }, authOptions);
	}

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Error thrown when there is an error with the server code, for example, unavailability.
	 */
	var ServerError = /** @class */ (function (_super) {
	    __extends$f(ServerError, _super);
	    function ServerError(errorCode, errorMessage, subError) {
	        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
	        _this.name = "ServerError";
	        Object.setPrototypeOf(_this, ServerError.prototype);
	        return _this;
	    }
	    return ServerError;
	}(AuthError));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var ThrottlingUtils = /** @class */ (function () {
	    function ThrottlingUtils() {
	    }
	    /**
	     * Prepares a RequestThumbprint to be stored as a key.
	     * @param thumbprint
	     */
	    ThrottlingUtils.generateThrottlingStorageKey = function (thumbprint) {
	        return ThrottlingConstants.THROTTLING_PREFIX + "." + JSON.stringify(thumbprint);
	    };
	    /**
	     * Performs necessary throttling checks before a network request.
	     * @param cacheManager
	     * @param thumbprint
	     */
	    ThrottlingUtils.preProcess = function (cacheManager, thumbprint) {
	        var _a;
	        var key = ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
	        var value = cacheManager.getThrottlingCache(key);
	        if (value) {
	            if (value.throttleTime < Date.now()) {
	                cacheManager.removeItem(key);
	                return;
	            }
	            throw new ServerError(((_a = value.errorCodes) === null || _a === void 0 ? void 0 : _a.join(" ")) || Constants.EMPTY_STRING, value.errorMessage, value.subError);
	        }
	    };
	    /**
	     * Performs necessary throttling checks after a network request.
	     * @param cacheManager
	     * @param thumbprint
	     * @param response
	     */
	    ThrottlingUtils.postProcess = function (cacheManager, thumbprint, response) {
	        if (ThrottlingUtils.checkResponseStatus(response) || ThrottlingUtils.checkResponseForRetryAfter(response)) {
	            var thumbprintValue = {
	                throttleTime: ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
	                error: response.body.error,
	                errorCodes: response.body.error_codes,
	                errorMessage: response.body.error_description,
	                subError: response.body.suberror
	            };
	            cacheManager.setThrottlingCache(ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue);
	        }
	    };
	    /**
	     * Checks a NetworkResponse object's status codes against 429 or 5xx
	     * @param response
	     */
	    ThrottlingUtils.checkResponseStatus = function (response) {
	        return response.status === 429 || response.status >= 500 && response.status < 600;
	    };
	    /**
	     * Checks a NetworkResponse object's RetryAfter header
	     * @param response
	     */
	    ThrottlingUtils.checkResponseForRetryAfter = function (response) {
	        if (response.headers) {
	            return response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) && (response.status < 200 || response.status >= 300);
	        }
	        return false;
	    };
	    /**
	     * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
	     * @param throttleTime
	     */
	    ThrottlingUtils.calculateThrottleTime = function (throttleTime) {
	        var time = throttleTime <= 0 ? 0 : throttleTime;
	        var currentSeconds = Date.now() / 1000;
	        return Math.floor(Math.min(currentSeconds + (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds + ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1000);
	    };
	    ThrottlingUtils.removeThrottle = function (cacheManager, clientId, request, homeAccountIdentifier) {
	        var thumbprint = {
	            clientId: clientId,
	            authority: request.authority,
	            scopes: request.scopes,
	            homeAccountIdentifier: homeAccountIdentifier,
	            claims: request.claims,
	            authenticationScheme: request.authenticationScheme,
	            resourceRequestMethod: request.resourceRequestMethod,
	            resourceRequestUri: request.resourceRequestUri,
	            shrClaims: request.shrClaims,
	            sshKid: request.sshKid
	        };
	        var key = this.generateThrottlingStorageKey(thumbprint);
	        cacheManager.removeItem(key);
	    };
	    return ThrottlingUtils;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var NetworkManager = /** @class */ (function () {
	    function NetworkManager(networkClient, cacheManager) {
	        this.networkClient = networkClient;
	        this.cacheManager = cacheManager;
	    }
	    /**
	     * Wraps sendPostRequestAsync with necessary preflight and postflight logic
	     * @param thumbprint
	     * @param tokenEndpoint
	     * @param options
	     */
	    NetworkManager.prototype.sendPostRequest = function (thumbprint, tokenEndpoint, options) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var response, e_1;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        ThrottlingUtils.preProcess(this.cacheManager, thumbprint);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.networkClient.sendPostRequestAsync(tokenEndpoint, options)];
	                    case 2:
	                        response = _a.sent();
	                        return [3 /*break*/, 4];
	                    case 3:
	                        e_1 = _a.sent();
	                        if (e_1 instanceof AuthError) {
	                            throw e_1;
	                        }
	                        else {
	                            throw ClientAuthError.createNetworkError(tokenEndpoint, e_1);
	                        }
	                    case 4:
	                        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response);
	                        return [2 /*return*/, response];
	                }
	            });
	        });
	    };
	    return NetworkManager;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var CcsCredentialType;
	(function (CcsCredentialType) {
	    CcsCredentialType["HOME_ACCOUNT_ID"] = "home_account_id";
	    CcsCredentialType["UPN"] = "UPN";
	})(CcsCredentialType || (CcsCredentialType = {}));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Validates server consumable params from the "request" objects
	 */
	var RequestValidator = /** @class */ (function () {
	    function RequestValidator() {
	    }
	    /**
	     * Utility to check if the `redirectUri` in the request is a non-null value
	     * @param redirectUri
	     */
	    RequestValidator.validateRedirectUri = function (redirectUri) {
	        if (StringUtils.isEmpty(redirectUri)) {
	            throw ClientConfigurationError.createRedirectUriEmptyError();
	        }
	    };
	    /**
	     * Utility to validate prompt sent by the user in the request
	     * @param prompt
	     */
	    RequestValidator.validatePrompt = function (prompt) {
	        var promptValues = [];
	        for (var value in PromptValue) {
	            promptValues.push(PromptValue[value]);
	        }
	        if (promptValues.indexOf(prompt) < 0) {
	            throw ClientConfigurationError.createInvalidPromptError(prompt);
	        }
	    };
	    RequestValidator.validateClaims = function (claims) {
	        try {
	            JSON.parse(claims);
	        }
	        catch (e) {
	            throw ClientConfigurationError.createInvalidClaimsRequestError();
	        }
	    };
	    /**
	     * Utility to validate code_challenge and code_challenge_method
	     * @param codeChallenge
	     * @param codeChallengeMethod
	     */
	    RequestValidator.validateCodeChallengeParams = function (codeChallenge, codeChallengeMethod) {
	        if (StringUtils.isEmpty(codeChallenge) || StringUtils.isEmpty(codeChallengeMethod)) {
	            throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
	        }
	        else {
	            this.validateCodeChallengeMethod(codeChallengeMethod);
	        }
	    };
	    /**
	     * Utility to validate code_challenge_method
	     * @param codeChallengeMethod
	     */
	    RequestValidator.validateCodeChallengeMethod = function (codeChallengeMethod) {
	        if ([
	            CodeChallengeMethodValues.PLAIN,
	            CodeChallengeMethodValues.S256
	        ].indexOf(codeChallengeMethod) < 0) {
	            throw ClientConfigurationError.createInvalidCodeChallengeMethodError();
	        }
	    };
	    /**
	     * Removes unnecessary, duplicate, and empty string query parameters from extraQueryParameters
	     * @param request
	     */
	    RequestValidator.sanitizeEQParams = function (eQParams, queryParams) {
	        if (!eQParams) {
	            return {};
	        }
	        // Remove any query parameters already included in SSO params
	        queryParams.forEach(function (value, key) {
	            if (eQParams[key]) {
	                delete eQParams[key];
	            }
	        });
	        // remove empty string parameters
	        // eslint-disable-next-line @typescript-eslint/no-unused-vars
	        return Object.fromEntries(Object.entries(eQParams).filter(function (_a) {
	            var value = _a[1];
	            return value !== "";
	        }));
	    };
	    return RequestValidator;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var RequestParameterBuilder = /** @class */ (function () {
	    function RequestParameterBuilder() {
	        this.parameters = new Map();
	    }
	    /**
	     * add response_type = code
	     */
	    RequestParameterBuilder.prototype.addResponseTypeCode = function () {
	        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.CODE_RESPONSE_TYPE));
	    };
	    /**
	     * add response_type = token id_token
	     */
	    RequestParameterBuilder.prototype.addResponseTypeForTokenAndIdToken = function () {
	        this.parameters.set(AADServerParamKeys.RESPONSE_TYPE, encodeURIComponent(Constants.TOKEN_RESPONSE_TYPE + " " + Constants.ID_TOKEN_RESPONSE_TYPE));
	    };
	    /**
	     * add response_mode. defaults to query.
	     * @param responseMode
	     */
	    RequestParameterBuilder.prototype.addResponseMode = function (responseMode) {
	        this.parameters.set(AADServerParamKeys.RESPONSE_MODE, encodeURIComponent((responseMode) ? responseMode : ResponseMode.QUERY));
	    };
	    /**
	     * Add flag to indicate STS should attempt to use WAM if available
	     */
	    RequestParameterBuilder.prototype.addNativeBroker = function () {
	        this.parameters.set(AADServerParamKeys.NATIVE_BROKER, encodeURIComponent("1"));
	    };
	    /**
	     * add scopes. set addOidcScopes to false to prevent default scopes in non-user scenarios
	     * @param scopeSet
	     * @param addOidcScopes
	     */
	    RequestParameterBuilder.prototype.addScopes = function (scopes, addOidcScopes) {
	        if (addOidcScopes === void 0) { addOidcScopes = true; }
	        var requestScopes = addOidcScopes ? __spreadArrays(scopes || [], OIDC_DEFAULT_SCOPES) : scopes || [];
	        var scopeSet = new ScopeSet(requestScopes);
	        this.parameters.set(AADServerParamKeys.SCOPE, encodeURIComponent(scopeSet.printScopes()));
	    };
	    /**
	     * add clientId
	     * @param clientId
	     */
	    RequestParameterBuilder.prototype.addClientId = function (clientId) {
	        this.parameters.set(AADServerParamKeys.CLIENT_ID, encodeURIComponent(clientId));
	    };
	    /**
	     * add redirect_uri
	     * @param redirectUri
	     */
	    RequestParameterBuilder.prototype.addRedirectUri = function (redirectUri) {
	        RequestValidator.validateRedirectUri(redirectUri);
	        this.parameters.set(AADServerParamKeys.REDIRECT_URI, encodeURIComponent(redirectUri));
	    };
	    /**
	     * add post logout redirectUri
	     * @param redirectUri
	     */
	    RequestParameterBuilder.prototype.addPostLogoutRedirectUri = function (redirectUri) {
	        RequestValidator.validateRedirectUri(redirectUri);
	        this.parameters.set(AADServerParamKeys.POST_LOGOUT_URI, encodeURIComponent(redirectUri));
	    };
	    /**
	     * add id_token_hint to logout request
	     * @param idTokenHint
	     */
	    RequestParameterBuilder.prototype.addIdTokenHint = function (idTokenHint) {
	        this.parameters.set(AADServerParamKeys.ID_TOKEN_HINT, encodeURIComponent(idTokenHint));
	    };
	    /**
	     * add domain_hint
	     * @param domainHint
	     */
	    RequestParameterBuilder.prototype.addDomainHint = function (domainHint) {
	        this.parameters.set(SSOTypes.DOMAIN_HINT, encodeURIComponent(domainHint));
	    };
	    /**
	     * add login_hint
	     * @param loginHint
	     */
	    RequestParameterBuilder.prototype.addLoginHint = function (loginHint) {
	        this.parameters.set(SSOTypes.LOGIN_HINT, encodeURIComponent(loginHint));
	    };
	    /**
	     * Adds the CCS (Cache Credential Service) query parameter for login_hint
	     * @param loginHint
	     */
	    RequestParameterBuilder.prototype.addCcsUpn = function (loginHint) {
	        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("UPN:" + loginHint));
	    };
	    /**
	     * Adds the CCS (Cache Credential Service) query parameter for account object
	     * @param loginHint
	     */
	    RequestParameterBuilder.prototype.addCcsOid = function (clientInfo) {
	        this.parameters.set(HeaderNames.CCS_HEADER, encodeURIComponent("Oid:" + clientInfo.uid + "@" + clientInfo.utid));
	    };
	    /**
	     * add sid
	     * @param sid
	     */
	    RequestParameterBuilder.prototype.addSid = function (sid) {
	        this.parameters.set(SSOTypes.SID, encodeURIComponent(sid));
	    };
	    /**
	     * add claims
	     * @param claims
	     */
	    RequestParameterBuilder.prototype.addClaims = function (claims, clientCapabilities) {
	        var mergedClaims = this.addClientCapabilitiesToClaims(claims, clientCapabilities);
	        RequestValidator.validateClaims(mergedClaims);
	        this.parameters.set(AADServerParamKeys.CLAIMS, encodeURIComponent(mergedClaims));
	    };
	    /**
	     * add correlationId
	     * @param correlationId
	     */
	    RequestParameterBuilder.prototype.addCorrelationId = function (correlationId) {
	        this.parameters.set(AADServerParamKeys.CLIENT_REQUEST_ID, encodeURIComponent(correlationId));
	    };
	    /**
	     * add library info query params
	     * @param libraryInfo
	     */
	    RequestParameterBuilder.prototype.addLibraryInfo = function (libraryInfo) {
	        // Telemetry Info
	        this.parameters.set(AADServerParamKeys.X_CLIENT_SKU, libraryInfo.sku);
	        this.parameters.set(AADServerParamKeys.X_CLIENT_VER, libraryInfo.version);
	        if (libraryInfo.os) {
	            this.parameters.set(AADServerParamKeys.X_CLIENT_OS, libraryInfo.os);
	        }
	        if (libraryInfo.cpu) {
	            this.parameters.set(AADServerParamKeys.X_CLIENT_CPU, libraryInfo.cpu);
	        }
	    };
	    /**
	     * Add client telemetry parameters
	     * @param appTelemetry
	     */
	    RequestParameterBuilder.prototype.addApplicationTelemetry = function (appTelemetry) {
	        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appName) {
	            this.parameters.set(AADServerParamKeys.X_APP_NAME, appTelemetry.appName);
	        }
	        if (appTelemetry === null || appTelemetry === void 0 ? void 0 : appTelemetry.appVersion) {
	            this.parameters.set(AADServerParamKeys.X_APP_VER, appTelemetry.appVersion);
	        }
	    };
	    /**
	     * add prompt
	     * @param prompt
	     */
	    RequestParameterBuilder.prototype.addPrompt = function (prompt) {
	        RequestValidator.validatePrompt(prompt);
	        this.parameters.set("" + AADServerParamKeys.PROMPT, encodeURIComponent(prompt));
	    };
	    /**
	     * add state
	     * @param state
	     */
	    RequestParameterBuilder.prototype.addState = function (state) {
	        if (!StringUtils.isEmpty(state)) {
	            this.parameters.set(AADServerParamKeys.STATE, encodeURIComponent(state));
	        }
	    };
	    /**
	     * add nonce
	     * @param nonce
	     */
	    RequestParameterBuilder.prototype.addNonce = function (nonce) {
	        this.parameters.set(AADServerParamKeys.NONCE, encodeURIComponent(nonce));
	    };
	    /**
	     * add code_challenge and code_challenge_method
	     * - throw if either of them are not passed
	     * @param codeChallenge
	     * @param codeChallengeMethod
	     */
	    RequestParameterBuilder.prototype.addCodeChallengeParams = function (codeChallenge, codeChallengeMethod) {
	        RequestValidator.validateCodeChallengeParams(codeChallenge, codeChallengeMethod);
	        if (codeChallenge && codeChallengeMethod) {
	            this.parameters.set(AADServerParamKeys.CODE_CHALLENGE, encodeURIComponent(codeChallenge));
	            this.parameters.set(AADServerParamKeys.CODE_CHALLENGE_METHOD, encodeURIComponent(codeChallengeMethod));
	        }
	        else {
	            throw ClientConfigurationError.createInvalidCodeChallengeParamsError();
	        }
	    };
	    /**
	     * add the `authorization_code` passed by the user to exchange for a token
	     * @param code
	     */
	    RequestParameterBuilder.prototype.addAuthorizationCode = function (code) {
	        this.parameters.set(AADServerParamKeys.CODE, encodeURIComponent(code));
	    };
	    /**
	     * add the `authorization_code` passed by the user to exchange for a token
	     * @param code
	     */
	    RequestParameterBuilder.prototype.addDeviceCode = function (code) {
	        this.parameters.set(AADServerParamKeys.DEVICE_CODE, encodeURIComponent(code));
	    };
	    /**
	     * add the `refreshToken` passed by the user
	     * @param refreshToken
	     */
	    RequestParameterBuilder.prototype.addRefreshToken = function (refreshToken) {
	        this.parameters.set(AADServerParamKeys.REFRESH_TOKEN, encodeURIComponent(refreshToken));
	    };
	    /**
	     * add the `code_verifier` passed by the user to exchange for a token
	     * @param codeVerifier
	     */
	    RequestParameterBuilder.prototype.addCodeVerifier = function (codeVerifier) {
	        this.parameters.set(AADServerParamKeys.CODE_VERIFIER, encodeURIComponent(codeVerifier));
	    };
	    /**
	     * add client_secret
	     * @param clientSecret
	     */
	    RequestParameterBuilder.prototype.addClientSecret = function (clientSecret) {
	        this.parameters.set(AADServerParamKeys.CLIENT_SECRET, encodeURIComponent(clientSecret));
	    };
	    /**
	     * add clientAssertion for confidential client flows
	     * @param clientAssertion
	     */
	    RequestParameterBuilder.prototype.addClientAssertion = function (clientAssertion) {
	        if (!StringUtils.isEmpty(clientAssertion)) {
	            this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION, encodeURIComponent(clientAssertion));
	        }
	    };
	    /**
	     * add clientAssertionType for confidential client flows
	     * @param clientAssertionType
	     */
	    RequestParameterBuilder.prototype.addClientAssertionType = function (clientAssertionType) {
	        if (!StringUtils.isEmpty(clientAssertionType)) {
	            this.parameters.set(AADServerParamKeys.CLIENT_ASSERTION_TYPE, encodeURIComponent(clientAssertionType));
	        }
	    };
	    /**
	     * add OBO assertion for confidential client flows
	     * @param clientAssertion
	     */
	    RequestParameterBuilder.prototype.addOboAssertion = function (oboAssertion) {
	        this.parameters.set(AADServerParamKeys.OBO_ASSERTION, encodeURIComponent(oboAssertion));
	    };
	    /**
	     * add grant type
	     * @param grantType
	     */
	    RequestParameterBuilder.prototype.addRequestTokenUse = function (tokenUse) {
	        this.parameters.set(AADServerParamKeys.REQUESTED_TOKEN_USE, encodeURIComponent(tokenUse));
	    };
	    /**
	     * add grant type
	     * @param grantType
	     */
	    RequestParameterBuilder.prototype.addGrantType = function (grantType) {
	        this.parameters.set(AADServerParamKeys.GRANT_TYPE, encodeURIComponent(grantType));
	    };
	    /**
	     * add client info
	     *
	     */
	    RequestParameterBuilder.prototype.addClientInfo = function () {
	        this.parameters.set(CLIENT_INFO, "1");
	    };
	    /**
	     * add extraQueryParams
	     * @param eQParams
	     */
	    RequestParameterBuilder.prototype.addExtraQueryParameters = function (eQParams) {
	        var _this = this;
	        var sanitizedEQParams = RequestValidator.sanitizeEQParams(eQParams, this.parameters);
	        Object.keys(sanitizedEQParams).forEach(function (key) {
	            _this.parameters.set(key, eQParams[key]);
	        });
	    };
	    RequestParameterBuilder.prototype.addClientCapabilitiesToClaims = function (claims, clientCapabilities) {
	        var mergedClaims;
	        // Parse provided claims into JSON object or initialize empty object
	        if (!claims) {
	            mergedClaims = {};
	        }
	        else {
	            try {
	                mergedClaims = JSON.parse(claims);
	            }
	            catch (e) {
	                throw ClientConfigurationError.createInvalidClaimsRequestError();
	            }
	        }
	        if (clientCapabilities && clientCapabilities.length > 0) {
	            if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
	                // Add access_token key to claims object
	                mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
	            }
	            // Add xms_cc claim with provided clientCapabilities to access_token key
	            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] = {
	                values: clientCapabilities
	            };
	        }
	        return JSON.stringify(mergedClaims);
	    };
	    /**
	     * adds `username` for Password Grant flow
	     * @param username
	     */
	    RequestParameterBuilder.prototype.addUsername = function (username) {
	        this.parameters.set(PasswordGrantConstants.username, encodeURIComponent(username));
	    };
	    /**
	     * adds `password` for Password Grant flow
	     * @param password
	     */
	    RequestParameterBuilder.prototype.addPassword = function (password) {
	        this.parameters.set(PasswordGrantConstants.password, encodeURIComponent(password));
	    };
	    /**
	     * add pop_jwk to query params
	     * @param cnfString
	     */
	    RequestParameterBuilder.prototype.addPopToken = function (cnfString) {
	        if (!StringUtils.isEmpty(cnfString)) {
	            this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.POP);
	            this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(cnfString));
	        }
	    };
	    /**
	     * add SSH JWK and key ID to query params
	     */
	    RequestParameterBuilder.prototype.addSshJwk = function (sshJwkString) {
	        if (!StringUtils.isEmpty(sshJwkString)) {
	            this.parameters.set(AADServerParamKeys.TOKEN_TYPE, AuthenticationScheme.SSH);
	            this.parameters.set(AADServerParamKeys.REQ_CNF, encodeURIComponent(sshJwkString));
	        }
	    };
	    /**
	     * add server telemetry fields
	     * @param serverTelemetryManager
	     */
	    RequestParameterBuilder.prototype.addServerTelemetry = function (serverTelemetryManager) {
	        this.parameters.set(AADServerParamKeys.X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
	        this.parameters.set(AADServerParamKeys.X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
	    };
	    /**
	     * Adds parameter that indicates to the server that throttling is supported
	     */
	    RequestParameterBuilder.prototype.addThrottling = function () {
	        this.parameters.set(AADServerParamKeys.X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
	    };
	    /**
	     * Adds logout_hint parameter for "silent" logout which prevent server account picker
	     */
	    RequestParameterBuilder.prototype.addLogoutHint = function (logoutHint) {
	        this.parameters.set(AADServerParamKeys.LOGOUT_HINT, encodeURIComponent(logoutHint));
	    };
	    /**
	     * Utility to create a URL from the params map
	     */
	    RequestParameterBuilder.prototype.createQueryString = function () {
	        var queryParameterArray = new Array();
	        this.parameters.forEach(function (value, key) {
	            queryParameterArray.push(key + "=" + value);
	        });
	        return queryParameterArray.join("&");
	    };
	    return RequestParameterBuilder;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Base application class which will construct requests to send to and handle responses from the Microsoft STS using the authorization code flow.
	 */
	var BaseClient = /** @class */ (function () {
	    function BaseClient(configuration, performanceClient) {
	        // Set the configuration
	        this.config = buildClientConfiguration(configuration);
	        // Initialize the logger
	        this.logger = new Logger(this.config.loggerOptions, name$1, version$1);
	        // Initialize crypto
	        this.cryptoUtils = this.config.cryptoInterface;
	        // Initialize storage interface
	        this.cacheManager = this.config.storageInterface;
	        // Set the network interface
	        this.networkClient = this.config.networkInterface;
	        // Set the NetworkManager
	        this.networkManager = new NetworkManager(this.networkClient, this.cacheManager);
	        // Set TelemetryManager
	        this.serverTelemetryManager = this.config.serverTelemetryManager;
	        // set Authority
	        this.authority = this.config.authOptions.authority;
	        // set performance telemetry client
	        this.performanceClient = performanceClient;
	    }
	    /**
	     * Creates default headers for requests to token endpoint
	     */
	    BaseClient.prototype.createTokenRequestHeaders = function (ccsCred) {
	        var headers = {};
	        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
	        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
	            switch (ccsCred.type) {
	                case CcsCredentialType.HOME_ACCOUNT_ID:
	                    try {
	                        var clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
	                        headers[HeaderNames.CCS_HEADER] = "Oid:" + clientInfo.uid + "@" + clientInfo.utid;
	                    }
	                    catch (e) {
	                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
	                    }
	                    break;
	                case CcsCredentialType.UPN:
	                    headers[HeaderNames.CCS_HEADER] = "UPN: " + ccsCred.credential;
	                    break;
	            }
	        }
	        return headers;
	    };
	    /**
	     * Http post to token endpoint
	     * @param tokenEndpoint
	     * @param queryString
	     * @param headers
	     * @param thumbprint
	     */
	    BaseClient.prototype.executePostToTokenEndpoint = function (tokenEndpoint, queryString, headers, thumbprint) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var response;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.networkManager.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers: headers })];
	                    case 1:
	                        response = _a.sent();
	                        if (this.config.serverTelemetryManager && response.status < 500 && response.status !== 429) {
	                            // Telemetry data successfully logged by server, clear Telemetry cache
	                            this.config.serverTelemetryManager.clearTelemetryCache();
	                        }
	                        return [2 /*return*/, response];
	                }
	            });
	        });
	    };
	    /**
	     * Updates the authority object of the client. Endpoint discovery must be completed.
	     * @param updatedAuthority
	     */
	    BaseClient.prototype.updateAuthority = function (updatedAuthority) {
	        if (!updatedAuthority.discoveryComplete()) {
	            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Updated authority has not completed endpoint discovery.");
	        }
	        this.authority = updatedAuthority;
	    };
	    /**
	     * Creates query string for the /token request
	     * @param request
	     */
	    BaseClient.prototype.createTokenQueryParameters = function (request) {
	        var parameterBuilder = new RequestParameterBuilder();
	        if (request.tokenQueryParameters) {
	            parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);
	        }
	        return parameterBuilder.createQueryString();
	    };
	    return BaseClient;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc
	 *
	 * Key:Value Schema:
	 *
	 * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>
	 *
	 * Value Schema:
	 * {
	 *      homeAccountId: home account identifier for the auth scheme,
	 *      environment: entity that issued the token, represented as a full host
	 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
	 *      clientId: client ID of the application
	 *      secret: Actual credential as a string
	 *      familyId: Family ID identifier, usually only used for refresh tokens
	 *      realm: Full tenant or organizational identifier that the account belongs to
	 *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.
	 *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)
	 *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request
	 *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow
	 * }
	 */
	var CredentialEntity = /** @class */ (function () {
	    function CredentialEntity() {
	    }
	    /**
	     * Generate Account Id key component as per the schema: <home_account_id>-<environment>
	     */
	    CredentialEntity.prototype.generateAccountId = function () {
	        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);
	    };
	    /**
	     * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>
	     */
	    CredentialEntity.prototype.generateCredentialId = function () {
	        return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);
	    };
	    /**
	     * Generate target key component as per schema: <target>
	     */
	    CredentialEntity.prototype.generateTarget = function () {
	        return CredentialEntity.generateTargetForCacheKey(this.target);
	    };
	    /**
	     * generates credential key
	     */
	    CredentialEntity.prototype.generateCredentialKey = function () {
	        return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);
	    };
	    /**
	     * returns the type of the cache (in this case credential)
	     */
	    CredentialEntity.prototype.generateType = function () {
	        switch (this.credentialType) {
	            case CredentialType.ID_TOKEN:
	                return CacheType.ID_TOKEN;
	            case CredentialType.ACCESS_TOKEN:
	            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
	                return CacheType.ACCESS_TOKEN;
	            case CredentialType.REFRESH_TOKEN:
	                return CacheType.REFRESH_TOKEN;
	            default: {
	                throw ClientAuthError.createUnexpectedCredentialTypeError();
	            }
	        }
	    };
	    /**
	     * generates credential key
	     * <home_account_id*>-\<environment>-<credential_type>-<client_id>-<realm\*>-<target\*>-<scheme\*>
	     */
	    CredentialEntity.generateCredentialCacheKey = function (homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {
	        var credentialKey = [
	            this.generateAccountIdForCacheKey(homeAccountId, environment),
	            this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),
	            this.generateTargetForCacheKey(target),
	            this.generateClaimsHashForCacheKey(requestedClaimsHash),
	            this.generateSchemeForCacheKey(tokenType)
	        ];
	        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
	    };
	    /**
	     * generates Account Id for keys
	     * @param homeAccountId
	     * @param environment
	     */
	    CredentialEntity.generateAccountIdForCacheKey = function (homeAccountId, environment) {
	        var accountId = [homeAccountId, environment];
	        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
	    };
	    /**
	     * Generates Credential Id for keys
	     * @param credentialType
	     * @param realm
	     * @param clientId
	     * @param familyId
	     */
	    CredentialEntity.generateCredentialIdForCacheKey = function (credentialType, clientId, realm, familyId) {
	        var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN
	            ? familyId || clientId
	            : clientId;
	        var credentialId = [
	            credentialType,
	            clientOrFamilyId,
	            realm || Constants.EMPTY_STRING,
	        ];
	        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
	    };
	    /**
	     * Generate target key component as per schema: <target>
	     */
	    CredentialEntity.generateTargetForCacheKey = function (scopes) {
	        return (scopes || Constants.EMPTY_STRING).toLowerCase();
	    };
	    /**
	     * Generate requested claims key component as per schema: <requestedClaims>
	     */
	    CredentialEntity.generateClaimsHashForCacheKey = function (requestedClaimsHash) {
	        return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();
	    };
	    /**
	     * Generate scheme key componenet as per schema: <scheme>
	     */
	    CredentialEntity.generateSchemeForCacheKey = function (tokenType) {
	        /*
	         * PoP Tokens and SSH certs include scheme in cache key
	         * Cast to lowercase to handle "bearer" from ADFS
	         */
	        return (tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? tokenType.toLowerCase() : Constants.EMPTY_STRING;
	    };
	    return CredentialEntity;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * ID_TOKEN Cache
	 *
	 * Key:Value Schema:
	 *
	 * Key Example: uid.utid-login.microsoftonline.com-idtoken-clientId-contoso.com-
	 *
	 * Value Schema:
	 * {
	 *      homeAccountId: home account identifier for the auth scheme,
	 *      environment: entity that issued the token, represented as a full host
	 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
	 *      clientId: client ID of the application
	 *      secret: Actual credential as a string
	 *      realm: Full tenant or organizational identifier that the account belongs to
	 * }
	 */
	var IdTokenEntity = /** @class */ (function (_super) {
	    __extends$f(IdTokenEntity, _super);
	    function IdTokenEntity() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Create IdTokenEntity
	     * @param homeAccountId
	     * @param authenticationResult
	     * @param clientId
	     * @param authority
	     */
	    IdTokenEntity.createIdTokenEntity = function (homeAccountId, environment, idToken, clientId, tenantId) {
	        var idTokenEntity = new IdTokenEntity();
	        idTokenEntity.credentialType = CredentialType.ID_TOKEN;
	        idTokenEntity.homeAccountId = homeAccountId;
	        idTokenEntity.environment = environment;
	        idTokenEntity.clientId = clientId;
	        idTokenEntity.secret = idToken;
	        idTokenEntity.realm = tenantId;
	        return idTokenEntity;
	    };
	    /**
	     * Validates an entity: checks for all expected params
	     * @param entity
	     */
	    IdTokenEntity.isIdTokenEntity = function (entity) {
	        if (!entity) {
	            return false;
	        }
	        return (entity.hasOwnProperty("homeAccountId") &&
	            entity.hasOwnProperty("environment") &&
	            entity.hasOwnProperty("credentialType") &&
	            entity.hasOwnProperty("realm") &&
	            entity.hasOwnProperty("clientId") &&
	            entity.hasOwnProperty("secret") &&
	            entity["credentialType"] === CredentialType.ID_TOKEN);
	    };
	    return IdTokenEntity;
	}(CredentialEntity));

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Utility class which exposes functions for managing date and time operations.
	 */
	var TimeUtils = /** @class */ (function () {
	    function TimeUtils() {
	    }
	    /**
	     * return the current time in Unix time (seconds).
	     */
	    TimeUtils.nowSeconds = function () {
	        // Date.getTime() returns in milliseconds.
	        return Math.round(new Date().getTime() / 1000.0);
	    };
	    /**
	     * check if a token is expired based on given UTC time in seconds.
	     * @param expiresOn
	     */
	    TimeUtils.isTokenExpired = function (expiresOn, offset) {
	        // check for access token expiry
	        var expirationSec = Number(expiresOn) || 0;
	        var offsetCurrentTimeSec = TimeUtils.nowSeconds() + offset;
	        // If current time + offset is greater than token expiration time, then token is expired.
	        return (offsetCurrentTimeSec > expirationSec);
	    };
	    /**
	     * If the current time is earlier than the time that a token was cached at, we must discard the token
	     * i.e. The system clock was turned back after acquiring the cached token
	     * @param cachedAt
	     * @param offset
	     */
	    TimeUtils.wasClockTurnedBack = function (cachedAt) {
	        var cachedAtSec = Number(cachedAt);
	        return cachedAtSec > TimeUtils.nowSeconds();
	    };
	    /**
	     * Waits for t number of milliseconds
	     * @param t number
	     * @param value T
	     */
	    TimeUtils.delay = function (t, value) {
	        return new Promise(function (resolve) { return setTimeout(function () { return resolve(value); }, t); });
	    };
	    return TimeUtils;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * ACCESS_TOKEN Credential Type
	 *
	 * Key:Value Schema:
	 *
	 * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read
	 *
	 * Value Schema:
	 * {
	 *      homeAccountId: home account identifier for the auth scheme,
	 *      environment: entity that issued the token, represented as a full host
	 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
	 *      clientId: client ID of the application
	 *      secret: Actual credential as a string
	 *      familyId: Family ID identifier, usually only used for refresh tokens
	 *      realm: Full tenant or organizational identifier that the account belongs to
	 *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.
	 *      cachedAt: Absolute device time when entry was created in the cache.
	 *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.
	 *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.
	 *      keyId: used for POP and SSH tokenTypes
	 *      tokenType: Type of the token issued. Usually "Bearer"
	 * }
	 */
	var AccessTokenEntity = /** @class */ (function (_super) {
	    __extends$f(AccessTokenEntity, _super);
	    function AccessTokenEntity() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Create AccessTokenEntity
	     * @param homeAccountId
	     * @param environment
	     * @param accessToken
	     * @param clientId
	     * @param tenantId
	     * @param scopes
	     * @param expiresOn
	     * @param extExpiresOn
	     */
	    AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
	        var _a, _b;
	        var atEntity = new AccessTokenEntity();
	        atEntity.homeAccountId = homeAccountId;
	        atEntity.credentialType = CredentialType.ACCESS_TOKEN;
	        atEntity.secret = accessToken;
	        var currentTime = TimeUtils.nowSeconds();
	        atEntity.cachedAt = currentTime.toString();
	        /*
	         * Token expiry time.
	         * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.
	         */
	        atEntity.expiresOn = expiresOn.toString();
	        atEntity.extendedExpiresOn = extExpiresOn.toString();
	        if (refreshOn) {
	            atEntity.refreshOn = refreshOn.toString();
	        }
	        atEntity.environment = environment;
	        atEntity.clientId = clientId;
	        atEntity.realm = tenantId;
	        atEntity.target = scopes;
	        atEntity.userAssertionHash = userAssertionHash;
	        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;
	        if (requestedClaims) {
	            atEntity.requestedClaims = requestedClaims;
	            atEntity.requestedClaimsHash = requestedClaimsHash;
	        }
	        /*
	         * Create Access Token With Auth Scheme instead of regular access token
	         * Cast to lower to handle "bearer" from ADFS
	         */
	        if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {
	            atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
	            switch (atEntity.tokenType) {
	                case AuthenticationScheme.POP:
	                    // Make sure keyId is present and add it to credential
	                    var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);
	                    if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {
	                        throw ClientAuthError.createTokenClaimsRequiredError();
	                    }
	                    atEntity.keyId = tokenClaims.cnf.kid;
	                    break;
	                case AuthenticationScheme.SSH:
	                    atEntity.keyId = keyId;
	            }
	        }
	        return atEntity;
	    };
	    /**
	     * Validates an entity: checks for all expected params
	     * @param entity
	     */
	    AccessTokenEntity.isAccessTokenEntity = function (entity) {
	        if (!entity) {
	            return false;
	        }
	        return (entity.hasOwnProperty("homeAccountId") &&
	            entity.hasOwnProperty("environment") &&
	            entity.hasOwnProperty("credentialType") &&
	            entity.hasOwnProperty("realm") &&
	            entity.hasOwnProperty("clientId") &&
	            entity.hasOwnProperty("secret") &&
	            entity.hasOwnProperty("target") &&
	            (entity["credentialType"] === CredentialType.ACCESS_TOKEN || entity["credentialType"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME));
	    };
	    return AccessTokenEntity;
	}(CredentialEntity));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * REFRESH_TOKEN Cache
	 *
	 * Key:Value Schema:
	 *
	 * Key Example: uid.utid-login.microsoftonline.com-refreshtoken-clientId--
	 *
	 * Value:
	 * {
	 *      homeAccountId: home account identifier for the auth scheme,
	 *      environment: entity that issued the token, represented as a full host
	 *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other
	 *      clientId: client ID of the application
	 *      secret: Actual credential as a string
	 *      familyId: Family ID identifier, '1' represents Microsoft Family
	 *      realm: Full tenant or organizational identifier that the account belongs to
	 *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.
	 * }
	 */
	var RefreshTokenEntity = /** @class */ (function (_super) {
	    __extends$f(RefreshTokenEntity, _super);
	    function RefreshTokenEntity() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Create RefreshTokenEntity
	     * @param homeAccountId
	     * @param authenticationResult
	     * @param clientId
	     * @param authority
	     */
	    RefreshTokenEntity.createRefreshTokenEntity = function (homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash) {
	        var rtEntity = new RefreshTokenEntity();
	        rtEntity.clientId = clientId;
	        rtEntity.credentialType = CredentialType.REFRESH_TOKEN;
	        rtEntity.environment = environment;
	        rtEntity.homeAccountId = homeAccountId;
	        rtEntity.secret = refreshToken;
	        rtEntity.userAssertionHash = userAssertionHash;
	        if (familyId)
	            rtEntity.familyId = familyId;
	        return rtEntity;
	    };
	    /**
	     * Validates an entity: checks for all expected params
	     * @param entity
	     */
	    RefreshTokenEntity.isRefreshTokenEntity = function (entity) {
	        if (!entity) {
	            return false;
	        }
	        return (entity.hasOwnProperty("homeAccountId") &&
	            entity.hasOwnProperty("environment") &&
	            entity.hasOwnProperty("credentialType") &&
	            entity.hasOwnProperty("clientId") &&
	            entity.hasOwnProperty("secret") &&
	            entity["credentialType"] === CredentialType.REFRESH_TOKEN);
	    };
	    return RefreshTokenEntity;
	}(CredentialEntity));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * InteractionRequiredServerErrorMessage contains string constants used by error codes and messages returned by the server indicating interaction is required
	 */
	var InteractionRequiredServerErrorMessage = [
	    "interaction_required",
	    "consent_required",
	    "login_required"
	];
	var InteractionRequiredAuthSubErrorMessage = [
	    "message_only",
	    "additional_action",
	    "basic_action",
	    "user_password_expired",
	    "consent_required"
	];
	/**
	 * Interaction required errors defined by the SDK
	 */
	var InteractionRequiredAuthErrorMessage = {
	    noTokensFoundError: {
	        code: "no_tokens_found",
	        desc: "No refresh token found in the cache. Please sign-in."
	    },
	    native_account_unavailable: {
	        code: "native_account_unavailable",
	        desc: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API."
	    }
	};
	/**
	 * Error thrown when user interaction is required.
	 */
	var InteractionRequiredAuthError = /** @class */ (function (_super) {
	    __extends$f(InteractionRequiredAuthError, _super);
	    function InteractionRequiredAuthError(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims) {
	        var _this = _super.call(this, errorCode, errorMessage, subError) || this;
	        Object.setPrototypeOf(_this, InteractionRequiredAuthError.prototype);
	        _this.timestamp = timestamp || Constants.EMPTY_STRING;
	        _this.traceId = traceId || Constants.EMPTY_STRING;
	        _this.correlationId = correlationId || Constants.EMPTY_STRING;
	        _this.claims = claims || Constants.EMPTY_STRING;
	        _this.name = "InteractionRequiredAuthError";
	        return _this;
	    }
	    /**
	     * Helper function used to determine if an error thrown by the server requires interaction to resolve
	     * @param errorCode
	     * @param errorString
	     * @param subError
	     */
	    InteractionRequiredAuthError.isInteractionRequiredError = function (errorCode, errorString, subError) {
	        var isInteractionRequiredErrorCode = !!errorCode && InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
	        var isInteractionRequiredSubError = !!subError && InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
	        var isInteractionRequiredErrorDesc = !!errorString && InteractionRequiredServerErrorMessage.some(function (irErrorCode) {
	            return errorString.indexOf(irErrorCode) > -1;
	        });
	        return isInteractionRequiredErrorCode || isInteractionRequiredErrorDesc || isInteractionRequiredSubError;
	    };
	    /**
	     * Creates an error thrown when the authorization code required for a token request is null or empty.
	     */
	    InteractionRequiredAuthError.createNoTokensFoundError = function () {
	        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.noTokensFoundError.code, InteractionRequiredAuthErrorMessage.noTokensFoundError.desc);
	    };
	    /**
	     * Creates an error thrown when the native broker returns ACCOUNT_UNAVAILABLE status, indicating that the account was removed and interactive sign-in is required
	     * @returns
	     */
	    InteractionRequiredAuthError.createNativeAccountUnavailableError = function () {
	        return new InteractionRequiredAuthError(InteractionRequiredAuthErrorMessage.native_account_unavailable.code, InteractionRequiredAuthErrorMessage.native_account_unavailable.desc);
	    };
	    return InteractionRequiredAuthError;
	}(AuthError));

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var CacheRecord = /** @class */ (function () {
	    function CacheRecord(accountEntity, idTokenEntity, accessTokenEntity, refreshTokenEntity, appMetadataEntity) {
	        this.account = accountEntity || null;
	        this.idToken = idTokenEntity || null;
	        this.accessToken = accessTokenEntity || null;
	        this.refreshToken = refreshTokenEntity || null;
	        this.appMetadata = appMetadataEntity || null;
	    }
	    return CacheRecord;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Class which provides helpers for OAuth 2.0 protocol specific values
	 */
	var ProtocolUtils = /** @class */ (function () {
	    function ProtocolUtils() {
	    }
	    /**
	     * Appends user state with random guid, or returns random guid.
	     * @param userState
	     * @param randomGuid
	     */
	    ProtocolUtils.setRequestState = function (cryptoObj, userState, meta) {
	        var libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);
	        return !StringUtils.isEmpty(userState) ? "" + libraryState + Constants.RESOURCE_DELIM + userState : libraryState;
	    };
	    /**
	     * Generates the state value used by the common library.
	     * @param randomGuid
	     * @param cryptoObj
	     */
	    ProtocolUtils.generateLibraryState = function (cryptoObj, meta) {
	        if (!cryptoObj) {
	            throw ClientAuthError.createNoCryptoObjectError("generateLibraryState");
	        }
	        // Create a state object containing a unique id and the timestamp of the request creation
	        var stateObj = {
	            id: cryptoObj.createNewGuid()
	        };
	        if (meta) {
	            stateObj.meta = meta;
	        }
	        var stateString = JSON.stringify(stateObj);
	        return cryptoObj.base64Encode(stateString);
	    };
	    /**
	     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
	     * @param state
	     * @param cryptoObj
	     */
	    ProtocolUtils.parseRequestState = function (cryptoObj, state) {
	        if (!cryptoObj) {
	            throw ClientAuthError.createNoCryptoObjectError("parseRequestState");
	        }
	        if (StringUtils.isEmpty(state)) {
	            throw ClientAuthError.createInvalidStateError(state, "Null, undefined or empty state");
	        }
	        try {
	            // Split the state between library state and user passed state and decode them separately
	            var splitState = state.split(Constants.RESOURCE_DELIM);
	            var libraryState = splitState[0];
	            var userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;
	            var libraryStateString = cryptoObj.base64Decode(libraryState);
	            var libraryStateObj = JSON.parse(libraryStateString);
	            return {
	                userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants.EMPTY_STRING,
	                libraryState: libraryStateObj
	            };
	        }
	        catch (e) {
	            throw ClientAuthError.createInvalidStateError(state, e);
	        }
	    };
	    return ProtocolUtils;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Url object class which can perform various transformations on url strings.
	 */
	var UrlString = /** @class */ (function () {
	    function UrlString(url) {
	        this._urlString = url;
	        if (StringUtils.isEmpty(this._urlString)) {
	            // Throws error if url is empty
	            throw ClientConfigurationError.createUrlEmptyError();
	        }
	        if (StringUtils.isEmpty(this.getHash())) {
	            this._urlString = UrlString.canonicalizeUri(url);
	        }
	    }
	    Object.defineProperty(UrlString.prototype, "urlString", {
	        get: function () {
	            return this._urlString;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Ensure urls are lower case and end with a / character.
	     * @param url
	     */
	    UrlString.canonicalizeUri = function (url) {
	        if (url) {
	            var lowerCaseUrl = url.toLowerCase();
	            if (StringUtils.endsWith(lowerCaseUrl, "?")) {
	                lowerCaseUrl = lowerCaseUrl.slice(0, -1);
	            }
	            else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
	                lowerCaseUrl = lowerCaseUrl.slice(0, -2);
	            }
	            if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
	                lowerCaseUrl += "/";
	            }
	            return lowerCaseUrl;
	        }
	        return url;
	    };
	    /**
	     * Throws if urlString passed is not a valid authority URI string.
	     */
	    UrlString.prototype.validateAsUri = function () {
	        // Attempts to parse url for uri components
	        var components;
	        try {
	            components = this.getUrlComponents();
	        }
	        catch (e) {
	            throw ClientConfigurationError.createUrlParseError(e);
	        }
	        // Throw error if URI or path segments are not parseable.
	        if (!components.HostNameAndPort || !components.PathSegments) {
	            throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
	        }
	        // Throw error if uri is insecure.
	        if (!components.Protocol || components.Protocol.toLowerCase() !== "https:") {
	            throw ClientConfigurationError.createInsecureAuthorityUriError(this.urlString);
	        }
	    };
	    /**
	     * Given a url and a query string return the url with provided query string appended
	     * @param url
	     * @param queryString
	     */
	    UrlString.appendQueryString = function (url, queryString) {
	        if (StringUtils.isEmpty(queryString)) {
	            return url;
	        }
	        return url.indexOf("?") < 0 ? url + "?" + queryString : url + "&" + queryString;
	    };
	    /**
	     * Returns a url with the hash removed
	     * @param url
	     */
	    UrlString.removeHashFromUrl = function (url) {
	        return UrlString.canonicalizeUri(url.split("#")[0]);
	    };
	    /**
	     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
	     * @param href The url
	     * @param tenantId The tenant id to replace
	     */
	    UrlString.prototype.replaceTenantPath = function (tenantId) {
	        var urlObject = this.getUrlComponents();
	        var pathArray = urlObject.PathSegments;
	        if (tenantId && (pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS))) {
	            pathArray[0] = tenantId;
	        }
	        return UrlString.constructAuthorityUriFromObject(urlObject);
	    };
	    /**
	     * Returns the anchor part(#) of the URL
	     */
	    UrlString.prototype.getHash = function () {
	        return UrlString.parseHash(this.urlString);
	    };
	    /**
	     * Parses out the components from a url string.
	     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
	     */
	    UrlString.prototype.getUrlComponents = function () {
	        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0
	        var regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
	        // If url string does not match regEx, we throw an error
	        var match = this.urlString.match(regEx);
	        if (!match) {
	            throw ClientConfigurationError.createUrlParseError("Given url string: " + this.urlString);
	        }
	        // Url component object
	        var urlComponents = {
	            Protocol: match[1],
	            HostNameAndPort: match[4],
	            AbsolutePath: match[5],
	            QueryString: match[7]
	        };
	        var pathSegments = urlComponents.AbsolutePath.split("/");
	        pathSegments = pathSegments.filter(function (val) { return val && val.length > 0; }); // remove empty elements
	        urlComponents.PathSegments = pathSegments;
	        if (!StringUtils.isEmpty(urlComponents.QueryString) && urlComponents.QueryString.endsWith("/")) {
	            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
	        }
	        return urlComponents;
	    };
	    UrlString.getDomainFromUrl = function (url) {
	        var regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
	        var match = url.match(regEx);
	        if (!match) {
	            throw ClientConfigurationError.createUrlParseError("Given url string: " + url);
	        }
	        return match[2];
	    };
	    UrlString.getAbsoluteUrl = function (relativeUrl, baseUrl) {
	        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
	            var url = new UrlString(baseUrl);
	            var baseComponents = url.getUrlComponents();
	            return baseComponents.Protocol + "//" + baseComponents.HostNameAndPort + relativeUrl;
	        }
	        return relativeUrl;
	    };
	    /**
	     * Parses hash string from given string. Returns empty string if no hash symbol is found.
	     * @param hashString
	     */
	    UrlString.parseHash = function (hashString) {
	        var hashIndex1 = hashString.indexOf("#");
	        var hashIndex2 = hashString.indexOf("#/");
	        if (hashIndex2 > -1) {
	            return hashString.substring(hashIndex2 + 2);
	        }
	        else if (hashIndex1 > -1) {
	            return hashString.substring(hashIndex1 + 1);
	        }
	        return Constants.EMPTY_STRING;
	    };
	    /**
	     * Parses query string from given string. Returns empty string if no query symbol is found.
	     * @param queryString
	     */
	    UrlString.parseQueryString = function (queryString) {
	        var queryIndex1 = queryString.indexOf("?");
	        var queryIndex2 = queryString.indexOf("/?");
	        if (queryIndex2 > -1) {
	            return queryString.substring(queryIndex2 + 2);
	        }
	        else if (queryIndex1 > -1) {
	            return queryString.substring(queryIndex1 + 1);
	        }
	        return Constants.EMPTY_STRING;
	    };
	    UrlString.constructAuthorityUriFromObject = function (urlObject) {
	        return new UrlString(urlObject.Protocol + "//" + urlObject.HostNameAndPort + "/" + urlObject.PathSegments.join("/"));
	    };
	    /**
	     * Returns URL hash as server auth code response object.
	     */
	    UrlString.getDeserializedHash = function (hash) {
	        // Check if given hash is empty
	        if (StringUtils.isEmpty(hash)) {
	            return {};
	        }
	        // Strip the # symbol if present
	        var parsedHash = UrlString.parseHash(hash);
	        // If # symbol was not present, above will return empty string, so give original hash value
	        var deserializedHash = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedHash) ? hash : parsedHash);
	        // Check if deserialization didn't work
	        if (!deserializedHash) {
	            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedHash));
	        }
	        return deserializedHash;
	    };
	    /**
	     * Returns URL query string as server auth code response object.
	     */
	    UrlString.getDeserializedQueryString = function (query) {
	        // Check if given query is empty
	        if (StringUtils.isEmpty(query)) {
	            return {};
	        }
	        // Strip the ? symbol if present
	        var parsedQueryString = UrlString.parseQueryString(query);
	        // If ? symbol was not present, above will return empty string, so give original query value
	        var deserializedQueryString = StringUtils.queryStringToObject(StringUtils.isEmpty(parsedQueryString) ? query : parsedQueryString);
	        // Check if deserialization didn't work
	        if (!deserializedQueryString) {
	            throw ClientAuthError.createHashNotDeserializedError(JSON.stringify(deserializedQueryString));
	        }
	        return deserializedQueryString;
	    };
	    /**
	     * Check if the hash of the URL string contains known properties
	     */
	    UrlString.hashContainsKnownProperties = function (hash) {
	        if (StringUtils.isEmpty(hash) || hash.indexOf("=") < 0) {
	            // Hash doesn't contain key/value pairs
	            return false;
	        }
	        var parameters = UrlString.getDeserializedHash(hash);
	        return !!(parameters.code ||
	            parameters.error_description ||
	            parameters.error ||
	            parameters.state);
	    };
	    return UrlString;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Enumeration of operations that are instrumented by have their performance measured by the PerformanceClient.
	 *
	 * @export
	 * @enum {number}
	 */
	var PerformanceEvents;
	(function (PerformanceEvents) {
	    /**
	     * acquireTokenByCode API (msal-browser and msal-node).
	     * Used to acquire tokens by trading an authorization code against the token endpoint.
	     */
	    PerformanceEvents["AcquireTokenByCode"] = "acquireTokenByCode";
	    /**
	     * acquireTokenByRefreshToken API (msal-browser and msal-node).
	     * Used to renew an access token using a refresh token against the token endpoint.
	     */
	    PerformanceEvents["AcquireTokenByRefreshToken"] = "acquireTokenByRefreshToken";
	    /**
	     * acquireTokenSilent API (msal-browser and msal-node).
	     * Used to silently acquire a new access token (from the cache or the network).
	     */
	    PerformanceEvents["AcquireTokenSilent"] = "acquireTokenSilent";
	    /**
	     * acquireTokenSilentAsync (msal-browser).
	     * Internal API for acquireTokenSilent.
	     */
	    PerformanceEvents["AcquireTokenSilentAsync"] = "acquireTokenSilentAsync";
	    /**
	     * acquireTokenPopup (msal-browser).
	     * Used to acquire a new access token interactively through pop ups
	     */
	    PerformanceEvents["AcquireTokenPopup"] = "acquireTokenPopup";
	    /**
	     * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
	     * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
	     */
	    PerformanceEvents["CryptoOptsGetPublicKeyThumbprint"] = "cryptoOptsGetPublicKeyThumbprint";
	    /**
	     * signJwt API in CryptoOpts class (msal-browser).
	     * Used to signed a pop token.
	     */
	    PerformanceEvents["CryptoOptsSignJwt"] = "cryptoOptsSignJwt";
	    /**
	     * acquireToken API in the SilentCacheClient class (msal-browser).
	     * Used to read access tokens from the cache.
	     */
	    PerformanceEvents["SilentCacheClientAcquireToken"] = "silentCacheClientAcquireToken";
	    /**
	     * acquireToken API in the SilentIframeClient class (msal-browser).
	     * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
	     */
	    PerformanceEvents["SilentIframeClientAcquireToken"] = "silentIframeClientAcquireToken";
	    /**
	     * acquireToken API in SilentRereshClient (msal-browser).
	     * Used to acquire a new set of tokens from the token endpoint using a refresh token.
	     */
	    PerformanceEvents["SilentRefreshClientAcquireToken"] = "silentRefreshClientAcquireToken";
	    /**
	     * ssoSilent API (msal-browser).
	     * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
	     */
	    PerformanceEvents["SsoSilent"] = "ssoSilent";
	    /**
	     * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
	     * Used to load authority metadata for a request.
	     */
	    PerformanceEvents["StandardInteractionClientGetDiscoveredAuthority"] = "standardInteractionClientGetDiscoveredAuthority";
	    /**
	     * acquireToken APIs in msal-browser.
	     * Used to make an /authorize endpoint call with native brokering enabled.
	     */
	    PerformanceEvents["FetchAccountIdWithNativeBroker"] = "fetchAccountIdWithNativeBroker";
	    /**
	     * acquireToken API in NativeInteractionClient class (msal-browser).
	     * Used to acquire a token from Native component when native brokering is enabled.
	     */
	    PerformanceEvents["NativeInteractionClientAcquireToken"] = "nativeInteractionClientAcquireToken";
	    /**
	     * Time spent creating default headers for requests to token endpoint
	     */
	    PerformanceEvents["BaseClientCreateTokenRequestHeaders"] = "baseClientCreateTokenRequestHeaders";
	    /**
	     * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
	     */
	    PerformanceEvents["BrokerHandhshake"] = "brokerHandshake";
	    /**
	     * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
	     */
	    PerformanceEvents["AcquireTokenByRefreshTokenInBroker"] = "acquireTokenByRefreshTokenInBroker";
	    /**
	     * Time taken for token acquisition by broker
	     */
	    PerformanceEvents["AcquireTokenByBroker"] = "acquireTokenByBroker";
	    /**
	     * Time spent on the network for refresh token acquisition
	     */
	    PerformanceEvents["RefreshTokenClientExecuteTokenRequest"] = "refreshTokenClientExecuteTokenRequest";
	    /**
	     * Time taken for acquiring refresh token , records RT size
	     */
	    PerformanceEvents["RefreshTokenClientAcquireToken"] = "refreshTokenClientAcquireToken";
	    /**
	     * Time taken for acquiring cached refresh token
	     */
	    PerformanceEvents["RefreshTokenClientAcquireTokenWithCachedRefreshToken"] = "refreshTokenClientAcquireTokenWithCachedRefreshToken";
	    /**
	     * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
	     */
	    PerformanceEvents["RefreshTokenClientAcquireTokenByRefreshToken"] = "refreshTokenClientAcquireTokenByRefreshToken";
	    /**
	     * Helper function to create token request body in RefreshTokenClient (msal-common).
	     */
	    PerformanceEvents["RefreshTokenClientCreateTokenRequestBody"] = "refreshTokenClientCreateTokenRequestBody";
	    /**
	     * acquireTokenFromCache (msal-browser).
	     * Internal API for acquiring token from cache
	     */
	    PerformanceEvents["AcquireTokenFromCache"] = "acquireTokenFromCache";
	    /**
	     * acquireTokenBySilentIframe (msal-browser).
	     * Internal API for acquiring token by silent Iframe
	     */
	    PerformanceEvents["AcquireTokenBySilentIframe"] = "acquireTokenBySilentIframe";
	    /**
	     * Internal API for initializing base request in BaseInteractionClient (msal-browser)
	     */
	    PerformanceEvents["InitializeBaseRequest"] = "initializeBaseRequest";
	    /**
	     * Internal API for initializing silent request in SilentCacheClient (msal-browser)
	     */
	    PerformanceEvents["InitializeSilentRequest"] = "initializeSilentRequest";
	    PerformanceEvents["InitializeClientApplication"] = "initializeClientApplication";
	    /**
	     * Helper function in SilentIframeClient class (msal-browser).
	     */
	    PerformanceEvents["SilentIframeClientTokenHelper"] = "silentIframeClientTokenHelper";
	    /**
	     * SilentHandler
	     */
	    PerformanceEvents["SilentHandlerInitiateAuthRequest"] = "silentHandlerInitiateAuthRequest";
	    PerformanceEvents["SilentHandlerMonitorIframeForHash"] = "silentHandlerMonitorIframeForHash";
	    PerformanceEvents["SilentHandlerLoadFrame"] = "silentHandlerLoadFrame";
	    /**
	     * Helper functions in StandardInteractionClient class (msal-browser)
	     */
	    PerformanceEvents["StandardInteractionClientCreateAuthCodeClient"] = "standardInteractionClientCreateAuthCodeClient";
	    PerformanceEvents["StandardInteractionClientGetClientConfiguration"] = "standardInteractionClientGetClientConfiguration";
	    PerformanceEvents["StandardInteractionClientInitializeAuthorizationRequest"] = "standardInteractionClientInitializeAuthorizationRequest";
	    PerformanceEvents["StandardInteractionClientInitializeAuthorizationCodeRequest"] = "standardInteractionClientInitializeAuthorizationCodeRequest";
	    /**
	     * getAuthCodeUrl API (msal-browser and msal-node).
	     */
	    PerformanceEvents["GetAuthCodeUrl"] = "getAuthCodeUrl";
	    /**
	     * Functions from InteractionHandler (msal-browser)
	     */
	    PerformanceEvents["HandleCodeResponseFromServer"] = "handleCodeResponseFromServer";
	    PerformanceEvents["HandleCodeResponseFromHash"] = "handleCodeResponseFromHash";
	    PerformanceEvents["UpdateTokenEndpointAuthority"] = "updateTokenEndpointAuthority";
	    /**
	     * APIs in Authorization Code Client (msal-common)
	     */
	    PerformanceEvents["AuthClientAcquireToken"] = "authClientAcquireToken";
	    PerformanceEvents["AuthClientExecuteTokenRequest"] = "authClientExecuteTokenRequest";
	    PerformanceEvents["AuthClientCreateTokenRequestBody"] = "authClientCreateTokenRequestBody";
	    PerformanceEvents["AuthClientCreateQueryString"] = "authClientCreateQueryString";
	    /**
	     * Generate functions in PopTokenGenerator (msal-common)
	     */
	    PerformanceEvents["PopTokenGenerateCnf"] = "popTokenGenerateCnf";
	    PerformanceEvents["PopTokenGenerateKid"] = "popTokenGenerateKid";
	    /**
	     * handleServerTokenResponse API in ResponseHandler (msal-common)
	     */
	    PerformanceEvents["HandleServerTokenResponse"] = "handleServerTokenResponse";
	    /**
	     * Authority functions
	     */
	    PerformanceEvents["AuthorityFactoryCreateDiscoveredInstance"] = "authorityFactoryCreateDiscoveredInstance";
	    PerformanceEvents["AuthorityResolveEndpointsAsync"] = "authorityResolveEndpointsAsync";
	    PerformanceEvents["AuthorityGetCloudDiscoveryMetadataFromNetwork"] = "authorityGetCloudDiscoveryMetadataFromNetwork";
	    PerformanceEvents["AuthorityUpdateCloudDiscoveryMetadata"] = "authorityUpdateCloudDiscoveryMetadata";
	    PerformanceEvents["AuthorityGetEndpointMetadataFromNetwork"] = "authorityGetEndpointMetadataFromNetwork";
	    PerformanceEvents["AuthorityUpdateEndpointMetadata"] = "authorityUpdateEndpointMetadata";
	    PerformanceEvents["AuthorityUpdateMetadataWithRegionalInformation"] = "authorityUpdateMetadataWithRegionalInformation";
	    /**
	     * Region Discovery functions
	     */
	    PerformanceEvents["RegionDiscoveryDetectRegion"] = "regionDiscoveryDetectRegion";
	    PerformanceEvents["RegionDiscoveryGetRegionFromIMDS"] = "regionDiscoveryGetRegionFromIMDS";
	    PerformanceEvents["RegionDiscoveryGetCurrentVersion"] = "regionDiscoveryGetCurrentVersion";
	    PerformanceEvents["AcquireTokenByCodeAsync"] = "acquireTokenByCodeAsync";
	    PerformanceEvents["GetEndpointMetadataFromNetwork"] = "getEndpointMetadataFromNetwork";
	    PerformanceEvents["GetCloudDiscoveryMetadataFromNetworkMeasurement"] = "getCloudDiscoveryMetadataFromNetworkMeasurement";
	    PerformanceEvents["HandleRedirectPromiseMeasurement"] = "handleRedirectPromiseMeasurement";
	    PerformanceEvents["UpdateCloudDiscoveryMetadataMeasurement"] = "updateCloudDiscoveryMetadataMeasurement";
	    PerformanceEvents["UsernamePasswordClientAcquireToken"] = "usernamePasswordClientAcquireToken";
	    PerformanceEvents["NativeMessageHandlerHandshake"] = "nativeMessageHandlerHandshake";
	    /**
	     * Cache operations
	     */
	    PerformanceEvents["ClearTokensAndKeysWithClaims"] = "clearTokensAndKeysWithClaims";
	})(PerformanceEvents || (PerformanceEvents = {}));
	/**
	 * State of the performance event.
	 *
	 * @export
	 * @enum {number}
	 */
	var PerformanceEventStatus;
	(function (PerformanceEventStatus) {
	    PerformanceEventStatus[PerformanceEventStatus["NotStarted"] = 0] = "NotStarted";
	    PerformanceEventStatus[PerformanceEventStatus["InProgress"] = 1] = "InProgress";
	    PerformanceEventStatus[PerformanceEventStatus["Completed"] = 2] = "Completed";
	})(PerformanceEventStatus || (PerformanceEventStatus = {}));
	var IntFields = new Set([
	    "accessTokenSize",
	    "durationMs",
	    "idTokenSize",
	    "matsSilentStatus",
	    "matsHttpStatus",
	    "refreshTokenSize",
	    "queuedTimeMs",
	    "startTimeMs",
	    "status",
	]);

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var KeyLocation;
	(function (KeyLocation) {
	    KeyLocation["SW"] = "sw";
	    KeyLocation["UHW"] = "uhw";
	})(KeyLocation || (KeyLocation = {}));
	var PopTokenGenerator = /** @class */ (function () {
	    function PopTokenGenerator(cryptoUtils, performanceClient) {
	        this.cryptoUtils = cryptoUtils;
	        this.performanceClient = performanceClient;
	    }
	    /**
	     * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
	     * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
	     * @param request
	     * @returns
	     */
	    PopTokenGenerator.prototype.generateCnf = function (request) {
	        var _a, _b;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var reqCnf, reqCnfString, _c;
	            return __generator$2(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
	                        return [4 /*yield*/, this.generateKid(request)];
	                    case 1:
	                        reqCnf = _d.sent();
	                        reqCnfString = this.cryptoUtils.base64Encode(JSON.stringify(reqCnf));
	                        _c = {
	                            kid: reqCnf.kid,
	                            reqCnfString: reqCnfString
	                        };
	                        return [4 /*yield*/, this.cryptoUtils.hashString(reqCnfString)];
	                    case 2: return [2 /*return*/, (_c.reqCnfHash = _d.sent(),
	                            _c)];
	                }
	            });
	        });
	    };
	    /**
	     * Generates key_id for a SHR token request
	     * @param request
	     * @returns
	     */
	    PopTokenGenerator.prototype.generateKid = function (request) {
	        var _a;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var kidThumbprint;
	            return __generator$2(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
	                        return [4 /*yield*/, this.cryptoUtils.getPublicKeyThumbprint(request)];
	                    case 1:
	                        kidThumbprint = _b.sent();
	                        return [2 /*return*/, {
	                                kid: kidThumbprint,
	                                xms_ksl: KeyLocation.SW
	                            }];
	                }
	            });
	        });
	    };
	    /**
	     * Signs the POP access_token with the local generated key-pair
	     * @param accessToken
	     * @param request
	     * @returns
	     */
	    PopTokenGenerator.prototype.signPopToken = function (accessToken, keyId, request) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            return __generator$2(this, function (_a) {
	                return [2 /*return*/, this.signPayload(accessToken, keyId, request)];
	            });
	        });
	    };
	    /**
	     * Utility function to generate the signed JWT for an access_token
	     * @param payload
	     * @param kid
	     * @param request
	     * @param claims
	     * @returns
	     */
	    PopTokenGenerator.prototype.signPayload = function (payload, keyId, request, claims) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, resourceUrlString, resourceUrlComponents;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        resourceRequestMethod = request.resourceRequestMethod, resourceRequestUri = request.resourceRequestUri, shrClaims = request.shrClaims, shrNonce = request.shrNonce;
	                        resourceUrlString = (resourceRequestUri) ? new UrlString(resourceRequestUri) : undefined;
	                        resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();
	                        return [4 /*yield*/, this.cryptoUtils.signJwt(__assign$4({ at: payload, ts: TimeUtils.nowSeconds(), m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(), u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort, nonce: shrNonce || this.cryptoUtils.createNewGuid(), p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath, q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : undefined, client_claims: shrClaims || undefined }, claims), keyId, request.correlationId)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    return PopTokenGenerator;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * APP_METADATA Cache
	 *
	 * Key:Value Schema:
	 *
	 * Key: appmetadata-<environment>-<client_id>
	 *
	 * Value:
	 * {
	 *      clientId: client ID of the application
	 *      environment: entity that issued the token, represented as a full host
	 *      familyId: Family ID identifier, '1' represents Microsoft Family
	 * }
	 */
	var AppMetadataEntity = /** @class */ (function () {
	    function AppMetadataEntity() {
	    }
	    /**
	     * Generate AppMetadata Cache Key as per the schema: appmetadata-<environment>-<client_id>
	     */
	    AppMetadataEntity.prototype.generateAppMetadataKey = function () {
	        return AppMetadataEntity.generateAppMetadataCacheKey(this.environment, this.clientId);
	    };
	    /**
	     * Generate AppMetadata Cache Key
	     */
	    AppMetadataEntity.generateAppMetadataCacheKey = function (environment, clientId) {
	        var appMetaDataKeyArray = [
	            APP_METADATA,
	            environment,
	            clientId,
	        ];
	        return appMetaDataKeyArray.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();
	    };
	    /**
	     * Creates AppMetadataEntity
	     * @param clientId
	     * @param environment
	     * @param familyId
	     */
	    AppMetadataEntity.createAppMetadataEntity = function (clientId, environment, familyId) {
	        var appMetadata = new AppMetadataEntity();
	        appMetadata.clientId = clientId;
	        appMetadata.environment = environment;
	        if (familyId) {
	            appMetadata.familyId = familyId;
	        }
	        return appMetadata;
	    };
	    /**
	     * Validates an entity: checks for all expected params
	     * @param entity
	     */
	    AppMetadataEntity.isAppMetadataEntity = function (key, entity) {
	        if (!entity) {
	            return false;
	        }
	        return (key.indexOf(APP_METADATA) === 0 &&
	            entity.hasOwnProperty("clientId") &&
	            entity.hasOwnProperty("environment"));
	    };
	    return AppMetadataEntity;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * This class instance helps track the memory changes facilitating
	 * decisions to read from and write to the persistent cache
	 */ var TokenCacheContext = /** @class */ (function () {
	    function TokenCacheContext(tokenCache, hasChanged) {
	        this.cache = tokenCache;
	        this.hasChanged = hasChanged;
	    }
	    Object.defineProperty(TokenCacheContext.prototype, "cacheHasChanged", {
	        /**
	         * boolean which indicates the changes in cache
	         */
	        get: function () {
	            return this.hasChanged;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(TokenCacheContext.prototype, "tokenCache", {
	        /**
	         * function to retrieve the token cache
	         */
	        get: function () {
	            return this.cache;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    return TokenCacheContext;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Class that handles response parsing.
	 */
	var ResponseHandler = /** @class */ (function () {
	    function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {
	        this.clientId = clientId;
	        this.cacheStorage = cacheStorage;
	        this.cryptoObj = cryptoObj;
	        this.logger = logger;
	        this.serializableCache = serializableCache;
	        this.persistencePlugin = persistencePlugin;
	        this.performanceClient = performanceClient;
	    }
	    /**
	     * Function which validates server authorization code response.
	     * @param serverResponseHash
	     * @param cachedState
	     * @param cryptoObj
	     */
	    ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {
	        if (!serverResponseHash.state || !cachedState) {
	            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError("Server State") : ClientAuthError.createStateNotFoundError("Cached State");
	        }
	        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {
	            throw ClientAuthError.createStateMismatchError();
	        }
	        // Check for error
	        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {
	            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {
	                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);
	            }
	            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);
	        }
	        if (serverResponseHash.client_info) {
	            buildClientInfo(serverResponseHash.client_info, cryptoObj);
	        }
	    };
	    /**
	     * Function which validates server authorization token response.
	     * @param serverResponse
	     */
	    ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {
	        // Check for error
	        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {
	            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
	                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);
	            }
	            var errString = serverResponse.error_codes + " - [" + serverResponse.timestamp + "]: " + serverResponse.error_description + " - Correlation ID: " + serverResponse.correlation_id + " - Trace ID: " + serverResponse.trace_id;
	            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);
	        }
	    };
	    /**
	     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
	     * @param serverTokenResponse
	     * @param authority
	     */
	    ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
	        var _a;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;
	            return __generator$2(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
	                        if (serverTokenResponse.id_token) {
	                            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);
	                            // token nonce check (TODO: Add a warning if no nonce is given?)
	                            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {
	                                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {
	                                    throw ClientAuthError.createNonceMismatchError();
	                                }
	                            }
	                            // token max_age check
	                            if (request.maxAge || (request.maxAge === 0)) {
	                                authTime = idTokenObj.claims.auth_time;
	                                if (!authTime) {
	                                    throw ClientAuthError.createAuthTimeNotFoundError();
	                                }
	                                AuthToken.checkMaxAge(authTime, request.maxAge);
	                            }
	                        }
	                        // generate homeAccountId
	                        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);
	                        if (!!authCodePayload && !!authCodePayload.state) {
	                            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
	                        }
	                        // Add keyId from request to serverTokenResponse if defined
	                        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;
	                        cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, , 5, 8]);
	                        if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];
	                        this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
	                        cacheContext = new TokenCacheContext(this.serializableCache, true);
	                        return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];
	                    case 2:
	                        _b.sent();
	                        _b.label = 3;
	                    case 3:
	                        /*
	                         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.
	                         * If not present, we should return null, as it's the case that another application called removeAccount in between
	                         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by
	                         * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.
	                         */
	                        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {
	                            key = cacheRecord.account.generateAccountKey();
	                            account = this.cacheStorage.getAccount(key);
	                            if (!account) {
	                                this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
	                                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];
	                            }
	                        }
	                        return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];
	                    case 4:
	                        _b.sent();
	                        return [3 /*break*/, 8];
	                    case 5:
	                        if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];
	                        this.logger.verbose("Persistence enabled, calling afterCacheAccess");
	                        return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];
	                    case 6:
	                        _b.sent();
	                        _b.label = 7;
	                    case 7: return [7 /*endfinally*/];
	                    case 8: return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];
	                }
	            });
	        });
	    };
	    /**
	     * Generates CacheRecord
	     * @param serverTokenResponse
	     * @param idTokenObj
	     * @param authority
	     */
	    ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {
	        var env = authority.getPreferredCache();
	        if (StringUtils.isEmpty(env)) {
	            throw ClientAuthError.createInvalidCacheEnvironmentError();
	        }
	        // IdToken: non AAD scenarios can have empty realm
	        var cachedIdToken;
	        var cachedAccount;
	        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {
	            cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);
	            cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);
	        }
	        // AccessToken
	        var cachedAccessToken = null;
	        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {
	            // If scopes not returned in server response, use request scopes
	            var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);
	            /*
	             * Use timestamp calculated before request
	             * Server may return timestamps as strings, parse to numbers if so.
	             */
	            var expiresIn = (typeof serverTokenResponse.expires_in === "string" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;
	            var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;
	            var refreshIn = (typeof serverTokenResponse.refresh_in === "string" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;
	            var tokenExpirationSeconds = reqTimestamp + expiresIn;
	            var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
	            var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;
	            // non AAD scenarios can have empty realm
	            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
	        }
	        // refreshToken
	        var cachedRefreshToken = null;
	        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {
	            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);
	        }
	        // appMetadata
	        var cachedAppMetadata = null;
	        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {
	            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);
	        }
	        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);
	    };
	    /**
	     * Generate Account
	     * @param serverTokenResponse
	     * @param idToken
	     * @param authority
	     */
	    ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {
	        var authorityType = authority.authorityType;
	        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;
	        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;
	        // ADFS does not require client_info in the response
	        if (authorityType === AuthorityType.Adfs) {
	            this.logger.verbose("Authority type is ADFS, creating ADFS account");
	            return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
	        }
	        // This fallback applies to B2C as well as they fall under an AAD account type.
	        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === "AAD") {
	            throw ClientAuthError.createClientInfoEmptyError();
	        }
	        return serverTokenResponse.client_info ?
	            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) :
	            AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);
	    };
	    /**
	     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
	     *
	     * Optionally takes a state string that is set as-is in the response.
	     *
	     * @param cacheRecord
	     * @param idTokenObj
	     * @param fromTokenCache
	     * @param stateString
	     */
	    ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {
	        var _a, _b, _c;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;
	            return __generator$2(this, function (_e) {
	                switch (_e.label) {
	                    case 0:
	                        accessToken = Constants.EMPTY_STRING;
	                        responseScopes = [];
	                        expiresOn = null;
	                        familyId = Constants.EMPTY_STRING;
	                        if (!cacheRecord.accessToken) return [3 /*break*/, 4];
	                        if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];
	                        popTokenGenerator = new PopTokenGenerator(cryptoObj);
	                        _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;
	                        if (!keyId) {
	                            throw ClientAuthError.createKeyIdMissingError();
	                        }
	                        return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];
	                    case 1:
	                        accessToken = _e.sent();
	                        return [3 /*break*/, 3];
	                    case 2:
	                        accessToken = cacheRecord.accessToken.secret;
	                        _e.label = 3;
	                    case 3:
	                        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
	                        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);
	                        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);
	                        _e.label = 4;
	                    case 4:
	                        if (cacheRecord.appMetadata) {
	                            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;
	                        }
	                        uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;
	                        tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;
	                        // for hybrid + native bridge enablement, send back the native account Id
	                        if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {
	                            cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;
	                        }
	                        return [2 /*return*/, {
	                                authority: authority.canonicalAuthority,
	                                uniqueId: uid,
	                                tenantId: tid,
	                                scopes: responseScopes,
	                                account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,
	                                idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,
	                                idTokenClaims: idTokenObj ? idTokenObj.claims : {},
	                                accessToken: accessToken,
	                                fromCache: fromTokenCache,
	                                expiresOn: expiresOn,
	                                correlationId: request.correlationId,
	                                requestId: requestId || Constants.EMPTY_STRING,
	                                extExpiresOn: extExpiresOn,
	                                familyId: familyId,
	                                tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,
	                                state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,
	                                cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,
	                                msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,
	                                code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,
	                                fromNativeBroker: false,
	                            }];
	                }
	            });
	        });
	    };
	    return ResponseHandler;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Oauth2.0 Authorization Code client
	 */
	var AuthorizationCodeClient = /** @class */ (function (_super) {
	    __extends$f(AuthorizationCodeClient, _super);
	    function AuthorizationCodeClient(configuration, performanceClient) {
	        var _this = _super.call(this, configuration, performanceClient) || this;
	        // Flag to indicate if client is for hybrid spa auth code redemption
	        _this.includeRedirectUri = true;
	        return _this;
	    }
	    /**
	     * Creates the URL of the authorization request letting the user input credentials and consent to the
	     * application. The URL target the /authorize endpoint of the authority configured in the
	     * application object.
	     *
	     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
	     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
	     * acquireToken(AuthorizationCodeRequest)
	     * @param request
	     */
	    AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {
	        var _a, _b;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var queryString;
	            return __generator$2(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);
	                        return [4 /*yield*/, this.createAuthCodeUrlQueryString(request)];
	                    case 1:
	                        queryString = _c.sent();
	                        return [2 /*return*/, UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];
	                }
	            });
	        });
	    };
	    /**
	     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
	     * authorization_code_grant
	     * @param request
	     */
	    AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {
	        var _a, _b, _c, _d, _e, _f;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var atsMeasurement, reqTimestamp, response, requestId, httpVerAuthority, responseHandler;
	            var _this = this;
	            return __generator$2(this, function (_g) {
	                switch (_g.label) {
	                    case 0:
	                        if (!request || !request.code) {
	                            throw ClientAuthError.createTokenRequestCannotBeMadeError();
	                        }
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
	                        atsMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement("AuthCodeClientAcquireToken", request.correlationId);
	                        this.logger.info("in acquireToken call in auth-code client");
	                        reqTimestamp = TimeUtils.nowSeconds();
	                        (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
	                        return [4 /*yield*/, this.executeTokenRequest(this.authority, request)];
	                    case 1:
	                        response = _g.sent();
	                        requestId = (_d = response.headers) === null || _d === void 0 ? void 0 : _d[HeaderNames.X_MS_REQUEST_ID];
	                        httpVerAuthority = (_e = response.headers) === null || _e === void 0 ? void 0 : _e[HeaderNames.X_MS_HTTP_VERSION];
	                        if (httpVerAuthority) {
	                            atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({
	                                httpVerAuthority: httpVerAuthority
	                            });
	                        }
	                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
	                        // Validate response. This function throws a server error if an error is returned by the server.
	                        responseHandler.validateTokenResponse(response.body);
	                        (_f = this.performanceClient) === null || _f === void 0 ? void 0 : _f.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);
	                        return [2 /*return*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId).then(function (result) {
	                                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
	                                    success: true
	                                });
	                                return result;
	                            })
	                                .catch(function (error) {
	                                _this.logger.verbose("Error in fetching token in ACC", request.correlationId);
	                                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
	                                    errorCode: error.errorCode,
	                                    subErrorCode: error.subError,
	                                    success: false
	                                });
	                                throw error;
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Handles the hash fragment response from public client code request. Returns a code response used by
	     * the client to exchange for a token in acquireToken.
	     * @param hashFragment
	     */
	    AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {
	        // Handle responses.
	        var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);
	        // Deserialize hash fragment response parameters.
	        var hashUrlString = new UrlString(hashFragment);
	        // Deserialize hash fragment response parameters.
	        var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash());
	        // Get code response
	        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);
	        // throw when there is no auth code in the response
	        if (!serverParams.code) {
	            throw ClientAuthError.createNoAuthCodeInServerResponseError();
	        }
	        return __assign$4(__assign$4({}, serverParams), { 
	            // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod
	            code: serverParams.code });
	    };
	    /**
	     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
	     * Default behaviour is to redirect the user to `window.location.href`.
	     * @param authorityUri
	     */
	    AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {
	        // Throw error if logoutRequest is null/undefined
	        if (!logoutRequest) {
	            throw ClientConfigurationError.createEmptyLogoutRequestError();
	        }
	        var queryString = this.createLogoutUrlQueryString(logoutRequest);
	        // Construct logout URI
	        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
	    };
	    /**
	     * Executes POST request to token endpoint
	     * @param authority
	     * @param request
	     */
	    AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {
	        var _a, _b;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var queryParametersString, endpoint, requestBody, ccsCredential, clientInfo, headers, thumbprint;
	            return __generator$2(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
	                        queryParametersString = this.createTokenQueryParameters(request);
	                        endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
	                        return [4 /*yield*/, this.createTokenRequestBody(request)];
	                    case 1:
	                        requestBody = _c.sent();
	                        ccsCredential = undefined;
	                        if (request.clientInfo) {
	                            try {
	                                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
	                                ccsCredential = {
	                                    credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
	                                    type: CcsCredentialType.HOME_ACCOUNT_ID
	                                };
	                            }
	                            catch (e) {
	                                this.logger.verbose("Could not parse client info for CCS Header: " + e);
	                            }
	                        }
	                        headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
	                        thumbprint = {
	                            clientId: this.config.authOptions.clientId,
	                            authority: authority.canonicalAuthority,
	                            scopes: request.scopes,
	                            claims: request.claims,
	                            authenticationScheme: request.authenticationScheme,
	                            resourceRequestMethod: request.resourceRequestMethod,
	                            resourceRequestUri: request.resourceRequestUri,
	                            shrClaims: request.shrClaims,
	                            sshKid: request.sshKid
	                        };
	                        return [2 /*return*/, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];
	                }
	            });
	        });
	    };
	    /**
	     * Generates a map for all the params to be sent to the service
	     * @param request
	     */
	    AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {
	        var _a, _b;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, correlationId, ccsCred, clientInfo, clientInfo;
	            var _c;
	            return __generator$2(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
	                        parameterBuilder = new RequestParameterBuilder();
	                        parameterBuilder.addClientId(this.config.authOptions.clientId);
	                        /*
	                         * For hybrid spa flow, there will be a code but no verifier
	                         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI
	                         */
	                        if (!this.includeRedirectUri) {
	                            // Just validate
	                            RequestValidator.validateRedirectUri(request.redirectUri);
	                        }
	                        else {
	                            // Validate and include redirect uri
	                            parameterBuilder.addRedirectUri(request.redirectUri);
	                        }
	                        // Add scope array, parameter builder will add default scopes and dedupe
	                        parameterBuilder.addScopes(request.scopes);
	                        // add code: user set, not validated
	                        parameterBuilder.addAuthorizationCode(request.code);
	                        // Add library metadata
	                        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
	                        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
	                        parameterBuilder.addThrottling();
	                        if (this.serverTelemetryManager) {
	                            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
	                        }
	                        // add code_verifier if passed
	                        if (request.codeVerifier) {
	                            parameterBuilder.addCodeVerifier(request.codeVerifier);
	                        }
	                        if (this.config.clientCredentials.clientSecret) {
	                            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
	                        }
	                        if (this.config.clientCredentials.clientAssertion) {
	                            clientAssertion = this.config.clientCredentials.clientAssertion;
	                            parameterBuilder.addClientAssertion(clientAssertion.assertion);
	                            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
	                        }
	                        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);
	                        parameterBuilder.addClientInfo();
	                        if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 2];
	                        popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
	                        return [4 /*yield*/, popTokenGenerator.generateCnf(request)];
	                    case 1:
	                        reqCnfData = _d.sent();
	                        // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
	                        parameterBuilder.addPopToken(reqCnfData.reqCnfString);
	                        return [3 /*break*/, 3];
	                    case 2:
	                        if (request.authenticationScheme === AuthenticationScheme.SSH) {
	                            if (request.sshJwk) {
	                                parameterBuilder.addSshJwk(request.sshJwk);
	                            }
	                            else {
	                                throw ClientConfigurationError.createMissingSshJwkError();
	                            }
	                        }
	                        _d.label = 3;
	                    case 3:
	                        correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
	                        parameterBuilder.addCorrelationId(correlationId);
	                        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
	                            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
	                        }
	                        ccsCred = undefined;
	                        if (request.clientInfo) {
	                            try {
	                                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);
	                                ccsCred = {
	                                    credential: "" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,
	                                    type: CcsCredentialType.HOME_ACCOUNT_ID
	                                };
	                            }
	                            catch (e) {
	                                this.logger.verbose("Could not parse client info for CCS Header: " + e);
	                            }
	                        }
	                        else {
	                            ccsCred = request.ccsCredential;
	                        }
	                        // Adds these as parameters in the request instead of headers to prevent CORS preflight request
	                        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
	                            switch (ccsCred.type) {
	                                case CcsCredentialType.HOME_ACCOUNT_ID:
	                                    try {
	                                        clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
	                                        parameterBuilder.addCcsOid(clientInfo);
	                                    }
	                                    catch (e) {
	                                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
	                                    }
	                                    break;
	                                case CcsCredentialType.UPN:
	                                    parameterBuilder.addCcsUpn(ccsCred.credential);
	                                    break;
	                            }
	                        }
	                        if (request.tokenBodyParameters) {
	                            parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);
	                        }
	                        // Add hybrid spa parameters if not already provided
	                        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {
	                            parameterBuilder.addExtraQueryParameters((_c = {},
	                                _c[AADServerParamKeys.RETURN_SPA_CODE] = "1",
	                                _c));
	                        }
	                        return [2 /*return*/, parameterBuilder.createQueryString()];
	                }
	            });
	        });
	    };
	    /**
	     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL
	     * @param request
	     */
	    AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {
	        var _a;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var parameterBuilder, requestScopes, correlationId, accountSid, accountLoginHintClaim, clientInfo, clientInfo, clientInfo, popTokenGenerator, reqCnfData;
	            return __generator$2(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);
	                        parameterBuilder = new RequestParameterBuilder();
	                        parameterBuilder.addClientId(this.config.authOptions.clientId);
	                        requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);
	                        parameterBuilder.addScopes(requestScopes);
	                        // validate the redirectUri (to be a non null value)
	                        parameterBuilder.addRedirectUri(request.redirectUri);
	                        correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();
	                        parameterBuilder.addCorrelationId(correlationId);
	                        // add response_mode. If not passed in it defaults to query.
	                        parameterBuilder.addResponseMode(request.responseMode);
	                        // add response_type = code
	                        parameterBuilder.addResponseTypeCode();
	                        // add library info parameters
	                        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
	                        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
	                        // add client_info=1
	                        parameterBuilder.addClientInfo();
	                        if (request.codeChallenge && request.codeChallengeMethod) {
	                            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);
	                        }
	                        if (request.prompt) {
	                            parameterBuilder.addPrompt(request.prompt);
	                        }
	                        if (request.domainHint) {
	                            parameterBuilder.addDomainHint(request.domainHint);
	                        }
	                        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object
	                        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
	                            // AAD will throw if prompt=select_account is passed with an account hint
	                            if (request.sid && request.prompt === PromptValue.NONE) {
	                                // SessionID is only used in silent calls
	                                this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
	                                parameterBuilder.addSid(request.sid);
	                            }
	                            else if (request.account) {
	                                accountSid = this.extractAccountSid(request.account);
	                                accountLoginHintClaim = this.extractLoginHint(request.account);
	                                // If login_hint claim is present, use it over sid/username
	                                if (accountLoginHintClaim) {
	                                    this.logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
	                                    parameterBuilder.addLoginHint(accountLoginHintClaim);
	                                    try {
	                                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
	                                        parameterBuilder.addCcsOid(clientInfo);
	                                    }
	                                    catch (e) {
	                                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
	                                    }
	                                }
	                                else if (accountSid && request.prompt === PromptValue.NONE) {
	                                    /*
	                                     * If account and loginHint are provided, we will check account first for sid before adding loginHint
	                                     * SessionId is only used in silent calls
	                                     */
	                                    this.logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
	                                    parameterBuilder.addSid(accountSid);
	                                    try {
	                                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
	                                        parameterBuilder.addCcsOid(clientInfo);
	                                    }
	                                    catch (e) {
	                                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
	                                    }
	                                }
	                                else if (request.loginHint) {
	                                    this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
	                                    parameterBuilder.addLoginHint(request.loginHint);
	                                    parameterBuilder.addCcsUpn(request.loginHint);
	                                }
	                                else if (request.account.username) {
	                                    // Fallback to account username if provided
	                                    this.logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
	                                    parameterBuilder.addLoginHint(request.account.username);
	                                    try {
	                                        clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
	                                        parameterBuilder.addCcsOid(clientInfo);
	                                    }
	                                    catch (e) {
	                                        this.logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
	                                    }
	                                }
	                            }
	                            else if (request.loginHint) {
	                                this.logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
	                                parameterBuilder.addLoginHint(request.loginHint);
	                                parameterBuilder.addCcsUpn(request.loginHint);
	                            }
	                        }
	                        else {
	                            this.logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
	                        }
	                        if (request.nonce) {
	                            parameterBuilder.addNonce(request.nonce);
	                        }
	                        if (request.state) {
	                            parameterBuilder.addState(request.state);
	                        }
	                        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
	                            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
	                        }
	                        if (request.extraQueryParameters) {
	                            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
	                        }
	                        if (!request.nativeBroker) return [3 /*break*/, 2];
	                        // signal ests that this is a WAM call
	                        parameterBuilder.addNativeBroker();
	                        if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 2];
	                        popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);
	                        return [4 /*yield*/, popTokenGenerator.generateCnf(request)];
	                    case 1:
	                        reqCnfData = _b.sent();
	                        parameterBuilder.addPopToken(reqCnfData.reqCnfString);
	                        _b.label = 2;
	                    case 2: return [2 /*return*/, parameterBuilder.createQueryString()];
	                }
	            });
	        });
	    };
	    /**
	     * This API validates the `EndSessionRequest` and creates a URL
	     * @param request
	     */
	    AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {
	        var parameterBuilder = new RequestParameterBuilder();
	        if (request.postLogoutRedirectUri) {
	            parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);
	        }
	        if (request.correlationId) {
	            parameterBuilder.addCorrelationId(request.correlationId);
	        }
	        if (request.idTokenHint) {
	            parameterBuilder.addIdTokenHint(request.idTokenHint);
	        }
	        if (request.state) {
	            parameterBuilder.addState(request.state);
	        }
	        if (request.logoutHint) {
	            parameterBuilder.addLogoutHint(request.logoutHint);
	        }
	        if (request.extraQueryParameters) {
	            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);
	        }
	        return parameterBuilder.createQueryString();
	    };
	    /**
	     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.
	     * @param account
	     */
	    AuthorizationCodeClient.prototype.extractAccountSid = function (account) {
	        var _a;
	        return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.sid) || null;
	    };
	    AuthorizationCodeClient.prototype.extractLoginHint = function (account) {
	        var _a;
	        return ((_a = account.idTokenClaims) === null || _a === void 0 ? void 0 : _a.login_hint) || null;
	    };
	    return AuthorizationCodeClient;
	}(BaseClient));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * OAuth2.0 refresh token client
	 */
	var RefreshTokenClient = /** @class */ (function (_super) {
	    __extends$f(RefreshTokenClient, _super);
	    function RefreshTokenClient(configuration, performanceClient) {
	        return _super.call(this, configuration, performanceClient) || this;
	    }
	    RefreshTokenClient.prototype.acquireToken = function (request) {
	        var _a, _b, _c, _d, _e, _f, _g;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var atsMeasurement, reqTimestamp, response, httpVerToken, requestId, responseHandler;
	            var _this = this;
	            return __generator$2(this, function (_h) {
	                switch (_h.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
	                        atsMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
	                        this.logger.verbose("RefreshTokenClientAcquireToken called", request.correlationId);
	                        reqTimestamp = TimeUtils.nowSeconds();
	                        (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
	                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority)];
	                    case 1:
	                        response = _h.sent();
	                        httpVerToken = (_d = response.headers) === null || _d === void 0 ? void 0 : _d[HeaderNames.X_MS_HTTP_VERSION];
	                        atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({
	                            refreshTokenSize: ((_e = response.body.refresh_token) === null || _e === void 0 ? void 0 : _e.length) || 0,
	                        });
	                        if (httpVerToken) {
	                            atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.addStaticFields({
	                                httpVerToken: httpVerToken,
	                            });
	                        }
	                        requestId = (_f = response.headers) === null || _f === void 0 ? void 0 : _f[HeaderNames.X_MS_REQUEST_ID];
	                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
	                        responseHandler.validateTokenResponse(response.body);
	                        (_g = this.performanceClient) === null || _g === void 0 ? void 0 : _g.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);
	                        return [2 /*return*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, undefined, true, request.forceCache, requestId).then(function (result) {
	                                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
	                                    success: true
	                                });
	                                return result;
	                            })
	                                .catch(function (error) {
	                                _this.logger.verbose("Error in fetching refresh token", request.correlationId);
	                                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
	                                    errorCode: error.errorCode,
	                                    subErrorCode: error.subError,
	                                    success: false
	                                });
	                                throw error;
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Gets cached refresh token and attaches to request, then calls acquireToken API
	     * @param request
	     */
	    RefreshTokenClient.prototype.acquireTokenByRefreshToken = function (request) {
	        var _a, _b, _c, _d;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var isFOCI, noFamilyRTInCache, clientMismatchErrorWithFamilyRT;
	            return __generator$2(this, function (_e) {
	                // Cannot renew token if no request object is given.
	                if (!request) {
	                    throw ClientConfigurationError.createEmptyTokenRequestError();
	                }
	                (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
	                // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
	                if (!request.account) {
	                    throw ClientAuthError.createNoAccountInSilentRequestError();
	                }
	                isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
	                // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest
	                if (isFOCI) {
	                    try {
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
	                        return [2 /*return*/, this.acquireTokenWithCachedRefreshToken(request, true)];
	                    }
	                    catch (e) {
	                        noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;
	                        clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;
	                        // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)
	                        if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
	                            (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
	                            return [2 /*return*/, this.acquireTokenWithCachedRefreshToken(request, false)];
	                            // throw in all other cases
	                        }
	                        else {
	                            throw e;
	                        }
	                    }
	                }
	                // fall back to application refresh token acquisition
	                (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
	                return [2 /*return*/, this.acquireTokenWithCachedRefreshToken(request, false)];
	            });
	        });
	    };
	    /**
	     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
	     * @param request
	     */
	    RefreshTokenClient.prototype.acquireTokenWithCachedRefreshToken = function (request, foci) {
	        var _a, _b, _c;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var atsMeasurement, refreshToken, refreshTokenRequest;
	            return __generator$2(this, function (_d) {
	                (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
	                atsMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
	                this.logger.verbose("RefreshTokenClientAcquireTokenWithCachedRefreshToken called", request.correlationId);
	                refreshToken = this.cacheManager.getRefreshToken(request.account, foci);
	                if (!refreshToken) {
	                    atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.discardMeasurement();
	                    throw InteractionRequiredAuthError.createNoTokensFoundError();
	                }
	                // attach cached RT size to the current measurement
	                atsMeasurement === null || atsMeasurement === void 0 ? void 0 : atsMeasurement.endMeasurement({
	                    success: true
	                });
	                refreshTokenRequest = __assign$4(__assign$4({}, request), { refreshToken: refreshToken.secret, authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER, ccsCredential: {
	                        credential: request.account.homeAccountId,
	                        type: CcsCredentialType.HOME_ACCOUNT_ID
	                    } });
	                (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
	                return [2 /*return*/, this.acquireToken(refreshTokenRequest)];
	            });
	        });
	    };
	    /**
	     * Constructs the network message and makes a NW call to the underlying secure token service
	     * @param request
	     * @param authority
	     */
	    RefreshTokenClient.prototype.executeTokenRequest = function (request, authority) {
	        var _a, _b, _c;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var acquireTokenMeasurement, queryParametersString, endpoint, requestBody, headers, thumbprint;
	            return __generator$2(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
	                        acquireTokenMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
	                        (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
	                        queryParametersString = this.createTokenQueryParameters(request);
	                        endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
	                        return [4 /*yield*/, this.createTokenRequestBody(request)];
	                    case 1:
	                        requestBody = _d.sent();
	                        headers = this.createTokenRequestHeaders(request.ccsCredential);
	                        thumbprint = {
	                            clientId: this.config.authOptions.clientId,
	                            authority: authority.canonicalAuthority,
	                            scopes: request.scopes,
	                            claims: request.claims,
	                            authenticationScheme: request.authenticationScheme,
	                            resourceRequestMethod: request.resourceRequestMethod,
	                            resourceRequestUri: request.resourceRequestUri,
	                            shrClaims: request.shrClaims,
	                            sshKid: request.sshKid
	                        };
	                        return [2 /*return*/, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)
	                                .then(function (result) {
	                                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
	                                    success: true
	                                });
	                                return result;
	                            })
	                                .catch(function (error) {
	                                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
	                                    success: false
	                                });
	                                throw error;
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Helper function to create the token request body
	     * @param request
	     */
	    RefreshTokenClient.prototype.createTokenRequestBody = function (request) {
	        var _a, _b, _c;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var correlationId, acquireTokenMeasurement, parameterBuilder, clientAssertion, popTokenGenerator, reqCnfData, clientInfo;
	            return __generator$2(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
	                        correlationId = request.correlationId;
	                        acquireTokenMeasurement = (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.startMeasurement(PerformanceEvents.BaseClientCreateTokenRequestHeaders, correlationId);
	                        parameterBuilder = new RequestParameterBuilder();
	                        parameterBuilder.addClientId(this.config.authOptions.clientId);
	                        parameterBuilder.addScopes(request.scopes);
	                        parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);
	                        parameterBuilder.addClientInfo();
	                        parameterBuilder.addLibraryInfo(this.config.libraryInfo);
	                        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);
	                        parameterBuilder.addThrottling();
	                        if (this.serverTelemetryManager) {
	                            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);
	                        }
	                        parameterBuilder.addCorrelationId(correlationId);
	                        parameterBuilder.addRefreshToken(request.refreshToken);
	                        if (this.config.clientCredentials.clientSecret) {
	                            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);
	                        }
	                        if (this.config.clientCredentials.clientAssertion) {
	                            clientAssertion = this.config.clientCredentials.clientAssertion;
	                            parameterBuilder.addClientAssertion(clientAssertion.assertion);
	                            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);
	                        }
	                        if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 2];
	                        popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
	                        (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
	                        return [4 /*yield*/, popTokenGenerator.generateCnf(request)];
	                    case 1:
	                        reqCnfData = _d.sent();
	                        // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
	                        parameterBuilder.addPopToken(reqCnfData.reqCnfString);
	                        return [3 /*break*/, 3];
	                    case 2:
	                        if (request.authenticationScheme === AuthenticationScheme.SSH) {
	                            if (request.sshJwk) {
	                                parameterBuilder.addSshJwk(request.sshJwk);
	                            }
	                            else {
	                                acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
	                                    success: false
	                                });
	                                throw ClientConfigurationError.createMissingSshJwkError();
	                            }
	                        }
	                        _d.label = 3;
	                    case 3:
	                        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {
	                            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);
	                        }
	                        if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {
	                            switch (request.ccsCredential.type) {
	                                case CcsCredentialType.HOME_ACCOUNT_ID:
	                                    try {
	                                        clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
	                                        parameterBuilder.addCcsOid(clientInfo);
	                                    }
	                                    catch (e) {
	                                        this.logger.verbose("Could not parse home account ID for CCS Header: " + e);
	                                    }
	                                    break;
	                                case CcsCredentialType.UPN:
	                                    parameterBuilder.addCcsUpn(request.ccsCredential.credential);
	                                    break;
	                            }
	                        }
	                        acquireTokenMeasurement === null || acquireTokenMeasurement === void 0 ? void 0 : acquireTokenMeasurement.endMeasurement({
	                            success: true
	                        });
	                        return [2 /*return*/, parameterBuilder.createQueryString()];
	                }
	            });
	        });
	    };
	    return RefreshTokenClient;
	}(BaseClient));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var SilentFlowClient = /** @class */ (function (_super) {
	    __extends$f(SilentFlowClient, _super);
	    function SilentFlowClient(configuration, performanceClient) {
	        return _super.call(this, configuration, performanceClient) || this;
	    }
	    /**
	     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew
	     * the given token and returns the renewed token
	     * @param request
	     */
	    SilentFlowClient.prototype.acquireToken = function (request) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var e_1, refreshTokenClient;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        _a.trys.push([0, 2, , 3]);
	                        return [4 /*yield*/, this.acquireCachedToken(request)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                    case 2:
	                        e_1 = _a.sent();
	                        if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {
	                            refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);
	                            return [2 /*return*/, refreshTokenClient.acquireTokenByRefreshToken(request)];
	                        }
	                        else {
	                            throw e_1;
	                        }
	                    case 3: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Retrieves token from cache or throws an error if it must be refreshed.
	     * @param request
	     */
	    SilentFlowClient.prototype.acquireCachedToken = function (request) {
	        var _a, _b, _c, _d, _e;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var environment, cacheRecord;
	            return __generator$2(this, function (_f) {
	                switch (_f.label) {
	                    case 0:
	                        // Cannot renew token if no request object is given.
	                        if (!request) {
	                            throw ClientConfigurationError.createEmptyTokenRequestError();
	                        }
	                        if (request.forceRefresh) {
	                            // Must refresh due to present force_refresh flag.
	                            (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);
	                            this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.");
	                            throw ClientAuthError.createRefreshRequiredError();
	                        }
	                        else if (!this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {
	                            // Must refresh due to presence of claims in request preventing cache lookup
	                            (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CLAIMS_REQUESTED_CACHE_SKIPPED);
	                            this.logger.info("SilentFlowClient:acquireCachedToken - Skipping cache because claims-based caching is disabled and claims were requested.");
	                            throw ClientAuthError.createRefreshRequiredError();
	                        }
	                        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
	                        if (!request.account) {
	                            throw ClientAuthError.createNoAccountInSilentRequestError();
	                        }
	                        environment = request.authority || this.authority.getPreferredCache();
	                        cacheRecord = this.cacheManager.readCacheRecord(request.account, request, environment);
	                        if (!cacheRecord.accessToken) {
	                            // Must refresh due to non-existent access_token.
	                            (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
	                            this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
	                            throw ClientAuthError.createRefreshRequiredError();
	                        }
	                        else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) ||
	                            TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
	                            // Must refresh due to expired access_token.
	                            (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
	                            this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within " + this.config.systemOptions.tokenRenewalOffsetSeconds + " seconds.");
	                            throw ClientAuthError.createRefreshRequiredError();
	                        }
	                        else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {
	                            // Must refresh due to the refresh_in value.
	                            (_e = this.serverTelemetryManager) === null || _e === void 0 ? void 0 : _e.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);
	                            this.logger.info("SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.");
	                            throw ClientAuthError.createRefreshRequiredError();
	                        }
	                        if (this.config.serverTelemetryManager) {
	                            this.config.serverTelemetryManager.incrementCacheHits();
	                        }
	                        return [4 /*yield*/, this.generateResultFromCacheRecord(cacheRecord, request)];
	                    case 1: return [2 /*return*/, _f.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Helper function to build response object from the CacheRecord
	     * @param cacheRecord
	     */
	    SilentFlowClient.prototype.generateResultFromCacheRecord = function (cacheRecord, request) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var idTokenObj, authTime;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (cacheRecord.idToken) {
	                            idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);
	                        }
	                        // token max_age check
	                        if (request.maxAge || (request.maxAge === 0)) {
	                            authTime = idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.auth_time;
	                            if (!authTime) {
	                                throw ClientAuthError.createAuthTimeNotFoundError();
	                            }
	                            AuthToken.checkMaxAge(authTime, request.maxAge);
	                        }
	                        return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    return SilentFlowClient;
	}(BaseClient));

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	function isOpenIdConfigResponse(response) {
	    return (response.hasOwnProperty("authorization_endpoint") &&
	        response.hasOwnProperty("token_endpoint") &&
	        response.hasOwnProperty("issuer") &&
	        response.hasOwnProperty("jwks_uri"));
	}

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var rawMetdataJSON = { "endpointMetadata": { "https://login.microsoftonline.com/common/": { "token_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/common/": { "token_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/common/": { "token_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/common/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/common/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/common/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/consumers/": { "token_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/consumers/": { "token_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/consumers/": { "token_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/consumers/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/9188040d-6c67-4c5b-b112-36a304b66dad/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/consumers/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/consumers/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" }, "https://login.microsoftonline.com/organizations/": { "token_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.com/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.com/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.com/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.com/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.com", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pas.windows.net" }, "https://login.chinacloudapi.cn/organizations/": { "token_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.chinacloudapi.cn/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.partner.microsoftonline.cn/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://microsoftgraph.chinacloudapi.cn/oidc/userinfo", "authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.chinacloudapi.cn/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.chinacloudapi.cn/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "partner.microsoftonline.cn", "cloud_graph_host_name": "graph.chinacloudapi.cn", "msgraph_host": "microsoftgraph.chinacloudapi.cn", "rbac_url": "https://pas.chinacloudapi.cn" }, "https://login.microsoftonline.us/organizations/": { "token_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/token", "token_endpoint_auth_methods_supported": ["client_secret_post", "private_key_jwt", "client_secret_basic"], "jwks_uri": "https://login.microsoftonline.us/organizations/discovery/v2.0/keys", "response_modes_supported": ["query", "fragment", "form_post"], "subject_types_supported": ["pairwise"], "id_token_signing_alg_values_supported": ["RS256"], "response_types_supported": ["code", "id_token", "code id_token", "id_token token"], "scopes_supported": ["openid", "profile", "email", "offline_access"], "issuer": "https://login.microsoftonline.us/{tenantid}/v2.0", "request_uri_parameter_supported": false, "userinfo_endpoint": "https://graph.microsoft.com/oidc/userinfo", "authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/authorize", "device_authorization_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/devicecode", "http_logout_supported": true, "frontchannel_logout_supported": true, "end_session_endpoint": "https://login.microsoftonline.us/organizations/oauth2/v2.0/logout", "claims_supported": ["sub", "iss", "cloud_instance_name", "cloud_instance_host_name", "cloud_graph_host_name", "msgraph_host", "aud", "exp", "iat", "auth_time", "acr", "nonce", "preferred_username", "name", "tid", "ver", "at_hash", "c_hash", "email"], "kerberos_endpoint": "https://login.microsoftonline.us/organizations/kerberos", "tenant_region_scope": null, "cloud_instance_name": "microsoftonline.us", "cloud_graph_host_name": "graph.windows.net", "msgraph_host": "graph.microsoft.com", "rbac_url": "https://pasff.usgovcloudapi.net" } }, "instanceDiscoveryMetadata": { "https://login.microsoftonline.com/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/common/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/common/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/common/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/consumers/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/consumers/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/consumers/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.com/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.chinacloudapi.cn/organizations/": { "tenant_discovery_endpoint": "https://login.chinacloudapi.cn/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] }, "https://login.microsoftonline.us/organizations/": { "tenant_discovery_endpoint": "https://login.microsoftonline.us/organizations/v2.0/.well-known/openid-configuration", "api-version": "1.1", "metadata": [{ "preferred_network": "login.microsoftonline.com", "preferred_cache": "login.windows.net", "aliases": ["login.microsoftonline.com", "login.windows.net", "login.microsoft.com", "sts.windows.net"] }, { "preferred_network": "login.partner.microsoftonline.cn", "preferred_cache": "login.partner.microsoftonline.cn", "aliases": ["login.partner.microsoftonline.cn", "login.chinacloudapi.cn"] }, { "preferred_network": "login.microsoftonline.de", "preferred_cache": "login.microsoftonline.de", "aliases": ["login.microsoftonline.de"] }, { "preferred_network": "login.microsoftonline.us", "preferred_cache": "login.microsoftonline.us", "aliases": ["login.microsoftonline.us", "login.usgovcloudapi.net"] }, { "preferred_network": "login-us.microsoftonline.com", "preferred_cache": "login-us.microsoftonline.com", "aliases": ["login-us.microsoftonline.com"] }] } } };
	var EndpointMetadata = rawMetdataJSON.endpointMetadata;
	var InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Protocol modes supported by MSAL.
	 */
	var ProtocolMode;
	(function (ProtocolMode) {
	    ProtocolMode["AAD"] = "AAD";
	    ProtocolMode["OIDC"] = "OIDC";
	})(ProtocolMode || (ProtocolMode = {}));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var AuthorityMetadataEntity = /** @class */ (function () {
	    function AuthorityMetadataEntity() {
	        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
	    }
	    /**
	     * Update the entity with new aliases, preferred_cache and preferred_network values
	     * @param metadata
	     * @param fromNetwork
	     */
	    AuthorityMetadataEntity.prototype.updateCloudDiscoveryMetadata = function (metadata, fromNetwork) {
	        this.aliases = metadata.aliases;
	        this.preferred_cache = metadata.preferred_cache;
	        this.preferred_network = metadata.preferred_network;
	        this.aliasesFromNetwork = fromNetwork;
	    };
	    /**
	     * Update the entity with new endpoints
	     * @param metadata
	     * @param fromNetwork
	     */
	    AuthorityMetadataEntity.prototype.updateEndpointMetadata = function (metadata, fromNetwork) {
	        this.authorization_endpoint = metadata.authorization_endpoint;
	        this.token_endpoint = metadata.token_endpoint;
	        this.end_session_endpoint = metadata.end_session_endpoint;
	        this.issuer = metadata.issuer;
	        this.endpointsFromNetwork = fromNetwork;
	        this.jwks_uri = metadata.jwks_uri;
	    };
	    /**
	     * Save the authority that was used to create this cache entry
	     * @param authority
	     */
	    AuthorityMetadataEntity.prototype.updateCanonicalAuthority = function (authority) {
	        this.canonical_authority = authority;
	    };
	    /**
	     * Reset the exiresAt value
	     */
	    AuthorityMetadataEntity.prototype.resetExpiresAt = function () {
	        this.expiresAt = TimeUtils.nowSeconds() + AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS;
	    };
	    /**
	     * Returns whether or not the data needs to be refreshed
	     */
	    AuthorityMetadataEntity.prototype.isExpired = function () {
	        return this.expiresAt <= TimeUtils.nowSeconds();
	    };
	    /**
	     * Validates an entity: checks for all expected params
	     * @param entity
	     */
	    AuthorityMetadataEntity.isAuthorityMetadataEntity = function (key, entity) {
	        if (!entity) {
	            return false;
	        }
	        return (key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 &&
	            entity.hasOwnProperty("aliases") &&
	            entity.hasOwnProperty("preferred_cache") &&
	            entity.hasOwnProperty("preferred_network") &&
	            entity.hasOwnProperty("canonical_authority") &&
	            entity.hasOwnProperty("authorization_endpoint") &&
	            entity.hasOwnProperty("token_endpoint") &&
	            entity.hasOwnProperty("issuer") &&
	            entity.hasOwnProperty("aliasesFromNetwork") &&
	            entity.hasOwnProperty("endpointsFromNetwork") &&
	            entity.hasOwnProperty("expiresAt") &&
	            entity.hasOwnProperty("jwks_uri"));
	    };
	    return AuthorityMetadataEntity;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	function isCloudInstanceDiscoveryResponse(response) {
	    return (response.hasOwnProperty("tenant_discovery_endpoint") &&
	        response.hasOwnProperty("metadata"));
	}

	/*! @azure/msal-common v13.3.1 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	function isCloudInstanceDiscoveryErrorResponse(response) {
	    return (response.hasOwnProperty("error") &&
	        response.hasOwnProperty("error_description"));
	}

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var RegionDiscovery = /** @class */ (function () {
	    function RegionDiscovery(networkInterface, performanceClient, correlationId) {
	        this.networkInterface = networkInterface;
	        this.performanceClient = performanceClient;
	        this.correlationId = correlationId;
	    }
	    /**
	     * Detect the region from the application's environment.
	     *
	     * @returns Promise<string | null>
	     */
	    RegionDiscovery.prototype.detectRegion = function (environmentRegion, regionDiscoveryMetadata) {
	        var _a, _b, _c, _d;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var autodetectedRegionName, options, localIMDSVersionResponse, currentIMDSVersion, currentIMDSVersionResponse;
	            return __generator$2(this, function (_e) {
	                switch (_e.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
	                        autodetectedRegionName = environmentRegion;
	                        if (!!autodetectedRegionName) return [3 /*break*/, 8];
	                        options = RegionDiscovery.IMDS_OPTIONS;
	                        _e.label = 1;
	                    case 1:
	                        _e.trys.push([1, 6, , 7]);
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
	                        return [4 /*yield*/, this.getRegionFromIMDS(Constants.IMDS_VERSION, options)];
	                    case 2:
	                        localIMDSVersionResponse = _e.sent();
	                        if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
	                            autodetectedRegionName = localIMDSVersionResponse.body;
	                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
	                        }
	                        if (!(localIMDSVersionResponse.status === ResponseCodes.httpBadRequest)) return [3 /*break*/, 5];
	                        (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
	                        return [4 /*yield*/, this.getCurrentVersion(options)];
	                    case 3:
	                        currentIMDSVersion = _e.sent();
	                        if (!currentIMDSVersion) {
	                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
	                            return [2 /*return*/, null];
	                        }
	                        (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
	                        return [4 /*yield*/, this.getRegionFromIMDS(currentIMDSVersion, options)];
	                    case 4:
	                        currentIMDSVersionResponse = _e.sent();
	                        if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {
	                            autodetectedRegionName = currentIMDSVersionResponse.body;
	                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;
	                        }
	                        _e.label = 5;
	                    case 5: return [3 /*break*/, 7];
	                    case 6:
	                        _e.sent();
	                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
	                        return [2 /*return*/, null];
	                    case 7: return [3 /*break*/, 9];
	                    case 8:
	                        regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;
	                        _e.label = 9;
	                    case 9:
	                        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION
	                        if (!autodetectedRegionName) {
	                            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;
	                        }
	                        return [2 /*return*/, autodetectedRegionName || null];
	                }
	            });
	        });
	    };
	    /**
	     * Make the call to the IMDS endpoint
	     *
	     * @param imdsEndpointUrl
	     * @returns Promise<NetworkResponse<string>>
	     */
	    RegionDiscovery.prototype.getRegionFromIMDS = function (version, options) {
	        var _a;
	        return __awaiter$2(this, void 0, void 0, function () {
	            return __generator$2(this, function (_b) {
	                (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
	                return [2 /*return*/, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?api-version=" + version + "&format=text", options, Constants.IMDS_TIMEOUT)];
	            });
	        });
	    };
	    /**
	     * Get the most recent version of the IMDS endpoint available
	     *
	     * @returns Promise<string | null>
	     */
	    RegionDiscovery.prototype.getCurrentVersion = function (options) {
	        var _a;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var response;
	            return __generator$2(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(Constants.IMDS_ENDPOINT + "?format=json", options)];
	                    case 2:
	                        response = _b.sent();
	                        // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.
	                        if (response.status === ResponseCodes.httpBadRequest && response.body && response.body["newest-versions"] && response.body["newest-versions"].length > 0) {
	                            return [2 /*return*/, response.body["newest-versions"][0]];
	                        }
	                        return [2 /*return*/, null];
	                    case 3:
	                        _b.sent();
	                        return [2 /*return*/, null];
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    // Options for the IMDS endpoint request
	    RegionDiscovery.IMDS_OPTIONS = {
	        headers: {
	            Metadata: "true",
	        },
	    };
	    return RegionDiscovery;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the
	 * endpoint. It will store the pertinent config data in this object for use during token calls.
	 */
	var Authority = /** @class */ (function () {
	    function Authority(authority, networkInterface, cacheManager, authorityOptions, logger, performanceClient, correlationId) {
	        this.canonicalAuthority = authority;
	        this._canonicalAuthority.validateAsUri();
	        this.networkInterface = networkInterface;
	        this.cacheManager = cacheManager;
	        this.authorityOptions = authorityOptions;
	        this.regionDiscoveryMetadata = { region_used: undefined, region_source: undefined, region_outcome: undefined };
	        this.logger = logger;
	        this.performanceClient = performanceClient;
	        this.correlationId = correlationId;
	        this.regionDiscovery = new RegionDiscovery(networkInterface, this.performanceClient, this.correlationId);
	    }
	    /**
	     * Get {@link AuthorityType}
	     * @param authorityUri {@link IUri}
	     * @private
	     */
	    Authority.prototype.getAuthorityType = function (authorityUri) {
	        // CIAM auth url pattern is being standardized as: <tenant>.ciamlogin.com
	        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
	            return AuthorityType.Ciam;
	        }
	        var pathSegments = authorityUri.PathSegments;
	        if (pathSegments.length) {
	            switch (pathSegments[0].toLowerCase()) {
	                case Constants.ADFS:
	                    return AuthorityType.Adfs;
	                case Constants.DSTS:
	                    return AuthorityType.Dsts;
	            }
	        }
	        return AuthorityType.Default;
	    };
	    Object.defineProperty(Authority.prototype, "authorityType", {
	        // See above for AuthorityType
	        get: function () {
	            return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "protocolMode", {
	        /**
	         * ProtocolMode enum representing the way endpoints are constructed.
	         */
	        get: function () {
	            return this.authorityOptions.protocolMode;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "options", {
	        /**
	         * Returns authorityOptions which can be used to reinstantiate a new authority instance
	         */
	        get: function () {
	            return this.authorityOptions;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "canonicalAuthority", {
	        /**
	         * A URL that is the authority set by the developer
	         */
	        get: function () {
	            return this._canonicalAuthority.urlString;
	        },
	        /**
	         * Sets canonical authority.
	         */
	        set: function (url) {
	            this._canonicalAuthority = new UrlString(url);
	            this._canonicalAuthority.validateAsUri();
	            this._canonicalAuthorityUrlComponents = null;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "canonicalAuthorityUrlComponents", {
	        /**
	         * Get authority components.
	         */
	        get: function () {
	            if (!this._canonicalAuthorityUrlComponents) {
	                this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();
	            }
	            return this._canonicalAuthorityUrlComponents;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "hostnameAndPort", {
	        /**
	         * Get hostname and port i.e. login.microsoftonline.com
	         */
	        get: function () {
	            return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "tenant", {
	        /**
	         * Get tenant for authority.
	         */
	        get: function () {
	            return this.canonicalAuthorityUrlComponents.PathSegments[0];
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "authorizationEndpoint", {
	        /**
	         * OAuth /authorize endpoint for requests
	         */
	        get: function () {
	            if (this.discoveryComplete()) {
	                return this.replacePath(this.metadata.authorization_endpoint);
	            }
	            else {
	                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "tokenEndpoint", {
	        /**
	         * OAuth /token endpoint for requests
	         */
	        get: function () {
	            if (this.discoveryComplete()) {
	                return this.replacePath(this.metadata.token_endpoint);
	            }
	            else {
	                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "deviceCodeEndpoint", {
	        get: function () {
	            if (this.discoveryComplete()) {
	                return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
	            }
	            else {
	                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "endSessionEndpoint", {
	        /**
	         * OAuth logout endpoint for requests
	         */
	        get: function () {
	            if (this.discoveryComplete()) {
	                // ROPC policies may not have end_session_endpoint set
	                if (!this.metadata.end_session_endpoint) {
	                    throw ClientAuthError.createLogoutNotSupportedError();
	                }
	                return this.replacePath(this.metadata.end_session_endpoint);
	            }
	            else {
	                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "selfSignedJwtAudience", {
	        /**
	         * OAuth issuer for requests
	         */
	        get: function () {
	            if (this.discoveryComplete()) {
	                return this.replacePath(this.metadata.issuer);
	            }
	            else {
	                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    Object.defineProperty(Authority.prototype, "jwksUri", {
	        /**
	         * Jwks_uri for token signing keys
	         */
	        get: function () {
	            if (this.discoveryComplete()) {
	                return this.replacePath(this.metadata.jwks_uri);
	            }
	            else {
	                throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
	            }
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
	     * @param authorityUri {@link IUri}
	     * @private
	     */
	    Authority.prototype.canReplaceTenant = function (authorityUri) {
	        return authorityUri.PathSegments.length === 1
	            && !Authority.reservedTenantDomains.has(authorityUri.PathSegments[0])
	            && this.getAuthorityType(authorityUri) === AuthorityType.Default
	            && this.protocolMode === ProtocolMode.AAD;
	    };
	    /**
	     * Replaces tenant in url path with current tenant. Defaults to common.
	     * @param urlString
	     */
	    Authority.prototype.replaceTenant = function (urlString) {
	        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
	    };
	    /**
	     * Replaces path such as tenant or policy with the current tenant or policy.
	     * @param urlString
	     */
	    Authority.prototype.replacePath = function (urlString) {
	        var _this = this;
	        var endpoint = urlString;
	        var cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
	        var cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
	        var cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
	        var currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
	        currentAuthorityParts.forEach(function (currentPart, index) {
	            var cachedPart = cachedAuthorityParts[index];
	            if (index === 0 && _this.canReplaceTenant(cachedAuthorityUrlComponents)) {
	                var tenantId = (new UrlString(_this.metadata.authorization_endpoint)).getUrlComponents().PathSegments[0];
	                /**
	                 * Check if AAD canonical authority contains tenant domain name, for example "testdomain.onmicrosoft.com",
	                 * by comparing its first path segment to the corresponding authorization endpoint path segment, which is
	                 * always resolved with tenant id by OIDC.
	                 */
	                if (cachedPart !== tenantId) {
	                    _this.logger.verbose("Replacing tenant domain name " + cachedPart + " with id " + tenantId);
	                    cachedPart = tenantId;
	                }
	            }
	            if (currentPart !== cachedPart) {
	                endpoint = endpoint.replace("/" + cachedPart + "/", "/" + currentPart + "/");
	            }
	        });
	        return this.replaceTenant(endpoint);
	    };
	    Object.defineProperty(Authority.prototype, "defaultOpenIdConfigurationEndpoint", {
	        /**
	         * The default open id configuration endpoint for any canonical authority.
	         */
	        get: function () {
	            if (this.authorityType === AuthorityType.Adfs ||
	                this.authorityType === AuthorityType.Dsts ||
	                this.protocolMode === ProtocolMode.OIDC) {
	                return this.canonicalAuthority + ".well-known/openid-configuration";
	            }
	            return this.canonicalAuthority + "v2.0/.well-known/openid-configuration";
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Boolean that returns whethr or not tenant discovery has been completed.
	     */
	    Authority.prototype.discoveryComplete = function () {
	        return !!this.metadata;
	    };
	    /**
	     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
	     * and the /authorize, /token and logout endpoints.
	     */
	    Authority.prototype.resolveEndpointsAsync = function () {
	        var _a, _b, _c;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var metadataEntity, cloudDiscoverySource, endpointSource, cacheKey;
	            return __generator$2(this, function (_d) {
	                switch (_d.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
	                        metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
	                        if (!metadataEntity) {
	                            metadataEntity = new AuthorityMetadataEntity();
	                            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
	                        }
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
	                        return [4 /*yield*/, this.updateCloudDiscoveryMetadata(metadataEntity)];
	                    case 1:
	                        cloudDiscoverySource = _d.sent();
	                        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
	                        (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
	                        return [4 /*yield*/, this.updateEndpointMetadata(metadataEntity)];
	                    case 2:
	                        endpointSource = _d.sent();
	                        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointSource !== AuthorityMetadataSource.CACHE) {
	                            // Reset the expiration time unless both values came from a successful cache lookup
	                            metadataEntity.resetExpiresAt();
	                            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);
	                        }
	                        cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
	                        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
	                        this.metadata = metadataEntity;
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Update AuthorityMetadataEntity with new endpoints and return where the information came from
	     * @param metadataEntity
	     */
	    Authority.prototype.updateEndpointMetadata = function (metadataEntity) {
	        var _a, _b, _c, _d, _e, _f;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var metadata, harcodedMetadata;
	            return __generator$2(this, function (_g) {
	                switch (_g.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
	                        metadata = this.getEndpointMetadataFromConfig();
	                        if (metadata) {
	                            metadataEntity.updateEndpointMetadata(metadata, false);
	                            return [2 /*return*/, AuthorityMetadataSource.CONFIG];
	                        }
	                        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntity.isExpired()) {
	                            // No need to update
	                            return [2 /*return*/, AuthorityMetadataSource.CACHE];
	                        }
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
	                        return [4 /*yield*/, this.getEndpointMetadataFromNetwork()];
	                    case 1:
	                        metadata = _g.sent();
	                        if (!metadata) return [3 /*break*/, 4];
	                        if (!((_c = this.authorityOptions.azureRegionConfiguration) === null || _c === void 0 ? void 0 : _c.azureRegion)) return [3 /*break*/, 3];
	                        (_d = this.performanceClient) === null || _d === void 0 ? void 0 : _d.setPreQueueTime(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
	                        return [4 /*yield*/, this.updateMetadataWithRegionalInformation(metadata)];
	                    case 2:
	                        metadata = _g.sent();
	                        _g.label = 3;
	                    case 3:
	                        metadataEntity.updateEndpointMetadata(metadata, true);
	                        return [2 /*return*/, AuthorityMetadataSource.NETWORK];
	                    case 4:
	                        harcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
	                        if (!(harcodedMetadata && !this.authorityOptions.skipAuthorityMetadataCache)) return [3 /*break*/, 7];
	                        if (!((_e = this.authorityOptions.azureRegionConfiguration) === null || _e === void 0 ? void 0 : _e.azureRegion)) return [3 /*break*/, 6];
	                        (_f = this.performanceClient) === null || _f === void 0 ? void 0 : _f.setPreQueueTime(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
	                        return [4 /*yield*/, this.updateMetadataWithRegionalInformation(harcodedMetadata)];
	                    case 5:
	                        harcodedMetadata = _g.sent();
	                        _g.label = 6;
	                    case 6:
	                        metadataEntity.updateEndpointMetadata(harcodedMetadata, false);
	                        return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];
	                    case 7: throw ClientAuthError.createUnableToGetOpenidConfigError(this.defaultOpenIdConfigurationEndpoint);
	                }
	            });
	        });
	    };
	    /**
	     * Compares the number of url components after the domain to determine if the cached
	     * authority metadata can be used for the requested authority. Protects against same domain different
	     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
	     * @param metadataEntity
	     */
	    Authority.prototype.isAuthoritySameType = function (metadataEntity) {
	        var cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
	        var cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
	        return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;
	    };
	    /**
	     * Parse authorityMetadata config option
	     */
	    Authority.prototype.getEndpointMetadataFromConfig = function () {
	        if (this.authorityOptions.authorityMetadata) {
	            try {
	                return JSON.parse(this.authorityOptions.authorityMetadata);
	            }
	            catch (e) {
	                throw ClientConfigurationError.createInvalidAuthorityMetadataError();
	            }
	        }
	        return null;
	    };
	    /**
	     * Gets OAuth endpoints from the given OpenID configuration endpoint.
	     *
	     * @param hasHardcodedMetadata boolean
	     */
	    Authority.prototype.getEndpointMetadataFromNetwork = function () {
	        var _a;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var options, response;
	            return __generator$2(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
	                        options = {};
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.networkInterface.
	                                sendGetRequestAsync(this.defaultOpenIdConfigurationEndpoint, options)];
	                    case 2:
	                        response = _b.sent();
	                        return [2 /*return*/, isOpenIdConfigResponse(response.body) ? response.body : null];
	                    case 3:
	                        _b.sent();
	                        return [2 /*return*/, null];
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Get OAuth endpoints for common authorities.
	     */
	    Authority.prototype.getEndpointMetadataFromHardcodedValues = function () {
	        if (this.canonicalAuthority in EndpointMetadata) {
	            return EndpointMetadata[this.canonicalAuthority];
	        }
	        return null;
	    };
	    /**
	     * Update the retrieved metadata with regional information.
	     * User selected Azure region will be used if configured.
	     */
	    Authority.prototype.updateMetadataWithRegionalInformation = function (metadata) {
	        var _a, _b, _c, _d;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var userConfiguredAzureRegion, autodetectedRegionName;
	            return __generator$2(this, function (_e) {
	                switch (_e.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
	                        userConfiguredAzureRegion = (_b = this.authorityOptions.azureRegionConfiguration) === null || _b === void 0 ? void 0 : _b.azureRegion;
	                        if (!userConfiguredAzureRegion) return [3 /*break*/, 2];
	                        if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
	                            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
	                            this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;
	                            return [2 /*return*/, Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion)];
	                        }
	                        (_c = this.performanceClient) === null || _c === void 0 ? void 0 : _c.setPreQueueTime(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
	                        return [4 /*yield*/, this.regionDiscovery.detectRegion((_d = this.authorityOptions.azureRegionConfiguration) === null || _d === void 0 ? void 0 : _d.environmentRegion, this.regionDiscoveryMetadata)];
	                    case 1:
	                        autodetectedRegionName = _e.sent();
	                        if (autodetectedRegionName) {
	                            this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
	                            this.regionDiscoveryMetadata.region_used = autodetectedRegionName;
	                            return [2 /*return*/, Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName)];
	                        }
	                        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
	                        _e.label = 2;
	                    case 2: return [2 /*return*/, metadata];
	                }
	            });
	        });
	    };
	    /**
	     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
	     * and returns where the information was retrieved from
	     * @param metadataEntity
	     * @returns AuthorityMetadataSource
	     */
	    Authority.prototype.updateCloudDiscoveryMetadata = function (metadataEntity) {
	        var _a, _b;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var metadata, metadataEntityExpired, harcodedMetadata;
	            return __generator$2(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
	                        // attempt to read metadata from the config
	                        this.logger.verbose("Attempting to get cloud discovery metadata in the config");
	                        this.logger.verbosePii("Known Authorities: " + (this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE));
	                        this.logger.verbosePii("Authority Metadata: " + (this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE));
	                        this.logger.verbosePii("Canonical Authority: " + (metadataEntity.canonical_authority || Constants.NOT_APPLICABLE));
	                        metadata = this.getCloudDiscoveryMetadataFromConfig();
	                        if (metadata) {
	                            this.logger.verbose("Found cloud discovery metadata in the config.");
	                            metadataEntity.updateCloudDiscoveryMetadata(metadata, false);
	                            return [2 /*return*/, AuthorityMetadataSource.CONFIG];
	                        }
	                        // If the cached metadata came from config but that config was not passed to this instance, we must go to the network
	                        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the cache.");
	                        metadataEntityExpired = metadataEntity.isExpired();
	                        if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {
	                            this.logger.verbose("Found metadata in the cache.");
	                            // No need to update
	                            return [2 /*return*/, AuthorityMetadataSource.CACHE];
	                        }
	                        else if (metadataEntityExpired) {
	                            this.logger.verbose("The metadata entity is expired.");
	                        }
	                        this.logger.verbose("Did not find cloud discovery metadata in the cache... Attempting to get cloud discovery metadata from the network.");
	                        (_b = this.performanceClient) === null || _b === void 0 ? void 0 : _b.setPreQueueTime(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
	                        return [4 /*yield*/, this.getCloudDiscoveryMetadataFromNetwork()];
	                    case 1:
	                        metadata = _c.sent();
	                        if (metadata) {
	                            this.logger.verbose("cloud discovery metadata was successfully returned from getCloudDiscoveryMetadataFromNetwork()");
	                            metadataEntity.updateCloudDiscoveryMetadata(metadata, true);
	                            return [2 /*return*/, AuthorityMetadataSource.NETWORK];
	                        }
	                        this.logger.verbose("Did not find cloud discovery metadata from the network... Attempting to get cloud discovery metadata from hardcoded values.");
	                        harcodedMetadata = this.getCloudDiscoveryMetadataFromHarcodedValues();
	                        if (harcodedMetadata && !this.options.skipAuthorityMetadataCache) {
	                            this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
	                            metadataEntity.updateCloudDiscoveryMetadata(harcodedMetadata, false);
	                            return [2 /*return*/, AuthorityMetadataSource.HARDCODED_VALUES];
	                        }
	                        // Metadata could not be obtained from the config, cache, network or hardcoded values
	                        this.logger.error("Did not find cloud discovery metadata from hardcoded values... Metadata could not be obtained from config, cache, network or hardcoded values. Throwing Untrusted Authority Error.");
	                        throw ClientConfigurationError.createUntrustedAuthorityError();
	                }
	            });
	        });
	    };
	    /**
	     * Parse cloudDiscoveryMetadata config or check knownAuthorities
	     */
	    Authority.prototype.getCloudDiscoveryMetadataFromConfig = function () {
	        // CIAM does not support cloud discovery metadata
	        if (this.authorityType === AuthorityType.Ciam) {
	            this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
	            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
	        }
	        // Check if network response was provided in config
	        if (this.authorityOptions.cloudDiscoveryMetadata) {
	            this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
	            try {
	                this.logger.verbose("Attempting to parse the cloud discovery metadata.");
	                var parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
	                var metadata = Authority.getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
	                this.logger.verbose("Parsed the cloud discovery metadata.");
	                if (metadata) {
	                    this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
	                    return metadata;
	                }
	                else {
	                    this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
	                }
	            }
	            catch (e) {
	                this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
	                throw ClientConfigurationError.createInvalidCloudDiscoveryMetadataError();
	            }
	        }
	        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities
	        if (this.isInKnownAuthorities()) {
	            this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
	            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
	        }
	        return null;
	    };
	    /**
	     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
	     *
	     * @param hasHardcodedMetadata boolean
	     */
	    Authority.prototype.getCloudDiscoveryMetadataFromNetwork = function () {
	        var _a;
	        return __awaiter$2(this, void 0, void 0, function () {
	            var instanceDiscoveryEndpoint, options, match, response, typedResponseBody, metadata, error_1, typedError;
	            return __generator$2(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
	                        instanceDiscoveryEndpoint = "" + Constants.AAD_INSTANCE_DISCOVERY_ENDPT + this.canonicalAuthority + "oauth2/v2.0/authorize";
	                        options = {};
	                        match = null;
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options)];
	                    case 2:
	                        response = _b.sent();
	                        typedResponseBody = void 0;
	                        metadata = void 0;
	                        if (isCloudInstanceDiscoveryResponse(response.body)) {
	                            typedResponseBody = response.body;
	                            metadata = typedResponseBody.metadata;
	                            this.logger.verbosePii("tenant_discovery_endpoint is: " + typedResponseBody.tenant_discovery_endpoint);
	                        }
	                        else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
	                            this.logger.warning("A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: " + response.status);
	                            typedResponseBody = response.body;
	                            if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
	                                this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
	                                return [2 /*return*/, null];
	                            }
	                            this.logger.warning("The CloudInstanceDiscoveryErrorResponse error is " + typedResponseBody.error);
	                            this.logger.warning("The CloudInstanceDiscoveryErrorResponse error description is " + typedResponseBody.error_description);
	                            this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
	                            metadata = [];
	                        }
	                        else {
	                            this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
	                            return [2 /*return*/, null];
	                        }
	                        this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
	                        match = Authority.getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
	                        return [3 /*break*/, 4];
	                    case 3:
	                        error_1 = _b.sent();
	                        if (error_1 instanceof AuthError) {
	                            this.logger.error("There was a network error while attempting to get the cloud discovery instance metadata.\nError: " + error_1.errorCode + "\nError Description: " + error_1.errorMessage);
	                        }
	                        else {
	                            typedError = error_1;
	                            this.logger.error("A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\nError: " + typedError.name + "\nError Description: " + typedError.message);
	                        }
	                        return [2 /*return*/, null];
	                    case 4:
	                        // Custom Domain scenario, host is trusted because Instance Discovery call succeeded
	                        if (!match) {
	                            this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
	                            this.logger.verbose("Creating custom Authority for custom domain scenario.");
	                            match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
	                        }
	                        return [2 /*return*/, match];
	                }
	            });
	        });
	    };
	    /**
	     * Get cloud discovery metadata for common authorities
	     */
	    Authority.prototype.getCloudDiscoveryMetadataFromHarcodedValues = function () {
	        if (this.canonicalAuthority in InstanceDiscoveryMetadata) {
	            return InstanceDiscoveryMetadata[this.canonicalAuthority];
	        }
	        return null;
	    };
	    /**
	     * Helper function to determine if this host is included in the knownAuthorities config option
	     */
	    Authority.prototype.isInKnownAuthorities = function () {
	        var _this = this;
	        var matches = this.authorityOptions.knownAuthorities.filter(function (authority) {
	            return UrlString.getDomainFromUrl(authority).toLowerCase() === _this.hostnameAndPort;
	        });
	        return matches.length > 0;
	    };
	    /**
	     * helper function to populate the authority based on azureCloudOptions
	     * @param authorityString
	     * @param azureCloudOptions
	     */
	    Authority.generateAuthority = function (authorityString, azureCloudOptions) {
	        var authorityAzureCloudInstance;
	        if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
	            var tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;
	            authorityAzureCloudInstance = azureCloudOptions.azureCloudInstance + "/" + tenant + "/";
	        }
	        return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;
	    };
	    /**
	     * Creates cloud discovery metadata object from a given host
	     * @param host
	     */
	    Authority.createCloudDiscoveryMetadataFromHost = function (host) {
	        return {
	            preferred_network: host,
	            preferred_cache: host,
	            aliases: [host]
	        };
	    };
	    /**
	     * Searches instance discovery network response for the entry that contains the host in the aliases list
	     * @param response
	     * @param authority
	     */
	    Authority.getCloudDiscoveryMetadataFromNetworkResponse = function (response, authority) {
	        for (var i = 0; i < response.length; i++) {
	            var metadata = response[i];
	            if (metadata.aliases.indexOf(authority) > -1) {
	                return metadata;
	            }
	        }
	        return null;
	    };
	    /**
	     * helper function to generate environment from authority object
	     */
	    Authority.prototype.getPreferredCache = function () {
	        if (this.discoveryComplete()) {
	            return this.metadata.preferred_cache;
	        }
	        else {
	            throw ClientAuthError.createEndpointDiscoveryIncompleteError("Discovery incomplete.");
	        }
	    };
	    /**
	     * Returns whether or not the provided host is an alias of this authority instance
	     * @param host
	     */
	    Authority.prototype.isAlias = function (host) {
	        return this.metadata.aliases.indexOf(host) > -1;
	    };
	    /**
	     * Checks whether the provided host is that of a public cloud authority
	     *
	     * @param authority string
	     * @returns bool
	     */
	    Authority.isPublicCloudAuthority = function (host) {
	        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
	    };
	    /**
	     * Rebuild the authority string with the region
	     *
	     * @param host string
	     * @param region string
	     */
	    Authority.buildRegionalAuthorityString = function (host, region, queryString) {
	        // Create and validate a Url string object with the initial authority string
	        var authorityUrlInstance = new UrlString(host);
	        authorityUrlInstance.validateAsUri();
	        var authorityUrlParts = authorityUrlInstance.getUrlComponents();
	        var hostNameAndPort = region + "." + authorityUrlParts.HostNameAndPort;
	        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
	            hostNameAndPort = region + "." + Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX;
	        }
	        // Include the query string portion of the url
	        var url = UrlString.constructAuthorityUriFromObject(__assign$4(__assign$4({}, authorityUrlInstance.getUrlComponents()), { HostNameAndPort: hostNameAndPort })).urlString;
	        // Add the query string if a query string was provided
	        if (queryString)
	            return url + "?" + queryString;
	        return url;
	    };
	    /**
	     * Replace the endpoints in the metadata object with their regional equivalents.
	     *
	     * @param metadata OpenIdConfigResponse
	     * @param azureRegion string
	     */
	    Authority.replaceWithRegionalInformation = function (metadata, azureRegion) {
	        metadata.authorization_endpoint = Authority.buildRegionalAuthorityString(metadata.authorization_endpoint, azureRegion);
	        // TODO: Enquire on whether we should leave the query string or remove it before releasing the feature
	        metadata.token_endpoint = Authority.buildRegionalAuthorityString(metadata.token_endpoint, azureRegion, Constants.REGIONAL_AUTH_NON_MSI_QUERY_STRING);
	        if (metadata.end_session_endpoint) {
	            metadata.end_session_endpoint = Authority.buildRegionalAuthorityString(metadata.end_session_endpoint, azureRegion);
	        }
	        return metadata;
	    };
	    /**
	     * Transform CIAM_AUTHORIY as per the below rules:
	     * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
	     *
	     * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
	     * `ciamlogin.com` can also change in the future and we should accommodate the same
	     *
	     * @param authority
	     */
	    Authority.transformCIAMAuthority = function (authority) {
	        var ciamAuthority = authority.endsWith(Constants.FORWARD_SLASH) ? authority : "" + authority + Constants.FORWARD_SLASH;
	        var authorityUrl = new UrlString(authority);
	        var authorityUrlComponents = authorityUrl.getUrlComponents();
	        // check if transformation is needed
	        if (authorityUrlComponents.PathSegments.length === 0 && (authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL))) {
	            var tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
	            ciamAuthority = "" + ciamAuthority + tenantIdOrDomain + Constants.AAD_TENANT_DOMAIN_SUFFIX;
	        }
	        return ciamAuthority;
	    };
	    // Reserved tenant domain names that will not be replaced with tenant id
	    Authority.reservedTenantDomains = (new Set([
	        "{tenant}",
	        "{tenantid}",
	        AADAuthorityConstants.COMMON,
	        AADAuthorityConstants.CONSUMERS,
	        AADAuthorityConstants.ORGANIZATIONS
	    ]));
	    return Authority;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var AuthorityFactory = /** @class */ (function () {
	    function AuthorityFactory() {
	    }
	    /**
	     * Create an authority object of the correct type based on the url
	     * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)
	     *
	     * Also performs endpoint discovery.
	     *
	     * @param authorityUri
	     * @param networkClient
	     * @param protocolMode
	     */
	    AuthorityFactory.createDiscoveredInstance = function (authorityUri, networkClient, cacheManager, authorityOptions, logger, performanceClient, correlationId) {
	        return __awaiter$2(this, void 0, void 0, function () {
	            var authorityUriFinal, acquireTokenAuthority, e_1;
	            return __generator$2(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        performanceClient === null || performanceClient === void 0 ? void 0 : performanceClient.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
	                        authorityUriFinal = Authority.transformCIAMAuthority(authorityUri);
	                        acquireTokenAuthority = AuthorityFactory.createInstance(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, performanceClient, correlationId);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        performanceClient === null || performanceClient === void 0 ? void 0 : performanceClient.setPreQueueTime(PerformanceEvents.AuthorityResolveEndpointsAsync, correlationId);
	                        return [4 /*yield*/, acquireTokenAuthority.resolveEndpointsAsync()];
	                    case 2:
	                        _a.sent();
	                        return [2 /*return*/, acquireTokenAuthority];
	                    case 3:
	                        e_1 = _a.sent();
	                        throw ClientAuthError.createEndpointDiscoveryIncompleteError(e_1);
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Create an authority object of the correct type based on the url
	     * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)
	     *
	     * Does not perform endpoint discovery.
	     *
	     * @param authorityUrl
	     * @param networkInterface
	     * @param protocolMode
	     */
	    AuthorityFactory.createInstance = function (authorityUrl, networkInterface, cacheManager, authorityOptions, logger, performanceClient, correlationId) {
	        // Throw error if authority url is empty
	        if (StringUtils.isEmpty(authorityUrl)) {
	            throw ClientConfigurationError.createUrlEmptyError();
	        }
	        return new Authority(authorityUrl, networkInterface, cacheManager, authorityOptions, logger, performanceClient, correlationId);
	    };
	    return AuthorityFactory;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var ServerTelemetryEntity = /** @class */ (function () {
	    function ServerTelemetryEntity() {
	        this.failedRequests = [];
	        this.errors = [];
	        this.cacheHits = 0;
	    }
	    /**
	     * validates if a given cache entry is "Telemetry", parses <key,value>
	     * @param key
	     * @param entity
	     */
	    ServerTelemetryEntity.isServerTelemetryEntity = function (key, entity) {
	        var validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
	        var validateEntity = true;
	        if (entity) {
	            validateEntity =
	                entity.hasOwnProperty("failedRequests") &&
	                    entity.hasOwnProperty("errors") &&
	                    entity.hasOwnProperty("cacheHits");
	        }
	        return validateKey && validateEntity;
	    };
	    return ServerTelemetryEntity;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var ThrottlingEntity = /** @class */ (function () {
	    function ThrottlingEntity() {
	    }
	    /**
	     * validates if a given cache entry is "Throttling", parses <key,value>
	     * @param key
	     * @param entity
	     */
	    ThrottlingEntity.isThrottlingEntity = function (key, entity) {
	        var validateKey = false;
	        if (key) {
	            validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
	        }
	        var validateEntity = true;
	        if (entity) {
	            validateEntity = entity.hasOwnProperty("throttleTime");
	        }
	        return validateKey && validateEntity;
	    };
	    return ThrottlingEntity;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var StubbedNetworkModule = {
	    sendGetRequestAsync: function () {
	        var notImplErr = "Network interface - sendGetRequestAsync() has not been implemented for the Network interface.";
	        return Promise.reject(AuthError.createUnexpectedError(notImplErr));
	    },
	    sendPostRequestAsync: function () {
	        var notImplErr = "Network interface - sendPostRequestAsync() has not been implemented for the Network interface.";
	        return Promise.reject(AuthError.createUnexpectedError(notImplErr));
	    }
	};

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * ClientAuthErrorMessage class containing string constants used by error codes and messages.
	 */
	var JoseHeaderErrorMessage = {
	    missingKidError: {
	        code: "missing_kid_error",
	        desc: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided."
	    },
	    missingAlgError: {
	        code: "missing_alg_error",
	        desc: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided."
	    },
	};
	/**
	 * Error thrown when there is an error in the client code running on the browser.
	 */
	var JoseHeaderError = /** @class */ (function (_super) {
	    __extends$f(JoseHeaderError, _super);
	    function JoseHeaderError(errorCode, errorMessage) {
	        var _this = _super.call(this, errorCode, errorMessage) || this;
	        _this.name = "JoseHeaderError";
	        Object.setPrototypeOf(_this, JoseHeaderError.prototype);
	        return _this;
	    }
	    /**
	     * Creates an error thrown when keyId isn't set on JOSE header.
	     */
	    JoseHeaderError.createMissingKidError = function () {
	        return new JoseHeaderError(JoseHeaderErrorMessage.missingKidError.code, JoseHeaderErrorMessage.missingKidError.desc);
	    };
	    /**
	     * Creates an error thrown when algorithm isn't set on JOSE header.
	     */
	    JoseHeaderError.createMissingAlgError = function () {
	        return new JoseHeaderError(JoseHeaderErrorMessage.missingAlgError.code, JoseHeaderErrorMessage.missingAlgError.desc);
	    };
	    return JoseHeaderError;
	}(AuthError));

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var JoseHeader = /** @class */ (function () {
	    function JoseHeader(options) {
	        this.typ = options.typ;
	        this.alg = options.alg;
	        this.kid = options.kid;
	    }
	    /**
	     * Builds SignedHttpRequest formatted JOSE Header from the
	     * JOSE Header options provided or previously set on the object and returns
	     * the stringified header object.
	     * Throws if keyId or algorithm aren't provided since they are required for Access Token Binding.
	     * @param shrHeaderOptions
	     * @returns
	     */
	    JoseHeader.getShrHeaderString = function (shrHeaderOptions) {
	        // KeyID is required on the SHR header
	        if (!shrHeaderOptions.kid) {
	            throw JoseHeaderError.createMissingKidError();
	        }
	        // Alg is required on the SHR header
	        if (!shrHeaderOptions.alg) {
	            throw JoseHeaderError.createMissingAlgError();
	        }
	        var shrHeader = new JoseHeader({
	            // Access Token PoP headers must have type pop, but the type header can be overriden for special cases
	            typ: shrHeaderOptions.typ || JsonTypes.Pop,
	            kid: shrHeaderOptions.kid,
	            alg: shrHeaderOptions.alg
	        });
	        return JSON.stringify(shrHeader);
	    };
	    return JoseHeader;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var ServerTelemetryManager = /** @class */ (function () {
	    function ServerTelemetryManager(telemetryRequest, cacheManager) {
	        this.cacheOutcome = CacheOutcome.NO_CACHE_HIT;
	        this.cacheManager = cacheManager;
	        this.apiId = telemetryRequest.apiId;
	        this.correlationId = telemetryRequest.correlationId;
	        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
	        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
	        this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;
	    }
	    /**
	     * API to add MSER Telemetry to request
	     */
	    ServerTelemetryManager.prototype.generateCurrentRequestHeaderValue = function () {
	        var request = "" + this.apiId + SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR + this.cacheOutcome;
	        var platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
	        var regionDiscoveryFields = this.getRegionDiscoveryFields();
	        var requestWithRegionDiscoveryFields = [request, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
	        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
	    };
	    /**
	     * API to add MSER Telemetry for the last failed request
	     */
	    ServerTelemetryManager.prototype.generateLastRequestHeaderValue = function () {
	        var lastRequests = this.getLastRequests();
	        var maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);
	        var failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
	        var errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
	        var errorCount = lastRequests.errors.length;
	        // Indicate whether this header contains all data or partial data
	        var overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
	        var platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
	        return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
	    };
	    /**
	     * API to cache token failures for MSER data capture
	     * @param error
	     */
	    ServerTelemetryManager.prototype.cacheFailedRequest = function (error) {
	        var lastRequests = this.getLastRequests();
	        if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
	            // Remove a cached error to make room, first in first out
	            lastRequests.failedRequests.shift(); // apiId
	            lastRequests.failedRequests.shift(); // correlationId
	            lastRequests.errors.shift();
	        }
	        lastRequests.failedRequests.push(this.apiId, this.correlationId);
	        if (!StringUtils.isEmpty(error.subError)) {
	            lastRequests.errors.push(error.subError);
	        }
	        else if (!StringUtils.isEmpty(error.errorCode)) {
	            lastRequests.errors.push(error.errorCode);
	        }
	        else if (!!error && error.toString()) {
	            lastRequests.errors.push(error.toString());
	        }
	        else {
	            lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
	        }
	        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
	        return;
	    };
	    /**
	     * Update server telemetry cache entry by incrementing cache hit counter
	     */
	    ServerTelemetryManager.prototype.incrementCacheHits = function () {
	        var lastRequests = this.getLastRequests();
	        lastRequests.cacheHits += 1;
	        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);
	        return lastRequests.cacheHits;
	    };
	    /**
	     * Get the server telemetry entity from cache or initialize a new one
	     */
	    ServerTelemetryManager.prototype.getLastRequests = function () {
	        var initialValue = new ServerTelemetryEntity();
	        var lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
	        return lastRequests || initialValue;
	    };
	    /**
	     * Remove server telemetry cache entry
	     */
	    ServerTelemetryManager.prototype.clearTelemetryCache = function () {
	        var lastRequests = this.getLastRequests();
	        var numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);
	        var errorCount = lastRequests.errors.length;
	        if (numErrorsFlushed === errorCount) {
	            // All errors were sent on last request, clear Telemetry cache
	            this.cacheManager.removeItem(this.telemetryCacheKey);
	        }
	        else {
	            // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed
	            var serverTelemEntity = new ServerTelemetryEntity();
	            serverTelemEntity.failedRequests = lastRequests.failedRequests.slice(numErrorsFlushed * 2); // failedRequests contains 2 items for each error
	            serverTelemEntity.errors = lastRequests.errors.slice(numErrorsFlushed);
	            this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);
	        }
	    };
	    /**
	     * Returns the maximum number of errors that can be flushed to the server in the next network request
	     * @param serverTelemetryEntity
	     */
	    ServerTelemetryManager.maxErrorsToSend = function (serverTelemetryEntity) {
	        var i;
	        var maxErrors = 0;
	        var dataSize = 0;
	        var errorCount = serverTelemetryEntity.errors.length;
	        for (i = 0; i < errorCount; i++) {
	            // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs
	            var apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;
	            var correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;
	            var errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
	            // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators
	            dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;
	            if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
	                // Adding this entry to the header would still keep header size below the limit
	                maxErrors += 1;
	            }
	            else {
	                break;
	            }
	        }
	        return maxErrors;
	    };
	    /**
	     * Get the region discovery fields
	     *
	     * @returns string
	     */
	    ServerTelemetryManager.prototype.getRegionDiscoveryFields = function () {
	        var regionDiscoveryFields = [];
	        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
	        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
	        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
	        return regionDiscoveryFields.join(",");
	    };
	    /**
	     * Update the region discovery metadata
	     *
	     * @param regionDiscoveryMetadata
	     * @returns void
	     */
	    ServerTelemetryManager.prototype.updateRegionDiscoveryMetadata = function (regionDiscoveryMetadata) {
	        this.regionUsed = regionDiscoveryMetadata.region_used;
	        this.regionSource = regionDiscoveryMetadata.region_source;
	        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
	    };
	    /**
	     * Set cache outcome
	     */
	    ServerTelemetryManager.prototype.setCacheOutcome = function (cacheOutcome) {
	        this.cacheOutcome = cacheOutcome;
	    };
	    return ServerTelemetryManager;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var PerformanceClient = /** @class */ (function () {
	    /**
	     * Creates an instance of PerformanceClient,
	     * an abstract class containing core performance telemetry logic.
	     *
	     * @constructor
	     * @param {string} clientId Client ID of the application
	     * @param {string} authority Authority used by the application
	     * @param {Logger} logger Logger used by the application
	     * @param {string} libraryName Name of the library
	     * @param {string} libraryVersion Version of the library
	     */
	    function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {
	        this.authority = authority;
	        this.libraryName = libraryName;
	        this.libraryVersion = libraryVersion;
	        this.applicationTelemetry = applicationTelemetry;
	        this.clientId = clientId;
	        this.logger = logger;
	        this.callbacks = new Map();
	        this.eventsByCorrelationId = new Map();
	        this.queueMeasurements = new Map();
	        this.preQueueTimeByCorrelationId = new Map();
	    }
	    /**
	     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.
	     * Note: this function can be changed to abstract at the next major version bump.
	     *
	     * @param {string} measureName
	     * @param {string} correlationId
	     * @returns {IPerformanceMeasurement}
	     */
	    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
	    PerformanceClient.prototype.startPerformanceMeasurement = function (measureName, correlationId) {
	        return {};
	    };
	    /**
	     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.
	     * Note: this incorrectly-named function will be removed at the next major version bump.
	     *
	     * @param {string} measureName
	     * @param {string} correlationId
	     * @returns {IPerformanceMeasurement}
	     */
	    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
	    PerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {
	        return {};
	    };
	    /**
	     * Get integral fields.
	     * Override to change the set.
	     */
	    PerformanceClient.prototype.getIntFields = function () {
	        return IntFields;
	    };
	    /**
	     * Gets map of pre-queue times by correlation Id
	     *
	     * @param {PerformanceEvents} eventName
	     * @param {string} correlationId
	     * @returns {number}
	     */
	    PerformanceClient.prototype.getPreQueueTime = function (eventName, correlationId) {
	        var preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);
	        if (!preQueueEvent) {
	            this.logger.trace("PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: " + correlationId + ", unable to add queue measurement");
	            return;
	        }
	        else if (preQueueEvent.name !== eventName) {
	            this.logger.trace("PerformanceClient.getPreQueueTime: no pre-queue time found for " + eventName + ", unable to add queue measurement");
	            return;
	        }
	        return preQueueEvent.time;
	    };
	    /**
	     * Calculates the difference between current time and time when function was queued.
	     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.
	     *
	     * @param {number} preQueueTime
	     * @param {number} currentTime
	     * @returns {number}
	     */
	    PerformanceClient.prototype.calculateQueuedTime = function (preQueueTime, currentTime) {
	        if (preQueueTime < 1) {
	            this.logger.trace("PerformanceClient: preQueueTime should be a positive integer and not " + preQueueTime);
	            return 0;
	        }
	        if (currentTime < 1) {
	            this.logger.trace("PerformanceClient: currentTime should be a positive integer and not " + currentTime);
	            return 0;
	        }
	        if (currentTime < preQueueTime) {
	            this.logger.trace("PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved");
	            return 0;
	        }
	        return currentTime - preQueueTime;
	    };
	    /**
	     * Adds queue measurement time to QueueMeasurements array for given correlation ID.
	     *
	     * @param {PerformanceEvents} eventName
	     * @param {?string} correlationId
	     * @param {?number} queueTime
	     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements
	     * @returns
	     */
	    PerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime, manuallyCompleted) {
	        if (!correlationId) {
	            this.logger.trace("PerformanceClient.addQueueMeasurement: correlationId not provided for " + eventName + ", cannot add queue measurement");
	            return;
	        }
	        if (queueTime === 0) {
	            // Possible for there to be no queue time after calculation
	            this.logger.trace("PerformanceClient.addQueueMeasurement: queue time provided for " + eventName + " is " + queueTime);
	        }
	        else if (!queueTime) {
	            this.logger.trace("PerformanceClient.addQueueMeasurement: no queue time provided for " + eventName);
	            return;
	        }
	        var queueMeasurement = { eventName: eventName, queueTime: queueTime, manuallyCompleted: manuallyCompleted };
	        // Adds to existing correlation Id if present in queueMeasurements
	        var existingMeasurements = this.queueMeasurements.get(correlationId);
	        if (existingMeasurements) {
	            existingMeasurements.push(queueMeasurement);
	            this.queueMeasurements.set(correlationId, existingMeasurements);
	        }
	        else {
	            // Sets new correlation Id if not present in queueMeasurements
	            this.logger.trace("PerformanceClient.addQueueMeasurement: adding correlationId " + correlationId + " to queue measurements");
	            var measurementArray = [queueMeasurement];
	            this.queueMeasurements.set(correlationId, measurementArray);
	        }
	        // Delete processed pre-queue event.
	        this.preQueueTimeByCorrelationId.delete(correlationId);
	    };
	    /**
	     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.
	     *
	     * @param {PerformanceEvents} measureName
	     * @param {?string} [correlationId]
	     * @returns {InProgressPerformanceEvent}
	     */
	    PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {
	        var _this = this;
	        var _a, _b;
	        // Generate a placeholder correlation if the request does not provide one
	        var eventCorrelationId = correlationId || this.generateId();
	        if (!correlationId) {
	            this.logger.info("PerformanceClient: No correlation id provided for " + measureName + ", generating", eventCorrelationId);
	        }
	        // Duplicate code to address spelling error will be removed at the next major version bump.
	        this.logger.trace("PerformanceClient: Performance measurement started for " + measureName, eventCorrelationId);
	        var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);
	        performanceMeasurement.startMeasurement();
	        var inProgressEvent = {
	            eventId: this.generateId(),
	            status: PerformanceEventStatus.InProgress,
	            authority: this.authority,
	            libraryName: this.libraryName,
	            libraryVersion: this.libraryVersion,
	            clientId: this.clientId,
	            name: measureName,
	            startTimeMs: Date.now(),
	            correlationId: eventCorrelationId,
	            appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,
	            appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,
	        };
	        // Store in progress events so they can be discarded if not ended properly
	        this.cacheEventByCorrelationId(inProgressEvent);
	        // Return the event and functions the caller can use to properly end/flush the measurement
	        return {
	            endMeasurement: function (event) {
	                return _this.endMeasurement(__assign$4(__assign$4({}, inProgressEvent), event), performanceMeasurement);
	            },
	            discardMeasurement: function () {
	                return _this.discardMeasurements(inProgressEvent.correlationId);
	            },
	            addStaticFields: function (fields) {
	                return _this.addStaticFields(fields, inProgressEvent.correlationId);
	            },
	            increment: function (counters) {
	                return _this.increment(counters, inProgressEvent.correlationId);
	            },
	            measurement: performanceMeasurement,
	            event: inProgressEvent
	        };
	    };
	    /**
	     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,
	     * as consumers should instead use the function returned by startMeasurement.
	     * Adds a new field named as "[event name]DurationMs" for sub-measurements, completes and emits an event
	     * otherwise.
	     *
	     * @param {PerformanceEvent} event
	     * @param {IPerformanceMeasurement} measurement
	     * @returns {(PerformanceEvent | null)}
	     */
	    PerformanceClient.prototype.endMeasurement = function (event, measurement) {
	        var _this = this;
	        var _a, _b;
	        var rootEvent = this.eventsByCorrelationId.get(event.correlationId);
	        if (!rootEvent) {
	            this.logger.trace("PerformanceClient: Measurement not found for " + event.eventId, event.correlationId);
	            return null;
	        }
	        var isRoot = event.eventId === rootEvent.eventId;
	        var queueInfo = {
	            totalQueueTime: 0,
	            totalQueueCount: 0,
	            manuallyCompletedCount: 0
	        };
	        if (isRoot) {
	            queueInfo = this.getQueueInfo(event.correlationId);
	            this.discardCache(rootEvent.correlationId);
	        }
	        else {
	            (_a = rootEvent.incompleteSubMeasurements) === null || _a === void 0 ? void 0 : _a.delete(event.eventId);
	        }
	        measurement === null || measurement === void 0 ? void 0 : measurement.endMeasurement();
	        var durationMs = measurement === null || measurement === void 0 ? void 0 : measurement.flushMeasurement();
	        // null indicates no measurement was taken (e.g. needed performance APIs not present)
	        if (!durationMs) {
	            this.logger.trace("PerformanceClient: Performance measurement not taken", rootEvent.correlationId);
	            return null;
	        }
	        this.logger.trace("PerformanceClient: Performance measurement ended for " + event.name + ": " + durationMs + " ms", event.correlationId);
	        // Add sub-measurement attribute to root event.
	        if (!isRoot) {
	            rootEvent[event.name + "DurationMs"] = Math.floor(durationMs);
	            return __assign$4({}, rootEvent);
	        }
	        var finalEvent = __assign$4(__assign$4({}, rootEvent), event);
	        var incompleteSubsCount = 0;
	        // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.
	        (_b = finalEvent.incompleteSubMeasurements) === null || _b === void 0 ? void 0 : _b.forEach(function (subMeasurement) {
	            _this.logger.trace("PerformanceClient: Incomplete submeasurement " + subMeasurement.name + " found for " + event.name, finalEvent.correlationId);
	            incompleteSubsCount++;
	        });
	        finalEvent.incompleteSubMeasurements = undefined;
	        finalEvent = __assign$4(__assign$4({}, finalEvent), { durationMs: Math.round(durationMs), queuedTimeMs: queueInfo.totalQueueTime, queuedCount: queueInfo.totalQueueCount, queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount, status: PerformanceEventStatus.Completed, incompleteSubsCount: incompleteSubsCount });
	        this.truncateIntegralFields(finalEvent, this.getIntFields());
	        this.emitEvents([finalEvent], event.correlationId);
	        return finalEvent;
	    };
	    /**
	     * Saves extra information to be emitted when the measurements are flushed
	     * @param fields
	     * @param correlationId
	     */
	    PerformanceClient.prototype.addStaticFields = function (fields, correlationId) {
	        this.logger.trace("PerformanceClient: Updating static fields");
	        var event = this.eventsByCorrelationId.get(correlationId);
	        if (event) {
	            this.eventsByCorrelationId.set(correlationId, __assign$4(__assign$4({}, event), fields));
	        }
	        else {
	            this.logger.trace("PerformanceClient: Event not found for", correlationId);
	        }
	    };
	    /**
	     * Increment counters to be emitted when the measurements are flushed
	     * @param counters {Counters}
	     * @param correlationId {string} correlation identifier
	     */
	    PerformanceClient.prototype.increment = function (counters, correlationId) {
	        this.logger.trace("PerformanceClient: Updating counters");
	        var event = this.eventsByCorrelationId.get(correlationId);
	        if (event) {
	            for (var counter in counters) {
	                if (!event.hasOwnProperty(counter)) {
	                    event[counter] = 0;
	                }
	                event[counter] += counters[counter];
	            }
	        }
	        else {
	            this.logger.trace("PerformanceClient: Event not found for", correlationId);
	        }
	    };
	    /**
	     * Upserts event into event cache.
	     * First key is the correlation id, second key is the event id.
	     * Allows for events to be grouped by correlation id,
	     * and to easily allow for properties on them to be updated.
	     *
	     * @private
	     * @param {PerformanceEvent} event
	     */
	    PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {
	        var rootEvent = this.eventsByCorrelationId.get(event.correlationId);
	        if (rootEvent) {
	            this.logger.trace("PerformanceClient: Performance measurement for " + event.name + " added/updated", event.correlationId);
	            rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();
	            rootEvent.incompleteSubMeasurements.set(event.eventId, { name: event.name, startTimeMs: event.startTimeMs });
	        }
	        else {
	            this.logger.trace("PerformanceClient: Performance measurement for " + event.name + " started", event.correlationId);
	            this.eventsByCorrelationId.set(event.correlationId, __assign$4({}, event));
	        }
	    };
	    PerformanceClient.prototype.getQueueInfo = function (correlationId) {
	        var queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);
	        if (!queueMeasurementForCorrelationId) {
	            this.logger.trace("PerformanceClient: no queue measurements found for for correlationId: " + correlationId);
	        }
	        var totalQueueTime = 0;
	        var totalQueueCount = 0;
	        var manuallyCompletedCount = 0;
	        queueMeasurementForCorrelationId === null || queueMeasurementForCorrelationId === void 0 ? void 0 : queueMeasurementForCorrelationId.forEach(function (measurement) {
	            totalQueueTime += measurement.queueTime;
	            totalQueueCount++;
	            manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;
	        });
	        return {
	            totalQueueTime: totalQueueTime,
	            totalQueueCount: totalQueueCount,
	            manuallyCompletedCount: manuallyCompletedCount
	        };
	    };
	    /**
	     * Removes measurements for a given correlation id.
	     *
	     * @param {string} correlationId
	     */
	    PerformanceClient.prototype.discardMeasurements = function (correlationId) {
	        this.logger.trace("PerformanceClient: Performance measurements discarded", correlationId);
	        this.eventsByCorrelationId.delete(correlationId);
	    };
	    /**
	     * Removes cache for a given correlation id.
	     *
	     * @param {string} correlationId correlation identifier
	     */
	    PerformanceClient.prototype.discardCache = function (correlationId) {
	        this.discardMeasurements(correlationId);
	        this.logger.trace("PerformanceClient: QueueMeasurements discarded", correlationId);
	        this.queueMeasurements.delete(correlationId);
	        this.logger.trace("PerformanceClient: Pre-queue times discarded", correlationId);
	        this.preQueueTimeByCorrelationId.delete(correlationId);
	    };
	    /**
	     * Registers a callback function to receive performance events.
	     *
	     * @param {PerformanceCallbackFunction} callback
	     * @returns {string}
	     */
	    PerformanceClient.prototype.addPerformanceCallback = function (callback) {
	        var callbackId = this.generateId();
	        this.callbacks.set(callbackId, callback);
	        this.logger.verbose("PerformanceClient: Performance callback registered with id: " + callbackId);
	        return callbackId;
	    };
	    /**
	     * Removes a callback registered with addPerformanceCallback.
	     *
	     * @param {string} callbackId
	     * @returns {boolean}
	     */
	    PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {
	        var result = this.callbacks.delete(callbackId);
	        if (result) {
	            this.logger.verbose("PerformanceClient: Performance callback " + callbackId + " removed.");
	        }
	        else {
	            this.logger.verbose("PerformanceClient: Performance callback " + callbackId + " not removed.");
	        }
	        return result;
	    };
	    /**
	     * Emits events to all registered callbacks.
	     *
	     * @param {PerformanceEvent[]} events
	     * @param {?string} [correlationId]
	     */
	    PerformanceClient.prototype.emitEvents = function (events, correlationId) {
	        var _this = this;
	        this.logger.verbose("PerformanceClient: Emitting performance events", correlationId);
	        this.callbacks.forEach(function (callback, callbackId) {
	            _this.logger.trace("PerformanceClient: Emitting event to callback " + callbackId, correlationId);
	            callback.apply(null, [events]);
	        });
	    };
	    /**
	     * Enforce truncation of integral fields in performance event.
	     * @param {PerformanceEvent} event performance event to update.
	     * @param {Set<string>} intFields integral fields.
	     */
	    PerformanceClient.prototype.truncateIntegralFields = function (event, intFields) {
	        intFields.forEach(function (key) {
	            if (key in event && typeof event[key] === "number") {
	                event[key] = Math.floor(event[key]);
	            }
	        });
	    };
	    return PerformanceClient;
	}());

	/*! @azure/msal-common v13.3.1 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var StubPerformanceMeasurement = /** @class */ (function () {
	    function StubPerformanceMeasurement() {
	    }
	    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
	    StubPerformanceMeasurement.prototype.startMeasurement = function () { };
	    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
	    StubPerformanceMeasurement.prototype.endMeasurement = function () { };
	    StubPerformanceMeasurement.prototype.flushMeasurement = function () {
	        return null;
	    };
	    return StubPerformanceMeasurement;
	}());
	var StubPerformanceClient = /** @class */ (function (_super) {
	    __extends$f(StubPerformanceClient, _super);
	    function StubPerformanceClient() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    StubPerformanceClient.prototype.generateId = function () {
	        return "callback-id";
	    };
	    StubPerformanceClient.prototype.startPerformanceMeasuremeant = function () {
	        return new StubPerformanceMeasurement();
	    };
	    StubPerformanceClient.prototype.startPerformanceMeasurement = function () {
	        return new StubPerformanceMeasurement();
	    };
	    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
	    StubPerformanceClient.prototype.calculateQueuedTime = function (preQueueTime, currentTime) {
	        return 0;
	    };
	    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
	    StubPerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime) {
	        return;
	    };
	    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
	    StubPerformanceClient.prototype.setPreQueueTime = function (eventName, correlationId) {
	        return;
	    };
	    return StubPerformanceClient;
	}(PerformanceClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * BrowserAuthErrorMessage class containing string constants used by error codes and messages.
	 */
	var BrowserAuthErrorMessage = {
	    pkceNotGenerated: {
	        code: "pkce_not_created",
	        desc: "The PKCE code challenge and verifier could not be generated."
	    },
	    cryptoDoesNotExist: {
	        code: "crypto_nonexistent",
	        desc: "The crypto object or function is not available."
	    },
	    httpMethodNotImplementedError: {
	        code: "http_method_not_implemented",
	        desc: "The HTTP method given has not been implemented in this library."
	    },
	    emptyNavigateUriError: {
	        code: "empty_navigate_uri",
	        desc: "Navigation URI is empty. Please check stack trace for more info."
	    },
	    hashEmptyError: {
	        code: "hash_empty_error",
	        desc: "Hash value cannot be processed because it is empty. Please verify that your redirectUri is not clearing the hash. For more visit: aka.ms/msaljs/browser-errors."
	    },
	    hashDoesNotContainStateError: {
	        code: "no_state_in_hash",
	        desc: "Hash does not contain state. Please verify that the request originated from msal."
	    },
	    hashDoesNotContainKnownPropertiesError: {
	        code: "hash_does_not_contain_known_properties",
	        desc: "Hash does not contain known properites. Please verify that your redirectUri is not changing the hash. For more visit: aka.ms/msaljs/browser-errors."
	    },
	    unableToParseStateError: {
	        code: "unable_to_parse_state",
	        desc: "Unable to parse state. Please verify that the request originated from msal."
	    },
	    stateInteractionTypeMismatchError: {
	        code: "state_interaction_type_mismatch",
	        desc: "Hash contains state but the interaction type does not match the caller."
	    },
	    interactionInProgress: {
	        code: "interaction_in_progress",
	        desc: "Interaction is currently in progress. Please ensure that this interaction has been completed before calling an interactive API.  For more visit: aka.ms/msaljs/browser-errors."
	    },
	    popupWindowError: {
	        code: "popup_window_error",
	        desc: "Error opening popup window. This can happen if you are using IE or if popups are blocked in the browser."
	    },
	    emptyWindowError: {
	        code: "empty_window_error",
	        desc: "window.open returned null or undefined window object."
	    },
	    userCancelledError: {
	        code: "user_cancelled",
	        desc: "User cancelled the flow."
	    },
	    monitorPopupTimeoutError: {
	        code: "monitor_window_timeout",
	        desc: "Token acquisition in popup failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
	    },
	    monitorIframeTimeoutError: {
	        code: "monitor_window_timeout",
	        desc: "Token acquisition in iframe failed due to timeout. For more visit: aka.ms/msaljs/browser-errors."
	    },
	    redirectInIframeError: {
	        code: "redirect_in_iframe",
	        desc: "Redirects are not supported for iframed or brokered applications. Please ensure you are using MSAL.js in a top frame of the window if using the redirect APIs, or use the popup APIs."
	    },
	    blockTokenRequestsInHiddenIframeError: {
	        code: "block_iframe_reload",
	        desc: "Request was blocked inside an iframe because MSAL detected an authentication response. For more visit: aka.ms/msaljs/browser-errors"
	    },
	    blockAcquireTokenInPopupsError: {
	        code: "block_nested_popups",
	        desc: "Request was blocked inside a popup because MSAL detected it was running in a popup."
	    },
	    iframeClosedPrematurelyError: {
	        code: "iframe_closed_prematurely",
	        desc: "The iframe being monitored was closed prematurely."
	    },
	    silentLogoutUnsupportedError: {
	        code: "silent_logout_unsupported",
	        desc: "Silent logout not supported. Please call logoutRedirect or logoutPopup instead."
	    },
	    noAccountError: {
	        code: "no_account_error",
	        desc: "No account object provided to acquireTokenSilent and no active account has been set. Please call setActiveAccount or provide an account on the request."
	    },
	    silentPromptValueError: {
	        code: "silent_prompt_value_error",
	        desc: "The value given for the prompt value is not valid for silent requests - must be set to 'none' or 'no_session'."
	    },
	    noTokenRequestCacheError: {
	        code: "no_token_request_cache_error",
	        desc: "No token request found in cache."
	    },
	    unableToParseTokenRequestCacheError: {
	        code: "unable_to_parse_token_request_cache_error",
	        desc: "The cached token request could not be parsed."
	    },
	    noCachedAuthorityError: {
	        code: "no_cached_authority_error",
	        desc: "No cached authority found."
	    },
	    authRequestNotSet: {
	        code: "auth_request_not_set_error",
	        desc: "Auth Request not set. Please ensure initiateAuthRequest was called from the InteractionHandler"
	    },
	    invalidCacheType: {
	        code: "invalid_cache_type",
	        desc: "Invalid cache type"
	    },
	    notInBrowserEnvironment: {
	        code: "non_browser_environment",
	        desc: "Login and token requests are not supported in non-browser environments."
	    },
	    databaseNotOpen: {
	        code: "database_not_open",
	        desc: "Database is not open!"
	    },
	    noNetworkConnectivity: {
	        code: "no_network_connectivity",
	        desc: "No network connectivity. Check your internet connection."
	    },
	    postRequestFailed: {
	        code: "post_request_failed",
	        desc: "Network request failed: If the browser threw a CORS error, check that the redirectUri is registered in the Azure App Portal as type 'SPA'"
	    },
	    getRequestFailed: {
	        code: "get_request_failed",
	        desc: "Network request failed. Please check the network trace to determine root cause."
	    },
	    failedToParseNetworkResponse: {
	        code: "failed_to_parse_response",
	        desc: "Failed to parse network response. Check network trace."
	    },
	    unableToLoadTokenError: {
	        code: "unable_to_load_token",
	        desc: "Error loading token to cache."
	    },
	    signingKeyNotFoundInStorage: {
	        code: "crypto_key_not_found",
	        desc: "Cryptographic Key or Keypair not found in browser storage."
	    },
	    authCodeRequired: {
	        code: "auth_code_required",
	        desc: "An authorization code must be provided (as the `code` property on the request) to this flow."
	    },
	    authCodeOrNativeAccountRequired: {
	        code: "auth_code_or_nativeAccountId_required",
	        desc: "An authorization code or nativeAccountId must be provided to this flow."
	    },
	    spaCodeAndNativeAccountPresent: {
	        code: "spa_code_and_nativeAccountId_present",
	        desc: "Request cannot contain both spa code and native account id."
	    },
	    databaseUnavailable: {
	        code: "database_unavailable",
	        desc: "IndexedDB, which is required for persistent cryptographic key storage, is unavailable. This may be caused by browser privacy features which block persistent storage in third-party contexts."
	    },
	    unableToAcquireTokenFromNativePlatform: {
	        code: "unable_to_acquire_token_from_native_platform",
	        desc: "Unable to acquire token from native platform. For a list of possible reasons visit aka.ms/msaljs/browser-errors."
	    },
	    nativeHandshakeTimeout: {
	        code: "native_handshake_timeout",
	        desc: "Timed out while attempting to establish connection to browser extension"
	    },
	    nativeExtensionNotInstalled: {
	        code: "native_extension_not_installed",
	        desc: "Native extension is not installed. If you think this is a mistake call the initialize function."
	    },
	    nativeConnectionNotEstablished: {
	        code: "native_connection_not_established",
	        desc: "Connection to native platform has not been established. Please install a compatible browser extension and run initialize(). For more please visit aka.ms/msaljs/browser-errors."
	    },
	    nativeBrokerCalledBeforeInitialize: {
	        code: "native_broker_called_before_initialize",
	        desc: "You must call and await the initialize function before attempting to call any other MSAL API when native brokering is enabled. For more please visit aka.ms/msaljs/browser-errors."
	    },
	    nativePromptNotSupported: {
	        code: "native_prompt_not_supported",
	        desc: "The provided prompt is not supported by the native platform. This request should be routed to the web based flow."
	    }
	};
	/**
	 * Browser library error class thrown by the MSAL.js library for SPAs
	 */
	var BrowserAuthError = /** @class */ (function (_super) {
	    __extends$g(BrowserAuthError, _super);
	    function BrowserAuthError(errorCode, errorMessage) {
	        var _this = _super.call(this, errorCode, errorMessage) || this;
	        Object.setPrototypeOf(_this, BrowserAuthError.prototype);
	        _this.name = "BrowserAuthError";
	        return _this;
	    }
	    /**
	     * Creates an error thrown when PKCE is not implemented.
	     * @param errDetail
	     */
	    BrowserAuthError.createPkceNotGeneratedError = function (errDetail) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.pkceNotGenerated.code, BrowserAuthErrorMessage.pkceNotGenerated.desc + " Detail:" + errDetail);
	    };
	    /**
	     * Creates an error thrown when the crypto object is unavailable.
	     * @param errDetail
	     */
	    BrowserAuthError.createCryptoNotAvailableError = function (errDetail) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.cryptoDoesNotExist.code, BrowserAuthErrorMessage.cryptoDoesNotExist.desc + " Detail:" + errDetail);
	    };
	    /**
	     * Creates an error thrown when an HTTP method hasn't been implemented by the browser class.
	     * @param method
	     */
	    BrowserAuthError.createHttpMethodNotImplementedError = function (method) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.httpMethodNotImplementedError.code, BrowserAuthErrorMessage.httpMethodNotImplementedError.desc + " Given Method: " + method);
	    };
	    /**
	     * Creates an error thrown when the navigation URI is empty.
	     */
	    BrowserAuthError.createEmptyNavigationUriError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.emptyNavigateUriError.code, BrowserAuthErrorMessage.emptyNavigateUriError.desc);
	    };
	    /**
	     * Creates an error thrown when the hash string value is unexpectedly empty.
	     * @param hashValue
	     */
	    BrowserAuthError.createEmptyHashError = function (hashValue) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.hashEmptyError.code, BrowserAuthErrorMessage.hashEmptyError.desc + " Given Url: " + hashValue);
	    };
	    /**
	     * Creates an error thrown when the hash string value is unexpectedly empty.
	     */
	    BrowserAuthError.createHashDoesNotContainStateError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.hashDoesNotContainStateError.code, BrowserAuthErrorMessage.hashDoesNotContainStateError.desc);
	    };
	    /**
	     * Creates an error thrown when the hash string value does not contain known properties
	     */
	    BrowserAuthError.createHashDoesNotContainKnownPropertiesError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.hashDoesNotContainKnownPropertiesError.code, BrowserAuthErrorMessage.hashDoesNotContainKnownPropertiesError.desc);
	    };
	    /**
	     * Creates an error thrown when the hash string value is unexpectedly empty.
	     */
	    BrowserAuthError.createUnableToParseStateError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.unableToParseStateError.code, BrowserAuthErrorMessage.unableToParseStateError.desc);
	    };
	    /**
	     * Creates an error thrown when the state value in the hash does not match the interaction type of the API attempting to consume it.
	     */
	    BrowserAuthError.createStateInteractionTypeMismatchError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.stateInteractionTypeMismatchError.code, BrowserAuthErrorMessage.stateInteractionTypeMismatchError.desc);
	    };
	    /**
	     * Creates an error thrown when a browser interaction (redirect or popup) is in progress.
	     */
	    BrowserAuthError.createInteractionInProgressError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.interactionInProgress.code, BrowserAuthErrorMessage.interactionInProgress.desc);
	    };
	    /**
	     * Creates an error thrown when the popup window could not be opened.
	     * @param errDetail
	     */
	    BrowserAuthError.createPopupWindowError = function (errDetail) {
	        var errorMessage = BrowserAuthErrorMessage.popupWindowError.desc;
	        errorMessage = !StringUtils.isEmpty(errDetail) ? errorMessage + " Details: " + errDetail : errorMessage;
	        return new BrowserAuthError(BrowserAuthErrorMessage.popupWindowError.code, errorMessage);
	    };
	    /**
	     * Creates an error thrown when window.open returns an empty window object.
	     * @param errDetail
	     */
	    BrowserAuthError.createEmptyWindowCreatedError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.emptyWindowError.code, BrowserAuthErrorMessage.emptyWindowError.desc);
	    };
	    /**
	     * Creates an error thrown when the user closes a popup.
	     */
	    BrowserAuthError.createUserCancelledError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.userCancelledError.code, BrowserAuthErrorMessage.userCancelledError.desc);
	    };
	    /**
	     * Creates an error thrown when monitorPopupFromHash times out for a given popup.
	     */
	    BrowserAuthError.createMonitorPopupTimeoutError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.monitorPopupTimeoutError.code, BrowserAuthErrorMessage.monitorPopupTimeoutError.desc);
	    };
	    /**
	     * Creates an error thrown when monitorIframeFromHash times out for a given iframe.
	     */
	    BrowserAuthError.createMonitorIframeTimeoutError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.monitorIframeTimeoutError.code, BrowserAuthErrorMessage.monitorIframeTimeoutError.desc);
	    };
	    /**
	     * Creates an error thrown when navigateWindow is called inside an iframe or brokered applications.
	     * @param windowParentCheck
	     */
	    BrowserAuthError.createRedirectInIframeError = function (windowParentCheck) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.redirectInIframeError.code, BrowserAuthErrorMessage.redirectInIframeError.desc + " (window.parent !== window) => " + windowParentCheck);
	    };
	    /**
	     * Creates an error thrown when an auth reload is done inside an iframe.
	     */
	    BrowserAuthError.createBlockReloadInHiddenIframeError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.blockTokenRequestsInHiddenIframeError.code, BrowserAuthErrorMessage.blockTokenRequestsInHiddenIframeError.desc);
	    };
	    /**
	     * Creates an error thrown when a popup attempts to call an acquireToken API
	     * @returns
	     */
	    BrowserAuthError.createBlockAcquireTokenInPopupsError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.blockAcquireTokenInPopupsError.code, BrowserAuthErrorMessage.blockAcquireTokenInPopupsError.desc);
	    };
	    /**
	     * Creates an error thrown when an iframe is found to be closed before the timeout is reached.
	     */
	    BrowserAuthError.createIframeClosedPrematurelyError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.iframeClosedPrematurelyError.code, BrowserAuthErrorMessage.iframeClosedPrematurelyError.desc);
	    };
	    /**
	     * Creates an error thrown when the logout API is called on any of the silent interaction clients
	     */
	    BrowserAuthError.createSilentLogoutUnsupportedError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.silentLogoutUnsupportedError.code, BrowserAuthErrorMessage.silentLogoutUnsupportedError.desc);
	    };
	    /**
	     * Creates an error thrown when the account object is not provided in the acquireTokenSilent API.
	     */
	    BrowserAuthError.createNoAccountError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.noAccountError.code, BrowserAuthErrorMessage.noAccountError.desc);
	    };
	    /**
	     * Creates an error thrown when a given prompt value is invalid for silent requests.
	     */
	    BrowserAuthError.createSilentPromptValueError = function (givenPrompt) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.silentPromptValueError.code, BrowserAuthErrorMessage.silentPromptValueError.desc + " Given value: " + givenPrompt);
	    };
	    /**
	     * Creates an error thrown when the cached token request could not be retrieved from the cache
	     */
	    BrowserAuthError.createUnableToParseTokenRequestCacheError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.unableToParseTokenRequestCacheError.code, BrowserAuthErrorMessage.unableToParseTokenRequestCacheError.desc);
	    };
	    /**
	     * Creates an error thrown when the token request could not be retrieved from the cache
	     */
	    BrowserAuthError.createNoTokenRequestCacheError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.noTokenRequestCacheError.code, BrowserAuthErrorMessage.noTokenRequestCacheError.desc);
	    };
	    /**
	     * Creates an error thrown when handleCodeResponse is called before initiateAuthRequest (InteractionHandler)
	     */
	    BrowserAuthError.createAuthRequestNotSetError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.authRequestNotSet.code, BrowserAuthErrorMessage.authRequestNotSet.desc);
	    };
	    /**
	     * Creates an error thrown when the authority could not be retrieved from the cache
	     */
	    BrowserAuthError.createNoCachedAuthorityError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.noCachedAuthorityError.code, BrowserAuthErrorMessage.noCachedAuthorityError.desc);
	    };
	    /**
	     * Creates an error thrown if cache type is invalid.
	     */
	    BrowserAuthError.createInvalidCacheTypeError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.invalidCacheType.code, "" + BrowserAuthErrorMessage.invalidCacheType.desc);
	    };
	    /**
	     * Create an error thrown when login and token requests are made from a non-browser environment
	     */
	    BrowserAuthError.createNonBrowserEnvironmentError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.notInBrowserEnvironment.code, BrowserAuthErrorMessage.notInBrowserEnvironment.desc);
	    };
	    /**
	     * Create an error thrown when indexDB database is not open
	     */
	    BrowserAuthError.createDatabaseNotOpenError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.databaseNotOpen.code, BrowserAuthErrorMessage.databaseNotOpen.desc);
	    };
	    /**
	     * Create an error thrown when token fetch fails due to no internet
	     */
	    BrowserAuthError.createNoNetworkConnectivityError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.noNetworkConnectivity.code, BrowserAuthErrorMessage.noNetworkConnectivity.desc);
	    };
	    /**
	     * Create an error thrown when token fetch fails due to reasons other than internet connectivity
	     */
	    BrowserAuthError.createPostRequestFailedError = function (errorDesc, endpoint) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.postRequestFailed.code, BrowserAuthErrorMessage.postRequestFailed.desc + " | Network client threw: " + errorDesc + " | Attempted to reach: " + endpoint.split("?")[0]);
	    };
	    /**
	     * Create an error thrown when get request fails due to reasons other than internet connectivity
	     */
	    BrowserAuthError.createGetRequestFailedError = function (errorDesc, endpoint) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.getRequestFailed.code, BrowserAuthErrorMessage.getRequestFailed.desc + " | Network client threw: " + errorDesc + " | Attempted to reach: " + endpoint.split("?")[0]);
	    };
	    /**
	     * Create an error thrown when network client fails to parse network response
	     */
	    BrowserAuthError.createFailedToParseNetworkResponseError = function (endpoint) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.failedToParseNetworkResponse.code, BrowserAuthErrorMessage.failedToParseNetworkResponse.desc + " | Attempted to reach: " + endpoint.split("?")[0]);
	    };
	    /**
	     * Create an error thrown when the necessary information is not available to sideload tokens
	     */
	    BrowserAuthError.createUnableToLoadTokenError = function (errorDetail) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.unableToLoadTokenError.code, BrowserAuthErrorMessage.unableToLoadTokenError.desc + " | " + errorDetail);
	    };
	    /**
	     * Create an error thrown when the queried cryptographic key is not found in IndexedDB
	     */
	    BrowserAuthError.createSigningKeyNotFoundInStorageError = function (keyId) {
	        return new BrowserAuthError(BrowserAuthErrorMessage.signingKeyNotFoundInStorage.code, BrowserAuthErrorMessage.signingKeyNotFoundInStorage.desc + " | No match found for KeyId: " + keyId);
	    };
	    /**
	     * Create an error when an authorization code is required but not provided
	     */
	    BrowserAuthError.createAuthCodeRequiredError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.authCodeRequired.code, BrowserAuthErrorMessage.authCodeRequired.desc);
	    };
	    /**
	     * Create an error when an authorization code or native account ID is required but not provided
	     */
	    BrowserAuthError.createAuthCodeOrNativeAccountIdRequiredError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.authCodeOrNativeAccountRequired.code, BrowserAuthErrorMessage.authCodeOrNativeAccountRequired.desc);
	    };
	    /**
	     * Create an error when both authorization code and native account ID are provided
	     */
	    BrowserAuthError.createSpaCodeAndNativeAccountIdPresentError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.spaCodeAndNativeAccountPresent.code, BrowserAuthErrorMessage.spaCodeAndNativeAccountPresent.desc);
	    };
	    /**
	     * Create an error when IndexedDB is unavailable
	     */
	    BrowserAuthError.createDatabaseUnavailableError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.databaseUnavailable.code, BrowserAuthErrorMessage.databaseUnavailable.desc);
	    };
	    /**
	     * Create an error when native token acquisition is not possible
	     */
	    BrowserAuthError.createUnableToAcquireTokenFromNativePlatformError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.unableToAcquireTokenFromNativePlatform.code, BrowserAuthErrorMessage.unableToAcquireTokenFromNativePlatform.desc);
	    };
	    /**
	     * Create an error thrown when Handshake with browser extension times out
	     */
	    BrowserAuthError.createNativeHandshakeTimeoutError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.nativeHandshakeTimeout.code, BrowserAuthErrorMessage.nativeHandshakeTimeout.desc);
	    };
	    /**
	     * Create an error thrown when browser extension is not installed
	     */
	    BrowserAuthError.createNativeExtensionNotInstalledError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.nativeExtensionNotInstalled.code, BrowserAuthErrorMessage.nativeExtensionNotInstalled.desc);
	    };
	    /**
	     * Create an error when native connection has not been established
	     * @returns
	     */
	    BrowserAuthError.createNativeConnectionNotEstablishedError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.nativeConnectionNotEstablished.code, BrowserAuthErrorMessage.nativeConnectionNotEstablished.desc);
	    };
	    /**
	     * Create an error thrown when the initialize function hasn't been called
	     */
	    BrowserAuthError.createNativeBrokerCalledBeforeInitialize = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.nativeBrokerCalledBeforeInitialize.code, BrowserAuthErrorMessage.nativeBrokerCalledBeforeInitialize.desc);
	    };
	    /**
	     * Create an error thrown when requesting a token directly from the native platform with an unsupported prompt parameter e.g. select_account, login or create
	     * These requests must go through eSTS to ensure eSTS is aware of the new account
	     */
	    BrowserAuthError.createNativePromptParameterNotSupportedError = function () {
	        return new BrowserAuthError(BrowserAuthErrorMessage.nativePromptNotSupported.code, BrowserAuthErrorMessage.nativePromptNotSupported.desc);
	    };
	    return BrowserAuthError;
	}(AuthError));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Constants
	 */
	var BrowserConstants = {
	    /**
	     * Interaction in progress cache value
	     */
	    INTERACTION_IN_PROGRESS_VALUE: "interaction_in_progress",
	    /**
	     * Invalid grant error code
	     */
	    INVALID_GRANT_ERROR: "invalid_grant",
	    /**
	     * Default popup window width
	     */
	    POPUP_WIDTH: 483,
	    /**
	     * Default popup window height
	     */
	    POPUP_HEIGHT: 600,
	    /**
	     * Name of the popup window starts with
	     */
	    POPUP_NAME_PREFIX: "msal",
	    /**
	     * Default popup monitor poll interval in milliseconds
	     */
	    DEFAULT_POLL_INTERVAL_MS: 30,
	    /**
	     * Msal-browser SKU
	     */
	    MSAL_SKU: "msal.js.browser",
	};
	var NativeConstants = {
	    CHANNEL_ID: "53ee284d-920a-4b59-9d30-a60315b26836",
	    PREFERRED_EXTENSION_ID: "ppnbnpeolgkicgegkbkbjmhlideopiji",
	    MATS_TELEMETRY: "MATS"
	};
	var NativeExtensionMethod;
	(function (NativeExtensionMethod) {
	    NativeExtensionMethod["HandshakeRequest"] = "Handshake";
	    NativeExtensionMethod["HandshakeResponse"] = "HandshakeResponse";
	    NativeExtensionMethod["GetToken"] = "GetToken";
	    NativeExtensionMethod["Response"] = "Response";
	})(NativeExtensionMethod || (NativeExtensionMethod = {}));
	var BrowserCacheLocation;
	(function (BrowserCacheLocation) {
	    BrowserCacheLocation["LocalStorage"] = "localStorage";
	    BrowserCacheLocation["SessionStorage"] = "sessionStorage";
	    BrowserCacheLocation["MemoryStorage"] = "memoryStorage";
	})(BrowserCacheLocation || (BrowserCacheLocation = {}));
	/**
	 * HTTP Request types supported by MSAL.
	 */
	var HTTP_REQUEST_TYPE;
	(function (HTTP_REQUEST_TYPE) {
	    HTTP_REQUEST_TYPE["GET"] = "GET";
	    HTTP_REQUEST_TYPE["POST"] = "POST";
	})(HTTP_REQUEST_TYPE || (HTTP_REQUEST_TYPE = {}));
	/**
	 * Temporary cache keys for MSAL, deleted after any request.
	 */
	var TemporaryCacheKeys;
	(function (TemporaryCacheKeys) {
	    TemporaryCacheKeys["AUTHORITY"] = "authority";
	    TemporaryCacheKeys["ACQUIRE_TOKEN_ACCOUNT"] = "acquireToken.account";
	    TemporaryCacheKeys["SESSION_STATE"] = "session.state";
	    TemporaryCacheKeys["REQUEST_STATE"] = "request.state";
	    TemporaryCacheKeys["NONCE_IDTOKEN"] = "nonce.id_token";
	    TemporaryCacheKeys["ORIGIN_URI"] = "request.origin";
	    TemporaryCacheKeys["RENEW_STATUS"] = "token.renew.status";
	    TemporaryCacheKeys["URL_HASH"] = "urlHash";
	    TemporaryCacheKeys["REQUEST_PARAMS"] = "request.params";
	    TemporaryCacheKeys["SCOPES"] = "scopes";
	    TemporaryCacheKeys["INTERACTION_STATUS_KEY"] = "interaction.status";
	    TemporaryCacheKeys["CCS_CREDENTIAL"] = "ccs.credential";
	    TemporaryCacheKeys["CORRELATION_ID"] = "request.correlationId";
	    TemporaryCacheKeys["NATIVE_REQUEST"] = "request.native";
	    TemporaryCacheKeys["REDIRECT_CONTEXT"] = "request.redirect.context";
	})(TemporaryCacheKeys || (TemporaryCacheKeys = {}));
	var StaticCacheKeys;
	(function (StaticCacheKeys) {
	    StaticCacheKeys["ACCOUNT_KEYS"] = "msal.account.keys";
	    StaticCacheKeys["TOKEN_KEYS"] = "msal.token.keys";
	})(StaticCacheKeys || (StaticCacheKeys = {}));
	/**
	 * Cache keys stored in-memory
	 */
	var InMemoryCacheKeys;
	(function (InMemoryCacheKeys) {
	    InMemoryCacheKeys["WRAPPER_SKU"] = "wrapper.sku";
	    InMemoryCacheKeys["WRAPPER_VER"] = "wrapper.version";
	})(InMemoryCacheKeys || (InMemoryCacheKeys = {}));
	/**
	 * API Codes for Telemetry purposes.
	 * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs
	 * 0-99 Silent Flow
	 * 800-899 Auth Code Flow
	 */
	var ApiId;
	(function (ApiId) {
	    ApiId[ApiId["acquireTokenRedirect"] = 861] = "acquireTokenRedirect";
	    ApiId[ApiId["acquireTokenPopup"] = 862] = "acquireTokenPopup";
	    ApiId[ApiId["ssoSilent"] = 863] = "ssoSilent";
	    ApiId[ApiId["acquireTokenSilent_authCode"] = 864] = "acquireTokenSilent_authCode";
	    ApiId[ApiId["handleRedirectPromise"] = 865] = "handleRedirectPromise";
	    ApiId[ApiId["acquireTokenByCode"] = 866] = "acquireTokenByCode";
	    ApiId[ApiId["acquireTokenSilent_silentFlow"] = 61] = "acquireTokenSilent_silentFlow";
	    ApiId[ApiId["logout"] = 961] = "logout";
	    ApiId[ApiId["logoutPopup"] = 962] = "logoutPopup";
	})(ApiId || (ApiId = {}));
	/*
	 * Interaction type of the API - used for state and telemetry
	 */
	var InteractionType;
	(function (InteractionType) {
	    InteractionType["Redirect"] = "redirect";
	    InteractionType["Popup"] = "popup";
	    InteractionType["Silent"] = "silent";
	    InteractionType["None"] = "none";
	})(InteractionType || (InteractionType = {}));
	/**
	 * Types of interaction currently in progress.
	 * Used in events in wrapper libraries to invoke functions when certain interaction is in progress or all interactions are complete.
	 */
	var InteractionStatus;
	(function (InteractionStatus) {
	    /**
	     * Initial status before interaction occurs
	     */
	    InteractionStatus["Startup"] = "startup";
	    /**
	     * Status set when all login calls occuring
	     */
	    InteractionStatus["Login"] = "login";
	    /**
	     * Status set when logout call occuring
	     */
	    InteractionStatus["Logout"] = "logout";
	    /**
	     * Status set for acquireToken calls
	     */
	    InteractionStatus["AcquireToken"] = "acquireToken";
	    /**
	     * Status set for ssoSilent calls
	     */
	    InteractionStatus["SsoSilent"] = "ssoSilent";
	    /**
	     * Status set when handleRedirect in progress
	     */
	    InteractionStatus["HandleRedirect"] = "handleRedirect";
	    /**
	     * Status set when interaction is complete
	     */
	    InteractionStatus["None"] = "none";
	})(InteractionStatus || (InteractionStatus = {}));
	var DEFAULT_REQUEST = {
	    scopes: OIDC_DEFAULT_SCOPES
	};
	/**
	 * JWK Key Format string (Type MUST be defined for window crypto APIs)
	 */
	var KEY_FORMAT_JWK = "jwk";
	// Supported wrapper SKUs
	var WrapperSKU;
	(function (WrapperSKU) {
	    WrapperSKU["React"] = "@azure/msal-react";
	    WrapperSKU["Angular"] = "@azure/msal-angular";
	})(WrapperSKU || (WrapperSKU = {}));
	// DatabaseStorage Constants
	var DB_NAME = "msal.db";
	var DB_VERSION = 1;
	var DB_TABLE_NAME = DB_NAME + ".keys";
	var CacheLookupPolicy;
	(function (CacheLookupPolicy) {
	    /*
	     * acquireTokenSilent will attempt to retrieve an access token from the cache. If the access token is expired
	     * or cannot be found the refresh token will be used to acquire a new one. Finally, if the refresh token
	     * is expired acquireTokenSilent will attempt to acquire new access and refresh tokens.
	     */
	    CacheLookupPolicy[CacheLookupPolicy["Default"] = 0] = "Default";
	    /*
	     * acquireTokenSilent will only look for access tokens in the cache. It will not attempt to renew access or
	     * refresh tokens.
	     */
	    CacheLookupPolicy[CacheLookupPolicy["AccessToken"] = 1] = "AccessToken";
	    /*
	     * acquireTokenSilent will attempt to retrieve an access token from the cache. If the access token is expired or
	     * cannot be found, the refresh token will be used to acquire a new one. If the refresh token is expired, it
	     * will not be renewed and acquireTokenSilent will fail.
	     */
	    CacheLookupPolicy[CacheLookupPolicy["AccessTokenAndRefreshToken"] = 2] = "AccessTokenAndRefreshToken";
	    /*
	     * acquireTokenSilent will not attempt to retrieve access tokens from the cache and will instead attempt to
	     * exchange the cached refresh token for a new access token. If the refresh token is expired, it will not be
	     * renewed and acquireTokenSilent will fail.
	     */
	    CacheLookupPolicy[CacheLookupPolicy["RefreshToken"] = 3] = "RefreshToken";
	    /*
	     * acquireTokenSilent will not look in the cache for the access token. It will go directly to network with the
	     * cached refresh token. If the refresh token is expired an attempt will be made to renew it. This is equivalent to
	     * setting "forceRefresh: true".
	     */
	    CacheLookupPolicy[CacheLookupPolicy["RefreshTokenAndNetwork"] = 4] = "RefreshTokenAndNetwork";
	    /*
	     * acquireTokenSilent will attempt to renew both access and refresh tokens. It will not look in the cache. This will
	     * always fail if 3rd party cookies are blocked by the browser.
	     */
	    CacheLookupPolicy[CacheLookupPolicy["Skip"] = 5] = "Skip";
	})(CacheLookupPolicy || (CacheLookupPolicy = {}));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * BrowserAuthErrorMessage class containing string constants used by error codes and messages.
	 */
	var BrowserConfigurationAuthErrorMessage = {
	    redirectUriNotSet: {
	        code: "redirect_uri_empty",
	        desc: "A redirect URI is required for all calls, and none has been set."
	    },
	    postLogoutUriNotSet: {
	        code: "post_logout_uri_empty",
	        desc: "A post logout redirect has not been set."
	    },
	    storageNotSupportedError: {
	        code: "storage_not_supported",
	        desc: "Given storage configuration option was not supported."
	    },
	    noRedirectCallbacksSet: {
	        code: "no_redirect_callbacks",
	        desc: "No redirect callbacks have been set. Please call setRedirectCallbacks() with the appropriate function arguments before continuing. " +
	            "More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
	    },
	    invalidCallbackObject: {
	        code: "invalid_callback_object",
	        desc: "The object passed for the callback was invalid. " +
	            "More information is available here: https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL-basics."
	    },
	    stubPcaInstanceCalled: {
	        code: "stubbed_public_client_application_called",
	        desc: "Stub instance of Public Client Application was called. If using msal-react, please ensure context is not used without a provider. For more visit: aka.ms/msaljs/browser-errors"
	    },
	    inMemRedirectUnavailable: {
	        code: "in_mem_redirect_unavailable",
	        desc: "Redirect cannot be supported. In-memory storage was selected and storeAuthStateInCookie=false, which would cause the library to be unable to handle the incoming hash. If you would like to use the redirect API, please use session/localStorage or set storeAuthStateInCookie=true."
	    },
	    entropyNotProvided: {
	        code: "entropy_not_provided",
	        desc: "The available browser crypto interface requires entropy set via system.cryptoOptions.entropy configuration option."
	    }
	};
	/**
	 * Browser library error class thrown by the MSAL.js library for SPAs
	 */
	var BrowserConfigurationAuthError = /** @class */ (function (_super) {
	    __extends$g(BrowserConfigurationAuthError, _super);
	    function BrowserConfigurationAuthError(errorCode, errorMessage) {
	        var _this = _super.call(this, errorCode, errorMessage) || this;
	        _this.name = "BrowserConfigurationAuthError";
	        Object.setPrototypeOf(_this, BrowserConfigurationAuthError.prototype);
	        return _this;
	    }
	    /**
	     * Creates an error thrown when the redirect uri is empty (not set by caller)
	     */
	    BrowserConfigurationAuthError.createRedirectUriEmptyError = function () {
	        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.redirectUriNotSet.code, BrowserConfigurationAuthErrorMessage.redirectUriNotSet.desc);
	    };
	    /**
	     * Creates an error thrown when the post-logout redirect uri is empty (not set by caller)
	     */
	    BrowserConfigurationAuthError.createPostLogoutRedirectUriEmptyError = function () {
	        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.postLogoutUriNotSet.code, BrowserConfigurationAuthErrorMessage.postLogoutUriNotSet.desc);
	    };
	    /**
	     * Creates error thrown when given storage location is not supported.
	     * @param givenStorageLocation
	     */
	    BrowserConfigurationAuthError.createStorageNotSupportedError = function (givenStorageLocation) {
	        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.storageNotSupportedError.code, BrowserConfigurationAuthErrorMessage.storageNotSupportedError.desc + " Given Location: " + givenStorageLocation);
	    };
	    /**
	     * Creates error thrown when redirect callbacks are not set before calling loginRedirect() or acquireTokenRedirect().
	     */
	    BrowserConfigurationAuthError.createRedirectCallbacksNotSetError = function () {
	        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.noRedirectCallbacksSet.code, BrowserConfigurationAuthErrorMessage.noRedirectCallbacksSet.desc);
	    };
	    /**
	     * Creates error thrown when the stub instance of PublicClientApplication is called.
	     */
	    BrowserConfigurationAuthError.createStubPcaInstanceCalledError = function () {
	        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.stubPcaInstanceCalled.code, BrowserConfigurationAuthErrorMessage.stubPcaInstanceCalled.desc);
	    };
	    /*
	     * Create an error thrown when in-memory storage is used and storeAuthStateInCookie=false.
	     */
	    BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError = function () {
	        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.inMemRedirectUnavailable.code, BrowserConfigurationAuthErrorMessage.inMemRedirectUnavailable.desc);
	    };
	    /**
	     * Creates an error thrown when a crypto interface that requires entropy is initialized without entropy
	     */
	    BrowserConfigurationAuthError.createEntropyNotProvided = function () {
	        return new BrowserConfigurationAuthError(BrowserConfigurationAuthErrorMessage.entropyNotProvided.code, BrowserConfigurationAuthErrorMessage.entropyNotProvided.desc);
	    };
	    return BrowserConfigurationAuthError;
	}(AuthError));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var BrowserStorage = /** @class */ (function () {
	    function BrowserStorage(cacheLocation) {
	        this.validateWindowStorage(cacheLocation);
	        this.windowStorage = window[cacheLocation];
	    }
	    BrowserStorage.prototype.validateWindowStorage = function (cacheLocation) {
	        if (cacheLocation !== BrowserCacheLocation.LocalStorage && cacheLocation !== BrowserCacheLocation.SessionStorage) {
	            throw BrowserConfigurationAuthError.createStorageNotSupportedError(cacheLocation);
	        }
	        var storageSupported = !!window[cacheLocation];
	        if (!storageSupported) {
	            throw BrowserConfigurationAuthError.createStorageNotSupportedError(cacheLocation);
	        }
	    };
	    BrowserStorage.prototype.getItem = function (key) {
	        return this.windowStorage.getItem(key);
	    };
	    BrowserStorage.prototype.setItem = function (key, value) {
	        this.windowStorage.setItem(key, value);
	    };
	    BrowserStorage.prototype.removeItem = function (key) {
	        this.windowStorage.removeItem(key);
	    };
	    BrowserStorage.prototype.getKeys = function () {
	        return Object.keys(this.windowStorage);
	    };
	    BrowserStorage.prototype.containsKey = function (key) {
	        return this.windowStorage.hasOwnProperty(key);
	    };
	    return BrowserStorage;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var MemoryStorage = /** @class */ (function () {
	    function MemoryStorage() {
	        this.cache = new Map();
	    }
	    MemoryStorage.prototype.getItem = function (key) {
	        return this.cache.get(key) || null;
	    };
	    MemoryStorage.prototype.setItem = function (key, value) {
	        this.cache.set(key, value);
	    };
	    MemoryStorage.prototype.removeItem = function (key) {
	        this.cache.delete(key);
	    };
	    MemoryStorage.prototype.getKeys = function () {
	        var cacheKeys = [];
	        this.cache.forEach(function (value, key) {
	            cacheKeys.push(key);
	        });
	        return cacheKeys;
	    };
	    MemoryStorage.prototype.containsKey = function (key) {
	        return this.cache.has(key);
	    };
	    MemoryStorage.prototype.clear = function () {
	        this.cache.clear();
	    };
	    return MemoryStorage;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var BrowserProtocolUtils = /** @class */ (function () {
	    function BrowserProtocolUtils() {
	    }
	    /**
	     * Extracts the BrowserStateObject from the state string.
	     * @param browserCrypto
	     * @param state
	     */
	    BrowserProtocolUtils.extractBrowserRequestState = function (browserCrypto, state) {
	        if (StringUtils.isEmpty(state)) {
	            return null;
	        }
	        try {
	            var requestStateObj = ProtocolUtils.parseRequestState(browserCrypto, state);
	            return requestStateObj.libraryState.meta;
	        }
	        catch (e) {
	            throw ClientAuthError.createInvalidStateError(state, e);
	        }
	    };
	    /**
	     * Parses properties of server response from url hash
	     * @param locationHash Hash from url
	     */
	    BrowserProtocolUtils.parseServerResponseFromHash = function (locationHash) {
	        if (!locationHash) {
	            return {};
	        }
	        var hashUrlString = new UrlString(locationHash);
	        return UrlString.getDeserializedHash(hashUrlString.getHash());
	    };
	    return BrowserProtocolUtils;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * This class implements the cache storage interface for MSAL through browser local or session storage.
	 * Cookies are only used if storeAuthStateInCookie is true, and are only used for
	 * parameters such as state and nonce, generally.
	 */
	var BrowserCacheManager = /** @class */ (function (_super) {
	    __extends$g(BrowserCacheManager, _super);
	    function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {
	        var _this = _super.call(this, clientId, cryptoImpl, logger) || this;
	        // Cookie life calculation (hours * minutes * seconds * ms)
	        _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;
	        _this.cacheConfig = cacheConfig;
	        _this.logger = logger;
	        _this.internalStorage = new MemoryStorage();
	        _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);
	        _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.temporaryCacheLocation, _this.cacheConfig.cacheLocation);
	        // Migrate cache entries from older versions of MSAL.
	        if (cacheConfig.cacheMigrationEnabled) {
	            _this.migrateCacheEntries();
	            _this.createKeyMaps();
	        }
	        return _this;
	    }
	    /**
	     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.
	     * @param cacheLocation
	     */
	    BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {
	        switch (cacheLocation) {
	            case BrowserCacheLocation.LocalStorage:
	            case BrowserCacheLocation.SessionStorage:
	                try {
	                    return new BrowserStorage(cacheLocation);
	                }
	                catch (e) {
	                    this.logger.verbose(e);
	                    break;
	                }
	        }
	        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;
	        return new MemoryStorage();
	    };
	    /**
	     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.
	     * @param temporaryCacheLocation
	     * @param cacheLocation
	     */
	    BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (temporaryCacheLocation, cacheLocation) {
	        switch (cacheLocation) {
	            case BrowserCacheLocation.LocalStorage:
	            case BrowserCacheLocation.SessionStorage:
	                try {
	                    /*
	                     * When users do not explicitly choose their own temporaryCacheLocation,
	                     * temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs
	                     */
	                    return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);
	                }
	                catch (e) {
	                    this.logger.verbose(e);
	                    return this.internalStorage;
	                }
	            case BrowserCacheLocation.MemoryStorage:
	            default:
	                return this.internalStorage;
	        }
	    };
	    /**
	     * Migrate all old cache entries to new schema. No rollback supported.
	     * @param storeAuthStateInCookie
	     */
	    BrowserCacheManager.prototype.migrateCacheEntries = function () {
	        var _this = this;
	        var idTokenKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ID_TOKEN;
	        var clientInfoKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.CLIENT_INFO;
	        var errorKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ERROR;
	        var errorDescKey = Constants.CACHE_PREFIX + "." + PersistentCacheKeys.ERROR_DESC;
	        var idTokenValue = this.browserStorage.getItem(idTokenKey);
	        var clientInfoValue = this.browserStorage.getItem(clientInfoKey);
	        var errorValue = this.browserStorage.getItem(errorKey);
	        var errorDescValue = this.browserStorage.getItem(errorDescKey);
	        var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];
	        var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];
	        keysToMigrate.forEach(function (cacheKey, index) { return _this.migrateCacheEntry(cacheKey, values[index]); });
	    };
	    /**
	     * Utility function to help with migration.
	     * @param newKey
	     * @param value
	     * @param storeAuthStateInCookie
	     */
	    BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {
	        if (value) {
	            this.setTemporaryCache(newKey, value, true);
	        }
	    };
	    /**
	     * Searches all cache entries for MSAL accounts and creates the account key map
	     * This is used to migrate users from older versions of MSAL which did not create the map.
	     * @returns
	     */
	    BrowserCacheManager.prototype.createKeyMaps = function () {
	        var _this = this;
	        this.logger.trace("BrowserCacheManager - createKeyMaps called.");
	        var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);
	        var tokenKeys = this.getItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId);
	        if (accountKeys && tokenKeys) {
	            this.logger.verbose("BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.");
	            // Key maps already exist, no need to iterate through cache
	            return;
	        }
	        var allKeys = this.browserStorage.getKeys();
	        allKeys.forEach(function (key) {
	            if (_this.isCredentialKey(key)) {
	                // Get item, parse, validate and write key to map
	                var value = _this.getItem(key);
	                if (value) {
	                    var credObj = _this.validateAndParseJson(value);
	                    if (credObj && credObj.hasOwnProperty("credentialType")) {
	                        switch (credObj["credentialType"]) {
	                            case CredentialType.ID_TOKEN:
	                                if (IdTokenEntity.isIdTokenEntity(credObj)) {
	                                    _this.logger.trace("BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map");
	                                    _this.logger.tracePii("BrowserCacheManager:createKeyMaps - idToken with key: " + key + " found, saving key to token key map");
	                                    var idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);
	                                    var newKey = _this.updateCredentialCacheKey(key, idTokenEntity);
	                                    _this.addTokenKey(newKey, CredentialType.ID_TOKEN);
	                                    return;
	                                }
	                                else {
	                                    _this.logger.trace("BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.");
	                                    _this.logger.tracePii("BrowserCacheManager:createKeyMaps - failed idToken validation on key: " + key);
	                                }
	                                break;
	                            case CredentialType.ACCESS_TOKEN:
	                            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:
	                                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {
	                                    _this.logger.trace("BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map");
	                                    _this.logger.tracePii("BrowserCacheManager:createKeyMaps - accessToken with key: " + key + " found, saving key to token key map");
	                                    var accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);
	                                    var newKey = _this.updateCredentialCacheKey(key, accessTokenEntity);
	                                    _this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);
	                                    return;
	                                }
	                                else {
	                                    _this.logger.trace("BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.");
	                                    _this.logger.tracePii("BrowserCacheManager:createKeyMaps - failed accessToken validation on key: " + key);
	                                }
	                                break;
	                            case CredentialType.REFRESH_TOKEN:
	                                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {
	                                    _this.logger.trace("BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map");
	                                    _this.logger.tracePii("BrowserCacheManager:createKeyMaps - refreshToken with key: " + key + " found, saving key to token key map");
	                                    var refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);
	                                    var newKey = _this.updateCredentialCacheKey(key, refreshTokenEntity);
	                                    _this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);
	                                    return;
	                                }
	                                else {
	                                    _this.logger.trace("BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.");
	                                    _this.logger.tracePii("BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: " + key);
	                                }
	                                break;
	                            // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.
	                        }
	                    }
	                }
	            }
	            if (_this.isAccountKey(key)) {
	                var value = _this.getItem(key);
	                if (value) {
	                    var accountObj = _this.validateAndParseJson(value);
	                    if (accountObj && AccountEntity.isAccountEntity(accountObj)) {
	                        _this.logger.trace("BrowserCacheManager:createKeyMaps - account found, saving key to account key map");
	                        _this.logger.tracePii("BrowserCacheManager:createKeyMaps - account with key: " + key + " found, saving key to account key map");
	                        _this.addAccountKeyToMap(key);
	                    }
	                }
	            }
	        });
	    };
	    /**
	     * Parses passed value as JSON object, JSON.parse() will throw an error.
	     * @param input
	     */
	    BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {
	        try {
	            var parsedJson = JSON.parse(jsonValue);
	            /**
	             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object
	             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check
	             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.
	             *
	             */
	            return (parsedJson && typeof parsedJson === "object") ? parsedJson : null;
	        }
	        catch (error) {
	            return null;
	        }
	    };
	    /**
	     * fetches the entry from the browser storage based off the key
	     * @param key
	     */
	    BrowserCacheManager.prototype.getItem = function (key) {
	        return this.browserStorage.getItem(key);
	    };
	    /**
	     * sets the entry in the browser storage
	     * @param key
	     * @param value
	     */
	    BrowserCacheManager.prototype.setItem = function (key, value) {
	        this.browserStorage.setItem(key, value);
	    };
	    /**
	     * fetch the account entity from the platform cache
	     * @param accountKey
	     */
	    BrowserCacheManager.prototype.getAccount = function (accountKey) {
	        this.logger.trace("BrowserCacheManager.getAccount called");
	        var account = this.getItem(accountKey);
	        if (!account) {
	            this.removeAccountKeyFromMap(accountKey);
	            return null;
	        }
	        var parsedAccount = this.validateAndParseJson(account);
	        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {
	            this.removeAccountKeyFromMap(accountKey);
	            return null;
	        }
	        return CacheManager.toObject(new AccountEntity(), parsedAccount);
	    };
	    /**
	     * set account entity in the platform cache
	     * @param key
	     * @param value
	     */
	    BrowserCacheManager.prototype.setAccount = function (account) {
	        this.logger.trace("BrowserCacheManager.setAccount called");
	        var key = account.generateAccountKey();
	        this.setItem(key, JSON.stringify(account));
	        this.addAccountKeyToMap(key);
	    };
	    /**
	     * Returns the array of account keys currently cached
	     * @returns
	     */
	    BrowserCacheManager.prototype.getAccountKeys = function () {
	        this.logger.trace("BrowserCacheManager.getAccountKeys called");
	        var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);
	        if (accountKeys) {
	            return JSON.parse(accountKeys);
	        }
	        this.logger.verbose("BrowserCacheManager.getAccountKeys - No account keys found");
	        return [];
	    };
	    /**
	     * Add a new account to the key map
	     * @param key
	     */
	    BrowserCacheManager.prototype.addAccountKeyToMap = function (key) {
	        this.logger.trace("BrowserCacheManager.addAccountKeyToMap called");
	        this.logger.tracePii("BrowserCacheManager.addAccountKeyToMap called with key: " + key);
	        var accountKeys = this.getAccountKeys();
	        if (accountKeys.indexOf(key) === -1) {
	            // Only add key if it does not already exist in the map
	            accountKeys.push(key);
	            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));
	            this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key added");
	        }
	        else {
	            this.logger.verbose("BrowserCacheManager.addAccountKeyToMap account key already exists in map");
	        }
	    };
	    /**
	     * Remove an account from the key map
	     * @param key
	     */
	    BrowserCacheManager.prototype.removeAccountKeyFromMap = function (key) {
	        this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap called");
	        this.logger.tracePii("BrowserCacheManager.removeAccountKeyFromMap called with key: " + key);
	        var accountKeys = this.getAccountKeys();
	        var removalIndex = accountKeys.indexOf(key);
	        if (removalIndex > -1) {
	            accountKeys.splice(removalIndex, 1);
	            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));
	            this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap account key removed");
	        }
	        else {
	            this.logger.trace("BrowserCacheManager.removeAccountKeyFromMap key not found in existing map");
	        }
	    };
	    /**
	     * Extends inherited removeAccount function to include removal of the account key from the map
	     * @param key
	     */
	    BrowserCacheManager.prototype.removeAccount = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                _super.prototype.removeAccount.call(this, key);
	                this.removeAccountKeyFromMap(key);
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Removes given idToken from the cache and from the key map
	     * @param key
	     */
	    BrowserCacheManager.prototype.removeIdToken = function (key) {
	        _super.prototype.removeIdToken.call(this, key);
	        this.removeTokenKey(key, CredentialType.ID_TOKEN);
	    };
	    /**
	     * Removes given accessToken from the cache and from the key map
	     * @param key
	     */
	    BrowserCacheManager.prototype.removeAccessToken = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                _super.prototype.removeAccessToken.call(this, key);
	                this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Removes given refreshToken from the cache and from the key map
	     * @param key
	     */
	    BrowserCacheManager.prototype.removeRefreshToken = function (key) {
	        _super.prototype.removeRefreshToken.call(this, key);
	        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);
	    };
	    /**
	     * Gets the keys for the cached tokens associated with this clientId
	     * @returns
	     */
	    BrowserCacheManager.prototype.getTokenKeys = function () {
	        this.logger.trace("BrowserCacheManager.getTokenKeys called");
	        var item = this.getItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId);
	        if (item) {
	            var tokenKeys = this.validateAndParseJson(item);
	            if (tokenKeys &&
	                tokenKeys.hasOwnProperty("idToken") &&
	                tokenKeys.hasOwnProperty("accessToken") &&
	                tokenKeys.hasOwnProperty("refreshToken")) {
	                return tokenKeys;
	            }
	            else {
	                this.logger.error("BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.");
	            }
	        }
	        else {
	            this.logger.verbose("BrowserCacheManager.getTokenKeys - No token keys found");
	        }
	        return {
	            idToken: [],
	            accessToken: [],
	            refreshToken: []
	        };
	    };
	    /**
	     * Adds the given key to the token key map
	     * @param key
	     * @param type
	     */
	    BrowserCacheManager.prototype.addTokenKey = function (key, type) {
	        this.logger.trace("BrowserCacheManager addTokenKey called");
	        var tokenKeys = this.getTokenKeys();
	        switch (type) {
	            case CredentialType.ID_TOKEN:
	                if (tokenKeys.idToken.indexOf(key) === -1) {
	                    this.logger.info("BrowserCacheManager: addTokenKey - idToken added to map");
	                    tokenKeys.idToken.push(key);
	                }
	                break;
	            case CredentialType.ACCESS_TOKEN:
	                if (tokenKeys.accessToken.indexOf(key) === -1) {
	                    this.logger.info("BrowserCacheManager: addTokenKey - accessToken added to map");
	                    tokenKeys.accessToken.push(key);
	                }
	                break;
	            case CredentialType.REFRESH_TOKEN:
	                if (tokenKeys.refreshToken.indexOf(key) === -1) {
	                    this.logger.info("BrowserCacheManager: addTokenKey - refreshToken added to map");
	                    tokenKeys.refreshToken.push(key);
	                }
	                break;
	            default:
	                this.logger.error("BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: " + type);
	                ClientAuthError.createUnexpectedCredentialTypeError();
	        }
	        this.setItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId, JSON.stringify(tokenKeys));
	    };
	    /**
	     * Removes the given key from the token key map
	     * @param key
	     * @param type
	     */
	    BrowserCacheManager.prototype.removeTokenKey = function (key, type) {
	        this.logger.trace("BrowserCacheManager removeTokenKey called");
	        var tokenKeys = this.getTokenKeys();
	        switch (type) {
	            case CredentialType.ID_TOKEN:
	                this.logger.infoPii("BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: " + key + " from map");
	                var idRemoval = tokenKeys.idToken.indexOf(key);
	                if (idRemoval > -1) {
	                    this.logger.info("BrowserCacheManager: removeTokenKey - idToken removed from map");
	                    tokenKeys.idToken.splice(idRemoval, 1);
	                }
	                else {
	                    this.logger.info("BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.");
	                }
	                break;
	            case CredentialType.ACCESS_TOKEN:
	                this.logger.infoPii("BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: " + key + " from map");
	                var accessRemoval = tokenKeys.accessToken.indexOf(key);
	                if (accessRemoval > -1) {
	                    this.logger.info("BrowserCacheManager: removeTokenKey - accessToken removed from map");
	                    tokenKeys.accessToken.splice(accessRemoval, 1);
	                }
	                else {
	                    this.logger.info("BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.");
	                }
	                break;
	            case CredentialType.REFRESH_TOKEN:
	                this.logger.infoPii("BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: " + key + " from map");
	                var refreshRemoval = tokenKeys.refreshToken.indexOf(key);
	                if (refreshRemoval > -1) {
	                    this.logger.info("BrowserCacheManager: removeTokenKey - refreshToken removed from map");
	                    tokenKeys.refreshToken.splice(refreshRemoval, 1);
	                }
	                else {
	                    this.logger.info("BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.");
	                }
	                break;
	            default:
	                this.logger.error("BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: " + type);
	                ClientAuthError.createUnexpectedCredentialTypeError();
	        }
	        this.setItem(StaticCacheKeys.TOKEN_KEYS + "." + this.clientId, JSON.stringify(tokenKeys));
	    };
	    /**
	     * generates idToken entity from a string
	     * @param idTokenKey
	     */
	    BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {
	        var value = this.getItem(idTokenKey);
	        if (!value) {
	            this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
	            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);
	            return null;
	        }
	        var parsedIdToken = this.validateAndParseJson(value);
	        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {
	            this.logger.trace("BrowserCacheManager.getIdTokenCredential: called, no cache hit");
	            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);
	            return null;
	        }
	        this.logger.trace("BrowserCacheManager.getIdTokenCredential: cache hit");
	        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);
	    };
	    /**
	     * set IdToken credential to the platform cache
	     * @param idToken
	     */
	    BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {
	        this.logger.trace("BrowserCacheManager.setIdTokenCredential called");
	        var idTokenKey = idToken.generateCredentialKey();
	        this.setItem(idTokenKey, JSON.stringify(idToken));
	        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);
	    };
	    /**
	     * generates accessToken entity from a string
	     * @param key
	     */
	    BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {
	        var value = this.getItem(accessTokenKey);
	        if (!value) {
	            this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
	            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);
	            return null;
	        }
	        var parsedAccessToken = this.validateAndParseJson(value);
	        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {
	            this.logger.trace("BrowserCacheManager.getAccessTokenCredential: called, no cache hit");
	            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);
	            return null;
	        }
	        this.logger.trace("BrowserCacheManager.getAccessTokenCredential: cache hit");
	        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);
	    };
	    /**
	     * set accessToken credential to the platform cache
	     * @param accessToken
	     */
	    BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {
	        this.logger.trace("BrowserCacheManager.setAccessTokenCredential called");
	        var accessTokenKey = accessToken.generateCredentialKey();
	        this.setItem(accessTokenKey, JSON.stringify(accessToken));
	        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);
	    };
	    /**
	     * generates refreshToken entity from a string
	     * @param refreshTokenKey
	     */
	    BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {
	        var value = this.getItem(refreshTokenKey);
	        if (!value) {
	            this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
	            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);
	            return null;
	        }
	        var parsedRefreshToken = this.validateAndParseJson(value);
	        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {
	            this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: called, no cache hit");
	            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);
	            return null;
	        }
	        this.logger.trace("BrowserCacheManager.getRefreshTokenCredential: cache hit");
	        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);
	    };
	    /**
	     * set refreshToken credential to the platform cache
	     * @param refreshToken
	     */
	    BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {
	        this.logger.trace("BrowserCacheManager.setRefreshTokenCredential called");
	        var refreshTokenKey = refreshToken.generateCredentialKey();
	        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));
	        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);
	    };
	    /**
	     * fetch appMetadata entity from the platform cache
	     * @param appMetadataKey
	     */
	    BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {
	        var value = this.getItem(appMetadataKey);
	        if (!value) {
	            this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
	            return null;
	        }
	        var parsedMetadata = this.validateAndParseJson(value);
	        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {
	            this.logger.trace("BrowserCacheManager.getAppMetadata: called, no cache hit");
	            return null;
	        }
	        this.logger.trace("BrowserCacheManager.getAppMetadata: cache hit");
	        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);
	    };
	    /**
	     * set appMetadata entity to the platform cache
	     * @param appMetadata
	     */
	    BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {
	        this.logger.trace("BrowserCacheManager.setAppMetadata called");
	        var appMetadataKey = appMetadata.generateAppMetadataKey();
	        this.setItem(appMetadataKey, JSON.stringify(appMetadata));
	    };
	    /**
	     * fetch server telemetry entity from the platform cache
	     * @param serverTelemetryKey
	     */
	    BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {
	        var value = this.getItem(serverTelemetryKey);
	        if (!value) {
	            this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
	            return null;
	        }
	        var parsedMetadata = this.validateAndParseJson(value);
	        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {
	            this.logger.trace("BrowserCacheManager.getServerTelemetry: called, no cache hit");
	            return null;
	        }
	        this.logger.trace("BrowserCacheManager.getServerTelemetry: cache hit");
	        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);
	    };
	    /**
	     * set server telemetry entity to the platform cache
	     * @param serverTelemetryKey
	     * @param serverTelemetry
	     */
	    BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {
	        this.logger.trace("BrowserCacheManager.setServerTelemetry called");
	        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));
	    };
	    /**
	     *
	     */
	    BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {
	        var value = this.internalStorage.getItem(key);
	        if (!value) {
	            this.logger.trace("BrowserCacheManager.getAuthorityMetadata: called, no cache hit");
	            return null;
	        }
	        var parsedMetadata = this.validateAndParseJson(value);
	        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {
	            this.logger.trace("BrowserCacheManager.getAuthorityMetadata: cache hit");
	            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);
	        }
	        return null;
	    };
	    /**
	     *
	     */
	    BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {
	        var _this = this;
	        var allKeys = this.internalStorage.getKeys();
	        return allKeys.filter(function (key) {
	            return _this.isAuthorityMetadata(key);
	        });
	    };
	    /**
	     * Sets wrapper metadata in memory
	     * @param wrapperSKU
	     * @param wrapperVersion
	     */
	    BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {
	        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);
	        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);
	    };
	    /**
	     * Returns wrapper metadata from in-memory storage
	     */
	    BrowserCacheManager.prototype.getWrapperMetadata = function () {
	        var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;
	        var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;
	        return [sku, version];
	    };
	    /**
	     *
	     * @param entity
	     */
	    BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {
	        this.logger.trace("BrowserCacheManager.setAuthorityMetadata called");
	        this.internalStorage.setItem(key, JSON.stringify(entity));
	    };
	    /**
	     * Gets the active account
	     */
	    BrowserCacheManager.prototype.getActiveAccount = function () {
	        var activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);
	        var activeAccountValueFilters = this.getItem(activeAccountKeyFilters);
	        if (!activeAccountValueFilters) {
	            // if new active account cache type isn't found, it's an old version, so look for that instead
	            this.logger.trace("BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema");
	            var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);
	            var activeAccountValueLocal = this.getItem(activeAccountKeyLocal);
	            if (!activeAccountValueLocal) {
	                this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found");
	                return null;
	            }
	            var activeAccount = this.getAccountInfoByFilter({ localAccountId: activeAccountValueLocal })[0] || null;
	            if (activeAccount) {
	                this.logger.trace("BrowserCacheManager.getActiveAccount: Legacy active account cache schema found");
	                this.logger.trace("BrowserCacheManager.getActiveAccount: Adding active account filters cache schema");
	                this.setActiveAccount(activeAccount);
	                return activeAccount;
	            }
	            return null;
	        }
	        var activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);
	        if (activeAccountValueObj) {
	            this.logger.trace("BrowserCacheManager.getActiveAccount: Active account filters schema found");
	            return this.getAccountInfoByFilter({
	                homeAccountId: activeAccountValueObj.homeAccountId,
	                localAccountId: activeAccountValueObj.localAccountId
	            })[0] || null;
	        }
	        this.logger.trace("BrowserCacheManager.getActiveAccount: No active account found");
	        return null;
	    };
	    /**
	     * Sets the active account's localAccountId in cache
	     * @param account
	     */
	    BrowserCacheManager.prototype.setActiveAccount = function (account) {
	        var activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);
	        var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);
	        if (account) {
	            this.logger.verbose("setActiveAccount: Active account set");
	            var activeAccountValue = {
	                homeAccountId: account.homeAccountId,
	                localAccountId: account.localAccountId
	            };
	            this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));
	            this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);
	        }
	        else {
	            this.logger.verbose("setActiveAccount: No account passed, active account not set");
	            this.browserStorage.removeItem(activeAccountKey);
	            this.browserStorage.removeItem(activeAccountKeyLocal);
	        }
	    };
	    /**
	     * Gets a list of accounts that match all of the filters provided
	     * @param account
	     */
	    BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {
	        var allAccounts = this.getAllAccounts();
	        this.logger.trace("BrowserCacheManager.getAccountInfoByFilter: total " + allAccounts.length + " accounts found");
	        return allAccounts.filter(function (accountObj) {
	            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {
	                return false;
	            }
	            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {
	                return false;
	            }
	            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {
	                return false;
	            }
	            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {
	                return false;
	            }
	            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {
	                return false;
	            }
	            return true;
	        });
	    };
	    /**
	     * Checks the cache for accounts matching loginHint or SID
	     * @param loginHint
	     * @param sid
	     */
	    BrowserCacheManager.prototype.getAccountInfoByHints = function (loginHint, sid) {
	        var matchingAccounts = this.getAllAccounts().filter(function (accountInfo) {
	            if (sid) {
	                var accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims["sid"];
	                return sid === accountSid;
	            }
	            if (loginHint) {
	                return loginHint === accountInfo.username;
	            }
	            return false;
	        });
	        if (matchingAccounts.length === 1) {
	            return matchingAccounts[0];
	        }
	        else if (matchingAccounts.length > 1) {
	            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();
	        }
	        return null;
	    };
	    /**
	     * fetch throttling entity from the platform cache
	     * @param throttlingCacheKey
	     */
	    BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {
	        var value = this.getItem(throttlingCacheKey);
	        if (!value) {
	            this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
	            return null;
	        }
	        var parsedThrottlingCache = this.validateAndParseJson(value);
	        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {
	            this.logger.trace("BrowserCacheManager.getThrottlingCache: called, no cache hit");
	            return null;
	        }
	        this.logger.trace("BrowserCacheManager.getThrottlingCache: cache hit");
	        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);
	    };
	    /**
	     * set throttling entity to the platform cache
	     * @param throttlingCacheKey
	     * @param throttlingCache
	     */
	    BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {
	        this.logger.trace("BrowserCacheManager.setThrottlingCache called");
	        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));
	    };
	    /**
	     * Gets cache item with given key.
	     * Will retrieve from cookies if storeAuthStateInCookie is set to true.
	     * @param key
	     */
	    BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {
	        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
	        if (this.cacheConfig.storeAuthStateInCookie) {
	            var itemCookie = this.getItemCookie(key);
	            if (itemCookie) {
	                this.logger.trace("BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies");
	                return itemCookie;
	            }
	        }
	        var value = this.temporaryCacheStorage.getItem(key);
	        if (!value) {
	            // If temp cache item not found in session/memory, check local storage for items set by old versions
	            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {
	                var item = this.browserStorage.getItem(key);
	                if (item) {
	                    this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage");
	                    return item;
	                }
	            }
	            this.logger.trace("BrowserCacheManager.getTemporaryCache: No cache item found in local storage");
	            return null;
	        }
	        this.logger.trace("BrowserCacheManager.getTemporaryCache: Temporary cache item returned");
	        return value;
	    };
	    /**
	     * Sets the cache item with the key and value given.
	     * Stores in cookie if storeAuthStateInCookie is set to true.
	     * This can cause cookie overflow if used incorrectly.
	     * @param key
	     * @param value
	     */
	    BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {
	        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;
	        this.temporaryCacheStorage.setItem(key, value);
	        if (this.cacheConfig.storeAuthStateInCookie) {
	            this.logger.trace("BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie");
	            this.setItemCookie(key, value);
	        }
	    };
	    /**
	     * Removes the cache item with the given key.
	     * Will also clear the cookie item if storeAuthStateInCookie is set to true.
	     * @param key
	     */
	    BrowserCacheManager.prototype.removeItem = function (key) {
	        this.browserStorage.removeItem(key);
	        this.temporaryCacheStorage.removeItem(key);
	        if (this.cacheConfig.storeAuthStateInCookie) {
	            this.logger.trace("BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie");
	            this.clearItemCookie(key);
	        }
	    };
	    /**
	     * Checks whether key is in cache.
	     * @param key
	     */
	    BrowserCacheManager.prototype.containsKey = function (key) {
	        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);
	    };
	    /**
	     * Gets all keys in window.
	     */
	    BrowserCacheManager.prototype.getKeys = function () {
	        return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());
	    };
	    /**
	     * Clears all cache entries created by MSAL.
	     */
	    BrowserCacheManager.prototype.clear = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: 
	                    // Removes all accounts and their credentials
	                    return [4 /*yield*/, this.removeAllAccounts()];
	                    case 1:
	                        // Removes all accounts and their credentials
	                        _a.sent();
	                        this.removeAppMetadata();
	                        // Removes all remaining MSAL cache items
	                        this.getKeys().forEach(function (cacheKey) {
	                            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js
	                            if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(_this.clientId) !== -1))) {
	                                _this.removeItem(cacheKey);
	                            }
	                        });
	                        this.internalStorage.clear();
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Clears all access tokes that have claims prior to saving the current one
	     * @param credential
	     * @returns
	     */
	    BrowserCacheManager.prototype.clearTokensAndKeysWithClaims = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var tokenKeys, removedAccessTokens;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.trace("BrowserCacheManager.clearTokensAndKeysWithClaims called");
	                        tokenKeys = this.getTokenKeys();
	                        removedAccessTokens = [];
	                        tokenKeys.accessToken.forEach(function (key) {
	                            // if the access token has claims in its key, remove the token key and the token
	                            var credential = _this.getAccessTokenCredential(key);
	                            if ((credential === null || credential === void 0 ? void 0 : credential.requestedClaimsHash) && key.includes(credential.requestedClaimsHash.toLowerCase())) {
	                                removedAccessTokens.push(_this.removeAccessToken(key));
	                            }
	                        });
	                        return [4 /*yield*/, Promise.all(removedAccessTokens)];
	                    case 1:
	                        _a.sent();
	                        // warn if any access tokens are removed
	                        if (removedAccessTokens.length > 0) {
	                            this.logger.warning(removedAccessTokens.length + " access tokens with claims in the cache keys have been removed from the cache.");
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Add value to cookies
	     * @param cookieName
	     * @param cookieValue
	     * @param expires
	     */
	    BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {
	        var cookieStr = encodeURIComponent(cookieName) + "=" + encodeURIComponent(cookieValue) + ";path=/;SameSite=Lax;";
	        if (expires) {
	            var expireTime = this.getCookieExpirationTime(expires);
	            cookieStr += "expires=" + expireTime + ";";
	        }
	        if (this.cacheConfig.secureCookies) {
	            cookieStr += "Secure;";
	        }
	        document.cookie = cookieStr;
	    };
	    /**
	     * Get one item by key from cookies
	     * @param cookieName
	     */
	    BrowserCacheManager.prototype.getItemCookie = function (cookieName) {
	        var name = encodeURIComponent(cookieName) + "=";
	        var cookieList = document.cookie.split(";");
	        for (var i = 0; i < cookieList.length; i++) {
	            var cookie = cookieList[i];
	            while (cookie.charAt(0) === " ") {
	                cookie = cookie.substring(1);
	            }
	            if (cookie.indexOf(name) === 0) {
	                return decodeURIComponent(cookie.substring(name.length, cookie.length));
	            }
	        }
	        return Constants.EMPTY_STRING;
	    };
	    /**
	     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.
	     */
	    BrowserCacheManager.prototype.clearMsalCookies = function () {
	        var _this = this;
	        var cookiePrefix = Constants.CACHE_PREFIX + "." + this.clientId;
	        var cookieList = document.cookie.split(";");
	        cookieList.forEach(function (cookie) {
	            while (cookie.charAt(0) === " ") {
	                // eslint-disable-next-line no-param-reassign
	                cookie = cookie.substring(1);
	            }
	            if (cookie.indexOf(cookiePrefix) === 0) {
	                var cookieKey = cookie.split("=")[0];
	                _this.clearItemCookie(cookieKey);
	            }
	        });
	    };
	    /**
	     * Clear an item in the cookies by key
	     * @param cookieName
	     */
	    BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {
	        this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);
	    };
	    /**
	     * Get cookie expiration time
	     * @param cookieLifeDays
	     */
	    BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {
	        var today = new Date();
	        var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);
	        return expr.toUTCString();
	    };
	    /**
	     * Gets the cache object referenced by the browser
	     */
	    BrowserCacheManager.prototype.getCache = function () {
	        return this.browserStorage;
	    };
	    /**
	     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser
	     */
	    BrowserCacheManager.prototype.setCache = function () {
	        // sets nothing
	    };
	    /**
	     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)
	     * @param key
	     * @param addInstanceId
	     */
	    BrowserCacheManager.prototype.generateCacheKey = function (key) {
	        var generatedKey = this.validateAndParseJson(key);
	        if (!generatedKey) {
	            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {
	                return key;
	            }
	            return Constants.CACHE_PREFIX + "." + this.clientId + "." + key;
	        }
	        return JSON.stringify(key);
	    };
	    /**
	     * Create authorityKey to cache authority
	     * @param state
	     */
	    BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {
	        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;
	        return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + "." + stateId);
	    };
	    /**
	     * Create Nonce key to cache nonce
	     * @param state
	     */
	    BrowserCacheManager.prototype.generateNonceKey = function (stateString) {
	        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;
	        return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + "." + stateId);
	    };
	    /**
	     * Creates full cache key for the request state
	     * @param stateString State string for the request
	     */
	    BrowserCacheManager.prototype.generateStateKey = function (stateString) {
	        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests
	        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;
	        return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + "." + stateId);
	    };
	    /**
	     * Gets the cached authority based on the cached state. Returns empty if no cached state found.
	     */
	    BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {
	        var stateCacheKey = this.generateStateKey(cachedState);
	        var state = this.getTemporaryCache(stateCacheKey);
	        if (!state) {
	            return null;
	        }
	        var authorityCacheKey = this.generateAuthorityKey(state);
	        return this.getTemporaryCache(authorityCacheKey);
	    };
	    /**
	     * Updates account, authority, and state in cache
	     * @param serverAuthenticationRequest
	     * @param account
	     */
	    BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {
	        this.logger.trace("BrowserCacheManager.updateCacheEntries called");
	        // Cache the request state
	        var stateCacheKey = this.generateStateKey(state);
	        this.setTemporaryCache(stateCacheKey, state, false);
	        // Cache the nonce
	        var nonceCacheKey = this.generateNonceKey(state);
	        this.setTemporaryCache(nonceCacheKey, nonce, false);
	        // Cache authorityKey
	        var authorityCacheKey = this.generateAuthorityKey(state);
	        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);
	        if (account) {
	            var ccsCredential = {
	                credential: account.homeAccountId,
	                type: CcsCredentialType.HOME_ACCOUNT_ID
	            };
	            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);
	        }
	        else if (!StringUtils.isEmpty(loginHint)) {
	            var ccsCredential = {
	                credential: loginHint,
	                type: CcsCredentialType.UPN
	            };
	            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);
	        }
	    };
	    /**
	     * Reset all temporary cache items
	     * @param state
	     */
	    BrowserCacheManager.prototype.resetRequestCache = function (state) {
	        var _this = this;
	        this.logger.trace("BrowserCacheManager.resetRequestCache called");
	        // check state and remove associated cache items
	        if (!StringUtils.isEmpty(state)) {
	            this.getKeys().forEach(function (key) {
	                if (key.indexOf(state) !== -1) {
	                    _this.removeItem(key);
	                }
	            });
	        }
	        // delete generic interactive request parameters
	        if (state) {
	            this.removeItem(this.generateStateKey(state));
	            this.removeItem(this.generateNonceKey(state));
	            this.removeItem(this.generateAuthorityKey(state));
	        }
	        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));
	        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));
	        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));
	        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));
	        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));
	        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));
	        this.setInteractionInProgress(false);
	    };
	    /**
	     * Removes temporary cache for the provided state
	     * @param stateString
	     */
	    BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {
	        this.logger.trace("BrowserCacheManager.cleanRequestByState called");
	        // Interaction is completed - remove interaction status.
	        if (stateString) {
	            var stateKey = this.generateStateKey(stateString);
	            var cachedState = this.temporaryCacheStorage.getItem(stateKey);
	            this.logger.infoPii("BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: " + cachedState);
	            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);
	        }
	        this.clearMsalCookies();
	    };
	    /**
	     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state
	     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.
	     * @param interactionType
	     */
	    BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {
	        var _this = this;
	        this.logger.trace("BrowserCacheManager.cleanRequestByInteractionType called");
	        // Loop through all keys to find state key
	        this.getKeys().forEach(function (key) {
	            // If this key is not the state key, move on
	            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {
	                return;
	            }
	            // Retrieve state value, return if not a valid value
	            var stateValue = _this.temporaryCacheStorage.getItem(key);
	            if (!stateValue) {
	                return;
	            }
	            // Extract state and ensure it matches given InteractionType, then clean request cache
	            var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);
	            if (parsedState && parsedState.interactionType === interactionType) {
	                _this.logger.infoPii("BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: " + stateValue);
	                _this.resetRequestCache(stateValue);
	            }
	        });
	        this.clearMsalCookies();
	        this.setInteractionInProgress(false);
	    };
	    BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {
	        this.logger.trace("BrowserCacheManager.cacheCodeRequest called");
	        var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));
	        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);
	    };
	    /**
	     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.
	     */
	    BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {
	        this.logger.trace("BrowserCacheManager.getCachedRequest called");
	        // Get token request from cache and parse as TokenExchangeParameters.
	        var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);
	        if (!encodedTokenRequest) {
	            throw BrowserAuthError.createNoTokenRequestCacheError();
	        }
	        var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));
	        if (!parsedRequest) {
	            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();
	        }
	        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));
	        // Get cached authority and use if no authority is cached with request.
	        if (StringUtils.isEmpty(parsedRequest.authority)) {
	            var authorityCacheKey = this.generateAuthorityKey(state);
	            var cachedAuthority = this.getTemporaryCache(authorityCacheKey);
	            if (!cachedAuthority) {
	                throw BrowserAuthError.createNoCachedAuthorityError();
	            }
	            parsedRequest.authority = cachedAuthority;
	        }
	        return parsedRequest;
	    };
	    /**
	     * Gets cached native request for redirect flows
	     */
	    BrowserCacheManager.prototype.getCachedNativeRequest = function () {
	        this.logger.trace("BrowserCacheManager.getCachedNativeRequest called");
	        var cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);
	        if (!cachedRequest) {
	            this.logger.trace("BrowserCacheManager.getCachedNativeRequest: No cached native request found");
	            return null;
	        }
	        var parsedRequest = this.validateAndParseJson(cachedRequest);
	        if (!parsedRequest) {
	            this.logger.error("BrowserCacheManager.getCachedNativeRequest: Unable to parse native request");
	            return null;
	        }
	        return parsedRequest;
	    };
	    BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {
	        var clientId = this.getInteractionInProgress();
	        if (matchClientId) {
	            return clientId === this.clientId;
	        }
	        else {
	            return !!clientId;
	        }
	    };
	    BrowserCacheManager.prototype.getInteractionInProgress = function () {
	        var key = Constants.CACHE_PREFIX + "." + TemporaryCacheKeys.INTERACTION_STATUS_KEY;
	        return this.getTemporaryCache(key, false);
	    };
	    BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {
	        // Ensure we don't overwrite interaction in progress for a different clientId
	        var key = Constants.CACHE_PREFIX + "." + TemporaryCacheKeys.INTERACTION_STATUS_KEY;
	        if (inProgress) {
	            if (this.getInteractionInProgress()) {
	                throw BrowserAuthError.createInteractionInProgressError();
	            }
	            else {
	                // No interaction is in progress
	                this.setTemporaryCache(key, this.clientId, false);
	            }
	        }
	        else if (!inProgress && this.getInteractionInProgress() === this.clientId) {
	            this.removeItem(key);
	        }
	    };
	    /**
	     * Returns username retrieved from ADAL or MSAL v1 idToken
	     */
	    BrowserCacheManager.prototype.getLegacyLoginHint = function () {
	        // Only check for adal/msal token if no SSO params are being used
	        var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);
	        if (adalIdTokenString) {
	            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);
	            this.logger.verbose("Cached ADAL id token retrieved.");
	        }
	        // Check for cached MSAL v1 id token
	        var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);
	        if (msalIdTokenString) {
	            this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));
	            this.logger.verbose("Cached MSAL.js v1 id token retrieved");
	        }
	        var cachedIdTokenString = msalIdTokenString || adalIdTokenString;
	        if (cachedIdTokenString) {
	            var cachedIdToken = new AuthToken(cachedIdTokenString, this.cryptoImpl);
	            if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {
	                this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint");
	                return cachedIdToken.claims.preferred_username;
	            }
	            else if (cachedIdToken.claims && cachedIdToken.claims.upn) {
	                this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint");
	                return cachedIdToken.claims.upn;
	            }
	            else {
	                this.logger.verbose("No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.");
	            }
	        }
	        return null;
	    };
	    /**
	     * Updates a credential's cache key if the current cache key is outdated
	     */
	    BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {
	        var updatedCacheKey = credential.generateCredentialKey();
	        if (currentCacheKey !== updatedCacheKey) {
	            var cacheItem = this.getItem(currentCacheKey);
	            if (cacheItem) {
	                this.removeItem(currentCacheKey);
	                this.setItem(updatedCacheKey, cacheItem);
	                this.logger.verbose("Updated an outdated " + credential.credentialType + " cache key");
	                return updatedCacheKey;
	            }
	            else {
	                this.logger.error("Attempted to update an outdated " + credential.credentialType + " cache key but no item matching the outdated key was found in storage");
	            }
	        }
	        return currentCacheKey;
	    };
	    /**
	     * Returns application id as redirect context during AcquireTokenRedirect flow.
	     */
	    BrowserCacheManager.prototype.getRedirectRequestContext = function () {
	        return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);
	    };
	    /**
	     * Sets application id as the redirect context during AcquireTokenRedirect flow.
	     * @param value
	     */
	    BrowserCacheManager.prototype.setRedirectRequestContext = function (value) {
	        this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);
	    };
	    return BrowserCacheManager;
	}(CacheManager));
	var DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {
	    var cacheOptions = {
	        cacheLocation: BrowserCacheLocation.MemoryStorage,
	        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
	        storeAuthStateInCookie: false,
	        secureCookies: false,
	        cacheMigrationEnabled: false,
	        claimsBasedCachingEnabled: true
	    };
	    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);
	};

	/*! @azure/msal-browser v2.38.3 2023-10-27 */
	/* eslint-disable header/header */
	var name = "@azure/msal-browser";
	var version = "2.38.3";

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * This class implements the Fetch API for GET and POST requests. See more here: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
	 */
	var FetchClient = /** @class */ (function () {
	    function FetchClient() {
	    }
	    /**
	     * Fetch Client for REST endpoints - Get request
	     * @param url
	     * @param headers
	     * @param body
	     */
	    FetchClient.prototype.sendGetRequestAsync = function (url, options) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var response, e_1, _a;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        _b.trys.push([0, 2, , 3]);
	                        return [4 /*yield*/, fetch(url, {
	                                method: HTTP_REQUEST_TYPE.GET,
	                                headers: this.getFetchHeaders(options)
	                            })];
	                    case 1:
	                        response = _b.sent();
	                        return [3 /*break*/, 3];
	                    case 2:
	                        e_1 = _b.sent();
	                        if (window.navigator.onLine) {
	                            throw BrowserAuthError.createGetRequestFailedError(e_1, url);
	                        }
	                        else {
	                            throw BrowserAuthError.createNoNetworkConnectivityError();
	                        }
	                    case 3:
	                        _b.trys.push([3, 5, , 6]);
	                        _a = {
	                            headers: this.getHeaderDict(response.headers)
	                        };
	                        return [4 /*yield*/, response.json()];
	                    case 4: return [2 /*return*/, (_a.body = (_b.sent()),
	                            _a.status = response.status,
	                            _a)];
	                    case 5:
	                        _b.sent();
	                        throw BrowserAuthError.createFailedToParseNetworkResponseError(url);
	                    case 6: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Fetch Client for REST endpoints - Post request
	     * @param url
	     * @param headers
	     * @param body
	     */
	    FetchClient.prototype.sendPostRequestAsync = function (url, options) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var reqBody, response, e_3, _a;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        reqBody = (options && options.body) || Constants.EMPTY_STRING;
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, fetch(url, {
	                                method: HTTP_REQUEST_TYPE.POST,
	                                headers: this.getFetchHeaders(options),
	                                body: reqBody
	                            })];
	                    case 2:
	                        response = _b.sent();
	                        return [3 /*break*/, 4];
	                    case 3:
	                        e_3 = _b.sent();
	                        if (window.navigator.onLine) {
	                            throw BrowserAuthError.createPostRequestFailedError(e_3, url);
	                        }
	                        else {
	                            throw BrowserAuthError.createNoNetworkConnectivityError();
	                        }
	                    case 4:
	                        _b.trys.push([4, 6, , 7]);
	                        _a = {
	                            headers: this.getHeaderDict(response.headers)
	                        };
	                        return [4 /*yield*/, response.json()];
	                    case 5: return [2 /*return*/, (_a.body = (_b.sent()),
	                            _a.status = response.status,
	                            _a)];
	                    case 6:
	                        _b.sent();
	                        throw BrowserAuthError.createFailedToParseNetworkResponseError(url);
	                    case 7: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Get Fetch API Headers object from string map
	     * @param inputHeaders
	     */
	    FetchClient.prototype.getFetchHeaders = function (options) {
	        var headers = new Headers();
	        if (!(options && options.headers)) {
	            return headers;
	        }
	        var optionsHeaders = options.headers;
	        Object.keys(optionsHeaders).forEach(function (key) {
	            headers.append(key, optionsHeaders[key]);
	        });
	        return headers;
	    };
	    FetchClient.prototype.getHeaderDict = function (headers) {
	        var headerDict = {};
	        headers.forEach(function (value, key) {
	            headerDict[key] = value;
	        });
	        return headerDict;
	    };
	    return FetchClient;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * This client implements the XMLHttpRequest class to send GET and POST requests.
	 */
	var XhrClient = /** @class */ (function () {
	    function XhrClient() {
	    }
	    /**
	     * XhrClient for REST endpoints - Get request
	     * @param url
	     * @param headers
	     * @param body
	     */
	    XhrClient.prototype.sendGetRequestAsync = function (url, options) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, this.sendRequestAsync(url, HTTP_REQUEST_TYPE.GET, options)];
	            });
	        });
	    };
	    /**
	     * XhrClient for REST endpoints - Post request
	     * @param url
	     * @param headers
	     * @param body
	     */
	    XhrClient.prototype.sendPostRequestAsync = function (url, options) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, this.sendRequestAsync(url, HTTP_REQUEST_TYPE.POST, options)];
	            });
	        });
	    };
	    /**
	     * Helper for XhrClient requests.
	     * @param url
	     * @param method
	     * @param options
	     */
	    XhrClient.prototype.sendRequestAsync = function (url, method, options) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            var xhr = new XMLHttpRequest();
	            xhr.open(method, url, /* async: */ true);
	            _this.setXhrHeaders(xhr, options);
	            xhr.onload = function () {
	                if (xhr.status < 200 || xhr.status >= 300) {
	                    if (method === HTTP_REQUEST_TYPE.POST) {
	                        reject(BrowserAuthError.createPostRequestFailedError("Failed with status " + xhr.status, url));
	                    }
	                    else {
	                        reject(BrowserAuthError.createGetRequestFailedError("Failed with status " + xhr.status, url));
	                    }
	                }
	                try {
	                    var jsonResponse = JSON.parse(xhr.responseText);
	                    var networkResponse = {
	                        headers: _this.getHeaderDict(xhr),
	                        body: jsonResponse,
	                        status: xhr.status
	                    };
	                    resolve(networkResponse);
	                }
	                catch (e) {
	                    reject(BrowserAuthError.createFailedToParseNetworkResponseError(url));
	                }
	            };
	            xhr.onerror = function () {
	                if (window.navigator.onLine) {
	                    if (method === HTTP_REQUEST_TYPE.POST) {
	                        reject(BrowserAuthError.createPostRequestFailedError("Failed with status " + xhr.status, url));
	                    }
	                    else {
	                        reject(BrowserAuthError.createGetRequestFailedError("Failed with status " + xhr.status, url));
	                    }
	                }
	                else {
	                    reject(BrowserAuthError.createNoNetworkConnectivityError());
	                }
	            };
	            if (method === HTTP_REQUEST_TYPE.POST && options && options.body) {
	                xhr.send(options.body);
	            }
	            else if (method === HTTP_REQUEST_TYPE.GET) {
	                xhr.send();
	            }
	            else {
	                throw BrowserAuthError.createHttpMethodNotImplementedError(method);
	            }
	        });
	    };
	    /**
	     * Helper to set XHR headers for request.
	     * @param xhr
	     * @param options
	     */
	    XhrClient.prototype.setXhrHeaders = function (xhr, options) {
	        if (options && options.headers) {
	            var headers_1 = options.headers;
	            Object.keys(headers_1).forEach(function (key) {
	                xhr.setRequestHeader(key, headers_1[key]);
	            });
	        }
	    };
	    /**
	     * Gets a string map of the headers received in the response.
	     *
	     * Algorithm comes from https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders
	     * @param xhr
	     */
	    XhrClient.prototype.getHeaderDict = function (xhr) {
	        var headerString = xhr.getAllResponseHeaders();
	        var headerArr = headerString.trim().split(/[\r\n]+/);
	        var headerDict = {};
	        headerArr.forEach(function (value) {
	            var parts = value.split(": ");
	            var headerName = parts.shift();
	            var headerVal = parts.join(": ");
	            if (headerName && headerVal) {
	                headerDict[headerName] = headerVal;
	            }
	        });
	        return headerDict;
	    };
	    return XhrClient;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Utility class for browser specific functions
	 */
	var BrowserUtils = /** @class */ (function () {
	    function BrowserUtils() {
	    }
	    // #region Window Navigation and URL management
	    /**
	     * Clears hash from window url.
	     */
	    BrowserUtils.clearHash = function (contentWindow) {
	        // Office.js sets history.replaceState to null
	        contentWindow.location.hash = Constants.EMPTY_STRING;
	        if (typeof contentWindow.history.replaceState === "function") {
	            // Full removes "#" from url
	            contentWindow.history.replaceState(null, Constants.EMPTY_STRING, "" + contentWindow.location.origin + contentWindow.location.pathname + contentWindow.location.search);
	        }
	    };
	    /**
	     * Replaces current hash with hash from provided url
	     */
	    BrowserUtils.replaceHash = function (url) {
	        var urlParts = url.split("#");
	        urlParts.shift(); // Remove part before the hash
	        window.location.hash = urlParts.length > 0 ? urlParts.join("#") : Constants.EMPTY_STRING;
	    };
	    /**
	     * Returns boolean of whether the current window is in an iframe or not.
	     */
	    BrowserUtils.isInIframe = function () {
	        return window.parent !== window;
	    };
	    /**
	     * Returns boolean of whether or not the current window is a popup opened by msal
	     */
	    BrowserUtils.isInPopup = function () {
	        return typeof window !== "undefined" && !!window.opener &&
	            window.opener !== window &&
	            typeof window.name === "string" &&
	            window.name.indexOf(BrowserConstants.POPUP_NAME_PREFIX + ".") === 0;
	    };
	    // #endregion
	    /**
	     * Returns current window URL as redirect uri
	     */
	    BrowserUtils.getCurrentUri = function () {
	        return window.location.href.split("?")[0].split("#")[0];
	    };
	    /**
	     * Gets the homepage url for the current window location.
	     */
	    BrowserUtils.getHomepage = function () {
	        var currentUrl = new UrlString(window.location.href);
	        var urlComponents = currentUrl.getUrlComponents();
	        return urlComponents.Protocol + "//" + urlComponents.HostNameAndPort + "/";
	    };
	    /**
	     * Returns best compatible network client object.
	     */
	    BrowserUtils.getBrowserNetworkClient = function () {
	        if (window.fetch && window.Headers) {
	            return new FetchClient();
	        }
	        else {
	            return new XhrClient();
	        }
	    };
	    /**
	     * Throws error if we have completed an auth and are
	     * attempting another auth request inside an iframe.
	     */
	    BrowserUtils.blockReloadInHiddenIframes = function () {
	        var isResponseHash = UrlString.hashContainsKnownProperties(window.location.hash);
	        // return an error if called from the hidden iframe created by the msal js silent calls
	        if (isResponseHash && BrowserUtils.isInIframe()) {
	            throw BrowserAuthError.createBlockReloadInHiddenIframeError();
	        }
	    };
	    /**
	     * Block redirect operations in iframes unless explicitly allowed
	     * @param interactionType Interaction type for the request
	     * @param allowRedirectInIframe Config value to allow redirects when app is inside an iframe
	     */
	    BrowserUtils.blockRedirectInIframe = function (interactionType, allowRedirectInIframe) {
	        var isIframedApp = BrowserUtils.isInIframe();
	        if (interactionType === InteractionType.Redirect && isIframedApp && !allowRedirectInIframe) {
	            // If we are not in top frame, we shouldn't redirect. This is also handled by the service.
	            throw BrowserAuthError.createRedirectInIframeError(isIframedApp);
	        }
	    };
	    /**
	     * Block redirectUri loaded in popup from calling AcquireToken APIs
	     */
	    BrowserUtils.blockAcquireTokenInPopups = function () {
	        // Popups opened by msal popup APIs are given a name that starts with "msal."
	        if (BrowserUtils.isInPopup()) {
	            throw BrowserAuthError.createBlockAcquireTokenInPopupsError();
	        }
	    };
	    /**
	     * Throws error if token requests are made in non-browser environment
	     * @param isBrowserEnvironment Flag indicating if environment is a browser.
	     */
	    BrowserUtils.blockNonBrowserEnvironment = function (isBrowserEnvironment) {
	        if (!isBrowserEnvironment) {
	            throw BrowserAuthError.createNonBrowserEnvironmentError();
	        }
	    };
	    /**
	     * Throws error if native brokering is enabled but initialize hasn't been called
	     * @param allowNativeBroker
	     * @param initialized
	     */
	    BrowserUtils.blockNativeBrokerCalledBeforeInitialized = function (allowNativeBroker, initialized) {
	        if (allowNativeBroker && !initialized) {
	            throw BrowserAuthError.createNativeBrokerCalledBeforeInitialize();
	        }
	    };
	    /**
	     * Returns boolean of whether current browser is an Internet Explorer or Edge browser.
	     */
	    BrowserUtils.detectIEOrEdge = function () {
	        var ua = window.navigator.userAgent;
	        var msie = ua.indexOf("MSIE ");
	        var msie11 = ua.indexOf("Trident/");
	        var msedge = ua.indexOf("Edge/");
	        var isIE = msie > 0 || msie11 > 0;
	        var isEdge = msedge > 0;
	        return isIE || isEdge;
	    };
	    return BrowserUtils;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var BaseInteractionClient = /** @class */ (function () {
	    function BaseInteractionClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) {
	        this.config = config;
	        this.browserStorage = storageImpl;
	        this.browserCrypto = browserCrypto;
	        this.networkClient = this.config.system.networkClient;
	        this.eventHandler = eventHandler;
	        this.navigationClient = navigationClient;
	        this.nativeMessageHandler = nativeMessageHandler;
	        this.correlationId = correlationId || this.browserCrypto.createNewGuid();
	        this.logger = logger.clone(BrowserConstants.MSAL_SKU, version, this.correlationId);
	        this.performanceClient = performanceClient;
	    }
	    BaseInteractionClient.prototype.clearCacheOnLogout = function (account) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!account) return [3 /*break*/, 5];
	                        if (AccountEntity.accountInfoIsEqual(account, this.browserStorage.getActiveAccount(), false)) {
	                            this.logger.verbose("Setting active account to null");
	                            this.browserStorage.setActiveAccount(null);
	                        }
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.browserStorage.removeAccount(AccountEntity.generateAccountCacheKey(account))];
	                    case 2:
	                        _a.sent();
	                        this.logger.verbose("Cleared cache items belonging to the account provided in the logout request.");
	                        return [3 /*break*/, 4];
	                    case 3:
	                        _a.sent();
	                        this.logger.error("Account provided in logout request was not found. Local cache unchanged.");
	                        return [3 /*break*/, 4];
	                    case 4: return [3 /*break*/, 9];
	                    case 5:
	                        _a.trys.push([5, 8, , 9]);
	                        this.logger.verbose("No account provided in logout request, clearing all cache items.", this.correlationId);
	                        // Clear all accounts and tokens
	                        return [4 /*yield*/, this.browserStorage.clear()];
	                    case 6:
	                        // Clear all accounts and tokens
	                        _a.sent();
	                        // Clear any stray keys from IndexedDB
	                        return [4 /*yield*/, this.browserCrypto.clearKeystore()];
	                    case 7:
	                        // Clear any stray keys from IndexedDB
	                        _a.sent();
	                        return [3 /*break*/, 9];
	                    case 8:
	                        _a.sent();
	                        this.logger.error("Attempted to clear all MSAL cache items and failed. Local cache unchanged.");
	                        return [3 /*break*/, 9];
	                    case 9: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Initializer function for all request APIs
	     * @param request
	     */
	    BaseInteractionClient.prototype.initializeBaseRequest = function (request, account) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var authority, scopes, validatedRequest, _a;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.InitializeBaseRequest, request.correlationId);
	                        this.logger.verbose("Initializing BaseAuthRequest");
	                        authority = request.authority || this.config.auth.authority;
	                        if (!account) return [3 /*break*/, 2];
	                        return [4 /*yield*/, this.validateRequestAuthority(authority, account)];
	                    case 1:
	                        _b.sent();
	                        _b.label = 2;
	                    case 2:
	                        scopes = __spread(((request && request.scopes) || []));
	                        validatedRequest = __assign$5(__assign$5({}, request), { correlationId: this.correlationId, authority: authority,
	                            scopes: scopes });
	                        // Set authenticationScheme to BEARER if not explicitly set in the request
	                        if (!validatedRequest.authenticationScheme) {
	                            validatedRequest.authenticationScheme = AuthenticationScheme.BEARER;
	                            this.logger.verbose("Authentication Scheme wasn't explicitly set in request, defaulting to \"Bearer\" request");
	                        }
	                        else {
	                            if (validatedRequest.authenticationScheme === AuthenticationScheme.SSH) {
	                                if (!request.sshJwk) {
	                                    throw ClientConfigurationError.createMissingSshJwkError();
	                                }
	                                if (!request.sshKid) {
	                                    throw ClientConfigurationError.createMissingSshKidError();
	                                }
	                            }
	                            this.logger.verbose("Authentication Scheme set to \"" + validatedRequest.authenticationScheme + "\" as configured in Auth request");
	                        }
	                        if (!(this.config.cache.claimsBasedCachingEnabled && request.claims && !StringUtils.isEmptyObj(request.claims))) return [3 /*break*/, 4];
	                        _a = validatedRequest;
	                        return [4 /*yield*/, this.browserCrypto.hashString(request.claims)];
	                    case 3:
	                        _a.requestedClaimsHash = _b.sent();
	                        _b.label = 4;
	                    case 4: return [2 /*return*/, validatedRequest];
	                }
	            });
	        });
	    };
	    /**
	     *
	     * Use to get the redirect uri configured in MSAL or null.
	     * @param requestRedirectUri
	     * @returns Redirect URL
	     *
	     */
	    BaseInteractionClient.prototype.getRedirectUri = function (requestRedirectUri) {
	        this.logger.verbose("getRedirectUri called");
	        var redirectUri = requestRedirectUri || this.config.auth.redirectUri || BrowserUtils.getCurrentUri();
	        return UrlString.getAbsoluteUrl(redirectUri, BrowserUtils.getCurrentUri());
	    };
	    /*
	     * If authority provided in the request does not match environment/authority specified
	     * in the account or MSAL config, we throw an error.
	     */
	    BaseInteractionClient.prototype.validateRequestAuthority = function (authority, account) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var discoveredAuthority;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.getDiscoveredAuthority(authority)];
	                    case 1:
	                        discoveredAuthority = _a.sent();
	                        if (!discoveredAuthority.isAlias(account.environment)) {
	                            throw ClientConfigurationError.createAuthorityMismatchError();
	                        }
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     *
	     * @param apiId
	     * @param correlationId
	     * @param forceRefresh
	     */
	    BaseInteractionClient.prototype.initializeServerTelemetryManager = function (apiId, forceRefresh) {
	        this.logger.verbose("initializeServerTelemetryManager called");
	        var telemetryPayload = {
	            clientId: this.config.auth.clientId,
	            correlationId: this.correlationId,
	            apiId: apiId,
	            forceRefresh: forceRefresh || false,
	            wrapperSKU: this.browserStorage.getWrapperMetadata()[0],
	            wrapperVer: this.browserStorage.getWrapperMetadata()[1]
	        };
	        return new ServerTelemetryManager(telemetryPayload, this.browserStorage);
	    };
	    /**
	     * Used to get a discovered version of the default authority.
	     * @param requestAuthority
	     * @param requestCorrelationId
	     */
	    BaseInteractionClient.prototype.getDiscoveredAuthority = function (requestAuthority) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var authorityOptions;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.verbose("getDiscoveredAuthority called");
	                        authorityOptions = {
	                            protocolMode: this.config.auth.protocolMode,
	                            knownAuthorities: this.config.auth.knownAuthorities,
	                            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
	                            authorityMetadata: this.config.auth.authorityMetadata
	                        };
	                        if (!requestAuthority) return [3 /*break*/, 2];
	                        this.logger.verbose("Creating discovered authority with request authority");
	                        return [4 /*yield*/, AuthorityFactory.createDiscoveredInstance(requestAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                    case 2:
	                        this.logger.verbose("Creating discovered authority with configured authority");
	                        return [4 /*yield*/, AuthorityFactory.createDiscoveredInstance(this.config.auth.authority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger)];
	                    case 3: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    return BaseInteractionClient;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Defines the class structure and helper functions used by the "standard", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))
	 */
	var StandardInteractionClient = /** @class */ (function (_super) {
	    __extends$g(StandardInteractionClient, _super);
	    function StandardInteractionClient() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Generates an auth code request tied to the url request.
	     * @param request
	     */
	    StandardInteractionClient.prototype.initializeAuthorizationCodeRequest = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var generatedPkceParams, authCodeRequest;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);
	                        this.logger.verbose("initializeAuthorizationRequest called", request.correlationId);
	                        return [4 /*yield*/, this.browserCrypto.generatePkceCodes()];
	                    case 1:
	                        generatedPkceParams = _a.sent();
	                        authCodeRequest = __assign$5(__assign$5({}, request), { redirectUri: request.redirectUri, code: Constants.EMPTY_STRING, codeVerifier: generatedPkceParams.verifier });
	                        request.codeChallenge = generatedPkceParams.challenge;
	                        request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;
	                        return [2 /*return*/, authCodeRequest];
	                }
	            });
	        });
	    };
	    /**
	     * Initializer for the logout request.
	     * @param logoutRequest
	     */
	    StandardInteractionClient.prototype.initializeLogoutRequest = function (logoutRequest) {
	        this.logger.verbose("initializeLogoutRequest called", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);
	        var validLogoutRequest = __assign$5({ correlationId: this.correlationId || this.browserCrypto.createNewGuid() }, logoutRequest);
	        /**
	         * Set logout_hint to be login_hint from ID Token Claims if present
	         * and logoutHint attribute wasn't manually set in logout request
	         */
	        if (logoutRequest) {
	            // If logoutHint isn't set and an account was passed in, try to extract logoutHint from ID Token Claims
	            if (!logoutRequest.logoutHint) {
	                if (logoutRequest.account) {
	                    var logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);
	                    if (logoutHint) {
	                        this.logger.verbose("Setting logoutHint to login_hint ID Token Claim value for the account provided");
	                        validLogoutRequest.logoutHint = logoutHint;
	                    }
	                }
	                else {
	                    this.logger.verbose("logoutHint was not set and account was not passed into logout request, logoutHint will not be set");
	                }
	            }
	            else {
	                this.logger.verbose("logoutHint has already been set in logoutRequest");
	            }
	        }
	        else {
	            this.logger.verbose("logoutHint will not be set since no logout request was configured");
	        }
	        /*
	         * Only set redirect uri if logout request isn't provided or the set uri isn't null.
	         * Otherwise, use passed uri, config, or current page.
	         */
	        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {
	            if (logoutRequest && logoutRequest.postLogoutRedirectUri) {
	                this.logger.verbose("Setting postLogoutRedirectUri to uri set on logout request", validLogoutRequest.correlationId);
	                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());
	            }
	            else if (this.config.auth.postLogoutRedirectUri === null) {
	                this.logger.verbose("postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect", validLogoutRequest.correlationId);
	            }
	            else if (this.config.auth.postLogoutRedirectUri) {
	                this.logger.verbose("Setting postLogoutRedirectUri to configured uri", validLogoutRequest.correlationId);
	                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());
	            }
	            else {
	                this.logger.verbose("Setting postLogoutRedirectUri to current page", validLogoutRequest.correlationId);
	                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());
	            }
	        }
	        else {
	            this.logger.verbose("postLogoutRedirectUri passed as null, not setting post logout redirect uri", validLogoutRequest.correlationId);
	        }
	        return validLogoutRequest;
	    };
	    /**
	     * Parses login_hint ID Token Claim out of AccountInfo object to be used as
	     * logout_hint in end session request.
	     * @param account
	     */
	    StandardInteractionClient.prototype.getLogoutHintFromIdTokenClaims = function (account) {
	        var idTokenClaims = account.idTokenClaims;
	        if (idTokenClaims) {
	            if (idTokenClaims.login_hint) {
	                return idTokenClaims.login_hint;
	            }
	            else {
	                this.logger.verbose("The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request");
	            }
	        }
	        else {
	            this.logger.verbose("The provided account does not contain ID Token Claims, logoutHint will not be added to logout request");
	        }
	        return null;
	    };
	    /**
	     * Creates an Authorization Code Client with the given authority, or the default authority.
	     * @param serverTelemetryManager
	     * @param authorityUrl
	     */
	    StandardInteractionClient.prototype.createAuthCodeClient = function (serverTelemetryManager, authorityUrl, requestAzureCloudOptions) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var clientConfig;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.correlationId);
	                        // Create auth module.
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);
	                        return [4 /*yield*/, this.getClientConfiguration(serverTelemetryManager, authorityUrl, requestAzureCloudOptions)];
	                    case 1:
	                        clientConfig = _a.sent();
	                        return [2 /*return*/, new AuthorizationCodeClient(clientConfig, this.performanceClient)];
	                }
	            });
	        });
	    };
	    /**
	     * Creates a Client Configuration object with the given request authority, or the default authority.
	     * @param serverTelemetryManager
	     * @param requestAuthority
	     * @param requestCorrelationId
	     */
	    StandardInteractionClient.prototype.getClientConfiguration = function (serverTelemetryManager, requestAuthority, requestAzureCloudOptions) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var discoveredAuthority, logger;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);
	                        this.logger.verbose("getClientConfiguration called", this.correlationId);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);
	                        return [4 /*yield*/, this.getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions)];
	                    case 1:
	                        discoveredAuthority = _a.sent();
	                        logger = this.config.system.loggerOptions;
	                        return [2 /*return*/, {
	                                authOptions: {
	                                    clientId: this.config.auth.clientId,
	                                    authority: discoveredAuthority,
	                                    clientCapabilities: this.config.auth.clientCapabilities
	                                },
	                                systemOptions: {
	                                    tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,
	                                    preventCorsPreflight: true
	                                },
	                                loggerOptions: {
	                                    loggerCallback: logger.loggerCallback,
	                                    piiLoggingEnabled: logger.piiLoggingEnabled,
	                                    logLevel: logger.logLevel,
	                                    correlationId: this.correlationId
	                                },
	                                cacheOptions: {
	                                    claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled
	                                },
	                                cryptoInterface: this.browserCrypto,
	                                networkInterface: this.networkClient,
	                                storageInterface: this.browserStorage,
	                                serverTelemetryManager: serverTelemetryManager,
	                                libraryInfo: {
	                                    sku: BrowserConstants.MSAL_SKU,
	                                    version: version,
	                                    cpu: Constants.EMPTY_STRING,
	                                    os: Constants.EMPTY_STRING
	                                },
	                                telemetry: this.config.telemetry
	                            }];
	                }
	            });
	        });
	    };
	    /**
	     * @param hash
	     * @param interactionType
	     */
	    StandardInteractionClient.prototype.validateAndExtractStateFromHash = function (serverParams, interactionType, requestCorrelationId) {
	        this.logger.verbose("validateAndExtractStateFromHash called", requestCorrelationId);
	        if (!serverParams.state) {
	            throw BrowserAuthError.createHashDoesNotContainStateError();
	        }
	        var platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);
	        if (!platformStateObj) {
	            throw BrowserAuthError.createUnableToParseStateError();
	        }
	        if (platformStateObj.interactionType !== interactionType) {
	            throw BrowserAuthError.createStateInteractionTypeMismatchError();
	        }
	        this.logger.verbose("Returning state from hash", requestCorrelationId);
	        return serverParams.state;
	    };
	    /**
	     * Used to get a discovered version of the default authority.
	     * @param requestAuthority
	     * @param requestCorrelationId
	     */
	    StandardInteractionClient.prototype.getDiscoveredAuthority = function (requestAuthority, requestAzureCloudOptions) {
	        var _a;
	        return __awaiter$3(this, void 0, void 0, function () {
	            var getAuthorityMeasurement, authorityOptions, userAuthority, builtAuthority;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);
	                        this.logger.verbose("getDiscoveredAuthority called", this.correlationId);
	                        getAuthorityMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);
	                        authorityOptions = {
	                            protocolMode: this.config.auth.protocolMode,
	                            knownAuthorities: this.config.auth.knownAuthorities,
	                            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
	                            authorityMetadata: this.config.auth.authorityMetadata,
	                            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache
	                        };
	                        userAuthority = requestAuthority ? requestAuthority : this.config.auth.authority;
	                        builtAuthority = Authority.generateAuthority(userAuthority, requestAzureCloudOptions || this.config.auth.azureCloudOptions);
	                        this.logger.verbose("Creating discovered authority with configured authority", this.correlationId);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, this.correlationId);
	                        return [4 /*yield*/, AuthorityFactory.createDiscoveredInstance(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger, this.performanceClient, this.correlationId)
	                                .then(function (result) {
	                                getAuthorityMeasurement.endMeasurement({
	                                    success: true,
	                                });
	                                return result;
	                            })
	                                .catch(function (error) {
	                                getAuthorityMeasurement.endMeasurement({
	                                    errorCode: error.errorCode,
	                                    subErrorCode: error.subError,
	                                    success: false
	                                });
	                                throw error;
	                            })];
	                    case 1: return [2 /*return*/, _b.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Helper to initialize required request parameters for interactive APIs and ssoSilent()
	     * @param request
	     * @param interactionType
	     */
	    StandardInteractionClient.prototype.initializeAuthorizationRequest = function (request, interactionType) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var redirectUri, browserState, state, validatedRequest, _a, account, legacyLoginHint;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId);
	                        this.logger.verbose("initializeAuthorizationRequest called", this.correlationId);
	                        redirectUri = this.getRedirectUri(request.redirectUri);
	                        browserState = {
	                            interactionType: interactionType
	                        };
	                        state = ProtocolUtils.setRequestState(this.browserCrypto, (request && request.state) || Constants.EMPTY_STRING, browserState);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, this.correlationId);
	                        _a = [{}];
	                        return [4 /*yield*/, this.initializeBaseRequest(request)];
	                    case 1:
	                        validatedRequest = __assign$5.apply(void 0, [__assign$5.apply(void 0, _a.concat([_b.sent()])), { redirectUri: redirectUri, state: state, nonce: request.nonce || this.browserCrypto.createNewGuid(), responseMode: ResponseMode.FRAGMENT }]);
	                        account = request.account || this.browserStorage.getActiveAccount();
	                        if (account) {
	                            this.logger.verbose("Setting validated request account", this.correlationId);
	                            this.logger.verbosePii("Setting validated request account: " + account.homeAccountId, this.correlationId);
	                            validatedRequest.account = account;
	                        }
	                        // Check for ADAL/MSAL v1 SSO
	                        if (StringUtils.isEmpty(validatedRequest.loginHint) && !account) {
	                            legacyLoginHint = this.browserStorage.getLegacyLoginHint();
	                            if (legacyLoginHint) {
	                                validatedRequest.loginHint = legacyLoginHint;
	                            }
	                        }
	                        return [2 /*return*/, validatedRequest];
	                }
	            });
	        });
	    };
	    return StandardInteractionClient;
	}(BaseInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Abstract class which defines operations for a browser interaction handling class.
	 */
	var InteractionHandler = /** @class */ (function () {
	    function InteractionHandler(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {
	        this.authModule = authCodeModule;
	        this.browserStorage = storageImpl;
	        this.authCodeRequest = authCodeRequest;
	        this.logger = logger;
	        this.performanceClient = performanceClient;
	    }
	    /**
	     * Function to handle response parameters from hash.
	     * @param locationHash
	     */
	    InteractionHandler.prototype.handleCodeResponseFromHash = function (locationHash, state, authority, networkModule) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var stateKey, requestState, authCodeResponse;
	            return __generator$3(this, function (_a) {
	                this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromHash, this.authCodeRequest.correlationId);
	                this.logger.verbose("InteractionHandler.handleCodeResponse called");
	                // Check that location hash isn't empty.
	                if (StringUtils.isEmpty(locationHash)) {
	                    throw BrowserAuthError.createEmptyHashError(locationHash);
	                }
	                stateKey = this.browserStorage.generateStateKey(state);
	                requestState = this.browserStorage.getTemporaryCache(stateKey);
	                if (!requestState) {
	                    throw ClientAuthError.createStateNotFoundError("Cached State");
	                }
	                try {
	                    authCodeResponse = this.authModule.handleFragmentResponse(locationHash, requestState);
	                }
	                catch (e) {
	                    if (e instanceof ServerError && e.subError === BrowserAuthErrorMessage.userCancelledError.code) {
	                        // Translate server error caused by user closing native prompt to corresponding first class MSAL error
	                        throw BrowserAuthError.createUserCancelledError();
	                    }
	                    else {
	                        throw e;
	                    }
	                }
	                this.performanceClient.setPreQueueTime(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId);
	                return [2 /*return*/, this.handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule)];
	            });
	        });
	    };
	    /**
	     * Process auth code response from AAD
	     * @param authCodeResponse
	     * @param state
	     * @param authority
	     * @param networkModule
	     * @returns
	     */
	    InteractionHandler.prototype.handleCodeResponseFromServer = function (authCodeResponse, state, authority, networkModule, validateNonce) {
	        if (validateNonce === void 0) { validateNonce = true; }
	        return __awaiter$3(this, void 0, void 0, function () {
	            var stateKey, requestState, nonceKey, cachedNonce, cachedCcsCred, tokenResponse;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId);
	                        this.logger.trace("InteractionHandler.handleCodeResponseFromServer called");
	                        stateKey = this.browserStorage.generateStateKey(state);
	                        requestState = this.browserStorage.getTemporaryCache(stateKey);
	                        if (!requestState) {
	                            throw ClientAuthError.createStateNotFoundError("Cached State");
	                        }
	                        nonceKey = this.browserStorage.generateNonceKey(requestState);
	                        cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);
	                        // Assign code to request
	                        this.authCodeRequest.code = authCodeResponse.code;
	                        if (!authCodeResponse.cloud_instance_host_name) return [3 /*break*/, 2];
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId);
	                        return [4 /*yield*/, this.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule)];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)
	                        if (validateNonce) {
	                            authCodeResponse.nonce = cachedNonce || undefined;
	                        }
	                        authCodeResponse.state = requestState;
	                        // Add CCS parameters if available
	                        if (authCodeResponse.client_info) {
	                            this.authCodeRequest.clientInfo = authCodeResponse.client_info;
	                        }
	                        else {
	                            cachedCcsCred = this.checkCcsCredentials();
	                            if (cachedCcsCred) {
	                                this.authCodeRequest.ccsCredential = cachedCcsCred;
	                            }
	                        }
	                        // Acquire token with retrieved code.
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.AuthClientAcquireToken, this.authCodeRequest.correlationId);
	                        return [4 /*yield*/, this.authModule.acquireToken(this.authCodeRequest, authCodeResponse)];
	                    case 3:
	                        tokenResponse = _a.sent();
	                        this.browserStorage.cleanRequestByState(state);
	                        return [2 /*return*/, tokenResponse];
	                }
	            });
	        });
	    };
	    /**
	     * Updates authority based on cloudInstanceHostname
	     * @param cloudInstanceHostname
	     * @param authority
	     * @param networkModule
	     */
	    InteractionHandler.prototype.updateTokenEndpointAuthority = function (cloudInstanceHostname, authority, networkModule) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var cloudInstanceAuthorityUri, cloudInstanceAuthority;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId);
	                        cloudInstanceAuthorityUri = "https://" + cloudInstanceHostname + "/" + authority.tenant + "/";
	                        return [4 /*yield*/, AuthorityFactory.createDiscoveredInstance(cloudInstanceAuthorityUri, networkModule, this.browserStorage, authority.options, this.logger, this.performanceClient, this.authCodeRequest.correlationId)];
	                    case 1:
	                        cloudInstanceAuthority = _a.sent();
	                        this.authModule.updateAuthority(cloudInstanceAuthority);
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Looks up ccs creds in the cache
	     */
	    InteractionHandler.prototype.checkCcsCredentials = function () {
	        // Look up ccs credential in temp cache
	        var cachedCcsCred = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, true);
	        if (cachedCcsCred) {
	            try {
	                return JSON.parse(cachedCcsCred);
	            }
	            catch (e) {
	                this.authModule.logger.error("Cache credential could not be parsed");
	                this.authModule.logger.errorPii("Cache credential could not be parsed: " + cachedCcsCred);
	            }
	        }
	        return null;
	    };
	    return InteractionHandler;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var RedirectHandler = /** @class */ (function (_super) {
	    __extends$g(RedirectHandler, _super);
	    function RedirectHandler(authCodeModule, storageImpl, authCodeRequest, logger, browserCrypto, performanceClient) {
	        var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) || this;
	        _this.browserCrypto = browserCrypto;
	        return _this;
	    }
	    /**
	     * Redirects window to given URL.
	     * @param urlNavigate
	     */
	    RedirectHandler.prototype.initiateAuthRequest = function (requestUrl, params) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var navigationOptions, navigate;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.verbose("RedirectHandler.initiateAuthRequest called");
	                        if (!!StringUtils.isEmpty(requestUrl)) return [3 /*break*/, 7];
	                        // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true
	                        if (params.redirectStartPage) {
	                            this.logger.verbose("RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page");
	                            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, params.redirectStartPage, true);
	                        }
	                        // Set interaction status in the library.
	                        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, this.authCodeRequest.correlationId, true);
	                        this.browserStorage.cacheCodeRequest(this.authCodeRequest, this.browserCrypto);
	                        this.logger.infoPii("RedirectHandler.initiateAuthRequest: Navigate to: " + requestUrl);
	                        navigationOptions = {
	                            apiId: ApiId.acquireTokenRedirect,
	                            timeout: params.redirectTimeout,
	                            noHistory: false
	                        };
	                        if (!(typeof params.onRedirectNavigate === "function")) return [3 /*break*/, 4];
	                        this.logger.verbose("RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback");
	                        navigate = params.onRedirectNavigate(requestUrl);
	                        if (!(navigate !== false)) return [3 /*break*/, 2];
	                        this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating");
	                        return [4 /*yield*/, params.navigationClient.navigateExternal(requestUrl, navigationOptions)];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/];
	                    case 2:
	                        this.logger.verbose("RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation");
	                        return [2 /*return*/];
	                    case 3: return [3 /*break*/, 6];
	                    case 4:
	                        // Navigate window to request URL
	                        this.logger.verbose("RedirectHandler.initiateAuthRequest: Navigating window to navigate url");
	                        return [4 /*yield*/, params.navigationClient.navigateExternal(requestUrl, navigationOptions)];
	                    case 5:
	                        _a.sent();
	                        return [2 /*return*/];
	                    case 6: return [3 /*break*/, 8];
	                    case 7:
	                        // Throw error if request URL is empty.
	                        this.logger.info("RedirectHandler.initiateAuthRequest: Navigate url is empty");
	                        throw BrowserAuthError.createEmptyNavigationUriError();
	                    case 8: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Handle authorization code response in the window.
	     * @param hash
	     */
	    RedirectHandler.prototype.handleCodeResponseFromHash = function (locationHash, state, authority, networkModule) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var stateKey, requestState, authCodeResponse, nonceKey, cachedNonce, cachedCcsCred, tokenResponse;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.verbose("RedirectHandler.handleCodeResponse called");
	                        // Check that location hash isn't empty.
	                        if (StringUtils.isEmpty(locationHash)) {
	                            throw BrowserAuthError.createEmptyHashError(locationHash);
	                        }
	                        // Interaction is completed - remove interaction status.
	                        this.browserStorage.setInteractionInProgress(false);
	                        stateKey = this.browserStorage.generateStateKey(state);
	                        requestState = this.browserStorage.getTemporaryCache(stateKey);
	                        if (!requestState) {
	                            throw ClientAuthError.createStateNotFoundError("Cached State");
	                        }
	                        try {
	                            authCodeResponse = this.authModule.handleFragmentResponse(locationHash, requestState);
	                        }
	                        catch (e) {
	                            if (e instanceof ServerError && e.subError === BrowserAuthErrorMessage.userCancelledError.code) {
	                                // Translate server error caused by user closing native prompt to corresponding first class MSAL error
	                                throw BrowserAuthError.createUserCancelledError();
	                            }
	                            else {
	                                throw e;
	                            }
	                        }
	                        nonceKey = this.browserStorage.generateNonceKey(requestState);
	                        cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);
	                        // Assign code to request
	                        this.authCodeRequest.code = authCodeResponse.code;
	                        if (!authCodeResponse.cloud_instance_host_name) return [3 /*break*/, 2];
	                        return [4 /*yield*/, this.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule)];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        authCodeResponse.nonce = cachedNonce || undefined;
	                        authCodeResponse.state = requestState;
	                        // Add CCS parameters if available
	                        if (authCodeResponse.client_info) {
	                            this.authCodeRequest.clientInfo = authCodeResponse.client_info;
	                        }
	                        else {
	                            cachedCcsCred = this.checkCcsCredentials();
	                            if (cachedCcsCred) {
	                                this.authCodeRequest.ccsCredential = cachedCcsCred;
	                            }
	                        }
	                        return [4 /*yield*/, this.authModule.acquireToken(this.authCodeRequest, authCodeResponse)];
	                    case 3:
	                        tokenResponse = _a.sent();
	                        this.browserStorage.cleanRequestByState(state);
	                        return [2 /*return*/, tokenResponse];
	                }
	            });
	        });
	    };
	    return RedirectHandler;
	}(InteractionHandler));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var EventType;
	(function (EventType) {
	    EventType["INITIALIZE_START"] = "msal:initializeStart";
	    EventType["INITIALIZE_END"] = "msal:initializeEnd";
	    EventType["ACCOUNT_ADDED"] = "msal:accountAdded";
	    EventType["ACCOUNT_REMOVED"] = "msal:accountRemoved";
	    EventType["LOGIN_START"] = "msal:loginStart";
	    EventType["LOGIN_SUCCESS"] = "msal:loginSuccess";
	    EventType["LOGIN_FAILURE"] = "msal:loginFailure";
	    EventType["ACQUIRE_TOKEN_START"] = "msal:acquireTokenStart";
	    EventType["ACQUIRE_TOKEN_SUCCESS"] = "msal:acquireTokenSuccess";
	    EventType["ACQUIRE_TOKEN_FAILURE"] = "msal:acquireTokenFailure";
	    EventType["ACQUIRE_TOKEN_NETWORK_START"] = "msal:acquireTokenFromNetworkStart";
	    EventType["SSO_SILENT_START"] = "msal:ssoSilentStart";
	    EventType["SSO_SILENT_SUCCESS"] = "msal:ssoSilentSuccess";
	    EventType["SSO_SILENT_FAILURE"] = "msal:ssoSilentFailure";
	    EventType["ACQUIRE_TOKEN_BY_CODE_START"] = "msal:acquireTokenByCodeStart";
	    EventType["ACQUIRE_TOKEN_BY_CODE_SUCCESS"] = "msal:acquireTokenByCodeSuccess";
	    EventType["ACQUIRE_TOKEN_BY_CODE_FAILURE"] = "msal:acquireTokenByCodeFailure";
	    EventType["HANDLE_REDIRECT_START"] = "msal:handleRedirectStart";
	    EventType["HANDLE_REDIRECT_END"] = "msal:handleRedirectEnd";
	    EventType["POPUP_OPENED"] = "msal:popupOpened";
	    EventType["LOGOUT_START"] = "msal:logoutStart";
	    EventType["LOGOUT_SUCCESS"] = "msal:logoutSuccess";
	    EventType["LOGOUT_FAILURE"] = "msal:logoutFailure";
	    EventType["LOGOUT_END"] = "msal:logoutEnd";
	    EventType["RESTORE_FROM_BFCACHE"] = "msal:restoreFromBFCache";
	})(EventType || (EventType = {}));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var NativeStatusCode;
	(function (NativeStatusCode) {
	    NativeStatusCode["USER_INTERACTION_REQUIRED"] = "USER_INTERACTION_REQUIRED";
	    NativeStatusCode["USER_CANCEL"] = "USER_CANCEL";
	    NativeStatusCode["NO_NETWORK"] = "NO_NETWORK";
	    NativeStatusCode["TRANSIENT_ERROR"] = "TRANSIENT_ERROR";
	    NativeStatusCode["PERSISTENT_ERROR"] = "PERSISTENT_ERROR";
	    NativeStatusCode["DISABLED"] = "DISABLED";
	    NativeStatusCode["ACCOUNT_UNAVAILABLE"] = "ACCOUNT_UNAVAILABLE";
	})(NativeStatusCode || (NativeStatusCode = {}));
	var NativeAuthErrorMessage = {
	    extensionError: {
	        code: "ContentError"
	    },
	    userSwitch: {
	        code: "user_switch",
	        desc: "User attempted to switch accounts in the native broker, which is not allowed. All new accounts must sign-in through the standard web flow first, please try again."
	    },
	    tokensNotFoundInCache: {
	        code: "tokens_not_found_in_internal_memory_cache",
	        desc: "Tokens not cached in MSAL JS internal memory, please make the WAM request"
	    }
	};
	var NativeAuthError = /** @class */ (function (_super) {
	    __extends$g(NativeAuthError, _super);
	    function NativeAuthError(errorCode, description, ext) {
	        var _this = _super.call(this, errorCode, description) || this;
	        Object.setPrototypeOf(_this, NativeAuthError.prototype);
	        _this.name = "NativeAuthError";
	        _this.ext = ext;
	        return _this;
	    }
	    /**
	     * These errors should result in a fallback to the 'standard' browser based auth flow.
	     */
	    NativeAuthError.prototype.isFatal = function () {
	        if (this.ext && this.ext.status && (this.ext.status === NativeStatusCode.PERSISTENT_ERROR || this.ext.status === NativeStatusCode.DISABLED)) {
	            return true;
	        }
	        switch (this.errorCode) {
	            case NativeAuthErrorMessage.extensionError.code:
	                return true;
	            default:
	                return false;
	        }
	    };
	    /**
	     * Create the appropriate error object based on the WAM status code.
	     * @param code
	     * @param description
	     * @param ext
	     * @returns
	     */
	    NativeAuthError.createError = function (code, description, ext) {
	        if (ext && ext.status) {
	            switch (ext.status) {
	                case NativeStatusCode.ACCOUNT_UNAVAILABLE:
	                    return InteractionRequiredAuthError.createNativeAccountUnavailableError();
	                case NativeStatusCode.USER_INTERACTION_REQUIRED:
	                    return new InteractionRequiredAuthError(code, description);
	                case NativeStatusCode.USER_CANCEL:
	                    return BrowserAuthError.createUserCancelledError();
	                case NativeStatusCode.NO_NETWORK:
	                    return BrowserAuthError.createNoNetworkConnectivityError();
	            }
	        }
	        return new NativeAuthError(code, description, ext);
	    };
	    /**
	     * Creates user switch error when the user chooses a different account in the native broker prompt
	     * @returns
	     */
	    NativeAuthError.createUserSwitchError = function () {
	        return new NativeAuthError(NativeAuthErrorMessage.userSwitch.code, NativeAuthErrorMessage.userSwitch.desc);
	    };
	    /**
	     * Creates a tokens not found error when the internal cache look up fails
	     * @returns NativeAuthError: tokensNotFoundInCache
	     */
	    NativeAuthError.createTokensNotFoundInCacheError = function () {
	        return new NativeAuthError(NativeAuthErrorMessage.tokensNotFoundInCache.code, NativeAuthErrorMessage.tokensNotFoundInCache.desc);
	    };
	    return NativeAuthError;
	}(AuthError));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var SilentCacheClient = /** @class */ (function (_super) {
	    __extends$g(SilentCacheClient, _super);
	    function SilentCacheClient() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Returns unexpired tokens from the cache, if available
	     * @param silentRequest
	     */
	    SilentCacheClient.prototype.acquireToken = function (silentRequest) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var acquireTokenMeasurement, serverTelemetryManager, silentAuthClient, cachedToken, error_1;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        acquireTokenMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SilentCacheClientAcquireToken, silentRequest.correlationId);
	                        serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow);
	                        return [4 /*yield*/, this.createSilentFlowClient(serverTelemetryManager, silentRequest.authority, silentRequest.azureCloudOptions)];
	                    case 1:
	                        silentAuthClient = _a.sent();
	                        this.logger.verbose("Silent auth client created");
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 4, , 5]);
	                        return [4 /*yield*/, silentAuthClient.acquireCachedToken(silentRequest)];
	                    case 3:
	                        cachedToken = _a.sent();
	                        acquireTokenMeasurement.endMeasurement({
	                            success: true,
	                            fromCache: true
	                        });
	                        return [2 /*return*/, cachedToken];
	                    case 4:
	                        error_1 = _a.sent();
	                        if (error_1 instanceof BrowserAuthError && error_1.errorCode === BrowserAuthErrorMessage.signingKeyNotFoundInStorage.code) {
	                            this.logger.verbose("Signing keypair for bound access token not found. Refreshing bound access token and generating a new crypto keypair.");
	                        }
	                        acquireTokenMeasurement.endMeasurement({
	                            errorCode: error_1 instanceof AuthError && error_1.errorCode || undefined,
	                            subErrorCode: error_1 instanceof AuthError && error_1.subError || undefined,
	                            success: false
	                        });
	                        throw error_1;
	                    case 5: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Currently Unsupported
	     */
	    SilentCacheClient.prototype.logout = function () {
	        // Synchronous so we must reject
	        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
	    };
	    /**
	     * Creates an Silent Flow Client with the given authority, or the default authority.
	     * @param serverTelemetryManager
	     * @param authorityUrl
	     */
	    SilentCacheClient.prototype.createSilentFlowClient = function (serverTelemetryManager, authorityUrl, azureCloudOptions) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var clientConfig;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        // Create auth module.
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);
	                        return [4 /*yield*/, this.getClientConfiguration(serverTelemetryManager, authorityUrl, azureCloudOptions)];
	                    case 1:
	                        clientConfig = _a.sent();
	                        return [2 /*return*/, new SilentFlowClient(clientConfig, this.performanceClient)];
	                }
	            });
	        });
	    };
	    SilentCacheClient.prototype.initializeSilentRequest = function (request, account) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _a;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.InitializeSilentRequest, this.correlationId);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, this.correlationId);
	                        _a = [__assign$5({}, request)];
	                        return [4 /*yield*/, this.initializeBaseRequest(request, account)];
	                    case 1: return [2 /*return*/, __assign$5.apply(void 0, [__assign$5.apply(void 0, _a.concat([_b.sent()])), { account: account, forceRefresh: request.forceRefresh || false }])];
	                }
	            });
	        });
	    };
	    return SilentCacheClient;
	}(StandardInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var NativeInteractionClient = /** @class */ (function (_super) {
	    __extends$g(NativeInteractionClient, _super);
	    function NativeInteractionClient(config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, provider, accountId, nativeStorageImpl, correlationId) {
	        var _this = _super.call(this, config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId) || this;
	        _this.apiId = apiId;
	        _this.accountId = accountId;
	        _this.nativeMessageHandler = provider;
	        _this.nativeStorageManager = nativeStorageImpl;
	        _this.silentCacheClient = new SilentCacheClient(config, _this.nativeStorageManager, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId);
	        return _this;
	    }
	    /**
	     * Acquire token from native platform via browser extension
	     * @param request
	     */
	    NativeInteractionClient.prototype.acquireToken = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var nativeATMeasurement, reqTimestamp, nativeRequest, result, messageBody, response, validatedResponse;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.trace("NativeInteractionClient - acquireToken called.");
	                        nativeATMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);
	                        reqTimestamp = TimeUtils.nowSeconds();
	                        return [4 /*yield*/, this.initializeNativeRequest(request)];
	                    case 1:
	                        nativeRequest = _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 4, , 5]);
	                        return [4 /*yield*/, this.acquireTokensFromCache(this.accountId, nativeRequest)];
	                    case 3:
	                        result = _a.sent();
	                        nativeATMeasurement.endMeasurement({
	                            success: true,
	                            isNativeBroker: false,
	                            fromCache: true
	                        });
	                        return [2 /*return*/, result];
	                    case 4:
	                        _a.sent();
	                        // continue with a native call for any and all errors
	                        this.logger.info("MSAL internal Cache does not contain tokens, proceed to make a native call");
	                        return [3 /*break*/, 5];
	                    case 5:
	                        messageBody = {
	                            method: NativeExtensionMethod.GetToken,
	                            request: nativeRequest
	                        };
	                        return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];
	                    case 6:
	                        response = _a.sent();
	                        validatedResponse = this.validateNativeResponse(response);
	                        return [2 /*return*/, this.handleNativeResponse(validatedResponse, nativeRequest, reqTimestamp)
	                                .then(function (result) {
	                                nativeATMeasurement.endMeasurement({
	                                    success: true,
	                                    isNativeBroker: true,
	                                    requestId: result.requestId
	                                });
	                                return result;
	                            })
	                                .catch(function (error) {
	                                nativeATMeasurement.endMeasurement({
	                                    success: false,
	                                    errorCode: error.errorCode,
	                                    subErrorCode: error.subError,
	                                    isNativeBroker: true
	                                });
	                                throw error;
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Creates silent flow request
	     * @param request
	     * @param cachedAccount
	     * @returns CommonSilentFlowRequest
	     */
	    NativeInteractionClient.prototype.createSilentCacheRequest = function (request, cachedAccount) {
	        return {
	            authority: request.authority,
	            correlationId: this.correlationId,
	            scopes: ScopeSet.fromString(request.scope).asArray(),
	            account: cachedAccount,
	            forceRefresh: false,
	        };
	    };
	    /**
	     * Fetches the tokens from the cache if un-expired
	     * @param nativeAccountId
	     * @param request
	     * @returns authenticationResult
	     */
	    NativeInteractionClient.prototype.acquireTokensFromCache = function (nativeAccountId, request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var account, silentRequest, result, e_2;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!nativeAccountId) {
	                            this.logger.warning("NativeInteractionClient:acquireTokensFromCache - No nativeAccountId provided");
	                            throw ClientAuthError.createNoAccountFoundError();
	                        }
	                        account = this.browserStorage.getAccountInfoFilteredBy({ nativeAccountId: nativeAccountId });
	                        if (!account) {
	                            throw ClientAuthError.createNoAccountFoundError();
	                        }
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        silentRequest = this.createSilentCacheRequest(request, account);
	                        return [4 /*yield*/, this.silentCacheClient.acquireToken(silentRequest)];
	                    case 2:
	                        result = _a.sent();
	                        return [2 /*return*/, result];
	                    case 3:
	                        e_2 = _a.sent();
	                        throw e_2;
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Acquires a token from native platform then redirects to the redirectUri instead of returning the response
	     * @param request
	     */
	    NativeInteractionClient.prototype.acquireTokenRedirect = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var nativeRequest, messageBody, response, e_3, navigationOptions, redirectUri;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.trace("NativeInteractionClient - acquireTokenRedirect called.");
	                        return [4 /*yield*/, this.initializeNativeRequest(request)];
	                    case 1:
	                        nativeRequest = _a.sent();
	                        messageBody = {
	                            method: NativeExtensionMethod.GetToken,
	                            request: nativeRequest
	                        };
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 4, , 5]);
	                        return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];
	                    case 3:
	                        response = _a.sent();
	                        this.validateNativeResponse(response);
	                        return [3 /*break*/, 5];
	                    case 4:
	                        e_3 = _a.sent();
	                        // Only throw fatal errors here to allow application to fallback to regular redirect. Otherwise proceed and the error will be thrown in handleRedirectPromise
	                        if (e_3 instanceof NativeAuthError && e_3.isFatal()) {
	                            throw e_3;
	                        }
	                        return [3 /*break*/, 5];
	                    case 5:
	                        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, JSON.stringify(nativeRequest), true);
	                        navigationOptions = {
	                            apiId: ApiId.acquireTokenRedirect,
	                            timeout: this.config.system.redirectNavigationTimeout,
	                            noHistory: false
	                        };
	                        redirectUri = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(request.redirectUri);
	                        return [4 /*yield*/, this.navigationClient.navigateExternal(redirectUri, navigationOptions)];
	                    case 6:
	                        _a.sent(); // Need to treat this as external to ensure handleRedirectPromise is run again
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * If the previous page called native platform for a token using redirect APIs, send the same request again and return the response
	     */
	    NativeInteractionClient.prototype.handleRedirectPromise = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var cachedRequest, prompt, request, messageBody, reqTimestamp, response, result, e_4;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.trace("NativeInteractionClient - handleRedirectPromise called.");
	                        if (!this.browserStorage.isInteractionInProgress(true)) {
	                            this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null.");
	                            return [2 /*return*/, null];
	                        }
	                        cachedRequest = this.browserStorage.getCachedNativeRequest();
	                        if (!cachedRequest) {
	                            this.logger.verbose("NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null.");
	                            return [2 /*return*/, null];
	                        }
	                        prompt = cachedRequest.prompt, request = __rest(cachedRequest, ["prompt"]);
	                        if (prompt) {
	                            this.logger.verbose("NativeInteractionClient - handleRedirectPromise called and prompt was included in the original request, removing prompt from cached request to prevent second interaction with native broker window.");
	                        }
	                        this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));
	                        messageBody = {
	                            method: NativeExtensionMethod.GetToken,
	                            request: request
	                        };
	                        reqTimestamp = TimeUtils.nowSeconds();
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        this.logger.verbose("NativeInteractionClient - handleRedirectPromise sending message to native broker.");
	                        return [4 /*yield*/, this.nativeMessageHandler.sendMessage(messageBody)];
	                    case 2:
	                        response = _a.sent();
	                        this.validateNativeResponse(response);
	                        result = this.handleNativeResponse(response, request, reqTimestamp);
	                        this.browserStorage.setInteractionInProgress(false);
	                        return [2 /*return*/, result];
	                    case 3:
	                        e_4 = _a.sent();
	                        this.browserStorage.setInteractionInProgress(false);
	                        throw e_4;
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Logout from native platform via browser extension
	     * @param request
	     */
	    NativeInteractionClient.prototype.logout = function () {
	        this.logger.trace("NativeInteractionClient - logout called.");
	        return Promise.reject("Logout not implemented yet");
	    };
	    /**
	     * Transform response from native platform into AuthenticationResult object which will be returned to the end user
	     * @param response
	     * @param request
	     * @param reqTimestamp
	     */
	    NativeInteractionClient.prototype.handleNativeResponse = function (response, request, reqTimestamp) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var authority, authorityPreferredCache, idTokenObj, homeAccountIdentifier, accountEntity, result;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.trace("NativeInteractionClient - handleNativeResponse called.");
	                        if (response.account.id !== request.accountId) {
	                            // User switch in native broker prompt is not supported. All users must first sign in through web flow to ensure server state is in sync
	                            throw NativeAuthError.createUserSwitchError();
	                        }
	                        return [4 /*yield*/, this.getDiscoveredAuthority(request.authority)];
	                    case 1:
	                        authority = _a.sent();
	                        authorityPreferredCache = authority.getPreferredCache();
	                        idTokenObj = this.createIdTokenObj(response);
	                        homeAccountIdentifier = this.createHomeAccountIdentifier(response, idTokenObj);
	                        accountEntity = this.createAccountEntity(response, homeAccountIdentifier, idTokenObj, authorityPreferredCache);
	                        return [4 /*yield*/, this.generateAuthenticationResult(response, request, idTokenObj, accountEntity, authority.canonicalAuthority, reqTimestamp)];
	                    case 2:
	                        result = _a.sent();
	                        // cache accounts and tokens in the appropriate storage
	                        this.cacheAccount(accountEntity);
	                        this.cacheNativeTokens(response, request, homeAccountIdentifier, accountEntity, idTokenObj, result.accessToken, result.tenantId, reqTimestamp);
	                        return [2 /*return*/, result];
	                }
	            });
	        });
	    };
	    /**
	     * Create an idToken Object (not entity)
	     * @param response
	     * @returns
	     */
	    NativeInteractionClient.prototype.createIdTokenObj = function (response) {
	        return new AuthToken(response.id_token || Constants.EMPTY_STRING, this.browserCrypto);
	    };
	    /**
	     * creates an homeAccountIdentifier for the account
	     * @param response
	     * @param idTokenObj
	     * @returns
	     */
	    NativeInteractionClient.prototype.createHomeAccountIdentifier = function (response, idTokenObj) {
	        // Save account in browser storage
	        var homeAccountIdentifier = AccountEntity.generateHomeAccountId(response.client_info || Constants.EMPTY_STRING, AuthorityType.Default, this.logger, this.browserCrypto, idTokenObj);
	        return homeAccountIdentifier;
	    };
	    /**
	     * Creates account entity
	     * @param response
	     * @param homeAccountIdentifier
	     * @param idTokenObj
	     * @param authority
	     * @returns
	     */
	    NativeInteractionClient.prototype.createAccountEntity = function (response, homeAccountIdentifier, idTokenObj, authority) {
	        return AccountEntity.createAccount(response.client_info, homeAccountIdentifier, idTokenObj, undefined, undefined, undefined, authority, response.account.id);
	    };
	    /**
	     * Helper to generate scopes
	     * @param response
	     * @param request
	     * @returns
	     */
	    NativeInteractionClient.prototype.generateScopes = function (response, request) {
	        return response.scope ? ScopeSet.fromString(response.scope) : ScopeSet.fromString(request.scope);
	    };
	    /**
	     * If PoP token is requesred, records the PoP token if returned from the WAM, else generates one in the browser
	     * @param request
	     * @param response
	     */
	    NativeInteractionClient.prototype.generatePopAccessToken = function (response, request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var popTokenGenerator, shrParameters;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!(request.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];
	                        /**
	                         * This code prioritizes SHR returned from the native layer. In case of error/SHR not calculated from WAM and the AT
	                         * is still received, SHR is calculated locally
	                         */
	                        // Check if native layer returned an SHR token
	                        if (response.shr) {
	                            this.logger.trace("handleNativeServerResponse: SHR is enabled in native layer");
	                            return [2 /*return*/, response.shr];
	                        }
	                        popTokenGenerator = new PopTokenGenerator(this.browserCrypto);
	                        shrParameters = {
	                            resourceRequestMethod: request.resourceRequestMethod,
	                            resourceRequestUri: request.resourceRequestUri,
	                            shrClaims: request.shrClaims,
	                            shrNonce: request.shrNonce
	                        };
	                        /**
	                         * KeyID must be present in the native request from when the PoP key was generated in order for
	                         * PopTokenGenerator to query the full key for signing
	                         */
	                        if (!request.keyId) {
	                            throw ClientAuthError.createKeyIdMissingError();
	                        }
	                        return [4 /*yield*/, popTokenGenerator.signPopToken(response.access_token, request.keyId, shrParameters)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                    case 2: return [2 /*return*/, response.access_token];
	                }
	            });
	        });
	    };
	    /**
	     * Generates authentication result
	     * @param response
	     * @param request
	     * @param idTokenObj
	     * @param accountEntity
	     * @param authority
	     * @param reqTimestamp
	     * @returns
	     */
	    NativeInteractionClient.prototype.generateAuthenticationResult = function (response, request, idTokenObj, accountEntity, authority, reqTimestamp) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var mats, responseScopes, accountProperties, uid, tid, responseAccessToken, tokenType, result;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        mats = this.addTelemetryFromNativeResponse(response);
	                        responseScopes = response.scope ? ScopeSet.fromString(response.scope) : ScopeSet.fromString(request.scope);
	                        accountProperties = response.account.properties || {};
	                        uid = accountProperties["UID"] || idTokenObj.claims.oid || idTokenObj.claims.sub || Constants.EMPTY_STRING;
	                        tid = accountProperties["TenantId"] || idTokenObj.claims.tid || Constants.EMPTY_STRING;
	                        return [4 /*yield*/, this.generatePopAccessToken(response, request)];
	                    case 1:
	                        responseAccessToken = _a.sent();
	                        tokenType = (request.tokenType === AuthenticationScheme.POP) ? AuthenticationScheme.POP : AuthenticationScheme.BEARER;
	                        result = {
	                            authority: authority,
	                            uniqueId: uid,
	                            tenantId: tid,
	                            scopes: responseScopes.asArray(),
	                            account: accountEntity.getAccountInfo(),
	                            idToken: response.id_token,
	                            idTokenClaims: idTokenObj.claims,
	                            accessToken: responseAccessToken,
	                            fromCache: mats ? this.isResponseFromCache(mats) : false,
	                            expiresOn: new Date(Number(reqTimestamp + response.expires_in) * 1000),
	                            tokenType: tokenType,
	                            correlationId: this.correlationId,
	                            state: response.state,
	                            fromNativeBroker: true
	                        };
	                        return [2 /*return*/, result];
	                }
	            });
	        });
	    };
	    /**
	     * cache the account entity in browser storage
	     * @param accountEntity
	     */
	    NativeInteractionClient.prototype.cacheAccount = function (accountEntity) {
	        var _this = this;
	        // Store the account info and hence `nativeAccountId` in browser cache
	        this.browserStorage.setAccount(accountEntity);
	        // Remove any existing cached tokens for this account in browser storage
	        this.browserStorage.removeAccountContext(accountEntity).catch(function (e) {
	            _this.logger.error("Error occurred while removing account context from browser storage. " + e);
	        });
	    };
	    /**
	     * Stores the access_token and id_token in inmemory storage
	     * @param response
	     * @param request
	     * @param homeAccountIdentifier
	     * @param idTokenObj
	     * @param responseAccessToken
	     * @param tenantId
	     * @param reqTimestamp
	     */
	    NativeInteractionClient.prototype.cacheNativeTokens = function (response, request, homeAccountIdentifier, accountEntity, idTokenObj, responseAccessToken, tenantId, reqTimestamp) {
	        var cachedIdToken = IdTokenEntity.createIdTokenEntity(homeAccountIdentifier, request.authority, response.id_token || Constants.EMPTY_STRING, request.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);
	        // cache accessToken in inmemory storage
	        var expiresIn = (request.tokenType === AuthenticationScheme.POP)
	            ? Constants.SHR_NONCE_VALIDITY
	            : (typeof response.expires_in === "string"
	                ? parseInt(response.expires_in, 10)
	                : response.expires_in) || 0;
	        var tokenExpirationSeconds = reqTimestamp + expiresIn;
	        var responseScopes = this.generateScopes(response, request);
	        var cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(homeAccountIdentifier, request.authority, responseAccessToken, request.clientId, idTokenObj
	            ? idTokenObj.claims.tid || Constants.EMPTY_STRING
	            : tenantId, responseScopes.printScopes(), tokenExpirationSeconds, 0, this.browserCrypto);
	        var nativeCacheRecord = new CacheRecord(accountEntity, cachedIdToken, cachedAccessToken);
	        this.nativeStorageManager.saveCacheRecord(nativeCacheRecord);
	    };
	    NativeInteractionClient.prototype.addTelemetryFromNativeResponse = function (response) {
	        var mats = this.getMATSFromResponse(response);
	        if (!mats) {
	            return null;
	        }
	        this.performanceClient.addStaticFields({
	            extensionId: this.nativeMessageHandler.getExtensionId(),
	            extensionVersion: this.nativeMessageHandler.getExtensionVersion(),
	            matsBrokerVersion: mats.broker_version,
	            matsAccountJoinOnStart: mats.account_join_on_start,
	            matsAccountJoinOnEnd: mats.account_join_on_end,
	            matsDeviceJoin: mats.device_join,
	            matsPromptBehavior: mats.prompt_behavior,
	            matsApiErrorCode: mats.api_error_code,
	            matsUiVisible: mats.ui_visible,
	            matsSilentCode: mats.silent_code,
	            matsSilentBiSubCode: mats.silent_bi_sub_code,
	            matsSilentMessage: mats.silent_message,
	            matsSilentStatus: mats.silent_status,
	            matsHttpStatus: mats.http_status,
	            matsHttpEventCount: mats.http_event_count
	        }, this.correlationId);
	        return mats;
	    };
	    /**
	     * Validates native platform response before processing
	     * @param response
	     */
	    NativeInteractionClient.prototype.validateNativeResponse = function (response) {
	        if (response.hasOwnProperty("access_token") &&
	            response.hasOwnProperty("id_token") &&
	            response.hasOwnProperty("client_info") &&
	            response.hasOwnProperty("account") &&
	            response.hasOwnProperty("scope") &&
	            response.hasOwnProperty("expires_in")) {
	            return response;
	        }
	        else {
	            throw NativeAuthError.createUnexpectedError("Response missing expected properties.");
	        }
	    };
	    /**
	     * Gets MATS telemetry from native response
	     * @param response
	     * @returns
	     */
	    NativeInteractionClient.prototype.getMATSFromResponse = function (response) {
	        if (response.properties.MATS) {
	            try {
	                return JSON.parse(response.properties.MATS);
	            }
	            catch (e) {
	                this.logger.error("NativeInteractionClient - Error parsing MATS telemetry, returning null instead");
	            }
	        }
	        return null;
	    };
	    /**
	     * Returns whether or not response came from native cache
	     * @param response
	     * @returns
	     */
	    NativeInteractionClient.prototype.isResponseFromCache = function (mats) {
	        if (typeof mats.is_cached === "undefined") {
	            this.logger.verbose("NativeInteractionClient - MATS telemetry does not contain field indicating if response was served from cache. Returning false.");
	            return false;
	        }
	        return !!mats.is_cached;
	    };
	    /**
	     * Translates developer provided request object into NativeRequest object
	     * @param request
	     */
	    NativeInteractionClient.prototype.initializeNativeRequest = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var authority, canonicalAuthority, scopes, remainingProperties, scopeSet, getPrompt, validatedRequest, shrParameters, popTokenGenerator, reqCnfData;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.trace("NativeInteractionClient - initializeNativeRequest called");
	                        authority = request.authority || this.config.auth.authority;
	                        if (!request.account) return [3 /*break*/, 2];
	                        return [4 /*yield*/, this.validateRequestAuthority(authority, request.account)];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2:
	                        canonicalAuthority = new UrlString(authority);
	                        canonicalAuthority.validateAsUri();
	                        scopes = request.scopes, remainingProperties = __rest(request, ["scopes"]);
	                        scopeSet = new ScopeSet(scopes || []);
	                        scopeSet.appendScopes(OIDC_DEFAULT_SCOPES);
	                        getPrompt = function () {
	                            // If request is silent, prompt is always none
	                            switch (_this.apiId) {
	                                case ApiId.ssoSilent:
	                                case ApiId.acquireTokenSilent_silentFlow:
	                                    _this.logger.trace("initializeNativeRequest: silent request sets prompt to none");
	                                    return PromptValue.NONE;
	                            }
	                            // Prompt not provided, request may proceed and native broker decides if it needs to prompt
	                            if (!request.prompt) {
	                                _this.logger.trace("initializeNativeRequest: prompt was not provided");
	                                return undefined;
	                            }
	                            // If request is interactive, check if prompt provided is allowed to go directly to native broker
	                            switch (request.prompt) {
	                                case PromptValue.NONE:
	                                case PromptValue.CONSENT:
	                                case PromptValue.LOGIN:
	                                    _this.logger.trace("initializeNativeRequest: prompt is compatible with native flow");
	                                    return request.prompt;
	                                default:
	                                    _this.logger.trace("initializeNativeRequest: prompt = " + request.prompt + " is not compatible with native flow");
	                                    throw BrowserAuthError.createNativePromptParameterNotSupportedError();
	                            }
	                        };
	                        validatedRequest = __assign$5(__assign$5({}, remainingProperties), { accountId: this.accountId, clientId: this.config.auth.clientId, authority: canonicalAuthority.urlString, scope: scopeSet.printScopes(), redirectUri: this.getRedirectUri(request.redirectUri), prompt: getPrompt(), correlationId: this.correlationId, tokenType: request.authenticationScheme, windowTitleSubstring: document.title, extraParameters: __assign$5(__assign$5(__assign$5({}, request.extraQueryParameters), request.tokenQueryParameters), { telemetry: NativeConstants.MATS_TELEMETRY }), extendedExpiryToken: false // Make this configurable?
	                         });
	                        if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3 /*break*/, 4];
	                        shrParameters = {
	                            resourceRequestUri: request.resourceRequestUri,
	                            resourceRequestMethod: request.resourceRequestMethod,
	                            shrClaims: request.shrClaims,
	                            shrNonce: request.shrNonce
	                        };
	                        popTokenGenerator = new PopTokenGenerator(this.browserCrypto);
	                        return [4 /*yield*/, popTokenGenerator.generateCnf(shrParameters)];
	                    case 3:
	                        reqCnfData = _a.sent();
	                        // to reduce the URL length, it is recommended to send the short form of the req_cnf 
	                        validatedRequest.reqCnf = reqCnfData.reqCnfString;
	                        validatedRequest.keyId = reqCnfData.kid;
	                        _a.label = 4;
	                    case 4: return [2 /*return*/, validatedRequest];
	                }
	            });
	        });
	    };
	    return NativeInteractionClient;
	}(BaseInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var NativeMessageHandler = /** @class */ (function () {
	    function NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, extensionId) {
	        this.logger = logger;
	        this.handshakeTimeoutMs = handshakeTimeoutMs;
	        this.extensionId = extensionId;
	        this.resolvers = new Map(); // Used for non-handshake messages
	        this.handshakeResolvers = new Map(); // Used for handshake messages
	        this.responseId = 0;
	        this.messageChannel = new MessageChannel();
	        this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound
	        this.performanceClient = performanceClient;
	        this.handshakeEvent = performanceClient.startMeasurement(PerformanceEvents.NativeMessageHandlerHandshake);
	    }
	    /**
	     * Sends a given message to the extension and resolves with the extension response
	     * @param body
	     */
	    NativeMessageHandler.prototype.sendMessage = function (body) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var req;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                this.logger.trace("NativeMessageHandler - sendMessage called.");
	                req = {
	                    channel: NativeConstants.CHANNEL_ID,
	                    extensionId: this.extensionId,
	                    responseId: this.responseId++,
	                    body: body
	                };
	                this.logger.trace("NativeMessageHandler - Sending request to browser extension");
	                this.logger.tracePii("NativeMessageHandler - Sending request to browser extension: " + JSON.stringify(req));
	                this.messageChannel.port1.postMessage(req);
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        _this.resolvers.set(req.responseId, { resolve: resolve, reject: reject });
	                    })];
	            });
	        });
	    };
	    /**
	     * Returns an instance of the MessageHandler that has successfully established a connection with an extension
	     * @param {Logger} logger
	     * @param {number} handshakeTimeoutMs
	     * @param {IPerformanceClient} performanceClient
	     */
	    NativeMessageHandler.createProvider = function (logger, handshakeTimeoutMs, performanceClient) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var preferredProvider, backupProvider;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        logger.trace("NativeMessageHandler - createProvider called.");
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 5]);
	                        preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient, NativeConstants.PREFERRED_EXTENSION_ID);
	                        return [4 /*yield*/, preferredProvider.sendHandshakeRequest()];
	                    case 2:
	                        _a.sent();
	                        return [2 /*return*/, preferredProvider];
	                    case 3:
	                        _a.sent();
	                        backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, performanceClient);
	                        return [4 /*yield*/, backupProvider.sendHandshakeRequest()];
	                    case 4:
	                        _a.sent();
	                        return [2 /*return*/, backupProvider];
	                    case 5: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Send handshake request helper.
	     */
	    NativeMessageHandler.prototype.sendHandshakeRequest = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var req;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                this.logger.trace("NativeMessageHandler - sendHandshakeRequest called.");
	                // Register this event listener before sending handshake
	                window.addEventListener("message", this.windowListener, false); // false is important, because content script message processing should work first
	                req = {
	                    channel: NativeConstants.CHANNEL_ID,
	                    extensionId: this.extensionId,
	                    responseId: this.responseId++,
	                    body: {
	                        method: NativeExtensionMethod.HandshakeRequest
	                    }
	                };
	                this.handshakeEvent.addStaticFields({
	                    extensionId: this.extensionId,
	                    extensionHandshakeTimeoutMs: this.handshakeTimeoutMs
	                });
	                this.messageChannel.port1.onmessage = function (event) {
	                    _this.onChannelMessage(event);
	                };
	                window.postMessage(req, window.origin, [this.messageChannel.port2]);
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        _this.handshakeResolvers.set(req.responseId, { resolve: resolve, reject: reject });
	                        _this.timeoutId = window.setTimeout(function () {
	                            /*
	                             * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.
	                             * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port
	                             */
	                            window.removeEventListener("message", _this.windowListener, false);
	                            _this.messageChannel.port1.close();
	                            _this.messageChannel.port2.close();
	                            _this.handshakeEvent.endMeasurement({ extensionHandshakeTimedOut: true, success: false });
	                            reject(BrowserAuthError.createNativeHandshakeTimeoutError());
	                            _this.handshakeResolvers.delete(req.responseId);
	                        }, _this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here
	                    })];
	            });
	        });
	    };
	    /**
	     * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.
	     * @param event
	     */
	    NativeMessageHandler.prototype.onWindowMessage = function (event) {
	        this.logger.trace("NativeMessageHandler - onWindowMessage called");
	        // We only accept messages from ourselves
	        if (event.source !== window) {
	            return;
	        }
	        var request = event.data;
	        if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {
	            return;
	        }
	        if (request.extensionId && request.extensionId !== this.extensionId) {
	            return;
	        }
	        if (request.body.method === NativeExtensionMethod.HandshakeRequest) {
	            // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed
	            this.logger.verbose(request.extensionId ? "Extension with id: " + request.extensionId + " not installed" : "No extension installed");
	            clearTimeout(this.timeoutId);
	            this.messageChannel.port1.close();
	            this.messageChannel.port2.close();
	            window.removeEventListener("message", this.windowListener, false);
	            var handshakeResolver = this.handshakeResolvers.get(request.responseId);
	            if (handshakeResolver) {
	                this.handshakeEvent.endMeasurement({ success: false, extensionInstalled: false });
	                handshakeResolver.reject(BrowserAuthError.createNativeExtensionNotInstalledError());
	            }
	        }
	    };
	    /**
	     * Invoked when a message is received from the extension on the MessageChannel port
	     * @param event
	     */
	    NativeMessageHandler.prototype.onChannelMessage = function (event) {
	        this.logger.trace("NativeMessageHandler - onChannelMessage called.");
	        var request = event.data;
	        var resolver = this.resolvers.get(request.responseId);
	        var handshakeResolver = this.handshakeResolvers.get(request.responseId);
	        try {
	            var method = request.body.method;
	            if (method === NativeExtensionMethod.Response) {
	                if (!resolver) {
	                    return;
	                }
	                var response = request.body.response;
	                this.logger.trace("NativeMessageHandler - Received response from browser extension");
	                this.logger.tracePii("NativeMessageHandler - Received response from browser extension: " + JSON.stringify(response));
	                if (response.status !== "Success") {
	                    resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));
	                }
	                else if (response.result) {
	                    if (response.result["code"] && response.result["description"]) {
	                        resolver.reject(NativeAuthError.createError(response.result["code"], response.result["description"], response.result["ext"]));
	                    }
	                    else {
	                        resolver.resolve(response.result);
	                    }
	                }
	                else {
	                    throw AuthError.createUnexpectedError("Event does not contain result.");
	                }
	                this.resolvers.delete(request.responseId);
	            }
	            else if (method === NativeExtensionMethod.HandshakeResponse) {
	                if (!handshakeResolver) {
	                    return;
	                }
	                clearTimeout(this.timeoutId); // Clear setTimeout
	                window.removeEventListener("message", this.windowListener, false); // Remove 'No extension' listener
	                this.extensionId = request.extensionId;
	                this.extensionVersion = request.body.version;
	                this.logger.verbose("NativeMessageHandler - Received HandshakeResponse from extension: " + this.extensionId);
	                this.handshakeEvent.endMeasurement({ extensionInstalled: true, success: true });
	                handshakeResolver.resolve();
	                this.handshakeResolvers.delete(request.responseId);
	            }
	            // Do nothing if method is not Response or HandshakeResponse
	        }
	        catch (err) {
	            this.logger.error("Error parsing response from WAM Extension");
	            this.logger.errorPii("Error parsing response from WAM Extension: " + err.toString());
	            this.logger.errorPii("Unable to parse " + event);
	            if (resolver) {
	                resolver.reject(err);
	            }
	            else if (handshakeResolver) {
	                handshakeResolver.reject(err);
	            }
	        }
	    };
	    /**
	     * Returns the Id for the browser extension this handler is communicating with
	     * @returns
	     */
	    NativeMessageHandler.prototype.getExtensionId = function () {
	        return this.extensionId;
	    };
	    /**
	     * Returns the version for the browser extension this handler is communicating with
	     * @returns
	     */
	    NativeMessageHandler.prototype.getExtensionVersion = function () {
	        return this.extensionVersion;
	    };
	    /**
	     * Returns boolean indicating whether or not the request should attempt to use native broker
	     * @param logger
	     * @param config
	     * @param nativeExtensionProvider
	     * @param authenticationScheme
	     */
	    NativeMessageHandler.isNativeAvailable = function (config, logger, nativeExtensionProvider, authenticationScheme) {
	        logger.trace("isNativeAvailable called");
	        if (!config.system.allowNativeBroker) {
	            logger.trace("isNativeAvailable: allowNativeBroker is not enabled, returning false");
	            // Developer disabled WAM
	            return false;
	        }
	        if (!nativeExtensionProvider) {
	            logger.trace("isNativeAvailable: WAM extension provider is not initialized, returning false");
	            // Extension is not available
	            return false;
	        }
	        if (authenticationScheme) {
	            switch (authenticationScheme) {
	                case AuthenticationScheme.BEARER:
	                case AuthenticationScheme.POP:
	                    logger.trace("isNativeAvailable: authenticationScheme is supported, returning true");
	                    return true;
	                default:
	                    logger.trace("isNativeAvailable: authenticationScheme is not supported, returning false");
	                    return false;
	            }
	        }
	        return true;
	    };
	    return NativeMessageHandler;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var RedirectClient = /** @class */ (function (_super) {
	    __extends$g(RedirectClient, _super);
	    function RedirectClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {
	        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) || this;
	        _this.nativeStorage = nativeStorageImpl;
	        return _this;
	    }
	    /**
	     * Redirects the page to the /authorize endpoint of the IDP
	     * @param request
	     */
	    RedirectClient.prototype.acquireToken = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var validRequest, serverTelemetryManager, handleBackButton, authCodeRequest, authClient, interactionHandler, navigateUrl, redirectStartPage, e_1;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);
	                        return [4 /*yield*/, this.initializeAuthorizationRequest(request, InteractionType.Redirect)];
	                    case 1:
	                        validRequest = _a.sent();
	                        this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);
	                        serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);
	                        handleBackButton = function (event) {
	                            // Clear temporary cache if the back button is clicked during the redirect flow.
	                            if (event.persisted) {
	                                _this.logger.verbose("Page was restored from back/forward cache. Clearing temporary cache.");
	                                _this.browserStorage.cleanRequestByState(validRequest.state);
	                                _this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);
	                            }
	                        };
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 7, , 8]);
	                        // Create auth code request and generate PKCE params
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);
	                        return [4 /*yield*/, this.initializeAuthorizationCodeRequest(validRequest)];
	                    case 3:
	                        authCodeRequest = _a.sent();
	                        // Initialize the client
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);
	                        return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions)];
	                    case 4:
	                        authClient = _a.sent();
	                        this.logger.verbose("Auth code client created");
	                        interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.browserCrypto, this.performanceClient);
	                        return [4 /*yield*/, authClient.getAuthCodeUrl(__assign$5(__assign$5({}, validRequest), { nativeBroker: NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme) }))];
	                    case 5:
	                        navigateUrl = _a.sent();
	                        redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);
	                        this.logger.verbosePii("Redirect start page: " + redirectStartPage);
	                        // Clear temporary cache if the back button is clicked during the redirect flow.
	                        window.addEventListener("pageshow", handleBackButton);
	                        return [4 /*yield*/, interactionHandler.initiateAuthRequest(navigateUrl, {
	                                navigationClient: this.navigationClient,
	                                redirectTimeout: this.config.system.redirectNavigationTimeout,
	                                redirectStartPage: redirectStartPage,
	                                onRedirectNavigate: request.onRedirectNavigate
	                            })];
	                    case 6: 
	                    // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.
	                    return [2 /*return*/, _a.sent()];
	                    case 7:
	                        e_1 = _a.sent();
	                        if (e_1 instanceof AuthError) {
	                            e_1.setCorrelationId(this.correlationId);
	                        }
	                        window.removeEventListener("pageshow", handleBackButton);
	                        serverTelemetryManager.cacheFailedRequest(e_1);
	                        this.browserStorage.cleanRequestByState(validRequest.state);
	                        throw e_1;
	                    case 8: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Checks if navigateToLoginRequestUrl is set, and:
	     * - if true, performs logic to cache and navigate
	     * - if false, handles hash string and parses response
	     * @param hash
	     */
	    RedirectClient.prototype.handleRedirectPromise = function (hash) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var serverTelemetryManager, responseHash, state, serverParams, loginRequestUrl, loginRequestUrlNormalized, currentUrlNormalized, handleHashResult, navigationOptions, processHashOnRedirect, homepage, e_2;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 10, , 11]);
	                        if (!this.browserStorage.isInteractionInProgress(true)) {
	                            this.logger.info("handleRedirectPromise called but there is no interaction in progress, returning null.");
	                            return [2 /*return*/, null];
	                        }
	                        responseHash = this.getRedirectResponseHash(hash || window.location.hash);
	                        if (!responseHash) {
	                            // Not a recognized server response hash or hash not associated with a redirect request
	                            this.logger.info("handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache.");
	                            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);
	                            return [2 /*return*/, null];
	                        }
	                        state = void 0;
	                        try {
	                            serverParams = UrlString.getDeserializedHash(responseHash);
	                            state = this.validateAndExtractStateFromHash(serverParams, InteractionType.Redirect);
	                            this.logger.verbose("State extracted from hash");
	                        }
	                        catch (e) {
	                            this.logger.info("handleRedirectPromise was unable to extract state due to: " + e);
	                            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);
	                            return [2 /*return*/, null];
	                        }
	                        loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;
	                        loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);
	                        currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);
	                        if (!(loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl)) return [3 /*break*/, 3];
	                        // We are on the page we need to navigate to - handle hash
	                        this.logger.verbose("Current page is loginRequestUrl, handling hash");
	                        return [4 /*yield*/, this.handleHash(responseHash, state, serverTelemetryManager)];
	                    case 2:
	                        handleHashResult = _a.sent();
	                        if (loginRequestUrl.indexOf("#") > -1) {
	                            // Replace current hash with non-msal hash, if present
	                            BrowserUtils.replaceHash(loginRequestUrl);
	                        }
	                        return [2 /*return*/, handleHashResult];
	                    case 3:
	                        if (!!this.config.auth.navigateToLoginRequestUrl) return [3 /*break*/, 4];
	                        this.logger.verbose("NavigateToLoginRequestUrl set to false, handling hash");
	                        return [2 /*return*/, this.handleHash(responseHash, state, serverTelemetryManager)];
	                    case 4:
	                        if (!(!BrowserUtils.isInIframe() || this.config.system.allowRedirectInIframe)) return [3 /*break*/, 9];
	                        /*
	                         * Returned from authority using redirect - need to perform navigation before processing response
	                         * Cache the hash to be retrieved after the next redirect
	                         */
	                        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseHash, true);
	                        navigationOptions = {
	                            apiId: ApiId.handleRedirectPromise,
	                            timeout: this.config.system.redirectNavigationTimeout,
	                            noHistory: true
	                        };
	                        processHashOnRedirect = true;
	                        if (!(!loginRequestUrl || loginRequestUrl === "null")) return [3 /*break*/, 6];
	                        homepage = BrowserUtils.getHomepage();
	                        // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage
	                        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);
	                        this.logger.warning("Unable to get valid login request url from cache, redirecting to home page");
	                        return [4 /*yield*/, this.navigationClient.navigateInternal(homepage, navigationOptions)];
	                    case 5:
	                        processHashOnRedirect = _a.sent();
	                        return [3 /*break*/, 8];
	                    case 6:
	                        // Navigate to page that initiated the redirect request
	                        this.logger.verbose("Navigating to loginRequestUrl: " + loginRequestUrl);
	                        return [4 /*yield*/, this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions)];
	                    case 7:
	                        processHashOnRedirect = _a.sent();
	                        _a.label = 8;
	                    case 8:
	                        // If navigateInternal implementation returns false, handle the hash now
	                        if (!processHashOnRedirect) {
	                            return [2 /*return*/, this.handleHash(responseHash, state, serverTelemetryManager)];
	                        }
	                        _a.label = 9;
	                    case 9: return [2 /*return*/, null];
	                    case 10:
	                        e_2 = _a.sent();
	                        if (e_2 instanceof AuthError) {
	                            e_2.setCorrelationId(this.correlationId);
	                        }
	                        serverTelemetryManager.cacheFailedRequest(e_2);
	                        this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);
	                        throw e_2;
	                    case 11: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Gets the response hash for a redirect request
	     * Returns null if interactionType in the state value is not "redirect" or the hash does not contain known properties
	     * @param hash
	     */
	    RedirectClient.prototype.getRedirectResponseHash = function (hash) {
	        this.logger.verbose("getRedirectResponseHash called");
	        // Get current location hash from window or cache.
	        var isResponseHash = UrlString.hashContainsKnownProperties(hash);
	        if (isResponseHash) {
	            BrowserUtils.clearHash(window);
	            this.logger.verbose("Hash contains known properties, returning response hash");
	            return hash;
	        }
	        var cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);
	        this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));
	        this.logger.verbose("Hash does not contain known properties, returning cached hash");
	        return cachedHash;
	    };
	    /**
	     * Checks if hash exists and handles in window.
	     * @param hash
	     * @param state
	     */
	    RedirectClient.prototype.handleHash = function (hash, state, serverTelemetryManager) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var cachedRequest, serverParams, nativeInteractionClient, userRequestState, currentAuthority, authClient, interactionHandler;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        cachedRequest = this.browserStorage.getCachedRequest(state, this.browserCrypto);
	                        this.logger.verbose("handleHash called, retrieved cached request");
	                        serverParams = UrlString.getDeserializedHash(hash);
	                        if (serverParams.accountId) {
	                            this.logger.verbose("Account id found in hash, calling WAM for token");
	                            if (!this.nativeMessageHandler) {
	                                throw BrowserAuthError.createNativeConnectionNotEstablishedError();
	                            }
	                            nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, cachedRequest.correlationId);
	                            userRequestState = ProtocolUtils.parseRequestState(this.browserCrypto, state).userRequestState;
	                            return [2 /*return*/, nativeInteractionClient.acquireToken(__assign$5(__assign$5({}, cachedRequest), { state: userRequestState, prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently
	                                 })).finally(function () {
	                                    _this.browserStorage.cleanRequestByState(state);
	                                })];
	                        }
	                        currentAuthority = this.browserStorage.getCachedAuthority(state);
	                        if (!currentAuthority) {
	                            throw BrowserAuthError.createNoCachedAuthorityError();
	                        }
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, cachedRequest.correlationId);
	                        return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, currentAuthority)];
	                    case 1:
	                        authClient = _a.sent();
	                        this.logger.verbose("Auth code client created");
	                        ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, cachedRequest);
	                        interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, this.logger, this.browserCrypto, this.performanceClient);
	                        return [4 /*yield*/, interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient)];
	                    case 2: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
	     * Default behaviour is to redirect the user to `window.location.href`.
	     * @param logoutRequest
	     */
	    RedirectClient.prototype.logout = function (logoutRequest) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var validLogoutRequest, serverTelemetryManager, navigationOptions, authClient, logoutUri, navigate, e_3;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.verbose("logoutRedirect called");
	                        validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
	                        serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 10, , 11]);
	                        this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);
	                        // Clear cache on logout
	                        return [4 /*yield*/, this.clearCacheOnLogout(validLogoutRequest.account)];
	                    case 2:
	                        // Clear cache on logout
	                        _a.sent();
	                        navigationOptions = {
	                            apiId: ApiId.logout,
	                            timeout: this.config.system.redirectNavigationTimeout,
	                            noHistory: false
	                        };
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validLogoutRequest.correlationId);
	                        return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, logoutRequest && logoutRequest.authority)];
	                    case 3:
	                        authClient = _a.sent();
	                        this.logger.verbose("Auth code client created");
	                        logoutUri = authClient.getLogoutUri(validLogoutRequest);
	                        this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);
	                        if (!(logoutRequest && typeof logoutRequest.onRedirectNavigate === "function")) return [3 /*break*/, 7];
	                        navigate = logoutRequest.onRedirectNavigate(logoutUri);
	                        if (!(navigate !== false)) return [3 /*break*/, 5];
	                        this.logger.verbose("Logout onRedirectNavigate did not return false, navigating");
	                        // Ensure interaction is in progress
	                        if (!this.browserStorage.getInteractionInProgress()) {
	                            this.browserStorage.setInteractionInProgress(true);
	                        }
	                        return [4 /*yield*/, this.navigationClient.navigateExternal(logoutUri, navigationOptions)];
	                    case 4:
	                        _a.sent();
	                        return [2 /*return*/];
	                    case 5:
	                        // Ensure interaction is not in progress
	                        this.browserStorage.setInteractionInProgress(false);
	                        this.logger.verbose("Logout onRedirectNavigate returned false, stopping navigation");
	                        _a.label = 6;
	                    case 6: return [3 /*break*/, 9];
	                    case 7:
	                        // Ensure interaction is in progress
	                        if (!this.browserStorage.getInteractionInProgress()) {
	                            this.browserStorage.setInteractionInProgress(true);
	                        }
	                        return [4 /*yield*/, this.navigationClient.navigateExternal(logoutUri, navigationOptions)];
	                    case 8:
	                        _a.sent();
	                        return [2 /*return*/];
	                    case 9: return [3 /*break*/, 11];
	                    case 10:
	                        e_3 = _a.sent();
	                        if (e_3 instanceof AuthError) {
	                            e_3.setCorrelationId(this.correlationId);
	                        }
	                        serverTelemetryManager.cacheFailedRequest(e_3);
	                        this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e_3);
	                        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);
	                        throw e_3;
	                    case 11:
	                        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Use to get the redirectStartPage either from request or use current window
	     * @param requestStartPage
	     */
	    RedirectClient.prototype.getRedirectStartPage = function (requestStartPage) {
	        var redirectStartPage = requestStartPage || window.location.href;
	        return UrlString.getAbsoluteUrl(redirectStartPage, BrowserUtils.getCurrentUri());
	    };
	    return RedirectClient;
	}(StandardInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var PopupClient = /** @class */ (function (_super) {
	    __extends$g(PopupClient, _super);
	    function PopupClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {
	        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) || this;
	        // Properly sets this reference for the unload event.
	        _this.unloadWindow = _this.unloadWindow.bind(_this);
	        _this.nativeStorage = nativeStorageImpl;
	        return _this;
	    }
	    /**
	     * Acquires tokens by opening a popup window to the /authorize endpoint of the authority
	     * @param request
	     */
	    PopupClient.prototype.acquireToken = function (request) {
	        try {
	            var popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);
	            var popupWindowAttributes = request.popupWindowAttributes || {};
	            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.
	            if (this.config.system.asyncPopups) {
	                this.logger.verbose("asyncPopups set to true, acquiring token");
	                // Passes on popup position and dimensions if in request
	                return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);
	            }
	            else {
	                // asyncPopups flag is set to false. Opens popup before acquiring token.
	                this.logger.verbose("asyncPopup set to false, opening popup before acquiring token");
	                var popup = this.openSizedPopup("about:blank", popupName, popupWindowAttributes);
	                return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);
	            }
	        }
	        catch (e) {
	            return Promise.reject(e);
	        }
	    };
	    /**
	     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
	     * @param logoutRequest
	     */
	    PopupClient.prototype.logout = function (logoutRequest) {
	        try {
	            this.logger.verbose("logoutPopup called");
	            var validLogoutRequest = this.initializeLogoutRequest(logoutRequest);
	            var popupName = this.generateLogoutPopupName(validLogoutRequest);
	            var authority = logoutRequest && logoutRequest.authority;
	            var mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;
	            var popupWindowAttributes = (logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.popupWindowAttributes) || {};
	            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.
	            if (this.config.system.asyncPopups) {
	                this.logger.verbose("asyncPopups set to true");
	                // Passes on popup position and dimensions if in request
	                return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);
	            }
	            else {
	                // asyncPopups flag is set to false. Opens popup before logging out.
	                this.logger.verbose("asyncPopup set to false, opening popup");
	                var popup = this.openSizedPopup("about:blank", popupName, popupWindowAttributes);
	                return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);
	            }
	        }
	        catch (e) {
	            // Since this function is synchronous we need to reject
	            return Promise.reject(e);
	        }
	    };
	    /**
	     * Helper which obtains an access_token for your API via opening a popup window in the user's browser
	     * @param validRequest
	     * @param popupName
	     * @param popup
	     * @param popupWindowAttributes
	     *
	     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
	     */
	    PopupClient.prototype.acquireTokenPopupAsync = function (request, popupName, popupWindowAttributes, popup) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var serverTelemetryManager, validRequest, authCodeRequest, authClient, isNativeBroker, fetchNativeAccountIdMeasurement, navigateUrl, interactionHandler, popupParameters, popupWindow, hash, serverParams, state_1, nativeInteractionClient, userRequestState, result, e_1;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.verbose("acquireTokenPopupAsync called");
	                        serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);
	                        return [4 /*yield*/, this.initializeAuthorizationRequest(request, InteractionType.Popup)];
	                    case 1:
	                        validRequest = _a.sent();
	                        this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 8, , 9]);
	                        // Create auth code request and generate PKCE params
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);
	                        return [4 /*yield*/, this.initializeAuthorizationCodeRequest(validRequest)];
	                    case 3:
	                        authCodeRequest = _a.sent();
	                        // Initialize the client
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);
	                        return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions)];
	                    case 4:
	                        authClient = _a.sent();
	                        this.logger.verbose("Auth code client created");
	                        isNativeBroker = NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme);
	                        fetchNativeAccountIdMeasurement = void 0;
	                        if (isNativeBroker) {
	                            fetchNativeAccountIdMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.FetchAccountIdWithNativeBroker, request.correlationId);
	                        }
	                        return [4 /*yield*/, authClient.getAuthCodeUrl(__assign$5(__assign$5({}, validRequest), { nativeBroker: isNativeBroker }))];
	                    case 5:
	                        navigateUrl = _a.sent();
	                        interactionHandler = new InteractionHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);
	                        popupParameters = {
	                            popup: popup,
	                            popupName: popupName,
	                            popupWindowAttributes: popupWindowAttributes
	                        };
	                        popupWindow = this.initiateAuthRequest(navigateUrl, popupParameters);
	                        this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow: popupWindow }, null);
	                        return [4 /*yield*/, this.monitorPopupForHash(popupWindow)];
	                    case 6:
	                        hash = _a.sent();
	                        serverParams = UrlString.getDeserializedHash(hash);
	                        state_1 = this.validateAndExtractStateFromHash(serverParams, InteractionType.Popup, validRequest.correlationId);
	                        // Remove throttle if it exists
	                        ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest);
	                        if (serverParams.accountId) {
	                            this.logger.verbose("Account id found in hash, calling WAM for token");
	                            // end measurement for server call with native brokering enabled
	                            if (fetchNativeAccountIdMeasurement) {
	                                fetchNativeAccountIdMeasurement.endMeasurement({
	                                    success: true,
	                                    isNativeBroker: true
	                                });
	                            }
	                            if (!this.nativeMessageHandler) {
	                                throw BrowserAuthError.createNativeConnectionNotEstablishedError();
	                            }
	                            nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, validRequest.correlationId);
	                            userRequestState = ProtocolUtils.parseRequestState(this.browserCrypto, state_1).userRequestState;
	                            return [2 /*return*/, nativeInteractionClient.acquireToken(__assign$5(__assign$5({}, validRequest), { state: userRequestState, prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently
	                                 })).finally(function () {
	                                    _this.browserStorage.cleanRequestByState(state_1);
	                                })];
	                        }
	                        return [4 /*yield*/, interactionHandler.handleCodeResponseFromHash(hash, state_1, authClient.authority, this.networkClient)];
	                    case 7:
	                        result = _a.sent();
	                        return [2 /*return*/, result];
	                    case 8:
	                        e_1 = _a.sent();
	                        if (popup) {
	                            // Close the synchronous popup if an error is thrown before the window unload event is registered
	                            popup.close();
	                        }
	                        if (e_1 instanceof AuthError) {
	                            e_1.setCorrelationId(this.correlationId);
	                        }
	                        serverTelemetryManager.cacheFailedRequest(e_1);
	                        this.browserStorage.cleanRequestByState(validRequest.state);
	                        throw e_1;
	                    case 9: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     *
	     * @param validRequest
	     * @param popupName
	     * @param requestAuthority
	     * @param popup
	     * @param mainWindowRedirectUri
	     * @param popupWindowAttributes
	     */
	    PopupClient.prototype.logoutPopupAsync = function (validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var serverTelemetryManager, authClient, logoutUri, popupWindow, navigationOptions, absoluteUrl, e_2;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.verbose("logoutPopupAsync called");
	                        this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);
	                        serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 5, , 6]);
	                        // Clear cache on logout
	                        return [4 /*yield*/, this.clearCacheOnLogout(validRequest.account)];
	                    case 2:
	                        // Clear cache on logout
	                        _a.sent();
	                        // Initialize the client
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validRequest.correlationId);
	                        return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, requestAuthority)];
	                    case 3:
	                        authClient = _a.sent();
	                        this.logger.verbose("Auth code client created");
	                        logoutUri = authClient.getLogoutUri(validRequest);
	                        this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);
	                        popupWindow = this.openPopup(logoutUri, { popupName: popupName, popupWindowAttributes: popupWindowAttributes, popup: popup });
	                        this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, { popupWindow: popupWindow }, null);
	                        return [4 /*yield*/, this.waitForLogoutPopup(popupWindow)];
	                    case 4:
	                        _a.sent();
	                        if (mainWindowRedirectUri) {
	                            navigationOptions = {
	                                apiId: ApiId.logoutPopup,
	                                timeout: this.config.system.redirectNavigationTimeout,
	                                noHistory: false
	                            };
	                            absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());
	                            this.logger.verbose("Redirecting main window to url specified in the request");
	                            this.logger.verbosePii("Redirecting main window to: " + absoluteUrl);
	                            this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);
	                        }
	                        else {
	                            this.logger.verbose("No main window navigation requested");
	                        }
	                        return [3 /*break*/, 6];
	                    case 5:
	                        e_2 = _a.sent();
	                        if (popup) {
	                            // Close the synchronous popup if an error is thrown before the window unload event is registered
	                            popup.close();
	                        }
	                        if (e_2 instanceof AuthError) {
	                            e_2.setCorrelationId(this.correlationId);
	                        }
	                        this.browserStorage.setInteractionInProgress(false);
	                        this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e_2);
	                        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);
	                        serverTelemetryManager.cacheFailedRequest(e_2);
	                        throw e_2;
	                    case 6:
	                        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Opens a popup window with given request Url.
	     * @param requestUrl
	     */
	    PopupClient.prototype.initiateAuthRequest = function (requestUrl, params) {
	        // Check that request url is not empty.
	        if (!StringUtils.isEmpty(requestUrl)) {
	            this.logger.infoPii("Navigate to: " + requestUrl);
	            // Open the popup window to requestUrl.
	            return this.openPopup(requestUrl, params);
	        }
	        else {
	            // Throw error if request URL is empty.
	            this.logger.error("Navigate url is empty");
	            throw BrowserAuthError.createEmptyNavigationUriError();
	        }
	    };
	    /**
	     * Monitors a window until it loads a url with the same origin.
	     * @param popupWindow - window that is being monitored
	     * @param timeout - timeout for processing hash once popup is redirected back to application
	     */
	    PopupClient.prototype.monitorPopupForHash = function (popupWindow) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            /*
	             * Polling for popups needs to be tick-based,
	             * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).
	             */
	            var maxTicks = _this.config.system.windowHashTimeout / _this.config.system.pollIntervalMilliseconds;
	            var ticks = 0;
	            _this.logger.verbose("PopupHandler.monitorPopupForHash - polling started");
	            var intervalId = setInterval(function () {
	                // Window is closed
	                if (popupWindow.closed) {
	                    _this.logger.error("PopupHandler.monitorPopupForHash - window closed");
	                    _this.cleanPopup();
	                    clearInterval(intervalId);
	                    reject(BrowserAuthError.createUserCancelledError());
	                    return;
	                }
	                var href = Constants.EMPTY_STRING;
	                var hash = Constants.EMPTY_STRING;
	                try {
	                    /*
	                     * Will throw if cross origin,
	                     * which should be caught and ignored
	                     * since we need the interval to keep running while on STS UI.
	                     */
	                    href = popupWindow.location.href;
	                    hash = popupWindow.location.hash;
	                }
	                catch (e) { }
	                // Don't process blank pages or cross domain
	                if (StringUtils.isEmpty(href) || href === "about:blank") {
	                    return;
	                }
	                _this.logger.verbose("PopupHandler.monitorPopupForHash - popup window is on same origin as caller");
	                /*
	                 * Only run clock when we are on same domain for popups
	                 * as popup operations can take a long time.
	                 */
	                ticks++;
	                if (hash) {
	                    _this.logger.verbose("PopupHandler.monitorPopupForHash - found hash in url");
	                    clearInterval(intervalId);
	                    _this.cleanPopup(popupWindow);
	                    if (UrlString.hashContainsKnownProperties(hash)) {
	                        _this.logger.verbose("PopupHandler.monitorPopupForHash - hash contains known properties, returning.");
	                        resolve(hash);
	                    }
	                    else {
	                        _this.logger.error("PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely.");
	                        _this.logger.errorPii("PopupHandler.monitorPopupForHash - hash found: " + hash);
	                        reject(BrowserAuthError.createHashDoesNotContainKnownPropertiesError());
	                    }
	                }
	                else if (ticks > maxTicks) {
	                    _this.logger.error("PopupHandler.monitorPopupForHash - unable to find hash in url, timing out");
	                    clearInterval(intervalId);
	                    reject(BrowserAuthError.createMonitorPopupTimeoutError());
	                }
	            }, _this.config.system.pollIntervalMilliseconds);
	        });
	    };
	    /**
	     * Waits for user interaction in logout popup window
	     * @param popupWindow
	     * @returns
	     */
	    PopupClient.prototype.waitForLogoutPopup = function (popupWindow) {
	        var _this = this;
	        return new Promise(function (resolve) {
	            _this.logger.verbose("PopupHandler.waitForLogoutPopup - polling started");
	            var intervalId = setInterval(function () {
	                // Window is closed
	                if (popupWindow.closed) {
	                    _this.logger.error("PopupHandler.waitForLogoutPopup - window closed");
	                    _this.cleanPopup();
	                    clearInterval(intervalId);
	                    resolve();
	                }
	                var href = Constants.EMPTY_STRING;
	                try {
	                    /*
	                     * Will throw if cross origin,
	                     * which should be caught and ignored
	                     * since we need the interval to keep running while on STS UI.
	                     */
	                    href = popupWindow.location.href;
	                }
	                catch (e) { }
	                // Don't process blank pages or cross domain
	                if (StringUtils.isEmpty(href) || href === "about:blank") {
	                    return;
	                }
	                _this.logger.verbose("PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing.");
	                clearInterval(intervalId);
	                _this.cleanPopup(popupWindow);
	                resolve();
	            }, _this.config.system.pollIntervalMilliseconds);
	        });
	    };
	    /**
	     * @hidden
	     *
	     * Configures popup window for login.
	     *
	     * @param urlNavigate
	     * @param title
	     * @param popUpWidth
	     * @param popUpHeight
	     * @param popupWindowAttributes
	     * @ignore
	     * @hidden
	     */
	    PopupClient.prototype.openPopup = function (urlNavigate, popupParams) {
	        try {
	            var popupWindow = void 0;
	            // Popup window passed in, setting url to navigate to
	            if (popupParams.popup) {
	                popupWindow = popupParams.popup;
	                this.logger.verbosePii("Navigating popup window to: " + urlNavigate);
	                popupWindow.location.assign(urlNavigate);
	            }
	            else if (typeof popupParams.popup === "undefined") {
	                // Popup will be undefined if it was not passed in
	                this.logger.verbosePii("Opening popup window to: " + urlNavigate);
	                popupWindow = this.openSizedPopup(urlNavigate, popupParams.popupName, popupParams.popupWindowAttributes);
	            }
	            // Popup will be null if popups are blocked
	            if (!popupWindow) {
	                throw BrowserAuthError.createEmptyWindowCreatedError();
	            }
	            if (popupWindow.focus) {
	                popupWindow.focus();
	            }
	            this.currentWindow = popupWindow;
	            window.addEventListener("beforeunload", this.unloadWindow);
	            return popupWindow;
	        }
	        catch (e) {
	            this.logger.error("error opening popup " + e.message);
	            this.browserStorage.setInteractionInProgress(false);
	            throw BrowserAuthError.createPopupWindowError(e.toString());
	        }
	    };
	    /**
	     * Helper function to set popup window dimensions and position
	     * @param urlNavigate
	     * @param popupName
	     * @param popupWindowAttributes
	     * @returns
	     */
	    PopupClient.prototype.openSizedPopup = function (urlNavigate, popupName, popupWindowAttributes) {
	        var _a, _b, _c, _d;
	        /**
	         * adding winLeft and winTop to account for dual monitor
	         * using screenLeft and screenTop for IE8 and earlier
	         */
	        var winLeft = window.screenLeft ? window.screenLeft : window.screenX;
	        var winTop = window.screenTop ? window.screenTop : window.screenY;
	        /**
	         * window.innerWidth displays browser window"s height and width excluding toolbars
	         * using document.documentElement.clientWidth for IE8 and earlier
	         */
	        var winWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
	        var winHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
	        var width = (_a = popupWindowAttributes.popupSize) === null || _a === void 0 ? void 0 : _a.width;
	        var height = (_b = popupWindowAttributes.popupSize) === null || _b === void 0 ? void 0 : _b.height;
	        var top = (_c = popupWindowAttributes.popupPosition) === null || _c === void 0 ? void 0 : _c.top;
	        var left = (_d = popupWindowAttributes.popupPosition) === null || _d === void 0 ? void 0 : _d.left;
	        if (!width || width < 0 || width > winWidth) {
	            this.logger.verbose("Default popup window width used. Window width not configured or invalid.");
	            width = BrowserConstants.POPUP_WIDTH;
	        }
	        if (!height || height < 0 || height > winHeight) {
	            this.logger.verbose("Default popup window height used. Window height not configured or invalid.");
	            height = BrowserConstants.POPUP_HEIGHT;
	        }
	        if (!top || top < 0 || top > winHeight) {
	            this.logger.verbose("Default popup window top position used. Window top not configured or invalid.");
	            top = Math.max(0, ((winHeight / 2) - (BrowserConstants.POPUP_HEIGHT / 2)) + winTop);
	        }
	        if (!left || left < 0 || left > winWidth) {
	            this.logger.verbose("Default popup window left position used. Window left not configured or invalid.");
	            left = Math.max(0, ((winWidth / 2) - (BrowserConstants.POPUP_WIDTH / 2)) + winLeft);
	        }
	        return window.open(urlNavigate, popupName, "width=" + width + ", height=" + height + ", top=" + top + ", left=" + left + ", scrollbars=yes");
	    };
	    /**
	     * Event callback to unload main window.
	     */
	    PopupClient.prototype.unloadWindow = function (e) {
	        this.browserStorage.cleanRequestByInteractionType(InteractionType.Popup);
	        if (this.currentWindow) {
	            this.currentWindow.close();
	        }
	        // Guarantees browser unload will happen, so no other errors will be thrown.
	        e.preventDefault();
	    };
	    /**
	     * Closes popup, removes any state vars created during popup calls.
	     * @param popupWindow
	     */
	    PopupClient.prototype.cleanPopup = function (popupWindow) {
	        if (popupWindow) {
	            // Close window.
	            popupWindow.close();
	        }
	        // Remove window unload function
	        window.removeEventListener("beforeunload", this.unloadWindow);
	        // Interaction is completed - remove interaction status.
	        this.browserStorage.setInteractionInProgress(false);
	    };
	    /**
	     * Generates the name for the popup based on the client id and request
	     * @param clientId
	     * @param request
	     */
	    PopupClient.prototype.generatePopupName = function (scopes, authority) {
	        return BrowserConstants.POPUP_NAME_PREFIX + "." + this.config.auth.clientId + "." + scopes.join("-") + "." + authority + "." + this.correlationId;
	    };
	    /**
	     * Generates the name for the popup based on the client id and request for logouts
	     * @param clientId
	     * @param request
	     */
	    PopupClient.prototype.generateLogoutPopupName = function (request) {
	        var homeAccountId = request.account && request.account.homeAccountId;
	        return BrowserConstants.POPUP_NAME_PREFIX + "." + this.config.auth.clientId + "." + homeAccountId + "." + this.correlationId;
	    };
	    return PopupClient;
	}(StandardInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var NavigationClient = /** @class */ (function () {
	    function NavigationClient() {
	    }
	    /**
	     * Navigates to other pages within the same web application
	     * @param url
	     * @param options
	     */
	    NavigationClient.prototype.navigateInternal = function (url, options) {
	        return NavigationClient.defaultNavigateWindow(url, options);
	    };
	    /**
	     * Navigates to other pages outside the web application i.e. the Identity Provider
	     * @param url
	     * @param options
	     */
	    NavigationClient.prototype.navigateExternal = function (url, options) {
	        return NavigationClient.defaultNavigateWindow(url, options);
	    };
	    /**
	     * Default navigation implementation invoked by the internal and external functions
	     * @param url
	     * @param options
	     */
	    NavigationClient.defaultNavigateWindow = function (url, options) {
	        if (options.noHistory) {
	            window.location.replace(url);
	        }
	        else {
	            window.location.assign(url);
	        }
	        return new Promise(function (resolve) {
	            setTimeout(function () {
	                resolve(true);
	            }, options.timeout);
	        });
	    };
	    return NavigationClient;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	// Default timeout for popup windows and iframes in milliseconds
	var DEFAULT_POPUP_TIMEOUT_MS = 60000;
	var DEFAULT_IFRAME_TIMEOUT_MS = 6000;
	var DEFAULT_REDIRECT_TIMEOUT_MS = 30000;
	var DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS = 2000;
	/**
	 * MSAL function that sets the default options when not explicitly configured from app developer
	 *
	 * @param auth
	 * @param cache
	 * @param system
	 *
	 * @returns Configuration object
	 */
	function buildConfiguration(_a, isBrowserEnvironment) {
	    var userInputAuth = _a.auth, userInputCache = _a.cache, userInputSystem = _a.system, userInputTelemetry = _a.telemetry;
	    // Default auth options for browser
	    var DEFAULT_AUTH_OPTIONS = {
	        clientId: Constants.EMPTY_STRING,
	        authority: "" + Constants.DEFAULT_AUTHORITY,
	        knownAuthorities: [],
	        cloudDiscoveryMetadata: Constants.EMPTY_STRING,
	        authorityMetadata: Constants.EMPTY_STRING,
	        redirectUri: Constants.EMPTY_STRING,
	        postLogoutRedirectUri: Constants.EMPTY_STRING,
	        navigateToLoginRequestUrl: true,
	        clientCapabilities: [],
	        protocolMode: ProtocolMode.AAD,
	        azureCloudOptions: {
	            azureCloudInstance: AzureCloudInstance.None,
	            tenant: Constants.EMPTY_STRING
	        },
	        skipAuthorityMetadataCache: false,
	    };
	    // Default cache options for browser
	    var DEFAULT_CACHE_OPTIONS = {
	        cacheLocation: BrowserCacheLocation.SessionStorage,
	        temporaryCacheLocation: BrowserCacheLocation.SessionStorage,
	        storeAuthStateInCookie: false,
	        secureCookies: false,
	        // Default cache migration to true if cache location is localStorage since entries are preserved across tabs/windows. Migration has little to no benefit in sessionStorage and memoryStorage
	        cacheMigrationEnabled: userInputCache && userInputCache.cacheLocation === BrowserCacheLocation.LocalStorage ? true : false,
	        claimsBasedCachingEnabled: true
	    };
	    // Default logger options for browser
	    var DEFAULT_LOGGER_OPTIONS = {
	        // eslint-disable-next-line @typescript-eslint/no-empty-function
	        loggerCallback: function () {
	            // allow users to not set logger call back 
	        },
	        logLevel: LogLevel.Info,
	        piiLoggingEnabled: false
	    };
	    // Default system options for browser
	    var DEFAULT_BROWSER_SYSTEM_OPTIONS = __assign$5(__assign$5({}, DEFAULT_SYSTEM_OPTIONS), { loggerOptions: DEFAULT_LOGGER_OPTIONS, networkClient: isBrowserEnvironment ? BrowserUtils.getBrowserNetworkClient() : StubbedNetworkModule, navigationClient: new NavigationClient(), loadFrameTimeout: 0, 
	        // If loadFrameTimeout is provided, use that as default.
	        windowHashTimeout: (userInputSystem === null || userInputSystem === void 0 ? void 0 : userInputSystem.loadFrameTimeout) || DEFAULT_POPUP_TIMEOUT_MS, iframeHashTimeout: (userInputSystem === null || userInputSystem === void 0 ? void 0 : userInputSystem.loadFrameTimeout) || DEFAULT_IFRAME_TIMEOUT_MS, navigateFrameWait: isBrowserEnvironment && BrowserUtils.detectIEOrEdge() ? 500 : 0, redirectNavigationTimeout: DEFAULT_REDIRECT_TIMEOUT_MS, asyncPopups: false, allowRedirectInIframe: false, allowNativeBroker: false, nativeBrokerHandshakeTimeout: (userInputSystem === null || userInputSystem === void 0 ? void 0 : userInputSystem.nativeBrokerHandshakeTimeout) || DEFAULT_NATIVE_BROKER_HANDSHAKE_TIMEOUT_MS, pollIntervalMilliseconds: BrowserConstants.DEFAULT_POLL_INTERVAL_MS, cryptoOptions: {
	            useMsrCrypto: false,
	            entropy: undefined
	        } });
	    var providedSystemOptions = __assign$5(__assign$5({}, userInputSystem), { loggerOptions: (userInputSystem === null || userInputSystem === void 0 ? void 0 : userInputSystem.loggerOptions) || DEFAULT_LOGGER_OPTIONS });
	    var DEFAULT_TELEMETRY_OPTIONS = {
	        application: {
	            appName: Constants.EMPTY_STRING,
	            appVersion: Constants.EMPTY_STRING
	        }
	    };
	    var overlayedConfig = {
	        auth: __assign$5(__assign$5({}, DEFAULT_AUTH_OPTIONS), userInputAuth),
	        cache: __assign$5(__assign$5({}, DEFAULT_CACHE_OPTIONS), userInputCache),
	        system: __assign$5(__assign$5({}, DEFAULT_BROWSER_SYSTEM_OPTIONS), providedSystemOptions),
	        telemetry: __assign$5(__assign$5({}, DEFAULT_TELEMETRY_OPTIONS), userInputTelemetry)
	    };
	    return overlayedConfig;
	}

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var SilentHandler = /** @class */ (function (_super) {
	    __extends$g(SilentHandler, _super);
	    function SilentHandler(authCodeModule, storageImpl, authCodeRequest, logger, systemOptions, performanceClient) {
	        var _this = _super.call(this, authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) || this;
	        _this.navigateFrameWait = systemOptions.navigateFrameWait;
	        _this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;
	        return _this;
	    }
	    /**
	     * Creates a hidden iframe to given URL using user-requested scopes as an id.
	     * @param urlNavigate
	     * @param userRequestScopes
	     */
	    SilentHandler.prototype.initiateAuthRequest = function (requestUrl) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, this.authCodeRequest.correlationId);
	                        if (StringUtils.isEmpty(requestUrl)) {
	                            // Throw error if request URL is empty.
	                            this.logger.info("Navigate url is empty");
	                            throw BrowserAuthError.createEmptyNavigationUriError();
	                        }
	                        if (!this.navigateFrameWait) return [3 /*break*/, 2];
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);
	                        return [4 /*yield*/, this.loadFrame(requestUrl)];
	                    case 1: return [2 /*return*/, _a.sent()];
	                    case 2: return [2 /*return*/, this.loadFrameSync(requestUrl)];
	                }
	            });
	        });
	    };
	    /**
	     * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.
	     * @param iframe
	     * @param timeout
	     */
	    SilentHandler.prototype.monitorIframeForHash = function (iframe, timeout) {
	        var _this = this;
	        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, this.authCodeRequest.correlationId);
	        return new Promise(function (resolve, reject) {
	            if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {
	                _this.logger.warning("system.loadFrameTimeout or system.iframeHashTimeout set to lower (" + timeout + "ms) than the default (" + DEFAULT_IFRAME_TIMEOUT_MS + "ms). This may result in timeouts.");
	            }
	            /*
	             * Polling for iframes can be purely timing based,
	             * since we don't need to account for interaction.
	             */
	            var nowMark = window.performance.now();
	            var timeoutMark = nowMark + timeout;
	            var intervalId = setInterval(function () {
	                if (window.performance.now() > timeoutMark) {
	                    _this.removeHiddenIframe(iframe);
	                    clearInterval(intervalId);
	                    reject(BrowserAuthError.createMonitorIframeTimeoutError());
	                    return;
	                }
	                var href = Constants.EMPTY_STRING;
	                var contentWindow = iframe.contentWindow;
	                try {
	                    /*
	                     * Will throw if cross origin,
	                     * which should be caught and ignored
	                     * since we need the interval to keep running while on STS UI.
	                     */
	                    href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING;
	                }
	                catch (e) { }
	                if (StringUtils.isEmpty(href)) {
	                    return;
	                }
	                var contentHash = contentWindow ? contentWindow.location.hash : Constants.EMPTY_STRING;
	                if (UrlString.hashContainsKnownProperties(contentHash)) {
	                    // Success case
	                    _this.removeHiddenIframe(iframe);
	                    clearInterval(intervalId);
	                    resolve(contentHash);
	                    return;
	                }
	            }, _this.pollIntervalMilliseconds);
	        });
	    };
	    /**
	     * @hidden
	     * Loads iframe with authorization endpoint URL
	     * @ignore
	     */
	    SilentHandler.prototype.loadFrame = function (urlNavigate) {
	        var _this = this;
	        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);
	        /*
	         * This trick overcomes iframe navigation in IE
	         * IE does not load the page consistently in iframe
	         */
	        return new Promise(function (resolve, reject) {
	            var frameHandle = _this.createHiddenIframe();
	            setTimeout(function () {
	                if (!frameHandle) {
	                    reject("Unable to load iframe");
	                    return;
	                }
	                frameHandle.src = urlNavigate;
	                resolve(frameHandle);
	            }, _this.navigateFrameWait);
	        });
	    };
	    /**
	     * @hidden
	     * Loads the iframe synchronously when the navigateTimeFrame is set to `0`
	     * @param urlNavigate
	     * @param frameName
	     * @param logger
	     */
	    SilentHandler.prototype.loadFrameSync = function (urlNavigate) {
	        var frameHandle = this.createHiddenIframe();
	        frameHandle.src = urlNavigate;
	        return frameHandle;
	    };
	    /**
	     * @hidden
	     * Creates a new hidden iframe or gets an existing one for silent token renewal.
	     * @ignore
	     */
	    SilentHandler.prototype.createHiddenIframe = function () {
	        var authFrame = document.createElement("iframe");
	        authFrame.style.visibility = "hidden";
	        authFrame.style.position = "absolute";
	        authFrame.style.width = authFrame.style.height = "0";
	        authFrame.style.border = "0";
	        authFrame.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms");
	        document.getElementsByTagName("body")[0].appendChild(authFrame);
	        return authFrame;
	    };
	    /**
	     * @hidden
	     * Removes a hidden iframe from the page.
	     * @ignore
	     */
	    SilentHandler.prototype.removeHiddenIframe = function (iframe) {
	        if (document.body === iframe.parentNode) {
	            document.body.removeChild(iframe);
	        }
	    };
	    return SilentHandler;
	}(InteractionHandler));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var SilentIframeClient = /** @class */ (function (_super) {
	    __extends$g(SilentIframeClient, _super);
	    function SilentIframeClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {
	        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) || this;
	        _this.apiId = apiId;
	        _this.nativeStorage = nativeStorageImpl;
	        return _this;
	    }
	    /**
	     * Acquires a token silently by opening a hidden iframe to the /authorize endpoint with prompt=none or prompt=no_session
	     * @param request
	     */
	    SilentIframeClient.prototype.acquireToken = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var acquireTokenMeasurement, silentRequest, serverTelemetryManager, authClient, e_1;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientAcquireToken, request.correlationId);
	                        this.logger.verbose("acquireTokenByIframe called");
	                        acquireTokenMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SilentIframeClientAcquireToken, request.correlationId);
	                        // Check that we have some SSO data
	                        if (StringUtils.isEmpty(request.loginHint) && StringUtils.isEmpty(request.sid) && (!request.account || StringUtils.isEmpty(request.account.username))) {
	                            this.logger.warning("No user hint provided. The authorization server may need more information to complete this request.");
	                        }
	                        // Check that prompt is set to none or no_session, throw error if it is set to anything else.
	                        if (request.prompt && (request.prompt !== PromptValue.NONE) && (request.prompt !== PromptValue.NO_SESSION)) {
	                            acquireTokenMeasurement.endMeasurement({
	                                success: false
	                            });
	                            throw BrowserAuthError.createSilentPromptValueError(request.prompt);
	                        }
	                        // Create silent request
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);
	                        return [4 /*yield*/, this.initializeAuthorizationRequest(__assign$5(__assign$5({}, request), { prompt: request.prompt || PromptValue.NONE }), InteractionType.Silent)];
	                    case 1:
	                        silentRequest = _a.sent();
	                        this.browserStorage.updateCacheEntries(silentRequest.state, silentRequest.nonce, silentRequest.authority, silentRequest.loginHint || Constants.EMPTY_STRING, silentRequest.account || null);
	                        serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 5, , 6]);
	                        // Initialize the client
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);
	                        return [4 /*yield*/, this.createAuthCodeClient(serverTelemetryManager, silentRequest.authority, silentRequest.azureCloudOptions)];
	                    case 3:
	                        authClient = _a.sent();
	                        this.logger.verbose("Auth code client created");
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.SilentIframeClientTokenHelper, request.correlationId);
	                        return [4 /*yield*/, this.silentTokenHelper(authClient, silentRequest).then(function (result) {
	                                acquireTokenMeasurement.endMeasurement({
	                                    success: true,
	                                    fromCache: false,
	                                    requestId: result.requestId
	                                });
	                                return result;
	                            })];
	                    case 4: return [2 /*return*/, _a.sent()];
	                    case 5:
	                        e_1 = _a.sent();
	                        if (e_1 instanceof AuthError) {
	                            e_1.setCorrelationId(this.correlationId);
	                        }
	                        serverTelemetryManager.cacheFailedRequest(e_1);
	                        this.browserStorage.cleanRequestByState(silentRequest.state);
	                        acquireTokenMeasurement.endMeasurement({
	                            errorCode: e_1 instanceof AuthError && e_1.errorCode || undefined,
	                            subErrorCode: e_1 instanceof AuthError && e_1.subError || undefined,
	                            success: false
	                        });
	                        throw e_1;
	                    case 6: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Currently Unsupported
	     */
	    SilentIframeClient.prototype.logout = function () {
	        // Synchronous so we must reject
	        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
	    };
	    /**
	     * Helper which acquires an authorization code silently using a hidden iframe from given url
	     * using the scopes requested as part of the id, and exchanges the code for a set of OAuth tokens.
	     * @param navigateUrl
	     * @param userRequestScopes
	     */
	    SilentIframeClient.prototype.silentTokenHelper = function (authClient, silentRequest) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var authCodeRequest, navigateUrl, silentHandler, msalFrame, hash, serverParams, state, nativeInteractionClient, userRequestState;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentIframeClientTokenHelper, silentRequest.correlationId);
	                        // Create auth code request and generate PKCE params
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, silentRequest.correlationId);
	                        return [4 /*yield*/, this.initializeAuthorizationCodeRequest(silentRequest)];
	                    case 1:
	                        authCodeRequest = _a.sent();
	                        // Create authorize request url
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.GetAuthCodeUrl, silentRequest.correlationId);
	                        return [4 /*yield*/, authClient.getAuthCodeUrl(__assign$5(__assign$5({}, silentRequest), { nativeBroker: NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, silentRequest.authenticationScheme) }))];
	                    case 2:
	                        navigateUrl = _a.sent();
	                        silentHandler = new SilentHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.config.system, this.performanceClient);
	                        // Get the frame handle for the silent request
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerInitiateAuthRequest, silentRequest.correlationId);
	                        return [4 /*yield*/, silentHandler.initiateAuthRequest(navigateUrl)];
	                    case 3:
	                        msalFrame = _a.sent();
	                        // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerMonitorIframeForHash, silentRequest.correlationId);
	                        return [4 /*yield*/, silentHandler.monitorIframeForHash(msalFrame, this.config.system.iframeHashTimeout)];
	                    case 4:
	                        hash = _a.sent();
	                        serverParams = UrlString.getDeserializedHash(hash);
	                        state = this.validateAndExtractStateFromHash(serverParams, InteractionType.Silent, authCodeRequest.correlationId);
	                        if (serverParams.accountId) {
	                            this.logger.verbose("Account id found in hash, calling WAM for token");
	                            if (!this.nativeMessageHandler) {
	                                throw BrowserAuthError.createNativeConnectionNotEstablishedError();
	                            }
	                            nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.apiId, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.browserStorage, this.correlationId);
	                            userRequestState = ProtocolUtils.parseRequestState(this.browserCrypto, state).userRequestState;
	                            return [2 /*return*/, nativeInteractionClient.acquireToken(__assign$5(__assign$5({}, silentRequest), { state: userRequestState, prompt: silentRequest.prompt || PromptValue.NONE })).finally(function () {
	                                    _this.browserStorage.cleanRequestByState(state);
	                                })];
	                        }
	                        // Handle response from hash string
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.HandleCodeResponseFromHash, silentRequest.correlationId);
	                        return [2 /*return*/, silentHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient)];
	                }
	            });
	        });
	    };
	    return SilentIframeClient;
	}(StandardInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var SilentRefreshClient = /** @class */ (function (_super) {
	    __extends$g(SilentRefreshClient, _super);
	    function SilentRefreshClient() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * Exchanges the refresh token for new tokens
	     * @param request
	     */
	    SilentRefreshClient.prototype.acquireToken = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var silentRequest, _a, acquireTokenMeasurement, serverTelemetryManager, refreshTokenClient;
	            var _this = this;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentRefreshClientAcquireToken, request.correlationId);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, request.correlationId);
	                        _a = [__assign$5({}, request)];
	                        return [4 /*yield*/, this.initializeBaseRequest(request, request.account)];
	                    case 1:
	                        silentRequest = __assign$5.apply(void 0, _a.concat([_b.sent()]));
	                        acquireTokenMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SilentRefreshClientAcquireToken, silentRequest.correlationId);
	                        serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow);
	                        return [4 /*yield*/, this.createRefreshTokenClient(serverTelemetryManager, silentRequest.authority, silentRequest.azureCloudOptions)];
	                    case 2:
	                        refreshTokenClient = _b.sent();
	                        this.logger.verbose("Refresh token client created");
	                        // Send request to renew token. Auth module will throw errors if token cannot be renewed.
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
	                        return [2 /*return*/, refreshTokenClient.acquireTokenByRefreshToken(silentRequest)
	                                .then(function (result) {
	                                acquireTokenMeasurement.endMeasurement({
	                                    success: true,
	                                    fromCache: result.fromCache,
	                                    requestId: result.requestId
	                                });
	                                return result;
	                            })
	                                .catch(function (e) {
	                                if (e instanceof AuthError) {
	                                    e.setCorrelationId(_this.correlationId);
	                                }
	                                serverTelemetryManager.cacheFailedRequest(e);
	                                acquireTokenMeasurement.endMeasurement({
	                                    errorCode: e.errorCode,
	                                    subErrorCode: e.subError,
	                                    success: false
	                                });
	                                throw e;
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Currently Unsupported
	     */
	    SilentRefreshClient.prototype.logout = function () {
	        // Synchronous so we must reject
	        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
	    };
	    /**
	     * Creates a Refresh Client with the given authority, or the default authority.
	     * @param serverTelemetryManager
	     * @param authorityUrl
	     */
	    SilentRefreshClient.prototype.createRefreshTokenClient = function (serverTelemetryManager, authorityUrl, azureCloudOptions) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var clientConfig;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        // Create auth module.
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);
	                        return [4 /*yield*/, this.getClientConfiguration(serverTelemetryManager, authorityUrl, azureCloudOptions)];
	                    case 1:
	                        clientConfig = _a.sent();
	                        return [2 /*return*/, new RefreshTokenClient(clientConfig, this.performanceClient)];
	                }
	            });
	        });
	    };
	    return SilentRefreshClient;
	}(StandardInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var EventHandler = /** @class */ (function () {
	    function EventHandler(logger, browserCrypto) {
	        this.eventCallbacks = new Map();
	        this.logger = logger;
	        this.browserCrypto = browserCrypto;
	        this.listeningToStorageEvents = false;
	        this.handleAccountCacheChange = this.handleAccountCacheChange.bind(this);
	    }
	    /**
	     * Adds event callbacks to array
	     * @param callback
	     */
	    EventHandler.prototype.addEventCallback = function (callback) {
	        if (typeof window !== "undefined") {
	            var callbackId = this.browserCrypto.createNewGuid();
	            this.eventCallbacks.set(callbackId, callback);
	            this.logger.verbose("Event callback registered with id: " + callbackId);
	            return callbackId;
	        }
	        return null;
	    };
	    /**
	     * Removes callback with provided id from callback array
	     * @param callbackId
	     */
	    EventHandler.prototype.removeEventCallback = function (callbackId) {
	        this.eventCallbacks.delete(callbackId);
	        this.logger.verbose("Event callback " + callbackId + " removed.");
	    };
	    /**
	     * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
	     */
	    EventHandler.prototype.enableAccountStorageEvents = function () {
	        if (typeof window === "undefined") {
	            return;
	        }
	        if (!this.listeningToStorageEvents) {
	            this.logger.verbose("Adding account storage listener.");
	            this.listeningToStorageEvents = true;
	            window.addEventListener("storage", this.handleAccountCacheChange);
	        }
	        else {
	            this.logger.verbose("Account storage listener already registered.");
	        }
	    };
	    /**
	     * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
	     */
	    EventHandler.prototype.disableAccountStorageEvents = function () {
	        if (typeof window === "undefined") {
	            return;
	        }
	        if (this.listeningToStorageEvents) {
	            this.logger.verbose("Removing account storage listener.");
	            window.removeEventListener("storage", this.handleAccountCacheChange);
	            this.listeningToStorageEvents = false;
	        }
	        else {
	            this.logger.verbose("No account storage listener registered.");
	        }
	    };
	    /**
	     * Emits events by calling callback with event message
	     * @param eventType
	     * @param interactionType
	     * @param payload
	     * @param error
	     */
	    EventHandler.prototype.emitEvent = function (eventType, interactionType, payload, error) {
	        var _this = this;
	        if (typeof window !== "undefined") {
	            var message_1 = {
	                eventType: eventType,
	                interactionType: interactionType || null,
	                payload: payload || null,
	                error: error || null,
	                timestamp: Date.now()
	            };
	            this.logger.info("Emitting event: " + eventType);
	            this.eventCallbacks.forEach(function (callback, callbackId) {
	                _this.logger.verbose("Emitting event to callback " + callbackId + ": " + eventType);
	                callback.apply(null, [message_1]);
	            });
	        }
	    };
	    /**
	     * Emit account added/removed events when cached accounts are changed in a different tab or frame
	     */
	    EventHandler.prototype.handleAccountCacheChange = function (e) {
	        try {
	            var cacheValue = e.newValue || e.oldValue;
	            if (!cacheValue) {
	                return;
	            }
	            var parsedValue = JSON.parse(cacheValue);
	            if (typeof parsedValue !== "object" || !AccountEntity.isAccountEntity(parsedValue)) {
	                return;
	            }
	            var accountEntity = CacheManager.toObject(new AccountEntity(), parsedValue);
	            var accountInfo = accountEntity.getAccountInfo();
	            if (!e.oldValue && e.newValue) {
	                this.logger.info("Account was added to cache in a different window");
	                this.emitEvent(EventType.ACCOUNT_ADDED, undefined, accountInfo);
	            }
	            else if (!e.newValue && e.oldValue) {
	                this.logger.info("Account was removed from cache in a different window");
	                this.emitEvent(EventType.ACCOUNT_REMOVED, undefined, accountInfo);
	            }
	        }
	        catch (e) {
	            return;
	        }
	    };
	    return EventHandler;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Utility class for math specific functions in browser.
	 */
	var MathUtils = /** @class */ (function () {
	    function MathUtils() {
	    }
	    /**
	     * Decimal to Hex
	     *
	     * @param num
	     */
	    MathUtils.decimalToHex = function (num) {
	        var hex = num.toString(16);
	        while (hex.length < 2) {
	            hex = "0" + hex;
	        }
	        return hex;
	    };
	    return MathUtils;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var GuidGenerator = /** @class */ (function () {
	    function GuidGenerator(cryptoObj) {
	        this.cryptoObj = cryptoObj;
	    }
	    /*
	     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or
	     * pseudo-random numbers.
	     * The algorithm is as follows:
	     *     Set the two most significant bits (bits 6 and 7) of the
	     *        clock_seq_hi_and_reserved to zero and one, respectively.
	     *     Set the four most significant bits (bits 12 through 15) of the
	     *        time_hi_and_version field to the 4-bit version number from
	     *        Section 4.1.3. Version4
	     *     Set all the other bits to randomly (or pseudo-randomly) chosen
	     *     values.
	     * UUID                   = time-low "-" time-mid "-"time-high-and-version "-"clock-seq-reserved and low(2hexOctet)"-" node
	     * time-low               = 4hexOctet
	     * time-mid               = 2hexOctet
	     * time-high-and-version  = 2hexOctet
	     * clock-seq-and-reserved = hexOctet:
	     * clock-seq-low          = hexOctet
	     * node                   = 6hexOctet
	     * Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
	     * y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10
	     * y values are 8, 9, A, B
	     */
	    GuidGenerator.prototype.generateGuid = function () {
	        try {
	            var buffer = new Uint8Array(16);
	            this.cryptoObj.getRandomValues(buffer);
	            // buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).
	            buffer[6] |= 0x40; // buffer[6] | 01000000 will set the 6 bit to 1.
	            buffer[6] &= 0x4f; // buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = "4".
	            // buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.
	            buffer[8] |= 0x80; // buffer[8] | 10000000 will set the 7 bit to 1.
	            buffer[8] &= 0xbf; // buffer[8] & 10111111 will set the 6 bit to 0.
	            return MathUtils.decimalToHex(buffer[0]) + MathUtils.decimalToHex(buffer[1])
	                + MathUtils.decimalToHex(buffer[2]) + MathUtils.decimalToHex(buffer[3])
	                + "-" + MathUtils.decimalToHex(buffer[4]) + MathUtils.decimalToHex(buffer[5])
	                + "-" + MathUtils.decimalToHex(buffer[6]) + MathUtils.decimalToHex(buffer[7])
	                + "-" + MathUtils.decimalToHex(buffer[8]) + MathUtils.decimalToHex(buffer[9])
	                + "-" + MathUtils.decimalToHex(buffer[10]) + MathUtils.decimalToHex(buffer[11])
	                + MathUtils.decimalToHex(buffer[12]) + MathUtils.decimalToHex(buffer[13])
	                + MathUtils.decimalToHex(buffer[14]) + MathUtils.decimalToHex(buffer[15]);
	        }
	        catch (err) {
	            var guidHolder = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
	            var hex = "0123456789abcdef";
	            var r = 0;
	            var guidResponse = Constants.EMPTY_STRING;
	            for (var i = 0; i < 36; i++) {
	                if (guidHolder[i] !== "-" && guidHolder[i] !== "4") {
	                    // each x and y needs to be random
	                    r = Math.random() * 16 | 0;
	                }
	                if (guidHolder[i] === "x") {
	                    guidResponse += hex[r];
	                }
	                else if (guidHolder[i] === "y") {
	                    // clock-seq-and-reserved first hex is filtered and remaining hex values are random
	                    r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??
	                    r |= 0x8; // set pos 3 to 1 as 1???
	                    guidResponse += hex[r];
	                }
	                else {
	                    guidResponse += guidHolder[i];
	                }
	            }
	            return guidResponse;
	        }
	    };
	    /**
	     * verifies if a string is  GUID
	     * @param guid
	     */
	    GuidGenerator.prototype.isGuid = function (guid) {
	        var regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
	        return regexGuid.test(guid);
	    };
	    return GuidGenerator;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Utility functions for strings in a browser. See here for implementation details:
	 * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Solution_2_%E2%80%93_JavaScript's_UTF-16_%3E_UTF-8_%3E_base64
	 */
	var BrowserStringUtils = /** @class */ (function () {
	    function BrowserStringUtils() {
	    }
	    /**
	     * Converts string to Uint8Array
	     * @param sDOMStr
	     */
	    BrowserStringUtils.stringToUtf8Arr = function (sDOMStr) {
	        var nChr;
	        var nArrLen = 0;
	        var nStrLen = sDOMStr.length;
	        /* mapping... */
	        for (var nMapIdx = 0; nMapIdx < nStrLen; nMapIdx++) {
	            nChr = sDOMStr.charCodeAt(nMapIdx);
	            nArrLen += nChr < 0x80 ? 1 : nChr < 0x800 ? 2 : nChr < 0x10000 ? 3 : nChr < 0x200000 ? 4 : nChr < 0x4000000 ? 5 : 6;
	        }
	        var aBytes = new Uint8Array(nArrLen);
	        /* transcription... */
	        for (var nIdx = 0, nChrIdx = 0; nIdx < nArrLen; nChrIdx++) {
	            nChr = sDOMStr.charCodeAt(nChrIdx);
	            if (nChr < 128) {
	                /* one byte */
	                aBytes[nIdx++] = nChr;
	            }
	            else if (nChr < 0x800) {
	                /* two bytes */
	                aBytes[nIdx++] = 192 + (nChr >>> 6);
	                aBytes[nIdx++] = 128 + (nChr & 63);
	            }
	            else if (nChr < 0x10000) {
	                /* three bytes */
	                aBytes[nIdx++] = 224 + (nChr >>> 12);
	                aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	                aBytes[nIdx++] = 128 + (nChr & 63);
	            }
	            else if (nChr < 0x200000) {
	                /* four bytes */
	                aBytes[nIdx++] = 240 + (nChr >>> 18);
	                aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
	                aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	                aBytes[nIdx++] = 128 + (nChr & 63);
	            }
	            else if (nChr < 0x4000000) {
	                /* five bytes */
	                aBytes[nIdx++] = 248 + (nChr >>> 24);
	                aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
	                aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
	                aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	                aBytes[nIdx++] = 128 + (nChr & 63);
	            }
	            else /* if (nChr <= 0x7fffffff) */ {
	                /* six bytes */
	                aBytes[nIdx++] = 252 + (nChr >>> 30);
	                aBytes[nIdx++] = 128 + (nChr >>> 24 & 63);
	                aBytes[nIdx++] = 128 + (nChr >>> 18 & 63);
	                aBytes[nIdx++] = 128 + (nChr >>> 12 & 63);
	                aBytes[nIdx++] = 128 + (nChr >>> 6 & 63);
	                aBytes[nIdx++] = 128 + (nChr & 63);
	            }
	        }
	        return aBytes;
	    };
	    /**
	     * Converst string to ArrayBuffer
	     * @param dataString
	     */
	    BrowserStringUtils.stringToArrayBuffer = function (dataString) {
	        var data = new ArrayBuffer(dataString.length);
	        var dataView = new Uint8Array(data);
	        for (var i = 0; i < dataString.length; i++) {
	            dataView[i] = dataString.charCodeAt(i);
	        }
	        return data;
	    };
	    /**
	     * Converts Uint8Array to a string
	     * @param aBytes
	     */
	    BrowserStringUtils.utf8ArrToString = function (aBytes) {
	        var sView = Constants.EMPTY_STRING;
	        for (var nPart = void 0, nLen = aBytes.length, nIdx = 0; nIdx < nLen; nIdx++) {
	            nPart = aBytes[nIdx];
	            sView += String.fromCharCode(nPart > 251 && nPart < 254 && nIdx + 5 < nLen ? /* six bytes */
	                /* (nPart - 252 << 30) may be not so safe in ECMAScript! So...: */
	                (nPart - 252) * 1073741824 + (aBytes[++nIdx] - 128 << 24) + (aBytes[++nIdx] - 128 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
	                : nPart > 247 && nPart < 252 && nIdx + 4 < nLen ? /* five bytes */
	                    (nPart - 248 << 24) + (aBytes[++nIdx] - 128 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
	                    : nPart > 239 && nPart < 248 && nIdx + 3 < nLen ? /* four bytes */
	                        (nPart - 240 << 18) + (aBytes[++nIdx] - 128 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
	                        : nPart > 223 && nPart < 240 && nIdx + 2 < nLen ? /* three bytes */
	                            (nPart - 224 << 12) + (aBytes[++nIdx] - 128 << 6) + aBytes[++nIdx] - 128
	                            : nPart > 191 && nPart < 224 && nIdx + 1 < nLen ? /* two bytes */
	                                (nPart - 192 << 6) + aBytes[++nIdx] - 128
	                                : /* nPart < 127 ? */ /* one byte */
	                                    nPart);
	        }
	        return sView;
	    };
	    /**
	     * Returns stringified jwk.
	     * @param jwk
	     */
	    BrowserStringUtils.getSortedObjectString = function (obj) {
	        return JSON.stringify(obj, Object.keys(obj).sort());
	    };
	    return BrowserStringUtils;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Class which exposes APIs to encode plaintext to base64 encoded string. See here for implementation details:
	 * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Solution_2_%E2%80%93_JavaScript's_UTF-16_%3E_UTF-8_%3E_base64
	 */
	var Base64Encode = /** @class */ (function () {
	    function Base64Encode() {
	    }
	    /**
	     * Returns URL Safe b64 encoded string from a plaintext string.
	     * @param input
	     */
	    Base64Encode.prototype.urlEncode = function (input) {
	        return encodeURIComponent(this.encode(input)
	            .replace(/=/g, Constants.EMPTY_STRING)
	            .replace(/\+/g, "-")
	            .replace(/\//g, "_"));
	    };
	    /**
	     * Returns URL Safe b64 encoded string from an int8Array.
	     * @param inputArr
	     */
	    Base64Encode.prototype.urlEncodeArr = function (inputArr) {
	        return this.base64EncArr(inputArr)
	            .replace(/=/g, Constants.EMPTY_STRING)
	            .replace(/\+/g, "-")
	            .replace(/\//g, "_");
	    };
	    /**
	     * Returns b64 encoded string from plaintext string.
	     * @param input
	     */
	    Base64Encode.prototype.encode = function (input) {
	        var inputUtf8Arr = BrowserStringUtils.stringToUtf8Arr(input);
	        return this.base64EncArr(inputUtf8Arr);
	    };
	    /**
	     * Base64 encode byte array
	     * @param aBytes
	     */
	    Base64Encode.prototype.base64EncArr = function (aBytes) {
	        var eqLen = (3 - (aBytes.length % 3)) % 3;
	        var sB64Enc = Constants.EMPTY_STRING;
	        for (var nMod3 = void 0, nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {
	            nMod3 = nIdx % 3;
	            /* Uncomment the following line in order to split the output in lines 76-character long: */
	            /*
	             *if (nIdx > 0 && (nIdx * 4 / 3) % 76 === 0) { sB64Enc += "\r\n"; }
	             */
	            nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);
	            if (nMod3 === 2 || aBytes.length - nIdx === 1) {
	                sB64Enc += String.fromCharCode(this.uint6ToB64(nUint24 >>> 18 & 63), this.uint6ToB64(nUint24 >>> 12 & 63), this.uint6ToB64(nUint24 >>> 6 & 63), this.uint6ToB64(nUint24 & 63));
	                nUint24 = 0;
	            }
	        }
	        return eqLen === 0 ? sB64Enc : sB64Enc.substring(0, sB64Enc.length - eqLen) + (eqLen === 1 ? "=" : "==");
	    };
	    /**
	     * Base64 string to array encoding helper
	     * @param nUint6
	     */
	    Base64Encode.prototype.uint6ToB64 = function (nUint6) {
	        return nUint6 < 26 ?
	            nUint6 + 65
	            : nUint6 < 52 ?
	                nUint6 + 71
	                : nUint6 < 62 ?
	                    nUint6 - 4
	                    : nUint6 === 62 ?
	                        43
	                        : nUint6 === 63 ?
	                            47
	                            :
	                                65;
	    };
	    return Base64Encode;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Class which exposes APIs to decode base64 strings to plaintext. See here for implementation details:
	 * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Solution_2_%E2%80%93_JavaScript's_UTF-16_%3E_UTF-8_%3E_base64
	 */
	var Base64Decode = /** @class */ (function () {
	    function Base64Decode() {
	    }
	    /**
	     * Returns a URL-safe plaintext decoded string from b64 encoded input.
	     * @param input
	     */
	    Base64Decode.prototype.decode = function (input) {
	        var encodedString = input.replace(/-/g, "+").replace(/_/g, "/");
	        switch (encodedString.length % 4) {
	            case 0:
	                break;
	            case 2:
	                encodedString += "==";
	                break;
	            case 3:
	                encodedString += "=";
	                break;
	            default:
	                throw new Error("Invalid base64 string");
	        }
	        var inputUtf8Arr = this.base64DecToArr(encodedString);
	        return BrowserStringUtils.utf8ArrToString(inputUtf8Arr);
	    };
	    /**
	     * Decodes base64 into Uint8Array
	     * @param base64String
	     * @param nBlockSize
	     */
	    Base64Decode.prototype.base64DecToArr = function (base64String, nBlockSize) {
	        var sB64Enc = base64String.replace(/[^A-Za-z0-9\+\/]/g, Constants.EMPTY_STRING);
	        var nInLen = sB64Enc.length;
	        var nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2;
	        var aBytes = new Uint8Array(nOutLen);
	        for (var nMod3 = void 0, nMod4 = void 0, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
	            nMod4 = nInIdx & 3;
	            nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
	            if (nMod4 === 3 || nInLen - nInIdx === 1) {
	                for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
	                    aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
	                }
	                nUint24 = 0;
	            }
	        }
	        return aBytes;
	    };
	    /**
	     * Base64 string to array decoding helper
	     * @param charNum
	     */
	    Base64Decode.prototype.b64ToUint6 = function (charNum) {
	        return charNum > 64 && charNum < 91 ?
	            charNum - 65
	            : charNum > 96 && charNum < 123 ?
	                charNum - 71
	                : charNum > 47 && charNum < 58 ?
	                    charNum + 4
	                    : charNum === 43 ?
	                        62
	                        : charNum === 47 ?
	                            63
	                            :
	                                0;
	    };
	    return Base64Decode;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	// Constant byte array length
	var RANDOM_BYTE_ARR_LENGTH = 32;
	/**
	 * Class which exposes APIs to generate PKCE codes and code verifiers.
	 */
	var PkceGenerator = /** @class */ (function () {
	    function PkceGenerator(cryptoObj) {
	        this.base64Encode = new Base64Encode();
	        this.cryptoObj = cryptoObj;
	    }
	    /**
	     * Generates PKCE Codes. See the RFC for more information: https://tools.ietf.org/html/rfc7636
	     */
	    PkceGenerator.prototype.generateCodes = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var codeVerifier, codeChallenge;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        codeVerifier = this.generateCodeVerifier();
	                        return [4 /*yield*/, this.generateCodeChallengeFromVerifier(codeVerifier)];
	                    case 1:
	                        codeChallenge = _a.sent();
	                        return [2 /*return*/, {
	                                verifier: codeVerifier,
	                                challenge: codeChallenge
	                            }];
	                }
	            });
	        });
	    };
	    /**
	     * Generates a random 32 byte buffer and returns the base64
	     * encoded string to be used as a PKCE Code Verifier
	     */
	    PkceGenerator.prototype.generateCodeVerifier = function () {
	        try {
	            // Generate random values as utf-8
	            var buffer = new Uint8Array(RANDOM_BYTE_ARR_LENGTH);
	            this.cryptoObj.getRandomValues(buffer);
	            // encode verifier as base64
	            var pkceCodeVerifierB64 = this.base64Encode.urlEncodeArr(buffer);
	            return pkceCodeVerifierB64;
	        }
	        catch (e) {
	            throw BrowserAuthError.createPkceNotGeneratedError(e);
	        }
	    };
	    /**
	     * Creates a base64 encoded PKCE Code Challenge string from the
	     * hash created from the PKCE Code Verifier supplied
	     */
	    PkceGenerator.prototype.generateCodeChallengeFromVerifier = function (pkceCodeVerifier) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var pkceHashedCodeVerifier, e_1;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        _a.trys.push([0, 2, , 3]);
	                        return [4 /*yield*/, this.cryptoObj.sha256Digest(pkceCodeVerifier)];
	                    case 1:
	                        pkceHashedCodeVerifier = _a.sent();
	                        // encode hash as base64
	                        return [2 /*return*/, this.base64Encode.urlEncodeArr(new Uint8Array(pkceHashedCodeVerifier))];
	                    case 2:
	                        e_1 = _a.sent();
	                        throw BrowserAuthError.createPkceNotGeneratedError(e_1);
	                    case 3: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    return PkceGenerator;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var ModernBrowserCrypto = /** @class */ (function () {
	    function ModernBrowserCrypto() {
	    }
	    ModernBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {
	        return window.crypto.getRandomValues(dataBuffer);
	    };
	    ModernBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.crypto.subtle.generateKey(algorithm, extractable, keyUsages)];
	            });
	        });
	    };
	    ModernBrowserCrypto.prototype.exportKey = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key)];
	            });
	        });
	    };
	    ModernBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.crypto.subtle.importKey(KEY_FORMAT_JWK, keyData, algorithm, extractable, keyUsages)];
	            });
	        });
	    };
	    ModernBrowserCrypto.prototype.sign = function (algorithm, key, data) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.crypto.subtle.sign(algorithm, key, data)];
	            });
	        });
	    };
	    ModernBrowserCrypto.prototype.digest = function (algorithm, data) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.crypto.subtle.digest(algorithm, data)];
	            });
	        });
	    };
	    return ModernBrowserCrypto;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var MsrBrowserCrypto = /** @class */ (function () {
	    function MsrBrowserCrypto() {
	    }
	    MsrBrowserCrypto.prototype.initPrng = function (entropy) {
	        // Turn into array, as initPrng seems to not always like Uint8Array (even though it should support both)
	        return window.msrCrypto.initPrng(__spread(entropy));
	    };
	    MsrBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {
	        return window.msrCrypto.getRandomValues(dataBuffer);
	    };
	    MsrBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.msrCrypto.subtle.generateKey(algorithm, extractable, keyUsages)];
	            });
	        });
	    };
	    MsrBrowserCrypto.prototype.exportKey = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.msrCrypto.subtle.exportKey(KEY_FORMAT_JWK, key)];
	            });
	        });
	    };
	    MsrBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.msrCrypto.subtle.importKey(KEY_FORMAT_JWK, keyData, algorithm, extractable, keyUsages)];
	            });
	        });
	    };
	    MsrBrowserCrypto.prototype.sign = function (algorithm, key, data) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.msrCrypto.subtle.sign(algorithm, key, data)];
	            });
	        });
	    };
	    MsrBrowserCrypto.prototype.digest = function (algorithm, data) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, window.msrCrypto.subtle.digest(algorithm, data)];
	            });
	        });
	    };
	    return MsrBrowserCrypto;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var MsBrowserCrypto = /** @class */ (function () {
	    function MsBrowserCrypto() {
	    }
	    MsBrowserCrypto.prototype.getRandomValues = function (dataBuffer) {
	        return window["msCrypto"].getRandomValues(dataBuffer);
	    };
	    MsBrowserCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        var msGenerateKey = window["msCrypto"].subtle.generateKey(algorithm, extractable, keyUsages);
	                        msGenerateKey.addEventListener("complete", function (e) {
	                            resolve(e.target.result);
	                        });
	                        msGenerateKey.addEventListener("error", function (error) {
	                            reject(error);
	                        });
	                    })];
	            });
	        });
	    };
	    MsBrowserCrypto.prototype.exportKey = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        var msExportKey = window["msCrypto"].subtle.exportKey(KEY_FORMAT_JWK, key);
	                        msExportKey.addEventListener("complete", function (e) {
	                            var resultBuffer = e.target.result;
	                            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))
	                                .replace(/\r/g, Constants.EMPTY_STRING)
	                                .replace(/\n/g, Constants.EMPTY_STRING)
	                                .replace(/\t/g, Constants.EMPTY_STRING)
	                                .split(" ").join(Constants.EMPTY_STRING)
	                                .replace("\u0000", Constants.EMPTY_STRING);
	                            try {
	                                resolve(JSON.parse(resultString));
	                            }
	                            catch (e) {
	                                reject(e);
	                            }
	                        });
	                        msExportKey.addEventListener("error", function (error) {
	                            reject(error);
	                        });
	                    })];
	            });
	        });
	    };
	    MsBrowserCrypto.prototype.importKey = function (keyData, algorithm, extractable, keyUsages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var keyString, keyBuffer;
	            return __generator$3(this, function (_a) {
	                keyString = BrowserStringUtils.getSortedObjectString(keyData);
	                keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        var msImportKey = window["msCrypto"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, algorithm, extractable, keyUsages);
	                        msImportKey.addEventListener("complete", function (e) {
	                            resolve(e.target.result);
	                        });
	                        msImportKey.addEventListener("error", function (error) {
	                            reject(error);
	                        });
	                    })];
	            });
	        });
	    };
	    MsBrowserCrypto.prototype.sign = function (algorithm, key, data) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        var msSign = window["msCrypto"].subtle.sign(algorithm, key, data);
	                        msSign.addEventListener("complete", function (e) {
	                            resolve(e.target.result);
	                        });
	                        msSign.addEventListener("error", function (error) {
	                            reject(error);
	                        });
	                    })];
	            });
	        });
	    };
	    MsBrowserCrypto.prototype.digest = function (algorithm, data) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        var digestOperation = window["msCrypto"].subtle.digest(algorithm, data.buffer);
	                        digestOperation.addEventListener("complete", function (e) {
	                            resolve(e.target.result);
	                        });
	                        digestOperation.addEventListener("error", function (error) {
	                            reject(error);
	                        });
	                    })];
	            });
	        });
	    };
	    return MsBrowserCrypto;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams
	 */
	// RSA KeyGen Algorithm
	var PKCS1_V15_KEYGEN_ALG = "RSASSA-PKCS1-v1_5";
	// SHA-256 hashing algorithm
	var S256_HASH_ALG = "SHA-256";
	// MOD length for PoP tokens
	var MODULUS_LENGTH = 2048;
	// Public Exponent
	var PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);
	/**
	 * This class implements functions used by the browser library to perform cryptography operations such as
	 * hashing and encoding. It also has helper functions to validate the availability of specific APIs.
	 */
	var BrowserCrypto = /** @class */ (function () {
	    function BrowserCrypto(logger, cryptoOptions) {
	        var _a, _b;
	        this.logger = logger;
	        this.cryptoOptions = cryptoOptions;
	        if (this.hasBrowserCrypto()) {
	            // Use standard modern web crypto if available
	            this.logger.verbose("BrowserCrypto: modern crypto interface available");
	            this.subtleCrypto = new ModernBrowserCrypto();
	        }
	        else if (this.hasIECrypto()) {
	            // For IE11, use msCrypto interface
	            this.logger.verbose("BrowserCrypto: MS crypto interface available");
	            this.subtleCrypto = new MsBrowserCrypto();
	        }
	        else if (this.hasMsrCrypto() && ((_a = this.cryptoOptions) === null || _a === void 0 ? void 0 : _a.useMsrCrypto)) {
	            // For other browsers, use MSR Crypto if found
	            this.logger.verbose("BrowserCrypto: MSR crypto interface available");
	            this.subtleCrypto = new MsrBrowserCrypto();
	        }
	        else {
	            if (this.hasMsrCrypto()) {
	                this.logger.info("BrowserCrypto: MSR Crypto interface available but system.cryptoOptions.useMsrCrypto not enabled");
	            }
	            this.logger.error("BrowserCrypto: No crypto interfaces available.");
	            throw BrowserAuthError.createCryptoNotAvailableError("Browser crypto, msCrypto, or msrCrypto interfaces not available.");
	        }
	        // Mainly needed for MSR Crypto: https://github.com/microsoft/MSR-JavaScript-Crypto#random-number-generator-prng
	        if (this.subtleCrypto.initPrng) {
	            this.logger.verbose("BrowserCrypto: Interface requires entropy");
	            if (!((_b = this.cryptoOptions) === null || _b === void 0 ? void 0 : _b.entropy)) {
	                this.logger.error("BrowserCrypto: Interface requires entropy but none provided.");
	                throw BrowserConfigurationAuthError.createEntropyNotProvided();
	            }
	            this.logger.verbose("BrowserCrypto: Entropy provided");
	            this.subtleCrypto.initPrng(this.cryptoOptions.entropy);
	        }
	        this.keygenAlgorithmOptions = {
	            name: PKCS1_V15_KEYGEN_ALG,
	            hash: S256_HASH_ALG,
	            modulusLength: MODULUS_LENGTH,
	            publicExponent: PUBLIC_EXPONENT
	        };
	    }
	    /**
	     * Check whether IE crypto or other browser cryptography is available.
	     */
	    BrowserCrypto.prototype.hasIECrypto = function () {
	        return "msCrypto" in window;
	    };
	    /**
	     * Check whether browser crypto is available.
	     */
	    BrowserCrypto.prototype.hasBrowserCrypto = function () {
	        return "crypto" in window;
	    };
	    /**
	     * Check whether MSR crypto polyfill is available
	     */
	    BrowserCrypto.prototype.hasMsrCrypto = function () {
	        return "msrCrypto" in window;
	    };
	    /**
	     * Returns a sha-256 hash of the given dataString as an ArrayBuffer.
	     * @param dataString
	     */
	    BrowserCrypto.prototype.sha256Digest = function (dataString) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var data;
	            return __generator$3(this, function (_a) {
	                data = BrowserStringUtils.stringToUtf8Arr(dataString);
	                // MSR Crypto wants object with name property, instead of string
	                return [2 /*return*/, this.subtleCrypto.digest({ name: S256_HASH_ALG }, data)];
	            });
	        });
	    };
	    /**
	     * Populates buffer with cryptographically random values.
	     * @param dataBuffer
	     */
	    BrowserCrypto.prototype.getRandomValues = function (dataBuffer) {
	        return this.subtleCrypto.getRandomValues(dataBuffer);
	    };
	    /**
	     * Generates a keypair based on current keygen algorithm config.
	     * @param extractable
	     * @param usages
	     */
	    BrowserCrypto.prototype.generateKeyPair = function (extractable, usages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, this.subtleCrypto.generateKey(this.keygenAlgorithmOptions, extractable, usages)];
	            });
	        });
	    };
	    /**
	     * Export key as Json Web Key (JWK)
	     * @param key
	     * @param format
	     */
	    BrowserCrypto.prototype.exportJwk = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, this.subtleCrypto.exportKey(key)];
	            });
	        });
	    };
	    /**
	     * Imports key as Json Web Key (JWK), can set extractable and usages.
	     * @param key
	     * @param format
	     * @param extractable
	     * @param usages
	     */
	    BrowserCrypto.prototype.importJwk = function (key, extractable, usages) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, this.subtleCrypto.importKey(key, this.keygenAlgorithmOptions, extractable, usages)];
	            });
	        });
	    };
	    /**
	     * Signs given data with given key
	     * @param key
	     * @param data
	     */
	    BrowserCrypto.prototype.sign = function (key, data) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, this.subtleCrypto.sign(this.keygenAlgorithmOptions, key, data)];
	            });
	        });
	    };
	    return BrowserCrypto;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Storage wrapper for IndexedDB storage in browsers: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
	 */
	var DatabaseStorage = /** @class */ (function () {
	    function DatabaseStorage() {
	        this.dbName = DB_NAME;
	        this.version = DB_VERSION;
	        this.tableName = DB_TABLE_NAME;
	        this.dbOpen = false;
	    }
	    /**
	     * Opens IndexedDB instance.
	     */
	    DatabaseStorage.prototype.open = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        var openDB = window.indexedDB.open(_this.dbName, _this.version);
	                        openDB.addEventListener("upgradeneeded", function (e) {
	                            var event = e;
	                            event.target.result.createObjectStore(_this.tableName);
	                        });
	                        openDB.addEventListener("success", function (e) {
	                            var event = e;
	                            _this.db = event.target.result;
	                            _this.dbOpen = true;
	                            resolve();
	                        });
	                        openDB.addEventListener("error", function () { return reject(BrowserAuthError.createDatabaseUnavailableError()); });
	                    })];
	            });
	        });
	    };
	    /**
	     * Closes the connection to IndexedDB database when all pending transactions
	     * complete.
	     */
	    DatabaseStorage.prototype.closeConnection = function () {
	        var db = this.db;
	        if (db && this.dbOpen) {
	            db.close();
	            this.dbOpen = false;
	        }
	    };
	    /**
	     * Opens database if it's not already open
	     */
	    DatabaseStorage.prototype.validateDbIsOpen = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        if (!!this.dbOpen) return [3 /*break*/, 2];
	                        return [4 /*yield*/, this.open()];
	                    case 1: return [2 /*return*/, _a.sent()];
	                    case 2: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Retrieves item from IndexedDB instance.
	     * @param key
	     */
	    DatabaseStorage.prototype.getItem = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.validateDbIsOpen()];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, new Promise(function (resolve, reject) {
	                                // TODO: Add timeouts?
	                                if (!_this.db) {
	                                    return reject(BrowserAuthError.createDatabaseNotOpenError());
	                                }
	                                var transaction = _this.db.transaction([_this.tableName], "readonly");
	                                var objectStore = transaction.objectStore(_this.tableName);
	                                var dbGet = objectStore.get(key);
	                                dbGet.addEventListener("success", function (e) {
	                                    var event = e;
	                                    _this.closeConnection();
	                                    resolve(event.target.result);
	                                });
	                                dbGet.addEventListener("error", function (e) {
	                                    _this.closeConnection();
	                                    reject(e);
	                                });
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Adds item to IndexedDB under given key
	     * @param key
	     * @param payload
	     */
	    DatabaseStorage.prototype.setItem = function (key, payload) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.validateDbIsOpen()];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, new Promise(function (resolve, reject) {
	                                // TODO: Add timeouts?
	                                if (!_this.db) {
	                                    return reject(BrowserAuthError.createDatabaseNotOpenError());
	                                }
	                                var transaction = _this.db.transaction([_this.tableName], "readwrite");
	                                var objectStore = transaction.objectStore(_this.tableName);
	                                var dbPut = objectStore.put(payload, key);
	                                dbPut.addEventListener("success", function () {
	                                    _this.closeConnection();
	                                    resolve();
	                                });
	                                dbPut.addEventListener("error", function (e) {
	                                    _this.closeConnection();
	                                    reject(e);
	                                });
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Removes item from IndexedDB under given key
	     * @param key
	     */
	    DatabaseStorage.prototype.removeItem = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.validateDbIsOpen()];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, new Promise(function (resolve, reject) {
	                                if (!_this.db) {
	                                    return reject(BrowserAuthError.createDatabaseNotOpenError());
	                                }
	                                var transaction = _this.db.transaction([_this.tableName], "readwrite");
	                                var objectStore = transaction.objectStore(_this.tableName);
	                                var dbDelete = objectStore.delete(key);
	                                dbDelete.addEventListener("success", function () {
	                                    _this.closeConnection();
	                                    resolve();
	                                });
	                                dbDelete.addEventListener("error", function (e) {
	                                    _this.closeConnection();
	                                    reject(e);
	                                });
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Get all the keys from the storage object as an iterable array of strings.
	     */
	    DatabaseStorage.prototype.getKeys = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.validateDbIsOpen()];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, new Promise(function (resolve, reject) {
	                                if (!_this.db) {
	                                    return reject(BrowserAuthError.createDatabaseNotOpenError());
	                                }
	                                var transaction = _this.db.transaction([_this.tableName], "readonly");
	                                var objectStore = transaction.objectStore(_this.tableName);
	                                var dbGetKeys = objectStore.getAllKeys();
	                                dbGetKeys.addEventListener("success", function (e) {
	                                    var event = e;
	                                    _this.closeConnection();
	                                    resolve(event.target.result);
	                                });
	                                dbGetKeys.addEventListener("error", function (e) {
	                                    _this.closeConnection();
	                                    reject(e);
	                                });
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     *
	     * Checks whether there is an object under the search key in the object store
	     */
	    DatabaseStorage.prototype.containsKey = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.validateDbIsOpen()];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, new Promise(function (resolve, reject) {
	                                if (!_this.db) {
	                                    return reject(BrowserAuthError.createDatabaseNotOpenError());
	                                }
	                                var transaction = _this.db.transaction([_this.tableName], "readonly");
	                                var objectStore = transaction.objectStore(_this.tableName);
	                                var dbContainsKey = objectStore.count(key);
	                                dbContainsKey.addEventListener("success", function (e) {
	                                    var event = e;
	                                    _this.closeConnection();
	                                    resolve(event.target.result === 1);
	                                });
	                                dbContainsKey.addEventListener("error", function (e) {
	                                    _this.closeConnection();
	                                    reject(e);
	                                });
	                            })];
	                }
	            });
	        });
	    };
	    /**
	     * Deletes the MSAL database. The database is deleted rather than cleared to make it possible
	     * for client applications to downgrade to a previous MSAL version without worrying about forward compatibility issues
	     * with IndexedDB database versions.
	     */
	    DatabaseStorage.prototype.deleteDatabase = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                // Check if database being deleted exists
	                if (this.db && this.dbOpen) {
	                    this.closeConnection();
	                }
	                return [2 /*return*/, new Promise(function (resolve, reject) {
	                        var deleteDbRequest = window.indexedDB.deleteDatabase(DB_NAME);
	                        deleteDbRequest.addEventListener("success", function () { return resolve(true); });
	                        deleteDbRequest.addEventListener("blocked", function () { return resolve(true); });
	                        deleteDbRequest.addEventListener("error", function () { return reject(false); });
	                    })];
	            });
	        });
	    };
	    return DatabaseStorage;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,
	 * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.
	 */
	var AsyncMemoryStorage = /** @class */ (function () {
	    function AsyncMemoryStorage(logger, storeName) {
	        this.inMemoryCache = new MemoryStorage();
	        this.indexedDBCache = new DatabaseStorage();
	        this.logger = logger;
	        this.storeName = storeName;
	    }
	    AsyncMemoryStorage.prototype.handleDatabaseAccessError = function (error) {
	        if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {
	            this.logger.error("Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.");
	        }
	        else {
	            throw error;
	        }
	    };
	    /**
	     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous
	     * storage object if item isn't found in-memory.
	     * @param key
	     */
	    AsyncMemoryStorage.prototype.getItem = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var item, e_1;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        item = this.inMemoryCache.getItem(key);
	                        if (!!item) return [3 /*break*/, 4];
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        this.logger.verbose("Queried item not found in in-memory cache, now querying persistent storage.");
	                        return [4 /*yield*/, this.indexedDBCache.getItem(key)];
	                    case 2: return [2 /*return*/, _a.sent()];
	                    case 3:
	                        e_1 = _a.sent();
	                        this.handleDatabaseAccessError(e_1);
	                        return [3 /*break*/, 4];
	                    case 4: return [2 /*return*/, item];
	                }
	            });
	        });
	    };
	    /**
	     * Sets the item in the in-memory cache and then tries to set it in the asynchronous
	     * storage object with the given key.
	     * @param key
	     * @param value
	     */
	    AsyncMemoryStorage.prototype.setItem = function (key, value) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var e_2;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.inMemoryCache.setItem(key, value);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.indexedDBCache.setItem(key, value)];
	                    case 2:
	                        _a.sent();
	                        return [3 /*break*/, 4];
	                    case 3:
	                        e_2 = _a.sent();
	                        this.handleDatabaseAccessError(e_2);
	                        return [3 /*break*/, 4];
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.
	     * @param key
	     */
	    AsyncMemoryStorage.prototype.removeItem = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var e_3;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.inMemoryCache.removeItem(key);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.indexedDBCache.removeItem(key)];
	                    case 2:
	                        _a.sent();
	                        return [3 /*break*/, 4];
	                    case 3:
	                        e_3 = _a.sent();
	                        this.handleDatabaseAccessError(e_3);
	                        return [3 /*break*/, 4];
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the
	     * asynchronous storage object.
	     */
	    AsyncMemoryStorage.prototype.getKeys = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var cacheKeys, e_4;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        cacheKeys = this.inMemoryCache.getKeys();
	                        if (!(cacheKeys.length === 0)) return [3 /*break*/, 4];
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        this.logger.verbose("In-memory cache is empty, now querying persistent storage.");
	                        return [4 /*yield*/, this.indexedDBCache.getKeys()];
	                    case 2: return [2 /*return*/, _a.sent()];
	                    case 3:
	                        e_4 = _a.sent();
	                        this.handleDatabaseAccessError(e_4);
	                        return [3 /*break*/, 4];
	                    case 4: return [2 /*return*/, cacheKeys];
	                }
	            });
	        });
	    };
	    /**
	     * Returns true or false if the given key is present in the cache.
	     * @param key
	     */
	    AsyncMemoryStorage.prototype.containsKey = function (key) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var containsKey, e_5;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        containsKey = this.inMemoryCache.containsKey(key);
	                        if (!!containsKey) return [3 /*break*/, 4];
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        this.logger.verbose("Key not found in in-memory cache, now querying persistent storage.");
	                        return [4 /*yield*/, this.indexedDBCache.containsKey(key)];
	                    case 2: return [2 /*return*/, _a.sent()];
	                    case 3:
	                        e_5 = _a.sent();
	                        this.handleDatabaseAccessError(e_5);
	                        return [3 /*break*/, 4];
	                    case 4: return [2 /*return*/, containsKey];
	                }
	            });
	        });
	    };
	    /**
	     * Clears in-memory Map
	     */
	    AsyncMemoryStorage.prototype.clearInMemory = function () {
	        // InMemory cache is a Map instance, clear is straightforward
	        this.logger.verbose("Deleting in-memory keystore " + this.storeName);
	        this.inMemoryCache.clear();
	        this.logger.verbose("In-memory keystore " + this.storeName + " deleted");
	    };
	    /**
	     * Tries to delete the IndexedDB database
	     * @returns
	     */
	    AsyncMemoryStorage.prototype.clearPersistent = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var dbDeleted, e_6;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        _a.trys.push([0, 2, , 3]);
	                        this.logger.verbose("Deleting persistent keystore");
	                        return [4 /*yield*/, this.indexedDBCache.deleteDatabase()];
	                    case 1:
	                        dbDeleted = _a.sent();
	                        if (dbDeleted) {
	                            this.logger.verbose("Persistent keystore deleted");
	                        }
	                        return [2 /*return*/, dbDeleted];
	                    case 2:
	                        e_6 = _a.sent();
	                        this.handleDatabaseAccessError(e_6);
	                        return [2 /*return*/, false];
	                    case 3: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    return AsyncMemoryStorage;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var CryptoKeyStoreNames;
	(function (CryptoKeyStoreNames) {
	    CryptoKeyStoreNames["asymmetricKeys"] = "asymmetricKeys";
	    CryptoKeyStoreNames["symmetricKeys"] = "symmetricKeys";
	})(CryptoKeyStoreNames || (CryptoKeyStoreNames = {}));
	/**
	 * MSAL CryptoKeyStore DB Version 2
	 */
	var CryptoKeyStore = /** @class */ (function () {
	    function CryptoKeyStore(logger) {
	        this.logger = logger;
	        this.asymmetricKeys = new AsyncMemoryStorage(this.logger, CryptoKeyStoreNames.asymmetricKeys);
	        this.symmetricKeys = new AsyncMemoryStorage(this.logger, CryptoKeyStoreNames.symmetricKeys);
	    }
	    CryptoKeyStore.prototype.clear = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var e_1;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        // Delete in-memory keystores
	                        this.asymmetricKeys.clearInMemory();
	                        this.symmetricKeys.clearInMemory();
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.asymmetricKeys.clearPersistent()];
	                    case 2:
	                        _a.sent();
	                        return [2 /*return*/, true];
	                    case 3:
	                        e_1 = _a.sent();
	                        if (e_1 instanceof Error) {
	                            this.logger.error("Clearing keystore failed with error: " + e_1.message);
	                        }
	                        else {
	                            this.logger.error("Clearing keystore failed with unknown error");
	                        }
	                        return [2 /*return*/, false];
	                    case 4: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    return CryptoKeyStore;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and
	 * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).
	 */
	var CryptoOps = /** @class */ (function () {
	    function CryptoOps(logger, performanceClient, cryptoConfig) {
	        this.logger = logger;
	        // Browser crypto needs to be validated first before any other classes can be set.
	        this.browserCrypto = new BrowserCrypto(this.logger, cryptoConfig);
	        this.b64Encode = new Base64Encode();
	        this.b64Decode = new Base64Decode();
	        this.guidGenerator = new GuidGenerator(this.browserCrypto);
	        this.pkceGenerator = new PkceGenerator(this.browserCrypto);
	        this.cache = new CryptoKeyStore(this.logger);
	        this.performanceClient = performanceClient;
	    }
	    /**
	     * Creates a new random GUID - used to populate state and nonce.
	     * @returns string (GUID)
	     */
	    CryptoOps.prototype.createNewGuid = function () {
	        return this.guidGenerator.generateGuid();
	    };
	    /**
	     * Encodes input string to base64.
	     * @param input
	     */
	    CryptoOps.prototype.base64Encode = function (input) {
	        return this.b64Encode.encode(input);
	    };
	    /**
	     * Decodes input string from base64.
	     * @param input
	     */
	    CryptoOps.prototype.base64Decode = function (input) {
	        return this.b64Decode.decode(input);
	    };
	    /**
	     * Generates PKCE codes used in Authorization Code Flow.
	     */
	    CryptoOps.prototype.generatePkceCodes = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                return [2 /*return*/, this.pkceGenerator.generateCodes()];
	            });
	        });
	    };
	    /**
	     * Generates a keypair, stores it and returns a thumbprint
	     * @param request
	     */
	    CryptoOps.prototype.getPublicKeyThumbprint = function (request) {
	        var _a;
	        return __awaiter$3(this, void 0, void 0, function () {
	            var publicKeyThumbMeasurement, keyPair, publicKeyJwk, pubKeyThumprintObj, publicJwkString, publicJwkHash, privateKeyJwk, unextractablePrivateKey;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        publicKeyThumbMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);
	                        return [4 /*yield*/, this.browserCrypto.generateKeyPair(CryptoOps.EXTRACTABLE, CryptoOps.POP_KEY_USAGES)];
	                    case 1:
	                        keyPair = _b.sent();
	                        return [4 /*yield*/, this.browserCrypto.exportJwk(keyPair.publicKey)];
	                    case 2:
	                        publicKeyJwk = _b.sent();
	                        pubKeyThumprintObj = {
	                            e: publicKeyJwk.e,
	                            kty: publicKeyJwk.kty,
	                            n: publicKeyJwk.n
	                        };
	                        publicJwkString = BrowserStringUtils.getSortedObjectString(pubKeyThumprintObj);
	                        return [4 /*yield*/, this.hashString(publicJwkString)];
	                    case 3:
	                        publicJwkHash = _b.sent();
	                        return [4 /*yield*/, this.browserCrypto.exportJwk(keyPair.privateKey)];
	                    case 4:
	                        privateKeyJwk = _b.sent();
	                        return [4 /*yield*/, this.browserCrypto.importJwk(privateKeyJwk, false, ["sign"])];
	                    case 5:
	                        unextractablePrivateKey = _b.sent();
	                        // Store Keypair data in keystore
	                        return [4 /*yield*/, this.cache.asymmetricKeys.setItem(publicJwkHash, {
	                                privateKey: unextractablePrivateKey,
	                                publicKey: keyPair.publicKey,
	                                requestMethod: request.resourceRequestMethod,
	                                requestUri: request.resourceRequestUri
	                            })];
	                    case 6:
	                        // Store Keypair data in keystore
	                        _b.sent();
	                        if (publicKeyThumbMeasurement) {
	                            publicKeyThumbMeasurement.endMeasurement({
	                                success: true
	                            });
	                        }
	                        return [2 /*return*/, publicJwkHash];
	                }
	            });
	        });
	    };
	    /**
	     * Removes cryptographic keypair from key store matching the keyId passed in
	     * @param kid
	     */
	    CryptoOps.prototype.removeTokenBindingKey = function (kid) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var keyFound;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.cache.asymmetricKeys.removeItem(kid)];
	                    case 1:
	                        _a.sent();
	                        return [4 /*yield*/, this.cache.asymmetricKeys.containsKey(kid)];
	                    case 2:
	                        keyFound = _a.sent();
	                        return [2 /*return*/, !keyFound];
	                }
	            });
	        });
	    };
	    /**
	     * Removes all cryptographic keys from IndexedDB storage
	     */
	    CryptoOps.prototype.clearKeystore = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.cache.clear()];
	                    case 1: return [2 /*return*/, _a.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Signs the given object as a jwt payload with private key retrieved by given kid.
	     * @param payload
	     * @param kid
	     */
	    CryptoOps.prototype.signJwt = function (payload, kid, correlationId) {
	        var _a;
	        return __awaiter$3(this, void 0, void 0, function () {
	            var signJwtMeasurement, cachedKeyPair, publicKeyJwk, publicKeyJwkString, encodedKeyIdThumbprint, shrHeader, encodedShrHeader, encodedPayload, tokenString, tokenBuffer, signatureBuffer, encodedSignature, signedJwt;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        signJwtMeasurement = (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);
	                        return [4 /*yield*/, this.cache.asymmetricKeys.getItem(kid)];
	                    case 1:
	                        cachedKeyPair = _b.sent();
	                        if (!cachedKeyPair) {
	                            throw BrowserAuthError.createSigningKeyNotFoundInStorageError(kid);
	                        }
	                        return [4 /*yield*/, this.browserCrypto.exportJwk(cachedKeyPair.publicKey)];
	                    case 2:
	                        publicKeyJwk = _b.sent();
	                        publicKeyJwkString = BrowserStringUtils.getSortedObjectString(publicKeyJwk);
	                        encodedKeyIdThumbprint = this.b64Encode.urlEncode(JSON.stringify({ kid: kid }));
	                        shrHeader = JoseHeader.getShrHeaderString({ kid: encodedKeyIdThumbprint, alg: publicKeyJwk.alg });
	                        encodedShrHeader = this.b64Encode.urlEncode(shrHeader);
	                        // Generate payload
	                        payload.cnf = {
	                            jwk: JSON.parse(publicKeyJwkString)
	                        };
	                        encodedPayload = this.b64Encode.urlEncode(JSON.stringify(payload));
	                        tokenString = encodedShrHeader + "." + encodedPayload;
	                        tokenBuffer = BrowserStringUtils.stringToArrayBuffer(tokenString);
	                        return [4 /*yield*/, this.browserCrypto.sign(cachedKeyPair.privateKey, tokenBuffer)];
	                    case 3:
	                        signatureBuffer = _b.sent();
	                        encodedSignature = this.b64Encode.urlEncodeArr(new Uint8Array(signatureBuffer));
	                        signedJwt = tokenString + "." + encodedSignature;
	                        if (signJwtMeasurement) {
	                            signJwtMeasurement.endMeasurement({
	                                success: true
	                            });
	                        }
	                        return [2 /*return*/, signedJwt];
	                }
	            });
	        });
	    };
	    /**
	     * Returns the SHA-256 hash of an input string
	     * @param plainText
	     */
	    CryptoOps.prototype.hashString = function (plainText) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var hashBuffer, hashBytes;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.browserCrypto.sha256Digest(plainText)];
	                    case 1:
	                        hashBuffer = _a.sent();
	                        hashBytes = new Uint8Array(hashBuffer);
	                        return [2 /*return*/, this.b64Encode.urlEncodeArr(hashBytes)];
	                }
	            });
	        });
	    };
	    CryptoOps.POP_KEY_USAGES = ["sign", "verify"];
	    CryptoOps.EXTRACTABLE = true;
	    return CryptoOps;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */
	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var BrowserPerformanceMeasurement = /** @class */ (function () {
	    function BrowserPerformanceMeasurement(name, correlationId) {
	        this.correlationId = correlationId;
	        this.measureName = BrowserPerformanceMeasurement.makeMeasureName(name, correlationId);
	        this.startMark = BrowserPerformanceMeasurement.makeStartMark(name, correlationId);
	        this.endMark = BrowserPerformanceMeasurement.makeEndMark(name, correlationId);
	    }
	    BrowserPerformanceMeasurement.makeMeasureName = function (name, correlationId) {
	        return "msal.measure." + name + "." + correlationId;
	    };
	    BrowserPerformanceMeasurement.makeStartMark = function (name, correlationId) {
	        return "msal.start." + name + "." + correlationId;
	    };
	    BrowserPerformanceMeasurement.makeEndMark = function (name, correlationId) {
	        return "msal.end." + name + "." + correlationId;
	    };
	    BrowserPerformanceMeasurement.supportsBrowserPerformance = function () {
	        return typeof window !== "undefined" &&
	            typeof window.performance !== "undefined" &&
	            typeof window.performance.mark === "function" &&
	            typeof window.performance.measure === "function" &&
	            typeof window.performance.clearMarks === "function" &&
	            typeof window.performance.clearMeasures === "function" &&
	            typeof window.performance.getEntriesByName === "function";
	    };
	    /**
	     * Flush browser marks and measurements.
	     * @param {string} correlationId
	     * @param {SubMeasurement} measurements
	     */
	    BrowserPerformanceMeasurement.flushMeasurements = function (correlationId, measurements) {
	        if (BrowserPerformanceMeasurement.supportsBrowserPerformance()) {
	            try {
	                measurements.forEach(function (measurement) {
	                    var measureName = BrowserPerformanceMeasurement.makeMeasureName(measurement.name, correlationId);
	                    var entriesForMeasurement = window.performance.getEntriesByName(measureName, "measure");
	                    if (entriesForMeasurement.length > 0) {
	                        window.performance.clearMeasures(measureName);
	                        window.performance.clearMarks(BrowserPerformanceMeasurement.makeStartMark(measureName, correlationId));
	                        window.performance.clearMarks(BrowserPerformanceMeasurement.makeEndMark(measureName, correlationId));
	                    }
	                });
	            }
	            catch (e) {
	                // Silently catch and return null
	            }
	        }
	    };
	    BrowserPerformanceMeasurement.prototype.startMeasurement = function () {
	        if (BrowserPerformanceMeasurement.supportsBrowserPerformance()) {
	            try {
	                window.performance.mark(this.startMark);
	            }
	            catch (e) {
	                // Silently catch
	            }
	        }
	    };
	    BrowserPerformanceMeasurement.prototype.endMeasurement = function () {
	        if (BrowserPerformanceMeasurement.supportsBrowserPerformance()) {
	            try {
	                window.performance.mark(this.endMark);
	                window.performance.measure(this.measureName, this.startMark, this.endMark);
	            }
	            catch (e) {
	                // Silently catch
	            }
	        }
	    };
	    BrowserPerformanceMeasurement.prototype.flushMeasurement = function () {
	        if (BrowserPerformanceMeasurement.supportsBrowserPerformance()) {
	            try {
	                var entriesForMeasurement = window.performance.getEntriesByName(this.measureName, "measure");
	                if (entriesForMeasurement.length > 0) {
	                    var durationMs = entriesForMeasurement[0].duration;
	                    window.performance.clearMeasures(this.measureName);
	                    window.performance.clearMarks(this.startMark);
	                    window.performance.clearMarks(this.endMark);
	                    return durationMs;
	                }
	            }
	            catch (e) {
	                // Silently catch and return null
	            }
	        }
	        return null;
	    };
	    return BrowserPerformanceMeasurement;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var BrowserPerformanceClient = /** @class */ (function (_super) {
	    __extends$g(BrowserPerformanceClient, _super);
	    function BrowserPerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry, cryptoOptions) {
	        var _this = _super.call(this, clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) || this;
	        _this.browserCrypto = new BrowserCrypto(_this.logger, cryptoOptions);
	        _this.guidGenerator = new GuidGenerator(_this.browserCrypto);
	        return _this;
	    }
	    BrowserPerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {
	        return new BrowserPerformanceMeasurement(measureName, correlationId);
	    };
	    BrowserPerformanceClient.prototype.generateId = function () {
	        return this.guidGenerator.generateGuid();
	    };
	    BrowserPerformanceClient.prototype.getPageVisibility = function () {
	        var _a;
	        return ((_a = document.visibilityState) === null || _a === void 0 ? void 0 : _a.toString()) || null;
	    };
	    BrowserPerformanceClient.prototype.deleteIncompleteSubMeasurements = function (inProgressEvent) {
	        var rootEvent = this.eventsByCorrelationId.get(inProgressEvent.event.correlationId);
	        var isRootEvent = rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;
	        var incompleteMeasurements = [];
	        if (isRootEvent && (rootEvent === null || rootEvent === void 0 ? void 0 : rootEvent.incompleteSubMeasurements)) {
	            rootEvent.incompleteSubMeasurements.forEach(function (subMeasurement) {
	                incompleteMeasurements.push(__assign$5({}, subMeasurement));
	            });
	        }
	        // Clean up remaining marks for incomplete sub-measurements
	        if (incompleteMeasurements.length > 0) {
	            BrowserPerformanceMeasurement.flushMeasurements(inProgressEvent.event.correlationId, incompleteMeasurements);
	        }
	    };
	    BrowserPerformanceClient.prototype.supportsBrowserPerformanceNow = function () {
	        return typeof window !== "undefined" &&
	            typeof window.performance !== "undefined" &&
	            typeof window.performance.now === "function";
	    };
	    /**
	     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.
	     * Also captures browser page visibilityState.
	     *
	     * @param {PerformanceEvents} measureName
	     * @param {?string} [correlationId]
	     * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}
	     */
	    BrowserPerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {
	        var _this = this;
	        // Capture page visibilityState and then invoke start/end measurement
	        var startPageVisibility = this.getPageVisibility();
	        var inProgressEvent = _super.prototype.startMeasurement.call(this, measureName, correlationId);
	        return __assign$5(__assign$5({}, inProgressEvent), { endMeasurement: function (event) {
	                var res = inProgressEvent.endMeasurement(__assign$5({ startPageVisibility: startPageVisibility, endPageVisibility: _this.getPageVisibility() }, event));
	                _this.deleteIncompleteSubMeasurements(inProgressEvent);
	                return res;
	            }, discardMeasurement: function () {
	                inProgressEvent.discardMeasurement();
	                _this.deleteIncompleteSubMeasurements(inProgressEvent);
	                inProgressEvent.measurement.flushMeasurement();
	            } });
	    };
	    /**
	     * Adds pre-queue time to preQueueTimeByCorrelationId map.
	     * @param {PerformanceEvents} eventName
	     * @param {?string} correlationId
	     * @returns
	     */
	    BrowserPerformanceClient.prototype.setPreQueueTime = function (eventName, correlationId) {
	        if (!this.supportsBrowserPerformanceNow()) {
	            this.logger.trace("BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for " + eventName);
	            return;
	        }
	        if (!correlationId) {
	            this.logger.trace("BrowserPerformanceClient: correlationId for " + eventName + " not provided, unable to set telemetry queue time");
	            return;
	        }
	        var preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);
	        /**
	         * Manually complete queue measurement if there is an incomplete pre-queue event.
	         * Incomplete pre-queue events are instrumentation bugs that should be fixed.
	         */
	        if (preQueueEvent) {
	            this.logger.trace("BrowserPerformanceClient: Incomplete pre-queue " + preQueueEvent.name + " found", correlationId);
	            this.addQueueMeasurement(preQueueEvent.name, correlationId, undefined, true);
	        }
	        this.preQueueTimeByCorrelationId.set(correlationId, { name: eventName, time: window.performance.now() });
	    };
	    /**
	     * Calculates and adds queue time measurement for given performance event.
	     *
	     * @param {PerformanceEvents} eventName
	     * @param {?string} correlationId
	     * @param {?number} queueTime
	     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements
	     * @returns
	     */
	    BrowserPerformanceClient.prototype.addQueueMeasurement = function (eventName, correlationId, queueTime, manuallyCompleted) {
	        if (!this.supportsBrowserPerformanceNow()) {
	            this.logger.trace("BrowserPerformanceClient: window performance API not available, unable to add queue measurement for " + eventName);
	            return;
	        }
	        if (!correlationId) {
	            this.logger.trace("BrowserPerformanceClient: correlationId for " + eventName + " not provided, unable to add queue measurement");
	            return;
	        }
	        var preQueueTime = _super.prototype.getPreQueueTime.call(this, eventName, correlationId);
	        if (!preQueueTime) {
	            return;
	        }
	        var currentTime = window.performance.now();
	        var resQueueTime = queueTime || _super.prototype.calculateQueuedTime.call(this, preQueueTime, currentTime);
	        return _super.prototype.addQueueMeasurement.call(this, eventName, correlationId, resQueueTime, manuallyCompleted);
	    };
	    return BrowserPerformanceClient;
	}(PerformanceClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * Token cache manager
	 */
	var TokenCache = /** @class */ (function () {
	    function TokenCache(configuration, storage, logger, cryptoObj) {
	        this.isBrowserEnvironment = typeof window !== "undefined";
	        this.config = configuration;
	        this.storage = storage;
	        this.logger = logger;
	        this.cryptoObj = cryptoObj;
	    }
	    // Move getAllAccounts here and cache utility APIs
	    /**
	     * API to load tokens to msal-browser cache.
	     * @param request
	     * @param response
	     * @param options
	     * @returns `AuthenticationResult` for the response that was loaded.
	     */
	    TokenCache.prototype.loadExternalTokens = function (request, response, options) {
	        this.logger.info("TokenCache - loadExternalTokens called");
	        if (!response.id_token) {
	            throw BrowserAuthError.createUnableToLoadTokenError("Please ensure server response includes id token.");
	        }
	        var idToken = new AuthToken(response.id_token, this.cryptoObj);
	        var cacheRecord;
	        var authority;
	        if (request.account) {
	            var cacheRecordAccount = this.loadAccount(idToken, request.account.environment, undefined, undefined, request.account.homeAccountId);
	            cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(idToken, cacheRecordAccount.homeAccountId, request.account.environment, request.account.tenantId), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, request.account.environment, request.account.tenantId, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, request.account.environment));
	        }
	        else if (request.authority) {
	            var authorityUrl = Authority.generateAuthority(request.authority, request.azureCloudOptions);
	            var authorityOptions = {
	                protocolMode: this.config.auth.protocolMode,
	                knownAuthorities: this.config.auth.knownAuthorities,
	                cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
	                authorityMetadata: this.config.auth.authorityMetadata,
	                skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache,
	            };
	            authority = new Authority(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger);
	            // "clientInfo" from options takes precedence over "clientInfo" in response
	            if (options.clientInfo) {
	                this.logger.trace("TokenCache - homeAccountId from options");
	                var cacheRecordAccount = this.loadAccount(idToken, authority.hostnameAndPort, options.clientInfo, authority.authorityType);
	                cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(idToken, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort));
	            }
	            else if (response.client_info) {
	                this.logger.trace("TokenCache - homeAccountId from response");
	                var cacheRecordAccount = this.loadAccount(idToken, authority.hostnameAndPort, response.client_info, authority.authorityType);
	                cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(idToken, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort));
	            }
	            else {
	                throw BrowserAuthError.createUnableToLoadTokenError("Please provide clientInfo in the response or options.");
	            }
	        }
	        else {
	            throw BrowserAuthError.createUnableToLoadTokenError("Please provide a request with an account or a request with authority.");
	        }
	        return this.generateAuthenticationResult(request, idToken, cacheRecord, authority);
	    };
	    /**
	     * Helper function to load account to msal-browser cache
	     * @param idToken
	     * @param environment
	     * @param clientInfo
	     * @param authorityType
	     * @param requestHomeAccountId
	     * @returns `AccountEntity`
	     */
	    TokenCache.prototype.loadAccount = function (idToken, environment, clientInfo, authorityType, requestHomeAccountId) {
	        var homeAccountId;
	        if (requestHomeAccountId) {
	            homeAccountId = requestHomeAccountId;
	        }
	        else if (authorityType !== undefined && clientInfo) {
	            homeAccountId = AccountEntity.generateHomeAccountId(clientInfo, authorityType, this.logger, this.cryptoObj, idToken);
	        }
	        if (!homeAccountId) {
	            throw BrowserAuthError.createUnableToLoadTokenError("Unexpected missing homeAccountId");
	        }
	        var accountEntity = clientInfo ?
	            AccountEntity.createAccount(clientInfo, homeAccountId, idToken, undefined, undefined, undefined, environment) :
	            AccountEntity.createGenericAccount(homeAccountId, idToken, undefined, undefined, undefined, environment);
	        if (this.isBrowserEnvironment) {
	            this.logger.verbose("TokenCache - loading account");
	            this.storage.setAccount(accountEntity);
	            return accountEntity;
	        }
	        else {
	            throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
	        }
	    };
	    /**
	     * Helper function to load id tokens to msal-browser cache
	     * @param idToken
	     * @param homeAccountId
	     * @param environment
	     * @param tenantId
	     * @returns `IdTokenEntity`
	     */
	    TokenCache.prototype.loadIdToken = function (idToken, homeAccountId, environment, tenantId) {
	        var idTokenEntity = IdTokenEntity.createIdTokenEntity(homeAccountId, environment, idToken.rawToken, this.config.auth.clientId, tenantId);
	        if (this.isBrowserEnvironment) {
	            this.logger.verbose("TokenCache - loading id token");
	            this.storage.setIdTokenCredential(idTokenEntity);
	            return idTokenEntity;
	        }
	        else {
	            throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
	        }
	    };
	    /**
	     * Helper function to load access tokens to msal-browser cache
	     * @param request
	     * @param response
	     * @param homeAccountId
	     * @param environment
	     * @param tenantId
	     * @returns `AccessTokenEntity`
	     */
	    TokenCache.prototype.loadAccessToken = function (request, response, homeAccountId, environment, tenantId, options) {
	        if (!response.access_token) {
	            this.logger.verbose("TokenCache - No access token provided for caching");
	            return null;
	        }
	        if (!response.expires_in) {
	            throw BrowserAuthError.createUnableToLoadTokenError("Please ensure server response includes expires_in value.");
	        }
	        if (!options.extendedExpiresOn) {
	            throw BrowserAuthError.createUnableToLoadTokenError("Please provide an extendedExpiresOn value in the options.");
	        }
	        var scopes = new ScopeSet(request.scopes).printScopes();
	        var expiresOn = options.expiresOn || (response.expires_in + new Date().getTime() / 1000);
	        var extendedExpiresOn = options.extendedExpiresOn;
	        var accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(homeAccountId, environment, response.access_token, this.config.auth.clientId, tenantId, scopes, expiresOn, extendedExpiresOn, this.cryptoObj);
	        if (this.isBrowserEnvironment) {
	            this.logger.verbose("TokenCache - loading access token");
	            this.storage.setAccessTokenCredential(accessTokenEntity);
	            return accessTokenEntity;
	        }
	        else {
	            throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
	        }
	    };
	    /**
	     * Helper function to load refresh tokens to msal-browser cache
	     * @param request
	     * @param response
	     * @param homeAccountId
	     * @param environment
	     * @returns `RefreshTokenEntity`
	     */
	    TokenCache.prototype.loadRefreshToken = function (request, response, homeAccountId, environment) {
	        if (!response.refresh_token) {
	            this.logger.verbose("TokenCache - No refresh token provided for caching");
	            return null;
	        }
	        var refreshTokenEntity = RefreshTokenEntity.createRefreshTokenEntity(homeAccountId, environment, response.refresh_token, this.config.auth.clientId);
	        if (this.isBrowserEnvironment) {
	            this.logger.verbose("TokenCache - loading refresh token");
	            this.storage.setRefreshTokenCredential(refreshTokenEntity);
	            return refreshTokenEntity;
	        }
	        else {
	            throw BrowserAuthError.createUnableToLoadTokenError("loadExternalTokens is designed to work in browser environments only.");
	        }
	    };
	    /**
	     * Helper function to generate an `AuthenticationResult` for the result.
	     * @param request
	     * @param idTokenObj
	     * @param cacheRecord
	     * @param authority
	     * @returns `AuthenticationResult`
	     */
	    TokenCache.prototype.generateAuthenticationResult = function (request, idTokenObj, cacheRecord, authority) {
	        var _a, _b, _c;
	        var accessToken = Constants.EMPTY_STRING;
	        var responseScopes = [];
	        var expiresOn = null;
	        var extExpiresOn;
	        if (cacheRecord === null || cacheRecord === void 0 ? void 0 : cacheRecord.accessToken) {
	            accessToken = cacheRecord.accessToken.secret;
	            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
	            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);
	            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);
	        }
	        var uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;
	        var tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;
	        return {
	            authority: authority ? authority.canonicalAuthority : Constants.EMPTY_STRING,
	            uniqueId: uid,
	            tenantId: tid,
	            scopes: responseScopes,
	            account: (cacheRecord === null || cacheRecord === void 0 ? void 0 : cacheRecord.account) ? cacheRecord.account.getAccountInfo() : null,
	            idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,
	            idTokenClaims: idTokenObj ? idTokenObj.claims : {},
	            accessToken: accessToken,
	            fromCache: true,
	            expiresOn: expiresOn,
	            correlationId: request.correlationId || Constants.EMPTY_STRING,
	            requestId: Constants.EMPTY_STRING,
	            extExpiresOn: extExpiresOn,
	            familyId: Constants.EMPTY_STRING,
	            tokenType: ((_a = cacheRecord === null || cacheRecord === void 0 ? void 0 : cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,
	            state: Constants.EMPTY_STRING,
	            cloudGraphHostName: ((_b = cacheRecord === null || cacheRecord === void 0 ? void 0 : cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,
	            msGraphHost: ((_c = cacheRecord === null || cacheRecord === void 0 ? void 0 : cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,
	            code: undefined,
	            fromNativeBroker: false
	        };
	    };
	    return TokenCache;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var HybridSpaAuthorizationCodeClient = /** @class */ (function (_super) {
	    __extends$g(HybridSpaAuthorizationCodeClient, _super);
	    function HybridSpaAuthorizationCodeClient(config) {
	        var _this = _super.call(this, config) || this;
	        _this.includeRedirectUri = false;
	        return _this;
	    }
	    return HybridSpaAuthorizationCodeClient;
	}(AuthorizationCodeClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var SilentAuthCodeClient = /** @class */ (function (_super) {
	    __extends$g(SilentAuthCodeClient, _super);
	    function SilentAuthCodeClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, nativeMessageHandler, correlationId) {
	        var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) || this;
	        _this.apiId = apiId;
	        return _this;
	    }
	    /**
	     * Acquires a token silently by redeeming an authorization code against the /token endpoint
	     * @param request
	     */
	    SilentAuthCodeClient.prototype.acquireToken = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var silentRequest, serverTelemetryManager, authCodeRequest, clientConfig, authClient, silentHandler, e_1;
	            return __generator$3(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        this.logger.trace("SilentAuthCodeClient.acquireToken called");
	                        // Auth code payload is required
	                        if (!request.code) {
	                            throw BrowserAuthError.createAuthCodeRequiredError();
	                        }
	                        // Create silent request
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);
	                        return [4 /*yield*/, this.initializeAuthorizationRequest(request, InteractionType.Silent)];
	                    case 1:
	                        silentRequest = _a.sent();
	                        this.browserStorage.updateCacheEntries(silentRequest.state, silentRequest.nonce, silentRequest.authority, silentRequest.loginHint || Constants.EMPTY_STRING, silentRequest.account || null);
	                        serverTelemetryManager = this.initializeServerTelemetryManager(this.apiId);
	                        _a.label = 2;
	                    case 2:
	                        _a.trys.push([2, 4, , 5]);
	                        authCodeRequest = __assign$5(__assign$5({}, silentRequest), { code: request.code });
	                        // Initialize the client
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, request.correlationId);
	                        return [4 /*yield*/, this.getClientConfiguration(serverTelemetryManager, silentRequest.authority)];
	                    case 3:
	                        clientConfig = _a.sent();
	                        authClient = new HybridSpaAuthorizationCodeClient(clientConfig);
	                        this.logger.verbose("Auth code client created");
	                        silentHandler = new SilentHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.config.system, this.performanceClient);
	                        // Handle auth code parameters from request
	                        return [2 /*return*/, silentHandler.handleCodeResponseFromServer({
	                                code: request.code,
	                                msgraph_host: request.msGraphHost,
	                                cloud_graph_host_name: request.cloudGraphHostName,
	                                cloud_instance_host_name: request.cloudInstanceHostName
	                            }, silentRequest.state, authClient.authority, this.networkClient, false)];
	                    case 4:
	                        e_1 = _a.sent();
	                        if (e_1 instanceof AuthError) {
	                            e_1.setCorrelationId(this.correlationId);
	                        }
	                        serverTelemetryManager.cacheFailedRequest(e_1);
	                        this.browserStorage.cleanRequestByState(silentRequest.state);
	                        throw e_1;
	                    case 5: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Currently Unsupported
	     */
	    SilentAuthCodeClient.prototype.logout = function () {
	        // Synchronous so we must reject
	        return Promise.reject(BrowserAuthError.createSilentLogoutUnsupportedError());
	    };
	    return SilentAuthCodeClient;
	}(StandardInteractionClient));

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	var ClientApplication = /** @class */ (function () {
	    /**
	     * @constructor
	     * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object
	     *
	     * Important attributes in the Configuration object for auth are:
	     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
	     * - authority: the authority URL for your application.
	     * - redirect_uri: the uri of your application registered in the portal.
	     *
	     * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
	     * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
	     * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
	     * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
	     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
	     * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
	     *
	     * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
	     * Full B2C functionality will be available in this library in future versions.
	     *
	     * @param configuration Object for the MSAL PublicClientApplication instance
	     */
	    function ClientApplication(configuration) {
	        /*
	         * If loaded in an environment where window is not available,
	         * set internal flag to false so that further requests fail.
	         * This is to support server-side rendering environments.
	         */
	        this.isBrowserEnvironment = typeof window !== "undefined";
	        // Set the configuration.
	        this.config = buildConfiguration(configuration, this.isBrowserEnvironment);
	        this.initialized = false;
	        // Initialize logger
	        this.logger = new Logger(this.config.system.loggerOptions, name, version);
	        // Initialize the network module class.
	        this.networkClient = this.config.system.networkClient;
	        // Initialize the navigation client class.
	        this.navigationClient = this.config.system.navigationClient;
	        // Initialize redirectResponse Map
	        this.redirectResponse = new Map();
	        // Initial hybrid spa map
	        this.hybridAuthCodeResponses = new Map();
	        // Initialize performance client
	        this.performanceClient = this.isBrowserEnvironment ?
	            new BrowserPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name, version, this.config.telemetry.application, this.config.system.cryptoOptions) :
	            new StubPerformanceClient(this.config.auth.clientId, this.config.auth.authority, this.logger, name, version, this.config.telemetry.application);
	        // Initialize the crypto class.
	        this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps(this.logger, this.performanceClient, this.config.system.cryptoOptions) : DEFAULT_CRYPTO_IMPLEMENTATION;
	        this.eventHandler = new EventHandler(this.logger, this.browserCrypto);
	        // Initialize the browser storage class.
	        this.browserStorage = this.isBrowserEnvironment ?
	            new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) :
	            DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger);
	        // initialize in memory storage for native flows
	        var nativeCacheOptions = {
	            cacheLocation: BrowserCacheLocation.MemoryStorage,
	            temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,
	            storeAuthStateInCookie: false,
	            secureCookies: false,
	            cacheMigrationEnabled: false,
	            claimsBasedCachingEnabled: true
	        };
	        this.nativeInternalStorage = new BrowserCacheManager(this.config.auth.clientId, nativeCacheOptions, this.browserCrypto, this.logger);
	        // Initialize the token cache
	        this.tokenCache = new TokenCache(this.config, this.browserStorage, this.logger, this.browserCrypto);
	        // Register listener functions
	        this.trackPageVisibilityWithMeasurement = this.trackPageVisibilityWithMeasurement.bind(this);
	    }
	    /**
	     * Initializer function to perform async startup tasks such as connecting to WAM extension
	     */
	    ClientApplication.prototype.initialize = function () {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var allowNativeBroker, initMeasurement, _a, e_1, claimsTokensRemovalMeasurement;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.logger.trace("initialize called");
	                        if (this.initialized) {
	                            this.logger.info("initialize has already been called, exiting early.");
	                            return [2 /*return*/];
	                        }
	                        allowNativeBroker = this.config.system.allowNativeBroker;
	                        initMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.InitializeClientApplication);
	                        this.eventHandler.emitEvent(EventType.INITIALIZE_START);
	                        if (!allowNativeBroker) return [3 /*break*/, 4];
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 3, , 4]);
	                        _a = this;
	                        return [4 /*yield*/, NativeMessageHandler.createProvider(this.logger, this.config.system.nativeBrokerHandshakeTimeout, this.performanceClient)];
	                    case 2:
	                        _a.nativeExtensionProvider = _b.sent();
	                        return [3 /*break*/, 4];
	                    case 3:
	                        e_1 = _b.sent();
	                        this.logger.verbose(e_1);
	                        return [3 /*break*/, 4];
	                    case 4:
	                        if (!!this.config.cache.claimsBasedCachingEnabled) return [3 /*break*/, 6];
	                        this.logger.verbose("Claims-based caching is disabled. Clearing the previous cache with claims");
	                        claimsTokensRemovalMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims);
	                        return [4 /*yield*/, this.browserStorage.clearTokensAndKeysWithClaims()];
	                    case 5:
	                        _b.sent();
	                        claimsTokensRemovalMeasurement.endMeasurement({ success: true });
	                        _b.label = 6;
	                    case 6:
	                        this.initialized = true;
	                        this.eventHandler.emitEvent(EventType.INITIALIZE_END);
	                        initMeasurement.endMeasurement({ allowNativeBroker: allowNativeBroker, success: true });
	                        return [2 /*return*/];
	                }
	            });
	        });
	    };
	    // #region Redirect Flow
	    /**
	     * Event handler function which allows users to fire events after the PublicClientApplication object
	     * has loaded during redirect flows. This should be invoked on all page loads involved in redirect
	     * auth flows.
	     * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.
	     * @returns Token response or null. If the return value is null, then no auth redirect was detected.
	     */
	    ClientApplication.prototype.handleRedirectPromise = function (hash) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var loggedInAccounts, redirectResponseKey, response, request, redirectResponse, nativeClient, correlationId, redirectClient;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                this.logger.verbose("handleRedirectPromise called");
	                // Block token acquisition before initialize has been called if native brokering is enabled
	                BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized);
	                loggedInAccounts = this.getAllAccounts();
	                if (this.isBrowserEnvironment) {
	                    redirectResponseKey = hash || Constants.EMPTY_STRING;
	                    response = this.redirectResponse.get(redirectResponseKey);
	                    if (typeof response === "undefined") {
	                        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect);
	                        this.logger.verbose("handleRedirectPromise has been called for the first time, storing the promise");
	                        request = this.browserStorage.getCachedNativeRequest();
	                        redirectResponse = void 0;
	                        if (request && NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider) && this.nativeExtensionProvider && !hash) {
	                            this.logger.trace("handleRedirectPromise - acquiring token from native platform");
	                            nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.handleRedirectPromise, this.performanceClient, this.nativeExtensionProvider, request.accountId, this.nativeInternalStorage, request.correlationId);
	                            redirectResponse = nativeClient.handleRedirectPromise();
	                        }
	                        else {
	                            this.logger.trace("handleRedirectPromise - acquiring token from web flow");
	                            correlationId = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, true) || Constants.EMPTY_STRING;
	                            redirectClient = this.createRedirectClient(correlationId);
	                            redirectResponse = redirectClient.handleRedirectPromise(hash);
	                        }
	                        response = redirectResponse.then(function (result) {
	                            if (result) {
	                                // Emit login event if number of accounts change
	                                var isLoggingIn = loggedInAccounts.length < _this.getAllAccounts().length;
	                                if (isLoggingIn) {
	                                    _this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, result);
	                                    _this.logger.verbose("handleRedirectResponse returned result, login success");
	                                }
	                                else {
	                                    _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, result);
	                                    _this.logger.verbose("handleRedirectResponse returned result, acquire token success");
	                                }
	                            }
	                            _this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);
	                            return result;
	                        }).catch(function (e) {
	                            // Emit login event if there is an account
	                            if (loggedInAccounts.length > 0) {
	                                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);
	                            }
	                            else {
	                                _this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);
	                            }
	                            _this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);
	                            throw e;
	                        });
	                        this.redirectResponse.set(redirectResponseKey, response);
	                    }
	                    else {
	                        this.logger.verbose("handleRedirectPromise has been called previously, returning the result from the first call");
	                    }
	                    return [2 /*return*/, response];
	                }
	                this.logger.verbose("handleRedirectPromise returns null, not browser environment");
	                return [2 /*return*/, null];
	            });
	        });
	    };
	    /**
	     * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects
	     * the page, so any code that follows this function will not execute.
	     *
	     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
	     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
	     *
	     * @param request
	     */
	    ClientApplication.prototype.acquireTokenRedirect = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var correlationId, isLoggedIn, result, nativeClient, redirectClient;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                correlationId = this.getRequestCorrelationId(request);
	                this.logger.verbose("acquireTokenRedirect called", correlationId);
	                this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);
	                isLoggedIn = this.getAllAccounts().length > 0;
	                if (isLoggedIn) {
	                    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, request);
	                }
	                else {
	                    this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, request);
	                }
	                if (this.nativeExtensionProvider && this.canUseNative(request)) {
	                    nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenRedirect, this.performanceClient, this.nativeExtensionProvider, this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);
	                    result = nativeClient.acquireTokenRedirect(request).catch(function (e) {
	                        if (e instanceof NativeAuthError && e.isFatal()) {
	                            _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt
	                            var redirectClient = _this.createRedirectClient(request.correlationId);
	                            return redirectClient.acquireToken(request);
	                        }
	                        else if (e instanceof InteractionRequiredAuthError) {
	                            _this.logger.verbose("acquireTokenRedirect - Resolving interaction required error thrown by native broker by falling back to web flow");
	                            var redirectClient = _this.createRedirectClient(request.correlationId);
	                            return redirectClient.acquireToken(request);
	                        }
	                        _this.browserStorage.setInteractionInProgress(false);
	                        throw e;
	                    });
	                }
	                else {
	                    redirectClient = this.createRedirectClient(request.correlationId);
	                    result = redirectClient.acquireToken(request);
	                }
	                return [2 /*return*/, result.catch(function (e) {
	                        // If logged in, emit acquire token events
	                        if (isLoggedIn) {
	                            _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);
	                        }
	                        else {
	                            _this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);
	                        }
	                        throw e;
	                    })];
	            });
	        });
	    };
	    // #endregion
	    // #region Popup Flow
	    /**
	     * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser
	     *
	     * @param request
	     *
	     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
	     */
	    ClientApplication.prototype.acquireTokenPopup = function (request) {
	        var _this = this;
	        var correlationId = this.getRequestCorrelationId(request);
	        var atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, correlationId);
	        try {
	            this.logger.verbose("acquireTokenPopup called", correlationId);
	            this.preflightBrowserEnvironmentCheck(InteractionType.Popup);
	        }
	        catch (e) {
	            // Since this function is syncronous we need to reject
	            return Promise.reject(e);
	        }
	        // If logged in, emit acquire token events
	        var loggedInAccounts = this.getAllAccounts();
	        if (loggedInAccounts.length > 0) {
	            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, request);
	        }
	        else {
	            this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, request);
	        }
	        var result;
	        if (this.canUseNative(request)) {
	            result = this.acquireTokenNative(request, ApiId.acquireTokenPopup).then(function (response) {
	                _this.browserStorage.setInteractionInProgress(false);
	                atPopupMeasurement.endMeasurement({
	                    success: true,
	                    isNativeBroker: true,
	                    requestId: response.requestId
	                });
	                return response;
	            }).catch(function (e) {
	                if (e instanceof NativeAuthError && e.isFatal()) {
	                    _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt
	                    var popupClient = _this.createPopupClient(request.correlationId);
	                    return popupClient.acquireToken(request);
	                }
	                else if (e instanceof InteractionRequiredAuthError) {
	                    _this.logger.verbose("acquireTokenPopup - Resolving interaction required error thrown by native broker by falling back to web flow");
	                    var popupClient = _this.createPopupClient(request.correlationId);
	                    return popupClient.acquireToken(request);
	                }
	                _this.browserStorage.setInteractionInProgress(false);
	                throw e;
	            });
	        }
	        else {
	            var popupClient = this.createPopupClient(request.correlationId);
	            result = popupClient.acquireToken(request);
	        }
	        return result.then(function (result) {
	            /*
	             *  If logged in, emit acquire token events
	             */
	            var isLoggingIn = loggedInAccounts.length < _this.getAllAccounts().length;
	            if (isLoggingIn) {
	                _this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, result);
	            }
	            else {
	                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);
	            }
	            atPopupMeasurement.addStaticFields({
	                accessTokenSize: result.accessToken.length,
	                idTokenSize: result.idToken.length
	            });
	            atPopupMeasurement.endMeasurement({
	                success: true,
	                requestId: result.requestId
	            });
	            return result;
	        }).catch(function (e) {
	            if (loggedInAccounts.length > 0) {
	                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);
	            }
	            else {
	                _this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e);
	            }
	            atPopupMeasurement.endMeasurement({
	                errorCode: e.errorCode,
	                subErrorCode: e.subError,
	                success: false
	            });
	            // Since this function is syncronous we need to reject
	            return Promise.reject(e);
	        });
	    };
	    ClientApplication.prototype.trackPageVisibilityWithMeasurement = function () {
	        var measurement = this.ssoSilentMeasurement || this.acquireTokenByCodeAsyncMeasurement;
	        if (!measurement) {
	            return;
	        }
	        this.logger.info("Perf: Visibility change detected in ", measurement.event.name);
	        measurement.increment({
	            visibilityChangeCount: 1,
	        });
	    };
	    // #endregion
	    // #region Silent Flow
	    /**
	     * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:
	     * - Any browser using a form of Intelligent Tracking Prevention
	     * - If there is not an established session with the service
	     *
	     * In these cases, the request must be done inside a popup or full frame redirect.
	     *
	     * For the cases where interaction is required, you cannot send a request with prompt=none.
	     *
	     * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as
	     * you session on the server still exists.
	     * @param request {@link SsoSilentRequest}
	     *
	     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
	     */
	    ClientApplication.prototype.ssoSilent = function (request) {
	        var _a;
	        return __awaiter$3(this, void 0, void 0, function () {
	            var correlationId, validRequest, result, silentIframeClient;
	            var _this = this;
	            return __generator$3(this, function (_b) {
	                correlationId = this.getRequestCorrelationId(request);
	                validRequest = __assign$5(__assign$5({}, request), { 
	                    // will be PromptValue.NONE or PromptValue.NO_SESSION
	                    prompt: request.prompt, correlationId: correlationId });
	                this.preflightBrowserEnvironmentCheck(InteractionType.Silent);
	                this.ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, correlationId);
	                (_a = this.ssoSilentMeasurement) === null || _a === void 0 ? void 0 : _a.increment({
	                    visibilityChangeCount: 0
	                });
	                document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
	                this.logger.verbose("ssoSilent called", correlationId);
	                this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, validRequest);
	                if (this.canUseNative(validRequest)) {
	                    result = this.acquireTokenNative(validRequest, ApiId.ssoSilent).catch(function (e) {
	                        // If native token acquisition fails for availability reasons fallback to standard flow
	                        if (e instanceof NativeAuthError && e.isFatal()) {
	                            _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt
	                            var silentIframeClient = _this.createSilentIframeClient(validRequest.correlationId);
	                            return silentIframeClient.acquireToken(validRequest);
	                        }
	                        throw e;
	                    });
	                }
	                else {
	                    silentIframeClient = this.createSilentIframeClient(validRequest.correlationId);
	                    result = silentIframeClient.acquireToken(validRequest);
	                }
	                return [2 /*return*/, result.then(function (response) {
	                        var _a, _b;
	                        _this.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, response);
	                        (_a = _this.ssoSilentMeasurement) === null || _a === void 0 ? void 0 : _a.addStaticFields({
	                            accessTokenSize: response.accessToken.length,
	                            idTokenSize: response.idToken.length
	                        });
	                        (_b = _this.ssoSilentMeasurement) === null || _b === void 0 ? void 0 : _b.endMeasurement({
	                            success: true,
	                            isNativeBroker: response.fromNativeBroker,
	                            requestId: response.requestId
	                        });
	                        return response;
	                    }).catch(function (e) {
	                        var _a;
	                        _this.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e);
	                        (_a = _this.ssoSilentMeasurement) === null || _a === void 0 ? void 0 : _a.endMeasurement({
	                            errorCode: e.errorCode,
	                            subErrorCode: e.subError,
	                            success: false
	                        });
	                        throw e;
	                    }).finally(function () {
	                        document.removeEventListener("visibilitychange", _this.trackPageVisibilityWithMeasurement);
	                    })];
	            });
	        });
	    };
	    /**
	     * This function redeems an authorization code (passed as code) from the eSTS token endpoint.
	     * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.
	     * This API is not indended for normal authorization code acquisition and redemption.
	     *
	     * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.
	     *
	     * @param request {@link AuthorizationCodeRequest}
	     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
	     */
	    ClientApplication.prototype.acquireTokenByCode = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var correlationId, atbcMeasurement, hybridAuthCode_1, response;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                correlationId = this.getRequestCorrelationId(request);
	                this.preflightBrowserEnvironmentCheck(InteractionType.Silent);
	                this.logger.trace("acquireTokenByCode called", correlationId);
	                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_START, InteractionType.Silent, request);
	                atbcMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCode, request.correlationId);
	                try {
	                    if (request.code && request.nativeAccountId) {
	                        // Throw error in case server returns both spa_code and spa_accountid in exchange for auth code.
	                        throw BrowserAuthError.createSpaCodeAndNativeAccountIdPresentError();
	                    }
	                    else if (request.code) {
	                        hybridAuthCode_1 = request.code;
	                        response = this.hybridAuthCodeResponses.get(hybridAuthCode_1);
	                        if (!response) {
	                            this.logger.verbose("Initiating new acquireTokenByCode request", correlationId);
	                            response = this.acquireTokenByCodeAsync(__assign$5(__assign$5({}, request), { correlationId: correlationId }))
	                                .then(function (result) {
	                                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_SUCCESS, InteractionType.Silent, result);
	                                _this.hybridAuthCodeResponses.delete(hybridAuthCode_1);
	                                atbcMeasurement.addStaticFields({
	                                    accessTokenSize: result.accessToken.length,
	                                    idTokenSize: result.idToken.length
	                                });
	                                atbcMeasurement.endMeasurement({
	                                    success: true,
	                                    isNativeBroker: result.fromNativeBroker,
	                                    requestId: result.requestId
	                                });
	                                return result;
	                            })
	                                .catch(function (error) {
	                                _this.hybridAuthCodeResponses.delete(hybridAuthCode_1);
	                                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, error);
	                                atbcMeasurement.endMeasurement({
	                                    errorCode: error.errorCode,
	                                    subErrorCode: error.subError,
	                                    success: false
	                                });
	                                throw error;
	                            });
	                            this.hybridAuthCodeResponses.set(hybridAuthCode_1, response);
	                        }
	                        else {
	                            this.logger.verbose("Existing acquireTokenByCode request found", request.correlationId);
	                            atbcMeasurement.discardMeasurement();
	                        }
	                        return [2 /*return*/, response];
	                    }
	                    else if (request.nativeAccountId) {
	                        if (this.canUseNative(request, request.nativeAccountId)) {
	                            return [2 /*return*/, this.acquireTokenNative(request, ApiId.acquireTokenByCode, request.nativeAccountId).catch(function (e) {
	                                    // If native token acquisition fails for availability reasons fallback to standard flow
	                                    if (e instanceof NativeAuthError && e.isFatal()) {
	                                        _this.nativeExtensionProvider = undefined; // If extension gets uninstalled during session prevent future requests from continuing to attempt
	                                    }
	                                    throw e;
	                                })];
	                        }
	                        else {
	                            throw BrowserAuthError.createUnableToAcquireTokenFromNativePlatformError();
	                        }
	                    }
	                    else {
	                        throw BrowserAuthError.createAuthCodeOrNativeAccountIdRequiredError();
	                    }
	                }
	                catch (e) {
	                    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_BY_CODE_FAILURE, InteractionType.Silent, null, e);
	                    atbcMeasurement.endMeasurement({
	                        errorCode: e instanceof AuthError && e.errorCode || undefined,
	                        subErrorCode: e instanceof AuthError && e.subError || undefined,
	                        success: false
	                    });
	                    throw e;
	                }
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Creates a SilentAuthCodeClient to redeem an authorization code.
	     * @param request
	     * @returns Result of the operation to redeem the authorization code
	     */
	    ClientApplication.prototype.acquireTokenByCodeAsync = function (request) {
	        var _a;
	        return __awaiter$3(this, void 0, void 0, function () {
	            var silentAuthCodeClient, silentTokenResult;
	            var _this = this;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.logger.trace("acquireTokenByCodeAsync called", request.correlationId);
	                        this.acquireTokenByCodeAsyncMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenByCodeAsync, request.correlationId);
	                        (_a = this.acquireTokenByCodeAsyncMeasurement) === null || _a === void 0 ? void 0 : _a.increment({
	                            visibilityChangeCount: 0
	                        });
	                        document.addEventListener("visibilitychange", this.trackPageVisibilityWithMeasurement);
	                        silentAuthCodeClient = this.createSilentAuthCodeClient(request.correlationId);
	                        return [4 /*yield*/, silentAuthCodeClient.acquireToken(request).then(function (response) {
	                                var _a;
	                                (_a = _this.acquireTokenByCodeAsyncMeasurement) === null || _a === void 0 ? void 0 : _a.endMeasurement({
	                                    success: true,
	                                    fromCache: response.fromCache,
	                                    isNativeBroker: response.fromNativeBroker,
	                                    requestId: response.requestId
	                                });
	                                return response;
	                            }).catch(function (tokenRenewalError) {
	                                var _a;
	                                (_a = _this.acquireTokenByCodeAsyncMeasurement) === null || _a === void 0 ? void 0 : _a.endMeasurement({
	                                    errorCode: tokenRenewalError.errorCode,
	                                    subErrorCode: tokenRenewalError.subError,
	                                    success: false
	                                });
	                                throw tokenRenewalError;
	                            }).finally(function () {
	                                document.removeEventListener("visibilitychange", _this.trackPageVisibilityWithMeasurement);
	                            })];
	                    case 1:
	                        silentTokenResult = _b.sent();
	                        return [2 /*return*/, silentTokenResult];
	                }
	            });
	        });
	    };
	    /**
	     * Attempt to acquire an access token from the cache
	     * @param silentCacheClient SilentCacheClient
	     * @param commonRequest CommonSilentFlowRequest
	     * @param silentRequest SilentRequest
	     * @returns A promise that, when resolved, returns the access token
	     */
	    ClientApplication.prototype.acquireTokenFromCache = function (silentCacheClient, commonRequest, silentRequest) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenFromCache, commonRequest.correlationId);
	                switch (silentRequest.cacheLookupPolicy) {
	                    case CacheLookupPolicy.Default:
	                    case CacheLookupPolicy.AccessToken:
	                    case CacheLookupPolicy.AccessTokenAndRefreshToken:
	                        return [2 /*return*/, silentCacheClient.acquireToken(commonRequest)];
	                    default:
	                        throw ClientAuthError.createRefreshRequiredError();
	                }
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Attempt to acquire an access token via a refresh token
	     * @param commonRequest CommonSilentFlowRequest
	     * @param silentRequest SilentRequest
	     * @returns A promise that, when resolved, returns the access token
	     */
	    ClientApplication.prototype.acquireTokenByRefreshToken = function (commonRequest, silentRequest) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var silentRefreshClient;
	            return __generator$3(this, function (_a) {
	                this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenByRefreshToken, commonRequest.correlationId);
	                switch (silentRequest.cacheLookupPolicy) {
	                    case CacheLookupPolicy.Default:
	                    case CacheLookupPolicy.AccessTokenAndRefreshToken:
	                    case CacheLookupPolicy.RefreshToken:
	                    case CacheLookupPolicy.RefreshTokenAndNetwork:
	                        silentRefreshClient = this.createSilentRefreshClient(commonRequest.correlationId);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.SilentRefreshClientAcquireToken, commonRequest.correlationId);
	                        return [2 /*return*/, silentRefreshClient.acquireToken(commonRequest)];
	                    default:
	                        throw ClientAuthError.createRefreshRequiredError();
	                }
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Attempt to acquire an access token via an iframe
	     * @param request CommonSilentFlowRequest
	     * @returns A promise that, when resolved, returns the access token
	     */
	    ClientApplication.prototype.acquireTokenBySilentIframe = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var silentIframeClient;
	            return __generator$3(this, function (_a) {
	                this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenBySilentIframe, request.correlationId);
	                silentIframeClient = this.createSilentIframeClient(request.correlationId);
	                this.performanceClient.setPreQueueTime(PerformanceEvents.SilentIframeClientAcquireToken, request.correlationId);
	                return [2 /*return*/, silentIframeClient.acquireToken(request)];
	            });
	        });
	    };
	    // #endregion
	    // #region Logout
	    /**
	     * Deprecated logout function. Use logoutRedirect or logoutPopup instead
	     * @param logoutRequest
	     * @deprecated
	     */
	    ClientApplication.prototype.logout = function (logoutRequest) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var correlationId;
	            return __generator$3(this, function (_a) {
	                correlationId = this.getRequestCorrelationId(logoutRequest);
	                this.logger.warning("logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.", correlationId);
	                return [2 /*return*/, this.logoutRedirect(__assign$5({ correlationId: correlationId }, logoutRequest))];
	            });
	        });
	    };
	    /**
	     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
	     * Default behaviour is to redirect the user to `window.location.href`.
	     * @param logoutRequest
	     */
	    ClientApplication.prototype.logoutRedirect = function (logoutRequest) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var correlationId, redirectClient;
	            return __generator$3(this, function (_a) {
	                correlationId = this.getRequestCorrelationId(logoutRequest);
	                this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);
	                redirectClient = this.createRedirectClient(correlationId);
	                return [2 /*return*/, redirectClient.logout(logoutRequest)];
	            });
	        });
	    };
	    /**
	     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
	     * @param logoutRequest
	     */
	    ClientApplication.prototype.logoutPopup = function (logoutRequest) {
	        try {
	            var correlationId = this.getRequestCorrelationId(logoutRequest);
	            this.preflightBrowserEnvironmentCheck(InteractionType.Popup);
	            var popupClient = this.createPopupClient(correlationId);
	            return popupClient.logout(logoutRequest);
	        }
	        catch (e) {
	            // Since this function is syncronous we need to reject
	            return Promise.reject(e);
	        }
	    };
	    // #endregion
	    // #region Account APIs
	    /**
	     * Returns all accounts that MSAL currently has data for.
	     * (the account object is created at the time of successful login)
	     * or empty array when no accounts are found
	     * @returns Array of account objects in cache
	     */
	    ClientApplication.prototype.getAllAccounts = function () {
	        this.logger.verbose("getAllAccounts called");
	        return this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : [];
	    };
	    /**
	     * Returns the signed in account matching username.
	     * (the account object is created at the time of successful login)
	     * or null when no matching account is found.
	     * This API is provided for convenience but getAccountById should be used for best reliability
	     * @param username
	     * @returns The account object stored in MSAL
	     */
	    ClientApplication.prototype.getAccountByUsername = function (username) {
	        this.logger.trace("getAccountByUsername called");
	        if (!username) {
	            this.logger.warning("getAccountByUsername: No username provided");
	            return null;
	        }
	        var account = this.browserStorage.getAccountInfoFilteredBy({ username: username });
	        if (account) {
	            this.logger.verbose("getAccountByUsername: Account matching username found, returning");
	            this.logger.verbosePii("getAccountByUsername: Returning signed-in accounts matching username: " + username);
	            return account;
	        }
	        else {
	            this.logger.verbose("getAccountByUsername: No matching account found, returning null");
	            return null;
	        }
	    };
	    /**
	     * Returns the signed in account matching homeAccountId.
	     * (the account object is created at the time of successful login)
	     * or null when no matching account is found
	     * @param homeAccountId
	     * @returns The account object stored in MSAL
	     */
	    ClientApplication.prototype.getAccountByHomeId = function (homeAccountId) {
	        this.logger.trace("getAccountByHomeId called");
	        if (!homeAccountId) {
	            this.logger.warning("getAccountByHomeId: No homeAccountId provided");
	            return null;
	        }
	        var account = this.browserStorage.getAccountInfoFilteredBy({ homeAccountId: homeAccountId });
	        if (account) {
	            this.logger.verbose("getAccountByHomeId: Account matching homeAccountId found, returning");
	            this.logger.verbosePii("getAccountByHomeId: Returning signed-in accounts matching homeAccountId: " + homeAccountId);
	            return account;
	        }
	        else {
	            this.logger.verbose("getAccountByHomeId: No matching account found, returning null");
	            return null;
	        }
	    };
	    /**
	     * Returns the signed in account matching localAccountId.
	     * (the account object is created at the time of successful login)
	     * or null when no matching account is found
	     * @param localAccountId
	     * @returns The account object stored in MSAL
	     */
	    ClientApplication.prototype.getAccountByLocalId = function (localAccountId) {
	        this.logger.trace("getAccountByLocalId called");
	        if (!localAccountId) {
	            this.logger.warning("getAccountByLocalId: No localAccountId provided");
	            return null;
	        }
	        var account = this.browserStorage.getAccountInfoFilteredBy({ localAccountId: localAccountId });
	        if (account) {
	            this.logger.verbose("getAccountByLocalId: Account matching localAccountId found, returning");
	            this.logger.verbosePii("getAccountByLocalId: Returning signed-in accounts matching localAccountId: " + localAccountId);
	            return account;
	        }
	        else {
	            this.logger.verbose("getAccountByLocalId: No matching account found, returning null");
	            return null;
	        }
	    };
	    /**
	     * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
	     * @param account
	     */
	    ClientApplication.prototype.setActiveAccount = function (account) {
	        this.browserStorage.setActiveAccount(account);
	    };
	    /**
	     * Gets the currently active account
	     */
	    ClientApplication.prototype.getActiveAccount = function () {
	        return this.browserStorage.getActiveAccount();
	    };
	    // #endregion
	    // #region Helpers
	    /**
	     * Helper to validate app environment before making an auth request
	     *
	     * @protected
	     * @param {InteractionType} interactionType What kind of interaction is being used
	     * @param {boolean} [setInteractionInProgress=true] Whether to set interaction in progress temp cache flag
	     */
	    ClientApplication.prototype.preflightBrowserEnvironmentCheck = function (interactionType, setInteractionInProgress) {
	        if (setInteractionInProgress === void 0) { setInteractionInProgress = true; }
	        this.logger.verbose("preflightBrowserEnvironmentCheck started");
	        // Block request if not in browser environment
	        BrowserUtils.blockNonBrowserEnvironment(this.isBrowserEnvironment);
	        // Block redirects if in an iframe
	        BrowserUtils.blockRedirectInIframe(interactionType, this.config.system.allowRedirectInIframe);
	        // Block auth requests inside a hidden iframe
	        BrowserUtils.blockReloadInHiddenIframes();
	        // Block redirectUri opened in a popup from calling MSAL APIs
	        BrowserUtils.blockAcquireTokenInPopups();
	        // Block token acquisition before initialize has been called if native brokering is enabled
	        BrowserUtils.blockNativeBrokerCalledBeforeInitialized(this.config.system.allowNativeBroker, this.initialized);
	        // Block redirects if memory storage is enabled but storeAuthStateInCookie is not
	        if (interactionType === InteractionType.Redirect &&
	            this.config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage &&
	            !this.config.cache.storeAuthStateInCookie) {
	            throw BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError();
	        }
	        if (interactionType === InteractionType.Redirect || interactionType === InteractionType.Popup) {
	            this.preflightInteractiveRequest(setInteractionInProgress);
	        }
	    };
	    /**
	     * Preflight check for interactive requests
	     *
	     * @protected
	     * @param {boolean} setInteractionInProgress Whether to set interaction in progress temp cache flag
	     */
	    ClientApplication.prototype.preflightInteractiveRequest = function (setInteractionInProgress) {
	        this.logger.verbose("preflightInteractiveRequest called, validating app environment");
	        // block the reload if it occurred inside a hidden iframe
	        BrowserUtils.blockReloadInHiddenIframes();
	        // Set interaction in progress temporary cache or throw if alread set.
	        if (setInteractionInProgress) {
	            this.browserStorage.setInteractionInProgress(true);
	        }
	    };
	    /**
	     * Acquire a token from native device (e.g. WAM)
	     * @param request
	     */
	    ClientApplication.prototype.acquireTokenNative = function (request, apiId, accountId) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var nativeClient;
	            return __generator$3(this, function (_a) {
	                this.logger.trace("acquireTokenNative called");
	                if (!this.nativeExtensionProvider) {
	                    throw BrowserAuthError.createNativeConnectionNotEstablishedError();
	                }
	                nativeClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, apiId, this.performanceClient, this.nativeExtensionProvider, accountId || this.getNativeAccountId(request), this.nativeInternalStorage, request.correlationId);
	                return [2 /*return*/, nativeClient.acquireToken(request)];
	            });
	        });
	    };
	    /**
	     * Returns boolean indicating if this request can use the native broker
	     * @param request
	     */
	    ClientApplication.prototype.canUseNative = function (request, accountId) {
	        this.logger.trace("canUseNative called");
	        if (!NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, request.authenticationScheme)) {
	            this.logger.trace("canUseNative: isNativeAvailable returned false, returning false");
	            return false;
	        }
	        if (request.prompt) {
	            switch (request.prompt) {
	                case PromptValue.NONE:
	                case PromptValue.CONSENT:
	                case PromptValue.LOGIN:
	                    this.logger.trace("canUseNative: prompt is compatible with native flow");
	                    break;
	                default:
	                    this.logger.trace("canUseNative: prompt = " + request.prompt + " is not compatible with native flow, returning false");
	                    return false;
	            }
	        }
	        if (!accountId && !this.getNativeAccountId(request)) {
	            this.logger.trace("canUseNative: nativeAccountId is not available, returning false");
	            return false;
	        }
	        return true;
	    };
	    /**
	     * Get the native accountId from the account
	     * @param request
	     * @returns
	     */
	    ClientApplication.prototype.getNativeAccountId = function (request) {
	        var account = request.account || this.browserStorage.getAccountInfoByHints(request.loginHint, request.sid) || this.getActiveAccount();
	        return account && account.nativeAccountId || "";
	    };
	    /**
	     * Returns new instance of the Popup Interaction Client
	     * @param correlationId
	     */
	    ClientApplication.prototype.createPopupClient = function (correlationId) {
	        return new PopupClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);
	    };
	    /**
	     * Returns new instance of the Redirect Interaction Client
	     * @param correlationId
	     */
	    ClientApplication.prototype.createRedirectClient = function (correlationId) {
	        return new RedirectClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);
	    };
	    /**
	     * Returns new instance of the Silent Iframe Interaction Client
	     * @param correlationId
	     */
	    ClientApplication.prototype.createSilentIframeClient = function (correlationId) {
	        return new SilentIframeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.ssoSilent, this.performanceClient, this.nativeInternalStorage, this.nativeExtensionProvider, correlationId);
	    };
	    /**
	     * Returns new instance of the Silent Cache Interaction Client
	     */
	    ClientApplication.prototype.createSilentCacheClient = function (correlationId) {
	        return new SilentCacheClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);
	    };
	    /**
	     * Returns new instance of the Silent Refresh Interaction Client
	     */
	    ClientApplication.prototype.createSilentRefreshClient = function (correlationId) {
	        return new SilentRefreshClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, this.performanceClient, this.nativeExtensionProvider, correlationId);
	    };
	    /**
	     * Returns new instance of the Silent AuthCode Interaction Client
	     */
	    ClientApplication.prototype.createSilentAuthCodeClient = function (correlationId) {
	        return new SilentAuthCodeClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenByCode, this.performanceClient, this.nativeExtensionProvider, correlationId);
	    };
	    /**
	     * Adds event callbacks to array
	     * @param callback
	     */
	    ClientApplication.prototype.addEventCallback = function (callback) {
	        return this.eventHandler.addEventCallback(callback);
	    };
	    /**
	     * Removes callback with provided id from callback array
	     * @param callbackId
	     */
	    ClientApplication.prototype.removeEventCallback = function (callbackId) {
	        this.eventHandler.removeEventCallback(callbackId);
	    };
	    /**
	     * Registers a callback to receive performance events.
	     *
	     * @param {PerformanceCallbackFunction} callback
	     * @returns {string}
	     */
	    ClientApplication.prototype.addPerformanceCallback = function (callback) {
	        return this.performanceClient.addPerformanceCallback(callback);
	    };
	    /**
	     * Removes a callback registered with addPerformanceCallback.
	     *
	     * @param {string} callbackId
	     * @returns {boolean}
	     */
	    ClientApplication.prototype.removePerformanceCallback = function (callbackId) {
	        return this.performanceClient.removePerformanceCallback(callbackId);
	    };
	    /**
	     * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
	     */
	    ClientApplication.prototype.enableAccountStorageEvents = function () {
	        this.eventHandler.enableAccountStorageEvents();
	    };
	    /**
	     * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
	     */
	    ClientApplication.prototype.disableAccountStorageEvents = function () {
	        this.eventHandler.disableAccountStorageEvents();
	    };
	    /**
	     * Gets the token cache for the application.
	     */
	    ClientApplication.prototype.getTokenCache = function () {
	        return this.tokenCache;
	    };
	    /**
	     * Returns the logger instance
	     */
	    ClientApplication.prototype.getLogger = function () {
	        return this.logger;
	    };
	    /**
	     * Replaces the default logger set in configurations with new Logger with new configurations
	     * @param logger Logger instance
	     */
	    ClientApplication.prototype.setLogger = function (logger) {
	        this.logger = logger;
	    };
	    /**
	     * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.
	     * @param sku
	     * @param version
	     */
	    ClientApplication.prototype.initializeWrapperLibrary = function (sku, version) {
	        // Validate the SKU passed in is one we expect
	        this.browserStorage.setWrapperMetadata(sku, version);
	    };
	    /**
	     * Sets navigation client
	     * @param navigationClient
	     */
	    ClientApplication.prototype.setNavigationClient = function (navigationClient) {
	        this.navigationClient = navigationClient;
	    };
	    /**
	     * Returns the configuration object
	     */
	    ClientApplication.prototype.getConfiguration = function () {
	        return this.config;
	    };
	    /**
	     * Generates a correlation id for a request if none is provided.
	     *
	     * @protected
	     * @param {?Partial<BaseAuthRequest>} [request]
	     * @returns {string}
	     */
	    ClientApplication.prototype.getRequestCorrelationId = function (request) {
	        if (request === null || request === void 0 ? void 0 : request.correlationId) {
	            return request.correlationId;
	        }
	        if (this.isBrowserEnvironment) {
	            return this.browserCrypto.createNewGuid();
	        }
	        /*
	         * Included for fallback for non-browser environments,
	         * and to ensure this method always returns a string.
	         */
	        return Constants.EMPTY_STRING;
	    };
	    return ClientApplication;
	}());

	/*! @azure/msal-browser v2.38.3 2023-10-27 */

	/*
	 * Copyright (c) Microsoft Corporation. All rights reserved.
	 * Licensed under the MIT License.
	 */
	/**
	 * The PublicClientApplication class is the object exposed by the library to perform authentication and authorization functions in Single Page Applications
	 * to obtain JWT tokens as described in the OAuth 2.0 Authorization Code Flow with PKCE specification.
	 */
	var PublicClientApplication = /** @class */ (function (_super) {
	    __extends$g(PublicClientApplication, _super);
	    /**
	     * @constructor
	     * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object
	     *
	     * Important attributes in the Configuration object for auth are:
	     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
	     * - authority: the authority URL for your application.
	     * - redirect_uri: the uri of your application registered in the portal.
	     *
	     * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
	     * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
	     * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
	     * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
	     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
	     * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
	     *
	     * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
	     * Full B2C functionality will be available in this library in future versions.
	     *
	     * @param configuration object for the MSAL PublicClientApplication instance
	     */
	    function PublicClientApplication(configuration) {
	        var _this = _super.call(this, configuration) || this;
	        _this.astsAsyncMeasurement = undefined;
	        _this.activeSilentTokenRequests = new Map();
	        // Register listener functions
	        _this.trackPageVisibility = _this.trackPageVisibility.bind(_this);
	        return _this;
	    }
	    /**
	     * Use when initiating the login process by redirecting the user's browser to the authorization endpoint. This function redirects the page, so
	     * any code that follows this function will not execute.
	     *
	     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
	     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
	     *
	     * @param request
	     */
	    PublicClientApplication.prototype.loginRedirect = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var correlationId;
	            return __generator$3(this, function (_a) {
	                correlationId = this.getRequestCorrelationId(request);
	                this.logger.verbose("loginRedirect called", correlationId);
	                return [2 /*return*/, this.acquireTokenRedirect(__assign$5({ correlationId: correlationId }, (request || DEFAULT_REQUEST)))];
	            });
	        });
	    };
	    /**
	     * Use when initiating the login process via opening a popup window in the user's browser
	     *
	     * @param request
	     *
	     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
	     */
	    PublicClientApplication.prototype.loginPopup = function (request) {
	        var correlationId = this.getRequestCorrelationId(request);
	        this.logger.verbose("loginPopup called", correlationId);
	        return this.acquireTokenPopup(__assign$5({ correlationId: correlationId }, (request || DEFAULT_REQUEST)));
	    };
	    /**
	     * Silently acquire an access token for a given set of scopes. Returns currently processing promise if parallel requests are made.
	     *
	     * @param {@link (SilentRequest:type)}
	     * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse} object
	     */
	    PublicClientApplication.prototype.acquireTokenSilent = function (request) {
	        return __awaiter$3(this, void 0, void 0, function () {
	            var correlationId, atsMeasurement, account, thumbprint, silentRequestKey, cachedResponse, response;
	            var _this = this;
	            return __generator$3(this, function (_a) {
	                correlationId = this.getRequestCorrelationId(request);
	                atsMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilent, correlationId);
	                atsMeasurement.addStaticFields({
	                    cacheLookupPolicy: request.cacheLookupPolicy
	                });
	                this.preflightBrowserEnvironmentCheck(InteractionType.Silent);
	                this.logger.verbose("acquireTokenSilent called", correlationId);
	                account = request.account || this.getActiveAccount();
	                if (!account) {
	                    throw BrowserAuthError.createNoAccountError();
	                }
	                thumbprint = {
	                    clientId: this.config.auth.clientId,
	                    authority: request.authority || Constants.EMPTY_STRING,
	                    scopes: request.scopes,
	                    homeAccountIdentifier: account.homeAccountId,
	                    claims: request.claims,
	                    authenticationScheme: request.authenticationScheme,
	                    resourceRequestMethod: request.resourceRequestMethod,
	                    resourceRequestUri: request.resourceRequestUri,
	                    shrClaims: request.shrClaims,
	                    sshKid: request.sshKid
	                };
	                silentRequestKey = JSON.stringify(thumbprint);
	                cachedResponse = this.activeSilentTokenRequests.get(silentRequestKey);
	                if (typeof cachedResponse === "undefined") {
	                    this.logger.verbose("acquireTokenSilent called for the first time, storing active request", correlationId);
	                    this.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenSilentAsync, correlationId);
	                    response = this.acquireTokenSilentAsync(__assign$5(__assign$5({}, request), { correlationId: correlationId }), account)
	                        .then(function (result) {
	                        _this.activeSilentTokenRequests.delete(silentRequestKey);
	                        atsMeasurement.addStaticFields({
	                            accessTokenSize: result.accessToken.length,
	                            idTokenSize: result.idToken.length
	                        });
	                        atsMeasurement.endMeasurement({
	                            success: true,
	                            fromCache: result.fromCache,
	                            isNativeBroker: result.fromNativeBroker,
	                            cacheLookupPolicy: request.cacheLookupPolicy,
	                            requestId: result.requestId,
	                        });
	                        return result;
	                    })
	                        .catch(function (error) {
	                        _this.activeSilentTokenRequests.delete(silentRequestKey);
	                        atsMeasurement.endMeasurement({
	                            errorCode: error.errorCode,
	                            subErrorCode: error.subError,
	                            success: false
	                        });
	                        throw error;
	                    });
	                    this.activeSilentTokenRequests.set(silentRequestKey, response);
	                    return [2 /*return*/, response];
	                }
	                else {
	                    this.logger.verbose("acquireTokenSilent has been called previously, returning the result from the first call", correlationId);
	                    // Discard measurements for memoized calls, as they are usually only a couple of ms and will artificially deflate metrics
	                    atsMeasurement.discardMeasurement();
	                    return [2 /*return*/, cachedResponse];
	                }
	            });
	        });
	    };
	    PublicClientApplication.prototype.trackPageVisibility = function () {
	        if (!this.astsAsyncMeasurement) {
	            return;
	        }
	        this.logger.info("Perf: Visibility change detected");
	        this.astsAsyncMeasurement.increment({
	            visibilityChangeCount: 1,
	        });
	    };
	    /**
	     * Silently acquire an access token for a given set of scopes. Will use cached token if available, otherwise will attempt to acquire a new token from the network via refresh token.
	     * @param {@link (SilentRequest:type)}
	     * @param {@link (AccountInfo:type)}
	     * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthResponse}
	     */
	    PublicClientApplication.prototype.acquireTokenSilentAsync = function (request, account) {
	        var _a;
	        return __awaiter$3(this, void 0, void 0, function () {
	            var result, silentRequest, silentCacheClient, silentRequest_1, requestWithCLP_1;
	            var _this = this;
	            return __generator$3(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        this.performanceClient.addQueueMeasurement(PerformanceEvents.AcquireTokenSilentAsync, request.correlationId);
	                        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, request);
	                        this.astsAsyncMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilentAsync, request.correlationId);
	                        (_a = this.astsAsyncMeasurement) === null || _a === void 0 ? void 0 : _a.increment({
	                            visibilityChangeCount: 0
	                        });
	                        document.addEventListener("visibilitychange", this.trackPageVisibility);
	                        if (!(NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeExtensionProvider, request.authenticationScheme) && account.nativeAccountId)) return [3 /*break*/, 1];
	                        this.logger.verbose("acquireTokenSilent - attempting to acquire token from native platform");
	                        silentRequest = __assign$5(__assign$5({}, request), { account: account });
	                        result = this.acquireTokenNative(silentRequest, ApiId.acquireTokenSilent_silentFlow).catch(function (e) { return __awaiter$3(_this, void 0, void 0, function () {
	                            var silentIframeClient;
	                            return __generator$3(this, function (_a) {
	                                // If native token acquisition fails for availability reasons fallback to web flow
	                                if (e instanceof NativeAuthError && e.isFatal()) {
	                                    this.logger.verbose("acquireTokenSilent - native platform unavailable, falling back to web flow");
	                                    this.nativeExtensionProvider = undefined; // Prevent future requests from continuing to attempt
	                                    silentIframeClient = this.createSilentIframeClient(request.correlationId);
	                                    return [2 /*return*/, silentIframeClient.acquireToken(request)];
	                                }
	                                throw e;
	                            });
	                        }); });
	                        return [3 /*break*/, 3];
	                    case 1:
	                        this.logger.verbose("acquireTokenSilent - attempting to acquire token from web flow");
	                        silentCacheClient = this.createSilentCacheClient(request.correlationId);
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeSilentRequest, request.correlationId);
	                        return [4 /*yield*/, silentCacheClient.initializeSilentRequest(request, account)];
	                    case 2:
	                        silentRequest_1 = _b.sent();
	                        requestWithCLP_1 = __assign$5(__assign$5({}, request), { 
	                            // set the request's CacheLookupPolicy to Default if it was not optionally passed in
	                            cacheLookupPolicy: request.cacheLookupPolicy || CacheLookupPolicy.Default });
	                        this.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenFromCache, silentRequest_1.correlationId);
	                        result = this.acquireTokenFromCache(silentCacheClient, silentRequest_1, requestWithCLP_1).catch(function (cacheError) {
	                            if (requestWithCLP_1.cacheLookupPolicy === CacheLookupPolicy.AccessToken) {
	                                throw cacheError;
	                            }
	                            // block the reload if it occurred inside a hidden iframe
	                            BrowserUtils.blockReloadInHiddenIframes();
	                            _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_NETWORK_START, InteractionType.Silent, silentRequest_1);
	                            _this.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenByRefreshToken, silentRequest_1.correlationId);
	                            return _this.acquireTokenByRefreshToken(silentRequest_1, requestWithCLP_1).catch(function (refreshTokenError) {
	                                var isServerError = refreshTokenError instanceof ServerError;
	                                var isInteractionRequiredError = refreshTokenError instanceof InteractionRequiredAuthError;
	                                var rtNotFound = (refreshTokenError.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code);
	                                var isInvalidGrantError = (refreshTokenError.errorCode === BrowserConstants.INVALID_GRANT_ERROR);
	                                if ((!isServerError ||
	                                    !isInvalidGrantError ||
	                                    isInteractionRequiredError ||
	                                    requestWithCLP_1.cacheLookupPolicy === CacheLookupPolicy.AccessTokenAndRefreshToken ||
	                                    requestWithCLP_1.cacheLookupPolicy === CacheLookupPolicy.RefreshToken)
	                                    && (requestWithCLP_1.cacheLookupPolicy !== CacheLookupPolicy.Skip)
	                                    && !rtNotFound) {
	                                    throw refreshTokenError;
	                                }
	                                _this.logger.verbose("Refresh token expired/invalid or CacheLookupPolicy is set to Skip, attempting acquire token by iframe.", request.correlationId);
	                                _this.performanceClient.setPreQueueTime(PerformanceEvents.AcquireTokenBySilentIframe, silentRequest_1.correlationId);
	                                return _this.acquireTokenBySilentIframe(silentRequest_1);
	                            });
	                        });
	                        _b.label = 3;
	                    case 3: return [2 /*return*/, result.then(function (response) {
	                            var _a;
	                            _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, response);
	                            (_a = _this.astsAsyncMeasurement) === null || _a === void 0 ? void 0 : _a.endMeasurement({
	                                success: true,
	                                fromCache: response.fromCache,
	                                isNativeBroker: response.fromNativeBroker,
	                                requestId: response.requestId
	                            });
	                            return response;
	                        }).catch(function (tokenRenewalError) {
	                            var _a;
	                            _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, tokenRenewalError);
	                            (_a = _this.astsAsyncMeasurement) === null || _a === void 0 ? void 0 : _a.endMeasurement({
	                                errorCode: tokenRenewalError.errorCode,
	                                subErrorCode: tokenRenewalError.subError,
	                                success: false
	                            });
	                            throw tokenRenewalError;
	                        }).finally(function () {
	                            document.removeEventListener("visibilitychange", _this.trackPageVisibility);
	                        })];
	                }
	            });
	        });
	    };
	    return PublicClientApplication;
	}(ClientApplication));

	function e(e){this.message=e;}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,"");if(t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,o,a=0,i=0,c="";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);return c};function t(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw "Illegal base64url string!"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t="0"+t),"%"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e;}function o(e,r){if("string"!=typeof e)throw new n("Invalid token specified");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(".")[o]))}catch(e){throw new n("Invalid token specified: "+e.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";

	/**
	 * A manager for the map control's authentication.
	 * Exposed through the authentication property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var AuthenticationManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function AuthenticationManager(map) {
	        var _this = this;
	        /**
	         * A static fallback storage for when localStorage and sessionStorage are unavailable.
	         */
	        this.fallbackStorage = {};
	        /**
	         * Triggers the user provided function to fetch the token and stores it.
	         * @internal
	         */
	        this._triggerTokenFetch = function (isAnonymousAuth) {
	            if (isAnonymousAuth === void 0) { isAnonymousAuth = false; }
	            return new Promise(function (resolve, reject) {
	                if (typeof _this.options.getToken !== "function") {
	                    reject(new Error("Token cannot be ".concat(isAnonymousAuth ? 'fetched' : 'renewed', " because getToken was not set or is not a function.")));
	                    return;
	                }
	                _this.options.getToken(function (token) {
	                    try {
	                        // Try to get the timeout first as this will guarantee the token is correctly formatted.
	                        var timeout = _this._getTokenExpiry(token) - AuthenticationManager.constants.tokenRefreshClockSkew;
	                        _this._storeToken(token);
	                        _this._setTimeoutTokenFetch(timeout);
	                        resolve();
	                    }
	                    catch (_a) {
	                        reject(new Error("Invalid token returned by getToken function"));
	                    }
	                }, function (error) {
	                    reject(error);
	                }, _this.map);
	            });
	        };
	        /**
	         * Create a timer to trigger the user provided function to fetch the token.
	         * @param seconds delay in seconds
	         * @internal
	         */
	        this._setTimeoutTokenFetch = function (seconds) {
	            clearTimeout(_this.tokenTimeOutHandle); // Clear the previous refresh timeout in case it hadn't triggered yet.
	            // @ts-ignore
	            // tslint:disable-next-line: no-string-based-set-timeout
	            _this.tokenTimeOutHandle = setTimeout(_this._triggerTokenFetch, Math.min(seconds * 1000, 0x7fffffff) // setTimeout will fire immediately if the delay is greater than 2^31-1.
	            );
	        };
	        var serviceOptions = map.getServiceOptions();
	        this.options = serviceOptions.authOptions;
	        this.sessionId = serviceOptions.sessionId;
	        this.map = map;
	    }
	    /**
	     * Initializes the authentication mechanism specified in AuthenticationOptions.
	     * If this method has been called before the original initialize promise is returned.
	     */
	    AuthenticationManager.prototype.initialize = function () {
	        var _this = this;
	        if (!this.initPromise) {
	            // If an init promise hasn't been created this is the first initialize call.
	            this.initPromise = new Promise(function (resolve, reject) {
	                if (_this.options.authType === exports.AuthenticationType.subscriptionKey) {
	                    resolve();
	                }
	                else if (_this.options.authType === exports.AuthenticationType.aad) {
	                    // If a specific auth context was provided to the map use that.
	                    // If not use/create a default auth context shared between maps.
	                    _this.options.authContext = _this.options.authContext ||
	                        AuthenticationManager.getDefaultAuthContext(_this.options);
	                    _this.options.authContext.handleRedirectPromise().then(function () {
	                        // Login and acquire a token.
	                        // Fire it async so that users can add any listeners for token acquire events first.
	                        // tslint:disable-next-line: no-string-based-set-timeout
	                        setTimeout(function () { return _this._loginAndAcquireTokenForAAD(resolve, reject); });
	                    }).catch(function (error) {
	                        reject(new Error("Error logging in the AAD users: " + error));
	                        return;
	                    });
	                }
	                else if (_this.options.authType === exports.AuthenticationType.anonymous) {
	                    // Anonymous authentication, just call the users provided callback.
	                    resolve(_this._triggerTokenFetch(true));
	                }
	                else if (_this.options.authType === exports.AuthenticationType.sas) {
	                    if (_this.options.sasToken) {
	                        var expiresIn = -1;
	                        try {
	                            expiresIn = _this._getTokenExpiry(_this.options.sasToken);
	                        }
	                        catch (_a) {
	                            reject(new Error("An invalid sasToken was provided."));
	                            return;
	                        }
	                        if (expiresIn > AuthenticationManager.constants.tokenRefreshClockSkew) {
	                            // Save the initial token
	                            _this._storeToken(_this.options.sasToken);
	                            // Create a timer to refresh the token
	                            _this._setTimeoutTokenFetch(expiresIn - AuthenticationManager.constants.tokenRefreshClockSkew);
	                            resolve();
	                            return;
	                        }
	                    }
	                    // Call the users provided callback to fetch the token.
	                    resolve(_this._triggerTokenFetch());
	                }
	                else {
	                    reject(new Error("An invalid authentication type was specified."));
	                }
	            });
	        }
	        return this.initPromise;
	    };
	    /**
	     * Cleans up any resources used by the authentication manager.
	     */
	    AuthenticationManager.prototype.dispose = function () {
	        if (this.tokenTimeOutHandle) {
	            clearTimeout(this.tokenTimeOutHandle);
	            this.tokenTimeOutHandle = null;
	        }
	    };
	    /**
	     * Gets the default auth context to be shared between maps without one specified to them.
	     */
	    AuthenticationManager.getDefaultAuthContext = function (options) {
	        if (!options.aadAppId) {
	            throw new Error("No AAD app ID was specified.");
	        }
	        if (!options.aadTenant) {
	            throw new Error("No AAD tenant was specified.");
	        }
	        // Create a new auth context if one doesn't already exist.
	        if (!this.defaultAuthContext) {
	            this.defaultAuthContext = new PublicClientApplication({
	                auth: {
	                    authority: "".concat(options.aadInstance || env.aadInstance).concat(options.aadTenant),
	                    clientId: options.aadAppId
	                },
	                cache: {
	                    cacheLocation: this.constants.preferredCacheLocation
	                }
	            });
	        }
	        // Return either a reused auth context or the one created just above.
	        return this.defaultAuthContext;
	    };
	    /**
	     * Redirect to the login page if the user is not logged in, otherwise acquire the access token and resolve the promise.
	     * @param resolve the callback for the promise created from the initialize call
	     * @param reject the callback for the promise created from the initialize call
	     */
	    AuthenticationManager.prototype._loginAndAcquireTokenForAAD = function (resolve, reject) {
	        var _a;
	        var accounts = ((_a = this.options.authContext) === null || _a === void 0 ? void 0 : _a.getAllAccounts()) || [];
	        if (accounts.length === 0) {
	            // Redirect to the login page if the user is not logged in.
	            this.options.authContext.loginRedirect();
	            resolve();
	        }
	        else {
	            // Acquire the access token and then resolve the promise.
	            this.options.authContext.setActiveAccount(accounts[0]);
	            this._acquireTokenForAAD(resolve, reject);
	        }
	    };
	    /**
	     * Acquire an access token silently and save it for later use. User might be prompted to login if the call fails.
	     * A timeout will be set to refresh the token before it expires.
	     * @param resolve an optional callback for a promise
	     * @param reject an optional callback for a promise
	     */
	    AuthenticationManager.prototype._acquireTokenForAAD = function (resolve, reject) {
	        var _this = this;
	        var request = { scopes: [constants.aadResourceId] };
	        this.options.authContext
	            .acquireTokenSilent(request)
	            .then(function (response) {
	            // Save the token to local/session storage
	            _this._saveItem(AuthenticationManager.constants.storage.tokenKey, response.accessToken);
	            // Fire the token acquired event
	            var tokenEvent = {
	                map: _this.map,
	                type: AuthenticationManager.constants.events.tokenAcquired
	            };
	            _this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	            // Set a timeout to refresh the token before it expires
	            clearTimeout(_this.tokenTimeOutHandle);
	            var timeout = new Date(response.expiresOn).getTime() - Date.now();
	            _this.tokenTimeOutHandle = setTimeout(function () { return _this._acquireTokenForAAD(); }, timeout);
	            resolve === null || resolve === void 0 ? void 0 : resolve();
	        })
	            .catch(function (error) {
	            if (error instanceof InteractionRequiredAuthError) {
	                // Fallback to interaction when silent call fails
	                _this.options.authContext.acquireTokenRedirect(request);
	                return resolve === null || resolve === void 0 ? void 0 : resolve();
	            }
	            reject === null || reject === void 0 ? void 0 : reject(error);
	        });
	    };
	    /**
	     * Returns the current authentication type in use.
	     */
	    AuthenticationManager.prototype.getAuthType = function () {
	        return this.options.authType;
	    };
	    /**
	     * Returns the current client ID in use.
	     */
	    AuthenticationManager.prototype.getClientId = function () {
	        return this.options.clientId;
	    };
	    /**
	     * Returns the access token with an audience URI of https://atlas.microsoft.com.
	     */
	    AuthenticationManager.prototype.getToken = function () {
	        if (this.options.authType === exports.AuthenticationType.aad) {
	            return this._getItem(AuthenticationManager.constants.storage.tokenKey);
	        }
	        else if (this.options.authType === exports.AuthenticationType.anonymous
	            || this.options.authType === exports.AuthenticationType.sas) {
	            var token = this._getItem(AuthenticationManager.constants.storage.tokenKey);
	            if (!token) {
	                // Cached Token not present, invoke the user provided callback function to fetch function
	                this._triggerTokenFetch();
	            }
	            else {
	                // check for cached token validity
	                var expiresIn = this._getTokenExpiry(token);
	                if (expiresIn < 300 && expiresIn > 0) {
	                    // We are within a window for the token expiry,
	                    // trigger a new token fetch, but still return the current token
	                    this._triggerTokenFetch();
	                }
	                else if (expiresIn <= 0) {
	                    // token renew failed and dont have a token.
	                    this._saveItem(AuthenticationManager.constants.storage.tokenKey, "");
	                    throw new Error(AuthenticationManager.constants.errors.tokenExpired);
	                }
	            }
	            return token;
	        }
	        else if (this.options.authType === exports.AuthenticationType.subscriptionKey) {
	            return this.options.subscriptionKey;
	        }
	        else {
	            return undefined;
	        }
	    };
	    /**
	     * Given a token, calculate the time left for token expiry
	     * @param token
	     * @internal
	     */
	    AuthenticationManager.prototype._getTokenExpiry = function (token) {
	        var decodedToken = o(token);
	        var expiresIn = decodedToken.exp;
	        var now = this._getCurrentTime();
	        return expiresIn - now > 0 ? expiresIn - now : -1;
	    };
	    /**
	     * stores the token
	     * @param token token fetched from the user's server endpoint
	     * @internal
	     */
	    AuthenticationManager.prototype._storeToken = function (token) {
	        // Store the value
	        this._saveItem(AuthenticationManager.constants.storage.tokenKey, token);
	        var tokenEvent = {
	            map: this.map,
	            type: AuthenticationManager.constants.events.tokenAcquired
	        };
	        this.map.events.invoke(AuthenticationManager.constants.events.tokenAcquired, tokenEvent);
	    };
	    /**
	     * Saves the item to storage
	     * @param key key/identifier
	     * @param value value to be stored
	     */
	    AuthenticationManager.prototype._saveItem = function (key, value) {
	        if (this._supportsLocalStorage()) {
	            localStorage.setItem(key, value);
	            return true;
	        }
	        else if (this._supportsSessionStorage()) {
	            sessionStorage.setItem(key, value);
	            return true;
	        }
	        else {
	            this.fallbackStorage[key] = value;
	            return true;
	        }
	    };
	    /**
	     * Gets an item saved in storage
	     * @param key Key/Identifier to be used for lookup
	     */
	    AuthenticationManager.prototype._getItem = function (key) {
	        if (this._supportsLocalStorage()) {
	            return localStorage.getItem(key);
	        }
	        else if (this._supportsSessionStorage()) {
	            return sessionStorage.getItem(key);
	        }
	        else if (key in this.fallbackStorage) {
	            return this.fallbackStorage[key];
	        }
	        return null;
	    };
	    /**
	     * Returns true if browser supports localStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationManager.prototype._supportsLocalStorage = function () {
	        try {
	            if (!window.localStorage) {
	                return false;
	            } // Test availability
	            window.localStorage.setItem(AuthenticationManager.constants.storage.testStorageKey, "A"); // Try write
	            if (window.localStorage.getItem(AuthenticationManager.constants.storage.testStorageKey) !== "A") {
	                return false;
	            } // Test read/write
	            window.localStorage.removeItem(AuthenticationManager.constants.storage.testStorageKey); // Try delete
	            if (window.localStorage.getItem(AuthenticationManager.constants.storage.testStorageKey)) {
	                return false;
	            } // Test delete
	            return true; // Success
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * Returns true if browser supports sessionStorage, false otherwise.
	     * @ignore
	     */
	    AuthenticationManager.prototype._supportsSessionStorage = function () {
	        try {
	            if (!window.sessionStorage) {
	                return false;
	            } // Test availability
	            window.sessionStorage.setItem(AuthenticationManager.constants.storage.testStorageKey, "A"); // Try write
	            if (window.sessionStorage.getItem(AuthenticationManager.constants.storage.testStorageKey) !== "A") {
	                return false;
	            } // Test read/write
	            window.sessionStorage.removeItem(AuthenticationManager.constants.storage.testStorageKey); // Try delete
	            if (window.sessionStorage.getItem(AuthenticationManager.constants.storage.testStorageKey)) {
	                return false;
	            } // Test delete
	            return true; // Success
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * Return the number of seconds since 1970/01/01
	     * @ignore
	     */
	    AuthenticationManager.prototype._getCurrentTime = function () {
	        return Math.round(new Date().getTime() / 1000.0);
	    };
	    AuthenticationManager.prototype.signRequest = function (request) {
	        // Add the headers used for identifying a request is from the map control.
	        request.headers = request.headers || {};
	        request.headers[constants.sessionIdHeaderName] = this.sessionId;
	        request.headers[constants.msOriginHeaderName] = constants.msOriginHeaderValue;
	        request.headers[constants.mapAgentHeaderName] = "MapControl/".concat(version$2, " (Web)");
	        var token = this.getToken();
	        switch (this.options.authType) {
	            case exports.AuthenticationType.aad:
	            case exports.AuthenticationType.anonymous:
	                request.headers[constants.msClientIdHeaderName] = this.options.clientId;
	                request.headers[constants.authorizationHeaderName] = constants.authorizationTokenPrefix + token;
	                break;
	            case exports.AuthenticationType.sas:
	                request.headers[constants.authorizationHeaderName] = constants.jwtSasPrefix + token;
	                break;
	            case exports.AuthenticationType.subscriptionKey:
	                request.headers["subscription-key"] = token;
	                break;
	            default:
	                throw new Error("An invalid authentication type was specified");
	        }
	        return request;
	    };
	    /**
	     * Constants for internal use
	     */
	    AuthenticationManager.constants = {
	        // Enable localStorage for IE, as sessionStorage does not work for localhost.
	        preferredCacheLocation: "localStorage",
	        storage: {
	            tokenKey: "access.token.key",
	            testStorageKey: "testStorage"
	        },
	        events: {
	            tokenAcquired: "tokenacquired"
	        },
	        tokenExpiresIn: 3599,
	        tokenRefreshClockSkew: 300,
	        errors: {
	            tokenExpired: "Token Expired, Try again"
	        }
	    };
	    return AuthenticationManager;
	}());

	var __values$c = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's controls.
	 * Exposed through the controls property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ControlManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function ControlManager(map) {
	        this.map = map;
	        // Add containers for map controls
	        this.controlContainer = document.createElement("div");
	        this.controlContainer.classList.add("atlas-control-container");
	        for (var controlPosition in exports.ControlPosition) {
	            if (exports.ControlPosition.hasOwnProperty(controlPosition)) {
	                var subcontrolContainer = document.createElement("div");
	                subcontrolContainer.classList.add(exports.ControlPosition[controlPosition]);
	                subcontrolContainer.classList.add("subcontrol-container");
	                this.controlContainer.appendChild(subcontrolContainer);
	            }
	        }
	        this.map.getMapContainer().appendChild(this.controlContainer);
	        this.controls = new Set();
	    }
	    /**
	     * Add a control(s) to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     */
	    ControlManager.prototype.add = function (control, options) {
	        var e_1, _a;
	        if (Array.isArray(control)) {
	            try {
	                for (var control_1 = __values$c(control), control_1_1 = control_1.next(); !control_1_1.done; control_1_1 = control_1.next()) {
	                    var c = control_1_1.value;
	                    this._add(c, options);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (control_1_1 && !control_1_1.done && (_a = control_1.return)) _a.call(control_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._add(control, options);
	        }
	    };
	    /**
	     * Gets an array of all controls on the map
	     */
	    ControlManager.prototype.getControls = function () {
	        return Array.from(this.controls);
	    };
	    /**
	     * Remove a control(s) from the map.
	     * @param control The control to remove.
	     */
	    ControlManager.prototype.remove = function (control) {
	        var e_2, _a;
	        if (Array.isArray(control)) {
	            try {
	                for (var control_2 = __values$c(control), control_2_1 = control_2.next(); !control_2_1.done; control_2_1 = control_2.next()) {
	                    var c = control_2_1.value;
	                    this._remove(c);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (control_2_1 && !control_2_1.done && (_a = control_2.return)) _a.call(control_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._remove(control);
	        }
	    };
	    /**
	     * Add a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._add = function (control, options) {
	        this.controls.add(control);
	        var controlOptions = new ControlOptions().merge(options);
	        var controlHtml = control.onAdd(this.map, options);
	        var subcontrolContainers = this.controlContainer.getElementsByClassName(controlOptions.position);
	        if (subcontrolContainers.length > 0) {
	            subcontrolContainers.item(0).appendChild(controlHtml);
	        }
	        else {
	            throw new Error("Control position ".concat(controlOptions.position, " does not exist."));
	        }
	    };
	    /**
	     * Remove a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._remove = function (control) {
	        control.onRemove();
	        this.controls.delete(control);
	    };
	    return ControlManager;
	}());

	var __assign$3 = (window && window.__assign) || function () {
	    __assign$3 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3.apply(this, arguments);
	};
	/**
	 * @private
	 */
	var MapCallbackHandler = /** @class */ (function () {
	    function MapCallbackHandler(map) {
	        // Dictionary keys represent the following: layer name -> event type -> user callback => [modified callback, once].
	        this.callbacks = new Dictionary();
	        this.map = map;
	    }
	    MapCallbackHandler.prototype.addCallback = function (eventType, layer, callback, legacy, once) {
	        var _this = this;
	        var modifiedCallback;
	        // If using legacy callbacks provide a MapEventData object to the user's callback
	        // Legacy callbacks cannot be added as once handles, so we don't need any logic for the once case.
	        if (legacy) {
	            modifiedCallback = function (data) {
	                var position = (data.lngLat) ?
	                    new Position(data.lngLat.lng, data.lngLat.lat) :
	                    undefined;
	                var coordinate = (data.point) ?
	                    [data.point.x, data.point.y] :
	                    undefined;
	                var features = (data.features) ?
	                    data.features.map(function (f) { return new Feature(f.geometry, f.properties, f.id); }) :
	                    [];
	                var mapEventData = {
	                    type: data.type,
	                    originalEvent: data.originalEvent,
	                    position: position,
	                    coordinate: coordinate,
	                    features: features
	                };
	                callback(mapEventData);
	            };
	        }
	        else {
	            var lastOriginalEvent_1;
	            switch (eventType) {
	                case "data":
	                case "sourcedata":
	                case "styledata":
	                    modifiedCallback = function (data) {
	                        var mapEventData = __assign$3(__assign$3({ dataType: data.dataType }, (data.dataType === "source" && __assign$3(__assign$3(__assign$3({ isSourceLoaded: data.isSourceLoaded }, (data.sourceDataType && { sourceDataType: data.sourceDataType })), { source: _this.map.sources.getById(data.sourceId) }), (data.tile && {
	                            tile: {
	                                id: {
	                                    x: data.tile.tileID.canonical.x,
	                                    y: data.tile.tileID.canonical.y,
	                                    z: data.tile.tileID.canonical.z
	                                },
	                                size: data.tile.tileSize,
	                                state: data.tile.state
	                            }
	                        })))), { map: _this.map, type: data.type });
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "error":
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            error: data.error,
	                            map: _this.map,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "touchstart":
	                case "touchend":
	                case "touchmove":
	                case "touchcancel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var pixels = (data.points) ?
	                            data.points.map(function (p) { return new Pixel(p.x, p.y); }) :
	                            [];
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var positions = (data.lngLats) ?
	                            data.lngLats.map(function (l) { return new Position(l.lng, l.lat); }) :
	                            [];
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            pixel: pixel,
	                            pixels: pixels,
	                            position: position,
	                            positions: positions,
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            preventDefault: function () { return data.preventDefault(); },
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "mousedown":
	                case "mouseup":
	                case "mouseover":
	                case "mousemove":
	                case "click":
	                case "dblclick":
	                case "mouseout":
	                case "mouseenter":
	                case "mouseleave":
	                case "contextmenu":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            position: position,
	                            pixel: pixel,
	                            preventDefault: function () { return data.preventDefault(); },
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "styleimagemissing":
	                    modifiedCallback = function (data) {
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(data.id);
	                    };
	                    break;
	                case "wheel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            preventDefault: function () { return data.preventDefault(); },
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "resize":
	                    // The resize event is technically one of the default callback types.
	                    // However, since users can specify custom eventData to add to the resize event
	                    // we need to make sure to include that in our modified callback.
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Add any extra properties to the modified callback data.
	                        // Skip the "type" and "target" properties as these are
	                        // replaced by the "type" and "map" properties above.
	                        for (var prop in data) {
	                            if (prop !== "type" && prop !== "target") {
	                                mapEventData[prop] = data[prop];
	                            }
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                default:
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Not every event will have an originalEvent property.
	                        // Only add this properties to our modified callback's data if it will be defined.
	                        if (data.originalEvent) {
	                            mapEventData.originalEvent = data.originalEvent;
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	            }
	        }
	        // Add an empty dictionary for the specified layer if one doesn't already exist.
	        if (!this.callbacks.has(layer)) {
	            this.callbacks.set(layer, new Dictionary());
	        }
	        // Add an empty dictionary for the specified event type if one doesn't already exist.
	        if (!this.callbacks.get(layer).has(eventType)) {
	            this.callbacks.get(layer).set(eventType, new Map());
	        }
	        this.callbacks.get(layer).get(eventType).set(callback, [modifiedCallback, once]);
	    };
	    MapCallbackHandler.prototype.removeCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            this.callbacks.get(layer).get(eventType).delete(callback);
	        }
	    };
	    MapCallbackHandler.prototype.getModifiedCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            return this.callbacks.get(layer).get(eventType).get(callback)[0];
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getLayerCallbacks = function (layer) {
	        if (this.callbacks.has(layer)) {
	            return this.callbacks.get(layer);
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getEventCallbacks = function (eventType, layer) {
	        if (this.callbacks.has(layer)) {
	            var layerCallbacks = this.callbacks.get(layer);
	            if (layerCallbacks.has(eventType)) {
	                return layerCallbacks.get(eventType);
	            }
	        }
	        return undefined;
	    };
	    return MapCallbackHandler;
	}());

	var __values$b = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$7 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	// Disable unified signatures linter rule so we can generate separate docs for function overloads.
	// tslint:disable:unified-signatures
	var MAP_CLIENT_EVENTS = ['maxzoomchanged', 'minzoomchanged', 'mapconfigurationchanged'];
	/**
	 * A manager for the map control's events.
	 * Exposed through the events property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var EventManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function EventManager(map) {
	        this.map = map;
	        this.mapCallbackHandler = new MapCallbackHandler(this.map);
	    }
	    EventManager.prototype.add = function (eventType, targetOrCallback, callback) {
	        var e_1, _a;
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, false);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            try {
	                for (var targetOrCallback_1 = __values$b(targetOrCallback), targetOrCallback_1_1 = targetOrCallback_1.next(); !targetOrCallback_1_1.done; targetOrCallback_1_1 = targetOrCallback_1.next()) {
	                    var target = targetOrCallback_1_1.value;
	                    if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                        this._addLayerListener(eventType, target, callback, false, false);
	                    }
	                    else {
	                        target._addEventListener(eventType, callback, false);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (targetOrCallback_1_1 && !targetOrCallback_1_1.done && (_a = targetOrCallback_1.return)) _a.call(targetOrCallback_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	    };
	    EventManager.prototype.addOnce = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, true);
	        }
	        else if (targetOrCallback instanceof Layer && Layer._isMBoxEvent(eventType)) {
	            this._addLayerListener(eventType, targetOrCallback, callback, false, true);
	        }
	        else {
	            targetOrCallback._addEventListener(eventType, callback, true);
	        }
	    };
	    EventManager.prototype._addLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, true, false);
	        }
	        else {
	            this._addLayerListener(eventType, targetOrCallback, callback, true, false);
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addLayerListener = function (eventType, target, callback, legacy, once) {
	        var e_2, _a, e_3, _b;
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var layer = this.map.layers.getLayerById(layerId);
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        // Must disable it on every Mapbox layer our layer builds.
	        if (modifiedCallback && layer) {
	            try {
	                for (var _c = __values$b(layer._getLayerIds()), _d = _c.next(); !_d.done; _d = _c.next()) {
	                    var id = _d.value;
	                    this.map._getMap().off(eventType, id, modifiedCallback);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, layerId, callback, legacy, once);
	        // If the layer already exists on the map immediately add the callbacks.
	        // Otherwise the callbacks will be added once the layer is added to the map.
	        if (layer) {
	            modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	            try {
	                for (var _e = __values$b(layer._getLayerIds()), _f = _e.next(); !_f.done; _f = _e.next()) {
	                    var id = _f.value;
	                    this.map._getMap().on(eventType, id, modifiedCallback);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addGlobalListener = function (eventType, callback, legacy, once) {
	        // add our custom events emitted by Map client to the map (note: they don't utilize modifiedCallback) 
	        if (MAP_CLIENT_EVENTS.includes(eventType)) {
	            this.map._addEventListener(eventType, callback, once);
	            return;
	        }
	        var oldModifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, "", callback, legacy, once);
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // Enable the new modified callback on the Mapbox map.
	        if (eventType === "load" && this.map._isLoaded()) {
	            // Manually execute the callback if the load event has already fired.
	            // Use setTimeout to execute the callback async.
	            // This is for consistency with the case where the load event hasn't already fired.
	            // If the load event hasn't already fired the callback will also be executed async once it does fire.
	            var loadData_1 = { type: "load", map: this.map };
	            // tslint:disable-next-line: no-string-based-set-timeout
	            setTimeout(function () { return modifiedCallback(loadData_1); });
	        }
	        else if (eventType === "ready") {
	            // The ready event doesn't exist on the Mapbox map.
	            // Don't enable the callback for the Mapbox map.
	            if (this.map._isReady()) {
	                // Manually execute the callback if the ready event has already fired.
	                var readyData_1 = { type: "ready", map: this.map };
	                // tslint:disable-next-line: no-string-based-set-timeout
	                setTimeout(function () { return modifiedCallback(readyData_1); });
	            }
	        }
	        else {
	            // If a callback already exists disable it so the new one can replace it.
	            if (oldModifiedCallback) {
	                this.map._getMap().off(eventType, oldModifiedCallback);
	            }
	            this.map._getMap().on(eventType, modifiedCallback);
	        }
	    };
	    EventManager.prototype.invoke = function (eventType, targetOrArgs, args) {
	        // If args is undefined assume there is not target for the event.
	        if (typeof args === "undefined") {
	            // Empty string indicates the map global level.
	            this._invokeListeners(eventType, "", targetOrArgs);
	        }
	        else {
	            if (targetOrArgs instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                this._invokeListeners(eventType, targetOrArgs.getId(), args);
	            }
	            else if (targetOrArgs instanceof EventEmitter) {
	                targetOrArgs._invokeEvent(eventType, args);
	            }
	            else {
	                throw new Error("The invoke target is invalid.");
	            }
	        }
	    };
	    /**
	     * Invokes all listeners for the given event and layer.
	     * @param eventType The event type to invoke.
	     * @param layer The layer to invoke the event for. Use an empty string for map global events.
	     * @param args The data to pass to the listener callbacks.
	     * @private
	     */
	    EventManager.prototype._invokeListeners = function (eventType, layer, args) {
	        var _this = this;
	        // copy event callbacks in order to prevent being mutated during iteration below (even callbacks added as part of other event callbacks) 
	        var callbacks = new Dictionary(this.mapCallbackHandler.getEventCallbacks(eventType, layer));
	        if (callbacks) {
	            callbacks.forEach(function (_a, callback) {
	                var _b = __read$7(_a, 2); _b[0]; var once = _b[1];
	                // Invoking a listener this way circumvents the fire once logic in the modified callback.
	                // So we check if the callback was added as a fire once and if so remove it here.
	                if (once) {
	                    _this._removeListener(eventType, layer, callback);
	                }
	                callback(args);
	            });
	        }
	        else if (eventType === "error") {
	            // If there are no user specified callback for the error event print to console.
	            // tslint:disable-next-line:no-console
	            console.error("error" in args ? args.error : args);
	        }
	    };
	    EventManager.prototype.remove = function (eventType, targetOrCallback, callback) {
	        var e_4, _a;
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            try {
	                for (var targetOrCallback_2 = __values$b(targetOrCallback), targetOrCallback_2_1 = targetOrCallback_2.next(); !targetOrCallback_2_1.done; targetOrCallback_2_1 = targetOrCallback_2.next()) {
	                    var target = targetOrCallback_2_1.value;
	                    if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                        this._removeListener(eventType, target, callback);
	                    }
	                    else {
	                        target === null || target === void 0 ? void 0 : target._removeEventListener(eventType, callback);
	                    }
	                }
	            }
	            catch (e_4_1) { e_4 = { error: e_4_1 }; }
	            finally {
	                try {
	                    if (targetOrCallback_2_1 && !targetOrCallback_2_1.done && (_a = targetOrCallback_2.return)) _a.call(targetOrCallback_2);
	                }
	                finally { if (e_4) throw e_4.error; }
	            }
	        }
	    };
	    EventManager.prototype._removeLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            this._removeListener(eventType, targetOrCallback, callback);
	        }
	    };
	    /**
	     * Removes a listener from the map or a single layer.
	     * Will remove the event listeners from the layer's underlying Mapbox layers too.
	     * @internal
	     */
	    EventManager.prototype._removeListener = function (eventType, target, callback) {
	        var e_5, _a;
	        // remove our custom events emitted by Map client to the map (note: they don't utilize modifiedCallback)
	        if (MAP_CLIENT_EVENTS.includes(eventType)) {
	            this.map._removeEventListener(eventType, callback);
	            return;
	        }
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        if (modifiedCallback) {
	            // An empty layerId indicates the listener is being removed from the global map.
	            if (layerId) {
	                // If a callback already exists disable it so the new one can replace it.
	                // Must disable it on every Mapbox layer our layer builds.
	                var layer = this.map.layers.getLayerById(layerId);
	                if (layer) {
	                    try {
	                        for (var _b = __values$b(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                            var id = _c.value;
	                            this.map._getMap().off(eventType, id, modifiedCallback);
	                        }
	                    }
	                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
	                    finally {
	                        try {
	                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                        }
	                        finally { if (e_5) throw e_5.error; }
	                    }
	                }
	            }
	            else {
	                this.map._getMap().off(eventType, modifiedCallback);
	            }
	        }
	        this.mapCallbackHandler.removeCallback(eventType, layerId, callback);
	    };
	    /**
	     * Enables all the events associated with the specified layers.
	     * Enables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._enableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var e_6, _b;
	                    var _c = __read$7(_a, 1), modifiedCallback = _c[0];
	                    try {
	                        for (var _d = __values$b(layer._getLayerIds()), _e = _d.next(); !_e.done; _e = _d.next()) {
	                            var mbLayerId = _e.value;
	                            _this.map._getMap().on(eventType, mbLayerId, modifiedCallback);
	                        }
	                    }
	                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
	                    finally {
	                        try {
	                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
	                        }
	                        finally { if (e_6) throw e_6.error; }
	                    }
	                });
	            });
	        }
	    };
	    /**
	     * Disables all the events associated with the specified layers.
	     * Disables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._disableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var e_7, _b;
	                    var _c = __read$7(_a, 1), modifiedCallback = _c[0];
	                    try {
	                        for (var _d = __values$b(layer._getLayerIds()), _e = _d.next(); !_e.done; _e = _d.next()) {
	                            var mbLayerId = _e.value;
	                            _this.map._getMap().off(eventType, mbLayerId, modifiedCallback);
	                        }
	                    }
	                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
	                    finally {
	                        try {
	                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
	                        }
	                        finally { if (e_7) throw e_7.error; }
	                    }
	                });
	            });
	        }
	    };
	    return EventManager;
	}());

	var __values$a = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's HTML markers.
	 * Exposed through the markers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var HtmlMarkerManager = /** @class */ (function () {
	    /**
	     * Constructs the marker manager to be exposed only through the markers property of the Map class.
	     * @param map The map whose markers are being managed by this.
	     * @internal
	     */
	    function HtmlMarkerManager(map) {
	        this.markers = new Set();
	        this.map = map;
	    }
	    HtmlMarkerManager.prototype.add = function (element, position) {
	        var e_1, _a;
	        if (Array.isArray(element)) {
	            try {
	                for (var element_1 = __values$a(element), element_1_1 = element_1.next(); !element_1_1.done; element_1_1 = element_1.next()) {
	                    var marker = element_1_1.value;
	                    this._addMarker(marker, position);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (element_1_1 && !element_1_1.done && (_a = element_1.return)) _a.call(element_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addMarker(element, position);
	        }
	    };
	    /**
	     * Adds a single marker.
	     */
	    HtmlMarkerManager.prototype._addMarker = function (marker, position) {
	        marker._addToMap(this.map, position);
	        this.markers.add(marker);
	    };
	    /**
	     * Gets an array of all the markers on the map.
	     */
	    HtmlMarkerManager.prototype.getMarkers = function () {
	        return Array.from(this.markers);
	    };
	    /**
	     * Removes one or more HTML markers from the map.
	     * @param marker A HtmlMarker instance, a string id of a marker's htmlContent, or an array of these.
	     */
	    HtmlMarkerManager.prototype.remove = function (marker) {
	        var e_2, _a;
	        if (Array.isArray(marker)) {
	            try {
	                for (var marker_1 = __values$a(marker), marker_1_1 = marker_1.next(); !marker_1_1.done; marker_1_1 = marker_1.next()) {
	                    var singleMarker = marker_1_1.value;
	                    this._removeMarker(singleMarker);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (marker_1_1 && !marker_1_1.done && (_a = marker_1.return)) _a.call(marker_1);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._removeMarker(marker);
	        }
	    };
	    /**
	     * Removes a single marker.
	     */
	    HtmlMarkerManager.prototype._removeMarker = function (marker) {
	        var _this = this;
	        if (marker instanceof HtmlMarker) {
	            marker._removeFromMap();
	            this.markers.delete(marker);
	        }
	        else {
	            this.markers.forEach(function (singleMarker) {
	                if (singleMarker._getId() === marker) {
	                    singleMarker._removeFromMap();
	                    _this.markers.delete(singleMarker);
	                }
	            });
	        }
	    };
	    /**
	     * Clears all markers.
	     */
	    HtmlMarkerManager.prototype.clear = function () {
	        var _this = this;
	        this.markers.forEach(function (singleMarker) {
	            singleMarker._removeFromMap();
	            _this.markers.delete(singleMarker);
	        });
	    };
	    return HtmlMarkerManager;
	}());

	/**
	 * A manager for the map control's image sprite.
	 * Exposed through the imageSprite property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ImageSpriteManager = /** @class */ (function () {
	    /**
	     * Constructs the image sprite manager to be exposed only through the imageSprite property of the Map class.
	     * @param map The Map object this will manage the image sprite for.
	     * @internal
	     */
	    function ImageSpriteManager(map) {
	        this.userImages = new Dictionary();
	        this.imageLoadTimeout = 5000;
	        this.map = map;
	    }
	    /**
	     * Add an icon image to the map's image sprite for use with symbols and patterns.
	     * @param id The image's id.
	     * If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param icon The image to add to the map's sprite. Can be a data URI, inline SVG, or image URL.
	     * @param meta Additional options that describe the image
	     */
	    ImageSpriteManager.prototype.add = function (id, icon, meta) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            // Take no action if the new image uses the id of a previously added image.
	            if (_this.userImages.has(id)) {
	                resolve();
	                return;
	            }
	            if (icon instanceof HTMLImageElement || icon instanceof ImageData) {
	                _this.map._getMap().addImage(id, icon, meta);
	                _this.userImages.set(id, { image: icon, meta: meta });
	                resolve();
	            }
	            else if (typeof icon === "string") {
	                var imageSrc = void 0;
	                // Assume an inline svg image string if icon doesn't start with "data:", but does include "<svg"
	                if (/<svg/i.test(icon) && !(/^data:/i.test(icon))) {
	                    imageSrc = "data:image/svg+xml;base64," + window.btoa(icon);
	                }
	                else {
	                    imageSrc = icon;
	                }
	                // Use a timer to prevent the request from waiting forever.
	                var timeoutId_1;
	                var timedOut_1 = false;
	                // Use the map to send the request so transformRequest is used.
	                _this.map._sendRequest(imageSrc, "Image" /* ResourceType.Image */).then(function (response) {
	                    return !timedOut_1 ? response.blob() : undefined;
	                }).then(function (blob) {
	                    if (!timedOut_1 && blob) {
	                        clearTimeout(timeoutId_1);
	                        var imageEle_1 = new Image();
	                        // Wait for the blob to load into the element.
	                        imageEle_1.onload = function () {
	                            _this.map._getMap().addImage(id, imageEle_1, meta);
	                            _this.userImages.set(id, { image: imageEle_1, meta: meta });
	                            resolve();
	                        };
	                        // Reject if the blob failed to load in the element.
	                        imageEle_1.onerror = imageEle_1.onabort = function () {
	                            reject("Failed to load image into HTML element.");
	                        };
	                        // Convert the blob to a data url then load it into an Image element.
	                        imageEle_1.src = URL.createObjectURL(blob);
	                    }
	                }).catch(function () {
	                    if (!timedOut_1) {
	                        clearTimeout(timeoutId_1);
	                        reject("Failed to load image into HTML element.");
	                    }
	                });
	                // Allow the image a fixed amount of time to load the image before aborting.
	                // @ts-ignore
	                timeoutId_1 = setTimeout(function () {
	                    timedOut_1 = true;
	                    reject("Failed to load image within specified timeout: ".concat(_this.imageLoadTimeout, " ms."));
	                    // tslint:disable-next-line: no-string-based-set-timeout
	                }, _this.imageLoadTimeout);
	            }
	        });
	    };
	    /**
	     * Removes all images added by the user.
	     */
	    ImageSpriteManager.prototype.clear = function () {
	        var _this = this;
	        this.userImages.forEach(function (image, id) {
	            _this.map._getMap().removeImage(id);
	        });
	        // Clear the list of user added image ids.
	        this.userImages.clear();
	    };
	    /**
	     * Gets a list of all the image ids that have been added to the maps image sprite.
	     */
	    ImageSpriteManager.prototype.getImageIds = function () {
	        var ids = [];
	        this.userImages.forEach(function (image, id) {
	            ids.push(id);
	        });
	        return ids;
	    };
	    /**
	     * Creates and adds an image to the maps image sprite. Provide the name of the built-in template to use, and a color to apply.
	     * Optionally, specifiy a secondary color if the template supports one. A scale can also be specified.
	     * This will allow the SVG to be scaled before it is converted into an image and thus look much better when scaled up.
	     * Returns a promise.
	     * Reference this in the Polygon or Symbol layer.
	     * @param id  The image's id. If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param templateName The name of the template to use.
	     * @param color The primary color value. Default: #1A73AA
	     * @param secondaryColor A secondary color value. Default: white
	     * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	     */
	    ImageSpriteManager.prototype.createFromTemplate = function (id, templateName, color, secondaryColor, scale) {
	        color = color || "#1A73AA";
	        secondaryColor = secondaryColor || "#fff";
	        var t = getImageTemplate(templateName, scale);
	        t = t.replace(/{color}/g, color).replace(/{secondaryColor}/g, secondaryColor).replace(/{text}/g, "");
	        return this.add(id, t);
	    };
	    /**
	     * Checks to see if an image is already loaded into the maps image sprite.
	     * @param id The id to check the map's image sprite for.
	     */
	    ImageSpriteManager.prototype.hasImage = function (id) {
	        return this.userImages.has(id);
	    };
	    /**
	     * Removes an image from the map's image sprite.
	     * @param id The id of the image to remove.
	     */
	    ImageSpriteManager.prototype.remove = function (id) {
	        this.map._getMap().removeImage(id);
	        this.userImages.delete(id);
	    };
	    /**
	     * Restores the images the user has added to the Mapbox image sprite.
	     * @internal
	     */
	    ImageSpriteManager.prototype._restoreImages = function () {
	        var _this = this;
	        // Check that all user added images still exist in the sprite after changing styles.
	        // Currently Mapbox doesn't support diff operations for sprites.
	        // Therefore changing a sprite will cause a full style rebuild.
	        this.userImages.forEach(function (image, id) {
	            if (!_this.map._getMap().hasImage(id)) {
	                _this.map._getMap().addImage(id, image.image, image.meta);
	            }
	        });
	    };
	    return ImageSpriteManager;
	}());

	var __extends$e = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$9 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * Used to represent the layer described by a resource files.
	 * Serves primarily as a wrapper for multiple Mapbox layers in LayerManger.
	 * @private
	 */
	var FundamentalMapLayer = /** @class */ (function (_super) {
	    __extends$e(FundamentalMapLayer, _super);
	    /**
	     * Constructs a base layer used to represent the base, transit, and labels layers.
	     * @param mbLayers The stylesheet used to define the style sources and style layers.
	     * @param id The layer's id.
	     */
	    function FundamentalMapLayer(mbLayers, id) {
	        var _this = _super.call(this, id) || this;
	        _this.layers = mbLayers;
	        return _this;
	    }
	    /**
	     * Gets the options of the layer.
	     */
	    FundamentalMapLayer.prototype.getOptions = function () {
	        return {};
	    };
	    /**
	     * Sets the options of the layer.
	     * @param options The new options of the layer.
	     */
	    FundamentalMapLayer.prototype.setOptions = function (options) { return; };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._buildLayers = function () {
	        return this.layers;
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getLayerIds = function () {
	        return this.layers.map(function (l) { return l.id; });
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getSourceIds = function () {
	        var e_1, _a;
	        var ids = new Set();
	        try {
	            for (var _b = __values$9(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var layer = _c.value;
	                if ('source' in layer && typeof layer.source === "string") {
	                    // If the layer's source is just a string id use that.
	                    ids.add(layer.source);
	                }
	                else if ('source' in layer && layer.source) {
	                    // If the layer has an inline source definition the id will match the layer's.
	                    ids.add(layer.id);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return ids;
	    };
	    FundamentalMapLayer.prototype._updateLayoutProperty = function (name, newValue, oldValue, subValue) {
	        if (isEqual$1(newValue, oldValue))
	            return;
	        var map = this.map._getMap();
	        this.layers.forEach(function (layer) {
	            if (map.getLayer(layer.id)) {
	                map.setLayoutProperty(layer.id, name, subValue || newValue);
	            }
	            else {
	                console.warn("Could not update layout property ".concat(name, " for layer ").concat(layer.id, " to ").concat(subValue || newValue));
	            }
	        });
	    };
	    return FundamentalMapLayer;
	}(Layer));

	var __values$8 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$6 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$6 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * A manager for the map control's layers.
	 * Exposed through the layers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var LayerManager = /** @class */ (function () {
	    /**
	     * Constructs the layer manager to be exposed only through the layers property of the Map class.
	     * @param map The map whose layers are being managed by this.
	     * @internal
	     */
	    function LayerManager(map) {
	        this.layerIndex = [];
	        this.userLayers = [];
	        this.map = map;
	    }
	    LayerManager.prototype.add = function (layer, before) {
	        var e_1, _a;
	        var beforeId = before instanceof Layer ?
	            before.getId() :
	            before;
	        if (Array.isArray(layer)) {
	            try {
	                for (var layer_1 = __values$8(layer), layer_1_1 = layer_1.next(); !layer_1_1.done; layer_1_1 = layer_1.next()) {
	                    var singleLayer = layer_1_1.value;
	                    this._addLayer(singleLayer, beforeId);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (layer_1_1 && !layer_1_1.done && (_a = layer_1.return)) _a.call(layer_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addLayer(layer, beforeId);
	        }
	    };
	    /**
	     * Adds a single layer to the map.
	     * @private
	     */
	    LayerManager.prototype._addLayer = function (layer, before) {
	        if (!this.map._isReady() && !(layer instanceof FundamentalMapLayer)) {
	            throw new Error("The layer '".concat(layer.getId(), "' could not be added to the map because ") +
	                "the map is not ready. Please use a ready event listener to guarantee " +
	                "the map is ready before adding a layer to it.");
	        }
	        if (before !== layer.getId() && this.layerIndex.find(function (l) { return before === l.getId(); })) {
	            if (this._getMapboxLayerExists(layer)) {
	                // Replace the existing layer with the new one.
	                // Place the new layer behind the specified before layer.
	                var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layer.getId(); });
	                var userLayerIndex = this.userLayers.findIndex(function (ul) { return ul.layer.getId() === layer.getId(); });
	                this._removeMapboxLayers(layer);
	                this._addMapboxLayers(layer, before);
	                var tempLayer = this.layerIndex[layerIndex];
	                if (tempLayer) {
	                    this.map.events._disableLayerEvents(tempLayer);
	                }
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex.splice(layerIndex, 1);
	                var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === before; });
	                this.layerIndex.splice(beforeIndex, 0, layer);
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers[userLayerIndex] = { layer: layer, before: before };
	                }
	                if (tempLayer) {
	                    tempLayer.onRemove();
	                }
	                layer.onAdd(this.map);
	            }
	            else {
	                // Add the new layer behind the specified before layer.
	                this._addMapboxLayers(layer, before);
	                this.map.events._enableLayerEvents(layer);
	                var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === before; });
	                this.layerIndex.splice(beforeIndex, 0, layer);
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers.push({ layer: layer, before: before });
	                }
	                layer.onAdd(this.map);
	            }
	        }
	        else {
	            var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layer.getId(); });
	            var userLayerIndex = this.userLayers.findIndex(function (ul) { return ul.layer.getId() === layer.getId(); });
	            if (layerIndex >= 0 && userLayerIndex >= 0) {
	                // Replace the existing layer with the new one.
	                var tempLayer = this.layerIndex[layerIndex];
	                this._removeMapboxLayers(tempLayer);
	                this._addMapboxLayers(layer, layerIndex + 1);
	                this.map.events._disableLayerEvents(tempLayer);
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex[layerIndex] = layer;
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers[userLayerIndex] = { layer: layer, before: undefined };
	                }
	                tempLayer.onRemove();
	                layer.onAdd(this.map);
	            }
	            else {
	                // Add the layer to the top of the z-order.
	                this._addMapboxLayers(layer);
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex.push(layer);
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers.push({ layer: layer, before: before });
	                }
	                layer.onAdd(this.map);
	            }
	        }
	    };
	    /**
	     * Adds all the Mapbox layers built by an atlas layer to the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._addMapboxLayers = function (layer, before) {
	        var e_2, _a;
	        // if the TileLayer's tile URL isn't defined yet, don't add the source and layer.
	        if (layer instanceof TileLayer && !layer.getOptions().tileUrl) {
	            return;
	        }
	        // FundamentalMapLayers are a special case because they are created indirectly by StyleManager when mapbox
	        // loads a style by URL. When a FundamentalMapLayer is added to the LayerManager it is being done
	        // so to reflect layers that are already loaded in mapbox so they do not need to be added a second 
	        // time
	        if (layer instanceof FundamentalMapLayer) {
	            this.map.events._enableLayerEvents(layer);
	            return;
	        }
	        // SourceBuildingLayers are a special case because they create their own source and manage it internally.
	        // If adding a SourceBuildingLayer the source associated must also be added.
	        if (layer instanceof SourceBuildingLayer) {
	            this.map._getMap().addSource(layer._getSourceId(), layer._buildSource());
	            // we also need the abstraction for those source building layers added to the map if it is not already there
	            this.map.sources.setSourceState(layer._getSourceWrapper());
	        }
	        var mbBefore = this._getMapboxBefore(before);
	        try {
	            for (var _b = __values$8(layer._buildLayers()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayer = _c.value;
	                this.map._getMap().addLayer(mbLayer, mbBefore);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        this.map.events._enableLayerEvents(layer);
	    };
	    /**
	     * Removes all the Mapbox layers built by an atlas layer from the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._removeMapboxLayers = function (layer, force) {
	        var e_3, _a;
	        // FundamentalMapLayers are a special case because they are created indirectly by StyleManager when mapbox
	        // loads a style by URL. When a FundamentalMapLayer is removed from the LayerManager it is being done
	        // so to reflect layers that are already removed from mapbox so they do not need to be removed a second 
	        // time
	        if (layer instanceof FundamentalMapLayer && !force) {
	            this.map.events._disableLayerEvents(layer);
	            return;
	        }
	        try {
	            for (var _b = __values$8(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayerId = _c.value;
	                // Check if the layer does exist.
	                if (this.map._getMap().getLayer(mbLayerId)) {
	                    this.map._getMap().removeLayer(mbLayerId);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        this.map.events._disableLayerEvents(layer);
	        // SourceBuildingLayer are a special case because they create their own source and manage it internally.
	        // If removing a SourceBuildingLayer the source associated must also be removed.
	        if (layer instanceof SourceBuildingLayer &&
	            this.map._getMap().getSource(layer._getSourceId())) {
	            this.map._getMap().removeSource(layer._getSourceId());
	        }
	    };
	    /**
	     * Test if mapbox contains a mapbox.Layer defined in an atlas Layer.
	     *
	     * @param layer: Atlas layer or layerID to test.
	     * @returns True if layer exists in mapbox.
	     */
	    LayerManager.prototype._getMapboxLayerExists = function (layer) {
	        var _this = this;
	        var found = false;
	        if (typeof layer === "string") {
	            layer = this.layerIndex.find(function (l) { return l.getId() === layer; });
	            if (!layer) {
	                return false;
	            }
	            return true;
	        }
	        layer._getLayerIds().forEach(function (mbLayerId) {
	            var mbLayer = _this.map._getMap().getLayer(mbLayerId);
	            if (mbLayer)
	                found = true;
	        });
	        return found;
	    };
	    /**
	     * Gets the ID of the Mapbox layer to add before given the id of the atlas before layer.
	     * @private
	     */
	    LayerManager.prototype._getMapboxBefore = function (before) {
	        var e_4, _a, e_5, _b;
	        // If passed a string use it as the name of an atlas layer.
	        if (typeof before === "string") {
	            var beforeLayer = this.layerIndex.find(function (l) { return l.getId() === before; });
	            // If the before layer exists iterate over the mapbox layers
	            // it would build until a layer exists on the mapbox map.
	            if (beforeLayer) {
	                try {
	                    for (var _c = __values$8(beforeLayer._getLayerIds()), _d = _c.next(); !_d.done; _d = _c.next()) {
	                        var layerId = _d.value;
	                        if (this.map._getMap().getLayer(layerId)) {
	                            return layerId;
	                        }
	                    }
	                }
	                catch (e_4_1) { e_4 = { error: e_4_1 }; }
	                finally {
	                    try {
	                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                    }
	                    finally { if (e_4) throw e_4.error; }
	                }
	                // If none of the layers built by the specified before layer
	                // actually exists on the map start checking the next layers.
	                before = this.layerIndex.findIndex(function (l) { return l.getId() === before; }) + 1;
	            }
	            else {
	                // If the before layer hasn't been added just return undefined.
	                return undefined;
	            }
	        }
	        // If passed a number assume it is the index of the before layer.
	        // Or the string passed didn't lead to finding any existing mapbox layers.
	        //
	        // Iterate over all layers at or after the before index until one of
	        // the mapbox layers built by an atlas layer exists in the mapbox map.
	        for (var i = before; i < this.layerIndex.length; i++) {
	            try {
	                for (var _e = (e_5 = void 0, __values$8(this.layerIndex[i]._getLayerIds())), _f = _e.next(); !_f.done; _f = _e.next()) {
	                    var layerId = _f.value;
	                    if (this.map._getMap().getLayer(layerId)) {
	                        return layerId;
	                    }
	                }
	            }
	            catch (e_5_1) { e_5 = { error: e_5_1 }; }
	            finally {
	                try {
	                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                }
	                finally { if (e_5) throw e_5.error; }
	            }
	        }
	        // If nothing was found just return undefined.
	        return undefined;
	    };
	    /**
	     * Removes all layers from the map.
	     */
	    LayerManager.prototype.clear = function () {
	        for (var layerIndexIndex = this.layerIndex.length - 1; layerIndexIndex >= 0; layerIndexIndex--) {
	            var tempLayer = this.layerIndex[layerIndexIndex];
	            if (tempLayer) {
	                this._removeMapboxLayers(tempLayer, true);
	                this.layerIndex.splice(layerIndexIndex, 1);
	                tempLayer.onRemove();
	            }
	        }
	        this.userLayers = [];
	    };
	    /**
	     * Retrieves a layer with the specified id.
	     * @param id The id of the layer to retrieve.
	     */
	    LayerManager.prototype.getLayerById = function (id) {
	        var result = this.layerIndex.find(function (l) { return l.getId() === id; });
	        if (result)
	            return result;
	        return undefined;
	    };
	    /**
	     * Retrieves all layers that have been added to the map.
	     */
	    LayerManager.prototype.getLayers = function () {
	        return this.layerIndex.slice(0);
	    };
	    /**
	     * Returns a set of all the source IDs that any layers depend on.
	     * @internal
	     */
	    LayerManager.prototype._getSourceIds = function () {
	        var e_6, _a;
	        var ids = new Set();
	        try {
	            for (var _b = __values$8(this.layerIndex), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var layer = _c.value;
	                layer._getSourceIds().forEach(function (id) { return ids.add(id); });
	            }
	        }
	        catch (e_6_1) { e_6 = { error: e_6_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_6) throw e_6.error; }
	        }
	        return ids;
	    };
	    /**
	     *
	     * @returns Returns a set of all layers added through this SDK.
	     * @internal
	     */
	    LayerManager.prototype._getUserLayers = function () {
	        return Array.from(this.userLayers);
	    };
	    /**
	     * Moves a layer to a different z-position.
	     * @param layer The layer or id of the layer to move.
	     * @param before Optionally specify to move the layer before this.
	     */
	    LayerManager.prototype.move = function (layer, before) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        var beforeId = before instanceof Layer ? before.getId() : before;
	        if (!this.layerIndex.find(function (l) { return l.getId() === layerId; })) {
	            throw new Error("The layer '".concat(layerId, "' has not been added to the map and cannot be moved."));
	        }
	        var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	        this._moveMapboxLayers(this.layerIndex[layerIndex], beforeId);
	        layer = this.layerIndex[layerIndex];
	        this.layerIndex.splice(layerIndex, 1);
	        var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === beforeId; });
	        if (beforeIndex > -1) {
	            this.layerIndex.splice(beforeIndex, 0, layer);
	        }
	        else {
	            this.layerIndex.push(layer);
	        }
	        // Update before property of the user layer
	        var userLayer = this.userLayers.find(function (ul) { return ul.layer.getId() === layerId; });
	        if (userLayer) {
	            userLayer.before = beforeId;
	        }
	    };
	    LayerManager.prototype._moveMapboxLayers = function (layer, before) {
	        var e_7, _a;
	        var mbBefore = this._getMapboxBefore(before);
	        try {
	            for (var _b = __values$8(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayerId = _c.value;
	                this.map._getMap().moveLayer(mbLayerId, mbBefore);
	            }
	        }
	        catch (e_7_1) { e_7 = { error: e_7_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_7) throw e_7.error; }
	        }
	    };
	    /**
	        * Retrieve all Shapes and GeoJSON features that are visible on the map that are in a DataSource or VectorTileSource.
	        * Shape objects are editable, while Feature objects are not editable and either reside in a VectorTileSource or represent a cluster point.
	        * Clusters have the following properties:<br />
	        * `cluster`: `boolean` - Indicates that the point is a cluster.
	        * This will be set to true if Point object represents a cluster.
	        * All other point objects are unlikely to have this value unless
	        * a property with this same name was added to the Point property data from your app.<br />
	        * `cluster_id`: `string` - A unique id for the cluster.<br />
	        * `point_count`: `number` - The number of points inside the cluster.<br />
	        * `point_count_abbreviated`: `string` - An abbreviated string version of the point count. i.e. `"10K"`<br />
	        * Features/Shapes that are not visible or who's layer zoom range does not include the current zoom level will not be returned.
	        * Symbol features/Shapes that have been hidden due to text or icon collisions are not included.
	        * Features/Shapes from all other layers are included even if they have no contribution to the map rendering, e.g. alpha set to zero.
	        * The topmost rendered features/shapes appears first in the returned array and subsequent features are sorted in descending z-order.
	        * @param geometry A Position, Point, or BoundingBox that returned features must intersect. If not specified the whole visible world is used.
	        * @param layers An array of layers or their ids to limit the query to.
	        * @param filter A expression to filter the returned features by.
	        */
	    LayerManager.prototype.getRenderedShapes = function (geometry, layers, filter) {
	        var e_8, _a;
	        var _this = this;
	        // If no geometry was provided use a bounding box covering the whole world.
	        if (!geometry) {
	            geometry = [-180, -85.0511, 180, 85.0511];
	        }
	        // Mapbox's queryRenderedFeatures uses screen coordinates not GeoJSON positions.
	        // Here we convert the input bounding box or point into screen coordinates.
	        var scope;
	        if (Array.isArray(geometry)) {
	            if (geometry.length === 4 || geometry.length === 6) {
	                // BoundingBox has length of 4 or 6: [west, south, east, north] or [west, south, elevation1, east, north, elevation2]
	                scope = this.map.positionsToPixels([
	                    BoundingBox.getSouthWest(geometry),
	                    BoundingBox.getNorthEast(geometry)
	                ]);
	            }
	            else if (geometry.length === 2 || geometry.length === 3) {
	                // Position has length of 2, or 3: [lon, lat] or [lon, lat, elv]
	                scope = this.map.positionsToPixels([geometry])[0];
	            }
	        }
	        else {
	            scope = this.map.positionsToPixels([geometry.coordinates])[0];
	        }
	        // Create an array of all the mapbox layer ids that make up the layers specified by the user.
	        // Skip any mapbox layer ids that don't currently exist in the mapbox style.
	        var layerIds;
	        if (layers) {
	            layers = Array.isArray(layers) ? layers : [layers];
	            layerIds = [];
	            var _loop_1 = function (layer) {
	                var layerId = layer instanceof Layer ? layer.getId() : layer;
	                // If a specified layer hasn't been added to the map throw an error.
	                var index = this_1.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	                if (index > -1) {
	                    layerIds.push.apply(layerIds, __spreadArray$6([], __read$6(this_1.layerIndex[index]._getLayerIds()
	                        .filter(function (id) { return !!_this.map._getMap().getLayer(id); })), false));
	                }
	                else {
	                    throw new Error("The layer '".concat(layerId, "' has not been added to the map ") +
	                        "and its rendered features cannot be retrieved.");
	                }
	            };
	            var this_1 = this;
	            try {
	                for (var layers_1 = __values$8(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
	                    var layer = layers_1_1.value;
	                    _loop_1(layer);
	                }
	            }
	            catch (e_8_1) { e_8 = { error: e_8_1 }; }
	            finally {
	                try {
	                    if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return)) _a.call(layers_1);
	                }
	                finally { if (e_8) throw e_8.error; }
	            }
	        }
	        // Use queryRenderedFeatures to get a basic list of the features
	        // within the scope and belonging to the specified layers.
	        var features = this.map._getMap().queryRenderedFeatures(scope, {
	            layers: layerIds,
	            filter: filter
	        });
	        // Any features belonging to a DataSource will be mapped to the Shapes that wrap them.
	        return this.map.sources._mapFeaturesToShapes(features);
	    };
	    LayerManager.prototype.remove = function (layer) {
	        var e_9, _a;
	        if (Array.isArray(layer)) {
	            try {
	                for (var layer_2 = __values$8(layer), layer_2_1 = layer_2.next(); !layer_2_1.done; layer_2_1 = layer_2.next()) {
	                    var singleLayer = layer_2_1.value;
	                    this._removeLayer(singleLayer);
	                }
	            }
	            catch (e_9_1) { e_9 = { error: e_9_1 }; }
	            finally {
	                try {
	                    if (layer_2_1 && !layer_2_1.done && (_a = layer_2.return)) _a.call(layer_2);
	                }
	                finally { if (e_9) throw e_9.error; }
	            }
	        }
	        else {
	            this._removeLayer(layer);
	        }
	    };
	    /**
	     * Removes a single layer from the map.
	     * @private
	     */
	    LayerManager.prototype._removeLayer = function (layer) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	        if (layerIndex == -1) {
	            throw new Error("The layer '".concat(layerId, "' has not been added to the map and cannot be removed."));
	        }
	        var tempLayer = this.layerIndex[layerIndex];
	        this._removeMapboxLayers(tempLayer);
	        this.layerIndex.splice(layerIndex, 1);
	        var userLayerIndex = this.userLayers.findIndex(function (ul) { return ul.layer.getId() === layerId; });
	        if (userLayerIndex != -1) {
	            this.userLayers.splice(userLayerIndex, 1);
	        }
	        if (layer instanceof SourceBuildingLayer) {
	            this.map.sources.unsetSourceState(layer._getSourceId());
	        }
	        tempLayer.onRemove();
	    };
	    return LayerManager;
	}());

	var __values$7 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's popups.
	 * Exposed through the `popups` property of the `atlas.Map` class.
	 * Cannot be instantiated by the user.
	 */
	var PopupManager = /** @class */ (function () {
	    /**
	     * Constructs the popup manager to be exposed only through the `popups` property of the `Map` class.
	     * @param map The map whose popups are being managed by this.
	     * @internal
	     */
	    function PopupManager(map) {
	        var _this = this;
	        /**
	         * Listens for mouse or touch movement when dragging popups.
	         */
	        this._onDrag = function (event) {
	            // Determine the new x and y from the event data.
	            var x;
	            var y;
	            if (event.type === "mousemove") {
	                event = event;
	                x = event.clientX;
	                y = event.clientY;
	            }
	            else if (event.type === "touchmove") {
	                event = event;
	                x = event.touches[0].clientX;
	                y = event.touches[0].clientY;
	            }
	            _this.draggedPopups.forEach(function (popup) {
	                popup._dragToPixel([x, y]);
	            });
	        };
	        /**
	         * Listens for mouse up or touch end to indicate popups aren't being dragged anymore.
	         */
	        this._onUp = function () {
	            // Remove the listeners since no popups are being dragged anymore.
	            _this.map.getMapContainer().removeEventListener("mousemove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("touchmove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("mouseup", _this._onUp);
	            _this.map.getMapContainer().removeEventListener("touchend", _this._onUp);
	            _this.draggedPopups.forEach(function (popup) {
	                _this.draggedPopups.delete(popup);
	                popup._onUp();
	            });
	        };
	        this.map = map;
	        this.popups = new Set();
	        this.draggedPopups = new Set();
	    }
	    /**
	     * Adds a popup to the map
	     * @param popup The popup(s) to add.
	     */
	    PopupManager.prototype.add = function (popup) {
	        var e_1, _a;
	        popup = Array.isArray(popup) ? popup : [popup];
	        try {
	            for (var popup_1 = __values$7(popup), popup_1_1 = popup_1.next(); !popup_1_1.done; popup_1_1 = popup_1.next()) {
	                var p = popup_1_1.value;
	                if (!this.popups.has(p)) {
	                    this.popups.add(p);
	                    p.attach(this.map);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (popup_1_1 && !popup_1_1.done && (_a = popup_1.return)) _a.call(popup_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * Removes all popups from the map.
	     */
	    PopupManager.prototype.clear = function () {
	        var _this = this;
	        this.popups.forEach(function (popup) {
	            _this.popups.delete(popup);
	            popup.remove();
	        });
	    };
	    /**
	     * Removes a popup from the map
	     * @param popup The popup(s) to remove.
	     */
	    PopupManager.prototype.remove = function (popup) {
	        var e_2, _a;
	        popup = Array.isArray(popup) ? popup : [popup];
	        try {
	            for (var popup_2 = __values$7(popup), popup_2_1 = popup_2.next(); !popup_2_1.done; popup_2_1 = popup_2.next()) {
	                var p = popup_2_1.value;
	                if (this.popups.has(p)) {
	                    this.popups.delete(p);
	                    p.remove();
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (popup_2_1 && !popup_2_1.done && (_a = popup_2.return)) _a.call(popup_2);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	    };
	    /**
	     * Returns the popups currently attached to the map.
	     */
	    PopupManager.prototype.getPopups = function () {
	        return Array.from(this.popups);
	    };
	    /**
	     * Returns the div element that should contain all the popup containers.
	     * Creates it if it doesn't already exist.
	     * @internal
	     */
	    PopupManager.prototype._getCollectionDiv = function () {
	        var collection = this.map.getMapContainer()
	            .querySelector(".".concat(PopupManager.Css.collection));
	        if (!collection) {
	            // If the collection div doesn't exist create it.
	            collection = document.createElement("div");
	            collection.classList.add(PopupManager.Css.collection);
	            collection.setAttribute("aria-label", "Map Information");
	            this.map.getMapContainer().appendChild(collection);
	        }
	        return collection;
	    };
	    /**
	     * Adds a popup to the set of popups actively being dragged.
	     * @internal
	     */
	    PopupManager.prototype._addDraggedPopup = function (popup) {
	        // If no popups are being dragged yet add the listeners.
	        if (this.draggedPopups.size === 0) {
	            this.map.getMapContainer().addEventListener("mousemove", this._onDrag);
	            this.map.getMapContainer().addEventListener("touchmove", this._onDrag);
	            this.map.getMapContainer().addEventListener("mouseup", this._onUp);
	            this.map.getMapContainer().addEventListener("touchend", this._onUp);
	        }
	        // Track the popups being dragged for the mousemove events.
	        this.draggedPopups.add(popup);
	    };
	    PopupManager.Css = {
	        collection: "popup-collection-container"
	    };
	    return PopupManager;
	}());

	var __values$6 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's sources.
	 * Exposed through the sources property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var SourceManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function SourceManager(map) {
	        this.map = map;
	        this.sources = new Dictionary();
	    }
	    SourceManager.prototype.add = function (source, update) {
	        var e_1, _a;
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            try {
	                for (var source_1 = __values$6(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
	                    var singleSource = source_1_1.value;
	                    this._addSource(singleSource, update);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addSource(source, update);
	        }
	    };
	    /**
	     * Returns all rendered shape features in a source that match a specified filter. If the source is a vector tile source, a source layer name needs to be specified.
	     * @param source source to be queried
	     * @param filter a filter to limit the query
	     * @param sourceLayer the layer where shapes and features are matched
	     */
	    SourceManager.prototype.getRenderedShapes = function (source, filter, sourceLayer) {
	        var sourceID = typeof source === "string" ? source : source.getId();
	        var features = this.map._getMap().querySourceFeatures(sourceID, { sourceLayer: sourceLayer, filter: filter });
	        return this.map.sources._mapFeaturesToShapes(features, true, this.sources.get(sourceID));
	    };
	    /**
	     * Gets the state of a feature
	     * @param feature the ID of the feature
	     * @param source the ID of the source
	     * @param sourceLayer the ID of the layer
	     */
	    SourceManager.prototype.getFeatureState = function (feature, source, sourceLayer) {
	        var featureId;
	        if (typeof feature === "string") {
	            featureId = feature;
	        }
	        else {
	            featureId = feature instanceof Shape ? feature.getId() : feature.id;
	        }
	        var featureSource = typeof source === "string" ? source : source.getId();
	        return this.map._getMap().getFeatureState({ id: featureId, source: featureSource, sourceLayer: sourceLayer });
	    };
	    /**
	     * Removes the state or a single key value of the state of a feature.
	     * @param feature the ID of the feature
	     * @param source the ID of the source
	     * @param sourceLayer the ID of the layer
	     * @param key the key in the feature state to update
	     */
	    SourceManager.prototype.removeFeatureState = function (feature, source, sourceLayer, key) {
	        var featureId;
	        if (typeof feature === "string") {
	            featureId = feature;
	        }
	        else {
	            featureId = feature instanceof Shape ? feature.getId() : feature.id;
	        }
	        var featureSource = typeof source === "string" ? source : source.getId();
	        this.map._getMap().removeFeatureState({ id: featureId, source: featureSource, sourceLayer: sourceLayer }, key);
	    };
	    /**
	     * Sets the state of the feature by passing in a key value pair object.
	     * @param feature the ID of the feature
	     * @param source the ID of the source
	     * @param sourceLayer the ID of the layer
	     * @param key the key in the feature state to update
	     */
	    SourceManager.prototype.setFeatureState = function (feature, source, state, sourceLayer) {
	        var featureId;
	        if (typeof feature === "string") {
	            featureId = feature;
	        }
	        else {
	            featureId = feature instanceof Shape ? feature.getId() : feature.id;
	        }
	        var featureSource = typeof source === "string" ? source : source.getId();
	        this.map._getMap().setFeatureState({ id: featureId, source: featureSource, sourceLayer: sourceLayer }, state);
	    };
	    /**
	     * @internal
	     */
	    SourceManager.prototype._buildSources = function () {
	        var ret = {};
	        this.sources.forEach(function (source) {
	            ret[source.getId()] = source._buildSource();
	        });
	        return ret;
	    };
	    /**
	     * Removes all sources from the map.
	     */
	    SourceManager.prototype.clear = function () {
	        var _this = this;
	        this.sources.forEach(function (source) {
	            _this.remove(source);
	        });
	    };
	    /**
	     * Retrieves a source with the specified id.
	     * @param id
	     */
	    SourceManager.prototype.getById = function (id) {
	        return this.sources.get(id);
	    };
	    /**
	     * Retrieves all sources that have been added to the map.
	     */
	    SourceManager.prototype.getSources = function () {
	        return Array.from(this.sources.values());
	    };
	    /**
	     * Returns a boolean indicating if the source is loaded or not.
	     * @param source The id of a source or a Source object.
	     */
	    SourceManager.prototype.isSourceLoaded = function (source) {
	        var id = source instanceof Source ? source.getId() : source;
	        return this.map._getMap().isSourceLoaded(id);
	    };
	    SourceManager.prototype.remove = function (source, update) {
	        var e_2, _a;
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            try {
	                for (var source_2 = __values$6(source), source_2_1 = source_2.next(); !source_2_1.done; source_2_1 = source_2.next()) {
	                    var singleSource = source_2_1.value;
	                    this._removeSource(singleSource, update);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (source_2_1 && !source_2_1.done && (_a = source_2.return)) _a.call(source_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._removeSource(source, update);
	        }
	    };
	    /**
	     * @internal
	     */
	    SourceManager.prototype.setSourceState = function (newSource, shouldInvokeAddEvent) {
	        if (shouldInvokeAddEvent === void 0) { shouldInvokeAddEvent = true; }
	        this.sources.set(newSource.getId(), newSource);
	        newSource._setMap(this.map, shouldInvokeAddEvent);
	    };
	    /**
	     * @internal
	     */
	    SourceManager.prototype.unsetSourceState = function (id) {
	        if (this.sources.has(id)) {
	            this.sources.get(id)._setMap(null);
	            this.sources.delete(id);
	        }
	    };
	    SourceManager.prototype._removeSource = function (source, update) {
	        var id = source instanceof Source ? source.getId() : source;
	        if (this.sources.has(id)) {
	            if (this.map._getMap().getSource(id) && update) {
	                this.map._getMap().removeSource(id);
	            }
	            if (!this.map._getMap().getSource(id) || !update) {
	                this.unsetSourceState(id);
	            }
	            else {
	                throw new Error("One or more layers have a dependency on the source '".concat(id, "'"));
	            }
	            return;
	        }
	        throw new Error("'".concat(id, "' is not added to the map"));
	    };
	    SourceManager.prototype._addSource = function (source, update) {
	        // If adding a source that shares an id with an existing source throw an error unless update is false.
	        // Update being false assumes that a call to map.setStyle(...) will occurs soon.
	        if (this.sources.has(source.getId())) {
	            if (update) {
	                throw new Error("'".concat(source.getId(), "' is already added to the map"));
	            }
	            else {
	                this.unsetSourceState(source.getId());
	            }
	        }
	        if (update) {
	            // Check if the map is ready before adding any sources.
	            if (!this.map._isReady()) {
	                throw new Error("The source '".concat(source.getId(), "' could not be added to the map because ") +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before adding a source to it.");
	            }
	            this.map._getMap().addSource(source.getId(), source._buildSource());
	        }
	        this.setSourceState(source);
	    };
	    /**
	     * Converts an array of features as returned by one of Mapbox's query*Features(...) function
	     * to an array of our features or shapes if one is currently wrapping the feature.
	     * @internal
	     */
	    SourceManager.prototype._mapFeaturesToShapes = function (features, shapesOnly, dataSource) {
	        var e_3, _a;
	        var shapesOrFeatures = [];
	        try {
	            for (var features_1 = __values$6(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
	                var feature = features_1_1.value;
	                if ((dataSource || typeof feature["source"] === "string") &&
	                    typeof feature.properties[Shape._shapeIdPropName] === "string") {
	                    var source = dataSource || this.sources.get(feature["source"]);
	                    if (source instanceof DataSource) {
	                        var shape = source.getShapeById(feature.properties[Shape._shapeIdPropName]);
	                        if (shape instanceof Shape) {
	                            shapesOrFeatures.push(shape);
	                            continue;
	                        }
	                    }
	                }
	                if (!shapesOnly) {
	                    // If the feature couldn't be matched to a shape in a DataSource
	                    // just return the feature data as provided by mapbox.
	                    shapesOrFeatures.push(feature);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return shapesOrFeatures;
	    };
	    /**
	     * Sync SourceManager with mapbox sources.
	     * This function is responsible for creating wrappers for mapbox sources
	     * and setting the approperiate sourceManager state with them
	     * @internal
	     */
	    SourceManager.prototype._syncSources = function (sources) {
	        var _this = this;
	        if (!sources) {
	            console.warn('syncSources called with no style sources which is unexpected.');
	            return;
	        }
	        // 1. add / update the source wrappers
	        Object.keys(sources)
	            .map(function (sourceId) {
	            var sourceToAdd = sources[sourceId];
	            var newSource;
	            switch (sourceToAdd.type) {
	                case 'vector':
	                case 'raster':
	                case 'raster-dem': {
	                    newSource = new FundamentalMapSource(sourceId, {
	                        name: sourceId,
	                        tiles: sourceToAdd.tiles,
	                        type: sourceToAdd.type,
	                        url: sourceToAdd.url,
	                        tileSize: 'tileSize' in sourceToAdd ? sourceToAdd.tileSize : undefined
	                    });
	                    break;
	                }
	                case 'canvas': {
	                    newSource = new CanvasSource(sourceId, sourceToAdd);
	                    break;
	                }
	                case 'geojson': {
	                    var dataSource = new DataSource(sourceId, {
	                        maxZoom: sourceToAdd.maxzoom,
	                        cluster: sourceToAdd.cluster,
	                        clusterRadius: sourceToAdd.clusterRadius,
	                        tolerance: sourceToAdd.tolerance,
	                        lineMetrics: sourceToAdd.lineMetrics,
	                        clusterProperties: sourceToAdd.clusterProperties,
	                        buffer: sourceToAdd.buffer,
	                        clusterMinPoints: sourceToAdd.clusterMinPoints,
	                        generateId: sourceToAdd.generateId,
	                        promoteId: sourceToAdd.promoteId,
	                        filter: sourceToAdd.filter,
	                        // attribution?: sourceToAdd.attribution
	                    });
	                    if (typeof sourceToAdd.data !== 'string' && sourceToAdd.data !== undefined) {
	                        dataSource._addNoUpdate(sourceToAdd.data);
	                    }
	                    newSource = dataSource;
	                    break;
	                }
	                case 'image': {
	                    newSource = new ImageSource(sourceId, sourceToAdd);
	                    break;
	                }
	                case 'video': {
	                    newSource = new VideoSource(sourceId, sourceToAdd);
	                    break;
	                }
	                default: {
	                    newSource = new UnknownSource(sourceId, sourceToAdd);
	                }
	            }
	            return newSource;
	        }).forEach(function (newSource) {
	            // use deep equality of underlying maplibre sources to determine if the source has been updated or overriden on style update
	            var existing = _this.sources.get(newSource.getId());
	            var isUpdate = existing && newSource._isDeepEqual(existing);
	            if (!isUpdate && existing) {
	                _this.unsetSourceState(existing.getId());
	            }
	            _this.setSourceState(newSource, !isUpdate);
	        });
	        // 2. remove the source wrappers that are not in the style
	        Array.from(this.sources.keys())
	            .filter(function (sourceId) { return !(sourceId in sources); })
	            .forEach(function (sourceId) { return _this.unsetSourceState(sourceId); });
	    };
	    return SourceManager;
	}());

	var __extends$d = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for animating changes to the map control's camera.
	 */
	var AnimationOptions = /** @class */ (function (_super) {
	    __extends$d(AnimationOptions, _super);
	    function AnimationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The duration of the animation in milliseconds.
	         * Default `1000`.
	         * @default 1000
	         */
	        _this.duration = 1000;
	        /**
	         * The type of animation.<br />
	         * `"jump"` is an immediate change.<br />
	         * `"ease"` is a gradual change of the camera's settings.<br />
	         * `"fly"` is a gradual change of the camera's settings following an arc resembling flight.<br />
	         * Default `"jump"`.
	         * @default "jump"
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        _this.type = "jump";
	        return _this;
	    }
	    return AnimationOptions;
	}(Options));

	var __extends$c = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represent the amount of padding in pixels to add to the side of a BoundingBox when setting the camera of a map.
	 */
	var Padding = /** @class */ (function (_super) {
	    __extends$c(Padding, _super);
	    function Padding() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Amount of padding in pixels to add to the bottom.
	         * default `0`
	         * @default 0
	         */
	        _this.bottom = 0;
	        /**
	         * Amount of padding in pixels to add to the left.
	         * default `0`
	         * @default 0
	         */
	        _this.left = 0;
	        /**
	         * Amount of padding in pixels to add to the right.
	         * default `0`
	         * @default 0
	         */
	        _this.right = 0;
	        /**
	         * Amount of padding in pixels to add to the top.
	         * default `0`
	         * @default 0
	         */
	        _this.top = 0;
	        return _this;
	    }
	    return Padding;
	}(Options));

	var __extends$b = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$5 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$5 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$5 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * The options for setting the bounds of the map control's camera.
	 */
	var CameraBoundsOptions = /** @class */ (function (_super) {
	    __extends$b(CameraBoundsOptions, _super);
	    function CameraBoundsOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The bounds of the map control's camera.
	         * Default `[-180, -89, 180, 90]`.
	         * @default [-180, -89, 180, 90]
	         */
	        _this.bounds = [-180, -89, 180, 90];
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        /**
	         * The maximum zoom level to allow when the map view transitions to the specified bounds.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * An offset of the center of the given bounds relative to the map's center, measured in pixels.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * The amount of padding in pixels to add to the given bounds.
	         * Default `{top: 0, bottom: 0, left: 0, right: 0}`.
	         * @default {top: 0, bottom: 0, left: 0, right: 0}
	         */
	        _this.padding = new Padding();
	        return _this;
	    }
	    /**
	     * overwriting merge to accept one value for padding
	     */
	    CameraBoundsOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        try {
	            for (var valuesList_1 = __values$5(valuesList), valuesList_1_1 = valuesList_1.next(); !valuesList_1_1.done; valuesList_1_1 = valuesList_1.next()) {
	                var value = valuesList_1_1.value;
	                if (value && typeof value.padding === "number") {
	                    value.padding = {
	                        top: value.padding,
	                        bottom: value.padding,
	                        left: value.padding,
	                        right: value.padding
	                    };
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valuesList_1_1 && !valuesList_1_1.done && (_a = valuesList_1.return)) _a.call(valuesList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return _super.prototype.merge.apply(this, __spreadArray$5([], __read$5(valuesList), false));
	    };
	    return CameraBoundsOptions;
	}(Options));

	var __extends$a = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for setting the map control's camera.
	 */
	var CameraOptions = /** @class */ (function (_super) {
	    __extends$a(CameraOptions, _super);
	    function CameraOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The zoom level of the map view.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoom = 1;
	        /**
	         * The position to align the center of the map view with.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.center = new Position(0, 0);
	        /**
	         * A pixel offset to apply to the center of the map.
	         * This is useful if you want to programmatically pan the map to another location or if you want to center the map over a shape, then offset the maps view to make room for a popup.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.centerOffset = new Pixel(0, 0);
	        /**
	         * The bearing of the map (rotation) in degrees. When the bearing is 0, 90, 180, or 270 the top of the map container will be north, east, south or west respectively.
	         * Default `0`.
	         * @default 0
	         */
	        _this.bearing = 0;
	        /**
	         * The pitch (tilt) of the map in degrees between 0 and 60, where 0 is looking straight down on the map.
	         * Default `0`.
	         * @default 0
	         */
	        _this.pitch = 0;
	        /**
	         * The minimum zoom level that the map can be zoomed out to during the animation. Must be between 0 and 24, and less than or equal to `maxZoom`.
	         * Setting `minZoom` below 1 may result in an empty map when the zoom level is less than 1.
	         * Default `1`.
	         * @default 1
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom level that the map can be zoomed into during the animation. Must be between 0 and 24, and greater than or equal to `minZoom`.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * The minimum pitch that the map can be pitched to during the animation. Must be between 0 and 85, and less than or equal to `maxPitch`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minPitch = 0;
	        /**
	         * The maximum pitch that the map can be pitched to during the animation. Must be between 0 and 85, and greater than or equal to `minPitch`
	         * Default `60`.
	         * @default 60
	         */
	        _this.maxPitch = 60;
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        return _this;
	    }
	    return CameraOptions;
	}(Options));

	var __extends$9 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a layer of the map.
	 */
	var LayerOptions = /** @class */ (function (_super) {
	    __extends$9(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = undefined;
	        /**
	         * The name of the layer to place this layer before.  If not specified, the layer will be placed at the top of the
	         * layer list.
	         */
	        _this.before = undefined;
	        /**
	         * The minimum zoom at which the layer will display inclusive.
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom at which the layer will display inclusive.
	         */
	        _this.maxZoom = 20;
	        /**
	         * Whether to overwrite previous data for the layer.
	         */
	        _this.overwrite = false;
	        /**
	         * The opacity of the layer.
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return LayerOptions;
	}(Options));

	var __extends$8 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a circle layer.
	 * @deprecated Use BubbleLayerOptions with atlas.layer.BubbleLayer instead.
	 */
	var CircleLayerOptions = /** @class */ (function (_super) {
	    __extends$8(CircleLayerOptions, _super);
	    function CircleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the circles for the layer. Is used as the default if a fill color is not specified for a
	         * circle.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the circles for the layer. Is used as the default if an outline color is not specified for
	         * a circle.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The radius in pixels of the circles for the layer. Is used as the default if a radius is not specified for a
	         * circle.
	         */
	        _this.radius = 1;
	        /**
	         * The outline stroke width of the circles for the layer. Is used as the default if outline width is not specified
	         * for a circle.
	         */
	        _this.outlineWidth = 5;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-circles";
	        return _this;
	    }
	    return CircleLayerOptions;
	}(LayerOptions));

	var __extends$7 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a linestring layer.
	 * @deprecated Use LineLayerOptions with atlas.layer.LineLayer instead.
	 */
	var LinestringLayerOptions = /** @class */ (function (_super) {
	    __extends$7(LinestringLayerOptions, _super);
	    function LinestringLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of cap to use for the ends of the linestrings:
	         * <p>"butt" is a squared ending that is drawn to the exact endpoint of the line.</p>
	         * <p>"round" is a circular ending that is drawn past the exact endpoint with a radius of half the linestring's
	         * width.</p>
	         * <p>"square" is a squared ending that is drawn past the exact endpoint by half the linestring's width.
	         */
	        _this.cap = "butt";
	        /**
	         * The type of join to use for the linestrings:
	         * <p>"bevel" is a squared join that cuts a corner flat at half the linestring's width from the vertex.</p>
	         * <p>"round" is a circular join that rounds a corner with a radius of half the linestring's width from the
	         * vertex.</p>
	         * <p>"miter" is a sharp join that extends the segments of the linestring past the vertex until they intersect.</p>
	         */
	        _this.join = "miter";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-linestrings";
	        /**
	         * The color of the lines for the layer. Is used as the default if a specific color is not specified for a line.
	         */
	        _this.color = "#000";
	        /**
	         * The width of the lines for the layer. Is used as the default if a specific width is not specified for a line.
	         */
	        _this.width = 1;
	        return _this;
	    }
	    return LinestringLayerOptions;
	}(LayerOptions));

	var __extends$6 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a pin layer.
	 * @deprecated Use SymbolLayerOptions with atlas.layer.SymbolLayer instead.
	 */
	var PinLayerOptions = /** @class */ (function (_super) {
	    __extends$6(PinLayerOptions, _super);
	    function PinLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The factor by which the icon should be scaled. A value of 1 is the original size; a value of 2 will double the
	         * size of the icon.
	         */
	        _this.iconSize = 1;
	        /**
	         * The size of the title text.
	         */
	        _this.fontSize = 14;
	        /**
	         * The color of the title text.
	         */
	        _this.fontColor = "#000";
	        /**
	         * The font for the title of the pin.
	         */
	        _this.textFont = "SegoeUi-Regular";
	        /**
	         * Whether the icons should cluster when they collide on the map, or stay separate.
	         */
	        _this.cluster = true;
	        /**
	         * The icon to use to represent a cluster.
	         */
	        _this.clusterIcon = undefined;
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the title text should be
	         * offset. Negative numbers can be used to offset the title left and up.
	         */
	        _this.textOffset = [0, 0];
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-pins";
	        /**
	         * The icon of the pins for the layer. Is used as the default if an icon is not specified for a pin.
	         */
	        _this.icon = "pin-darkblue";
	        /**
	         * The title of the pins for the layer. Is used as the default if a title is not specified for a pin.
	         */
	        _this.title = "";
	        return _this;
	    }
	    return PinLayerOptions;
	}(LayerOptions));

	var __extends$5 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a polygon layer.
	 * @deprecated Use new PolygonLayerOptions with atlas.layer.PolygonLayer instead.
	 */
	var PolygonLayerOptions = /** @class */ (function (_super) {
	    __extends$5(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the polygons for the layer. Is used as the default if a fill color is not specified for a
	         * polygon.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the polygons for the layer. Is used as the default if an outline color is not specified for
	         * a polygon.
	         * @deprecated Use `atlas.layer.LineLayer` to provide an outline for a polygon.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-polygons";
	        return _this;
	    }
	    return PolygonLayerOptions;
	}(LayerOptions));

	var __extends$4 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a raster layer.
	 * @deprecated Use TileLayerOptions with atlas.layer.TileLayer instead.
	 */
	var RasterLayerOptions = /** @class */ (function (_super) {
	    __extends$4(RasterLayerOptions, _super);
	    function RasterLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-raster";
	        return _this;
	    }
	    return RasterLayerOptions;
	}(LayerOptions));

	var __extends$3 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for the map's lighting.
	 */
	var LightOptions = /** @class */ (function (_super) {
	    __extends$3(LightOptions, _super);
	    function LightOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies wether extruded geometries are lit relative to the map or viewport.
	         * Supported values:<br />
	         * `"map"`: The position of the light source is aligned to the rotation of the map.<br />
	         * `"viewport"`: The position fo the light source is aligned to the rotation of the viewport.<br />
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.anchor = "map";
	        /**
	         * Color tint for lighting extruded geometries.
	         * Default: `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.color = "#FFFFFF";
	        /**
	         * Intensity of lighting (on a scale from 0 to 1).
	         * Higher numbers will present as more extreme contrast.
	         * Default `0.5`
	         * @default 0.5
	         */
	        _this.intensity = 0.5;
	        /**
	         * Position of the light source relative to lit (extruded) geometries,
	         * in [r radial coordinate, a azimuthal angle, p polar angle]
	         * where r indicates the distance from the center of the base of an object to its light,
	         * a indicates the position of the light relative to 0°
	         * (0° when `anchor` is set to viewport corresponds to the top of the viewport,
	         * or 0° when `anchor` is set to map corresponds to due north, and degrees proceed clockwise),
	         * and p indicates the height of the light (from 0°, directly above, to 180°, directly below).
	         */
	        _this.position = [1.15, 210, 30];
	        return _this;
	    }
	    return LightOptions;
	}(Options));

	var __extends$2 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$4 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$4 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$4 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * The options for the map's style.
	 */
	var StyleOptions = /** @class */ (function (_super) {
	    __extends$2(StyleOptions, _super);
	    function StyleOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * If true, the gl context will be created with MSAA antialiasing, which can be useful for antialiasing WebGL layers.
	         */
	        _this.antialias = undefined;
	        /**
	         * If true the map will automatically resize whenever the window's size changes.
	         * Otherwise map.resize() must be called.
	         * Default `true`.
	         * @default true
	         */
	        _this.autoResize = true;
	        /**
	         * The language of the map labels.
	         * [Supported language]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages}.
	         * Default `atlas.getLanguage()`.
	         * @default atlas.getLanguage()
	         */
	        _this.language = getLanguage();
	        /**
	         * Sets the lighting options of the map.
	         */
	        _this.light = new LightOptions();
	        /**
	         * If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL().
	         * This option may only be set when initializing the map.
	         * Default `false`
	         * @default false
	         */
	        _this.preserveDrawingBuffer = false;
	        /**
	         * If true, the map will try to defer non-essential map layers and show essential layers as early as possible.
	         * This option may only be set when initializing the map.
	         * Default `false`
	         * @default false
	         */
	        _this.progressiveLoading = false;
	        /**
	         * The list of layer groups to be loaded at the initial stage. Passing an empty array will disable the progressive loading.
	         * This option may only be set when initializing the map.
	         * Default `['base']`
	         * @default ['base']
	         */
	        _this.progressiveLoadingInitialLayerGroups = ['base'];
	        /**
	         * Specifies if multiple copies of the world should be rendered when zoomed out.
	         * Default `true`
	         * @default true
	         */
	        _this.renderWorldCopies = true;
	        /**
	         * Specifies if buildings will be rendered with their models.
	         * If false all buildings will be rendered as just their footprints.
	         * Default `false`
	         * @default false
	         * @deprecated
	         */
	        _this.showBuildingModels = false;
	        /**
	         * Specifies if the feedback link should be displayed on the map or not.
	         * Default `true`
	         * @default true
	         */
	        _this.showFeedbackLink = true;
	        /**
	         * Specifies if the Microsoft logo should be hidden or not.
	         * If set to true a Microsoft copyright string will be added to the map.
	         * Default `true`
	         * @default true
	         */
	        _this.showLogo = true;
	        /**
	         * Specifies if the map should display labels
	         * @default true
	         */
	        _this.showLabels = true;
	        /**
	         * Additional custom attribution appended to map attribution.
	         * Default `undefined`
	         * @default undefined
	         */
	        _this.customAttribution = undefined;
	        /**
	         * Specifies if the map should render an outline around each tile and the tile ID.
	         * These tile boundaries are useful for debugging.
	         * The uncompressed file size of the first vector source is drawn in the top left corner of each tile,
	         * next to the tile ID.
	         * Default `false`
	         * @default false
	         */
	        _this.showTileBoundaries = false;
	        /**
	         * The name of the style to use when rendering the map. Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article.
	         * The default style is defined in the style set.
	         * @default undefined
	         */
	        _this.style = undefined;
	        /**
	         * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	         * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews}
	         * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country/region where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	         * default: `undefined`
	         * @default undefined
	         */
	        _this.view = getView();
	        /**
	         * @deprecated use `view` instead.
	         */
	        _this.userRegion = _this.view;
	        /**
	         * allows substituting a default MapControl's style transformer with custom one
	         * Default style transformer is meant to update the incoming fetched style to desired state, as well as to synchronize the SDK state with style state
	         * and move additional layers over
	         * @internal
	         */
	        _this.customStyleTransform = undefined;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the view property names to the new view one.
	     * Also converts the specified language to a best fit supported one.
	     * @internal
	     */
	    StyleOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        try {
	            for (var valueList_1 = __values$4(valueList), valueList_1_1 = valueList_1.next(); !valueList_1_1.done; valueList_1_1 = valueList_1.next()) {
	                var value = valueList_1_1.value;
	                if (value) {
	                    // Make sure both view and userRegion properties exist. Prefer view's value.
	                    if (value.hasOwnProperty("view")) {
	                        value.userRegion = value.view;
	                    }
	                    else if (value.hasOwnProperty("userRegion")) {
	                        value.view = value.userRegion;
	                    }
	                    // Make sure the language is converted to the best fit supported one.
	                    if (typeof value.language === "string") {
	                        value.language = Localizer.getCode(value.language);
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valueList_1_1 && !valueList_1_1.done && (_a = valueList_1.return)) _a.call(valueList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // Then execute the standard merge behavior.
	        return _super.prototype.merge.apply(this, __spreadArray$4([], __read$4(valueList), false));
	    };
	    return StyleOptions;
	}(Options));

	var __extends$1 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$2 = (window && window.__assign) || function () {
	    __assign$2 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2.apply(this, arguments);
	};
	var __values$3 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$3 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$3 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var composeTransformers = function (transformers) { return transformers.length == 0
	    ? undefined
	    : transformers.slice(1).reduce(function (chained, transform) {
	        return function (url, resourceType) {
	            var resourceParams = chained(url, resourceType);
	            return __assign$2(__assign$2({}, resourceParams), transform(resourceParams.url, resourceType));
	        };
	    }, transformers[0]); };
	/**
	 * Global properties used in all atlas service requests.
	 */
	var ServiceOptions = /** @class */ (function (_super) {
	    __extends$1(ServiceOptions, _super);
	    function ServiceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication options used to customize how the map control authenticates with Azure Maps services.
	         * If these authentication options are specified then ServiceOptions.subscriptionKey should not be.
	         * Recommend using the atlas.setAuthenticationOptions function instead.
	         */
	        _this.authOptions = getAuthenticationOptions();
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * default: false (true for the Azure Government cloud)
	         * @default false
	         */
	        _this.disableTelemetry = getDomain() === "atlas.azure.us";
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using disableTelemetry instead.
	         */
	        _this["disable-telemetry"] = _this.disableTelemetry;
	        /**
	         * The domain to use when requesting map tiles and other Azure Maps services.
	         * If the protocol is not specified `https` is assumed.
	         * Recommend using atlas.setDomain function instead.
	         * @default "atlas.microsoft.com"
	         */
	        _this.domain = getDomain();
	        /**
	         * The domain to use when requesting style data and other static assets.
	         */
	        _this.staticAssetsDomain = getStaticAssetsDomain();
	        /**
	         * The styleDefinitionsPath to use for getting the map styles.
	         * Recommend using atlas.setStyleDefinitionsPath function instead.
	         * @default atlas.getStyleDefinitionsPath()
	         * @internal
	         */
	        _this.styleDefinitionsPath = getStyleDefinitionsPath();
	        /**
	         * The style definitions version to request when requesting styles
	         * from styleDefinitionsPath.
	         */
	        _this.styleDefinitionsVersion = getStyleDefinitionsVersion();
	        /**
	         * The style API version used when requesting styles and stylesets
	         */
	        _this.styleAPIVersion = getStyleAPIVersion();
	        /**
	         * The map configuration defines the set of styles available to the map.
	         */
	        _this.mapConfiguration = undefined;
	        /**
	         * @deprecated use mapConfiguration instead
	         */
	        _this.styleSet = undefined;
	        /**
	         * Enable the accessibility feature to provide screen reader support for users who have difficulty visualizing the web application.
	         * This property is set to true by default.
	         * @default true
	         */
	        _this.enableAccessibility = true;
	        /**
	         * Enable accessibility
	         * @deprecated Recommend using enableAccessibility instead.
	         */
	        _this["enable-accessibility"] = _this.enableAccessibility;
	        /**
	         * Enable the fallback to the REST API geocoder for detecting location accessibility if extracting location from vector data fails.
	         * Disabling this option will prevent the generation of geocode API requests but may lead to a lack of location information for screen readers.
	         * default: true
	         * @default true
	         */
	        _this.enableAccessibilityLocationFallback = true;
	        /**
	         * Maximum number of images (raster tiles, sprites, icons) to load in parallel,
	         * which affects performance in raster-heavy maps. 16 by default.
	         */
	        _this.maxParallelImageRequests = getMaxParallelImageRequests();
	        /**
	         * A boolean that specifies if vector and raster tiles should be reloaded when they expire (based on expires header).
	         * This is useful for data sets that update frequently. When set to false, each tile will be loaded once, when needed, and not reloaded when they expire.
	         * default: true
	         * @default true
	         */
	        _this.refreshExpiredTiles = true;
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this.subscriptionKey = getSubscriptionKey();
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this["subscription-key"] = _this.subscriptionKey;
	        /**
	         * The session id to pass with requests.
	         * Recommend using atlas.setSessionId instead.
	         * @default Random UUID generated at runtime
	         */
	        _this.sessionId = getSessionId();
	        /**
	         * The session id to pass with requests.
	         * @deprecated Recommend using atlas.setSessionId instead.
	         */
	        _this["session-id"] = _this.sessionId;
	        _this._transformers = [];
	        /**
	         * If defined transformRequest will be called to provide custom request parameters for loading a tile.
	         */
	        _this.transformRequest = undefined;
	        /**
	         * Number of web workers instantiated on a page.
	         * By default, it is set to half the number of CPU cores (capped at 6).
	         */
	        _this.workerCount = getWorkerCount();
	        /**
	         * Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds.
	         * This setting affects all symbol layers.
	         * This setting does not affect the duration of runtime styling transitions or raster tile cross-fading.
	         * @default 300
	         */
	        _this.fadeDuration = 300;
	        /**
	         * Defines a CSS font-family for locally overriding generation of glyphs in the
	         * 'CJK Unified Ideographs', 'Hiragana', 'Katakana' and 'Hangul Syllables' ranges.
	         * In these ranges, font settings from the map's style will be ignored,
	         * except for font-weight keywords (light/regular/medium/bold). Set to false,
	         * to enable font settings from the map's style for these glyph ranges.
	         * The purpose of this option is to avoid bandwidth-intensive glyph server requests.
	         * @default 'sans-serif'
	         */
	        _this.localIdeographFontFamily = 'sans-serif';
	        /**
	         * True to validate styles before it's getting applied.
	         * Validation takes significant(few hundred ms) time to process styles during initial load.
	         * Can be set to false for production environment to improve performance.
	         * @internal
	         * @default 'false'
	         */
	        _this.validateStyle = false;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the old dash property names to the new camelCase ones.
	     * @internal
	     */
	    ServiceOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var currentStyleDefinitionsVersion = this.styleDefinitionsVersion;
	        try {
	            // Make sure both camel and dash case properties exist. Prefer the camel case ones.
	            for (var valueList_1 = __values$3(valueList), valueList_1_1 = valueList_1.next(); !valueList_1_1.done; valueList_1_1 = valueList_1.next()) {
	                var value = valueList_1_1.value;
	                if (value) {
	                    // authOptions can also have a subscription key so check for that first.
	                    // If authOptions are specified then they should be preferred over the previous ServiceOptions.subscriptionKey.
	                    if (value.authOptions) {
	                        if (typeof value.authOptions.subscriptionKey === "string") {
	                            value.subscriptionKey = value["subscription-key"] =
	                                value.authOptions.subscriptionKey;
	                        }
	                    }
	                    else {
	                        if (typeof value.subscriptionKey === "string") {
	                            value["subscription-key"] = value.subscriptionKey;
	                            value.authOptions = {
	                                authType: exports.AuthenticationType.subscriptionKey,
	                                subscriptionKey: value.subscriptionKey,
	                            };
	                        }
	                        else if (typeof value["subscription-key"] === "string") {
	                            value.subscriptionKey = value["subscription-key"];
	                            value.authOptions = {
	                                authType: exports.AuthenticationType.subscriptionKey,
	                                subscriptionKey: value["subscription-key"],
	                            };
	                        }
	                    }
	                    if (typeof value.sessionId === "string") {
	                        value["session-id"] = value.sessionId;
	                    }
	                    else if (typeof value["session-id"] === "string") {
	                        value.sessionId = value["session-id"];
	                    }
	                    if (typeof value.disableTelemetry === "boolean") {
	                        value["disable-telemetry"] = value.disableTelemetry;
	                    }
	                    else if (typeof value["disable-telemetry"] === "boolean") {
	                        value.disableTelemetry = value["disable-telemetry"];
	                    }
	                    if (typeof value.enableAccessibility === "boolean") {
	                        value["enable-accessibility"] = value.enableAccessibility;
	                    }
	                    else if (typeof value["enable-accessibility"] === "boolean") {
	                        value.enableAccessibility = value["enable-accessibility"];
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valueList_1_1 && !valueList_1_1.done && (_a = valueList_1.return)) _a.call(valueList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // default merge behavior overrides _transformers
	        // won't change default behavior in Options as usually that's what desired
	        // instead capture it here and reassign.
	        var currentTransforms = this._transformers;
	        var transformersToMerge = valueList ? valueList.filter(function (value) { return value !== undefined; }).reduce(function (flattened, value) { return __spreadArray$3(__spreadArray$3([], __read$3(flattened), false), __read$3(value._transformers || []), false); }, []) : [];
	        // Then execute the standard merge behavior.
	        // If subscription key auth method isn't being used then the subscription key property should be undefined.
	        var merged = _super.prototype.merge.apply(this, __spreadArray$3([], __read$3(valueList), false));
	        if (merged.authOptions.authType !== exports.AuthenticationType.subscriptionKey) {
	            merged["subscription-key"] = merged.subscriptionKey = undefined;
	        }
	        // if mapConfiguration is not set and legacy styleSet option is used, assign it to mapConfiguration
	        if (merged.styleSet !== undefined && merged.mapConfiguration === undefined) {
	            merged.mapConfiguration = merged.styleSet;
	        }
	        // reassign properties from legacy mapConfiguration to new structure if needed
	        if (merged.mapConfiguration && typeof merged.mapConfiguration !== 'string') {
	            merged.mapConfiguration = __assign$2(__assign$2({}, merged.mapConfiguration), { defaultConfiguration: merged.mapConfiguration.defaultConfiguration || merged.mapConfiguration['defaultStyle'], configurations: merged.mapConfiguration.configurations || merged.mapConfiguration['styles'] });
	        }
	        this._transformers = __spreadArray$3(__spreadArray$3([], __read$3(currentTransforms || []), false), __read$3(transformersToMerge.filter(function (toMerge) { return !currentTransforms.includes(toMerge); })), false);
	        if (this.transformRequest && !this._transformers.includes(this.transformRequest)) {
	            this._transformers.push(this.transformRequest);
	        }
	        // NOTE: do not allow changing to a soon deprecated style-version, only version above-equal 2023-01-01 should be allowed
	        var minVersionComparator = new Date(Date.UTC(2023, 0));
	        var styleDefinitionVersionDate = new Date(this.styleDefinitionsVersion);
	        if (isNaN(styleDefinitionVersionDate.getTime()) || styleDefinitionVersionDate.getTime() < minVersionComparator.getTime()) {
	            console.warn("Style definition version ".concat(this.styleDefinitionsVersion, " is invalid or deprecated, style definition version is unchanged (").concat(currentStyleDefinitionsVersion, ")"));
	            this.styleDefinitionsVersion = currentStyleDefinitionsVersion;
	        }
	        // chain transformers in a middleware fashion
	        this.transformRequest = composeTransformers(this._transformers);
	        return merged;
	    };
	    /**
	     * Appends request transformer
	     */
	    ServiceOptions.prototype.addTransformer = function (transformer) {
	        if (!this._transformers) {
	            this._transformers = [];
	        }
	        this._transformers.push(transformer);
	        this.transformRequest = composeTransformers(this._transformers);
	    };
	    /**
	     * Removes request transformer
	     */
	    ServiceOptions.prototype.removeTransformer = function (transformer) {
	        if (!this._transformers) {
	            return;
	        }
	        this._transformers = this._transformers.filter(function (existing) { return transformer !== existing; });
	        this.transformRequest = composeTransformers(this._transformers);
	    };
	    /**
	     * Customizer for _.cloneDeep calls, allows objects to pass through with only a shallow cloning.
	     * Currently the only objects being cloned should be the `AuthenticationOptions`.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ServiceOptions._cloneCustomizer = function (value) {
	        if (typeof value === "object") {
	            return Object.assign({}, value);
	        }
	    };
	    return ServiceOptions;
	}(Options));

	var LayerGroupComparator = /** @class */ (function () {
	    function LayerGroupComparator() {
	    }
	    /**
	     * Extract layer group name from layer id. This method assumes the layer group is
	     * the fourth token in a dotted string where the first token is "microsoft".
	     * @param layer Mapbox layer to extract layer group name from
	     * @returns layer group if present, undefined otherwise.
	     * @internal
	     */
	    LayerGroupComparator.getLayerGroup = function (layer) {
	        if (typeof layer !== 'string' && layer.metadata && layer.metadata['microsoft.maps:layerGroup']) {
	            return layer.metadata['microsoft.maps:layerGroup'];
	        }
	        var layerId = typeof layer !== 'string' ? layer.id : layer;
	        if (!layerId.startsWith("microsoft.")) {
	            return undefined;
	        }
	        var idTokens = layerId.split('.');
	        if (idTokens.length >= 4) {
	            return idTokens[3];
	        }
	        return undefined;
	    };
	    return LayerGroupComparator;
	}());

	var HijackablePromise = /** @class */ (function () {
	    function HijackablePromise(origin) {
	        var _this = this;
	        this.isHijacked = function () { return _this._hijackedToResolve !== undefined || _this._hijackedToReject !== undefined; };
	        this.isResolved = function () { return _this._hijackedToResolve !== undefined || _this._toResolve !== undefined; };
	        this.isRejected = function () { return _this._hijackedToReject !== undefined || _this._toReject !== undefined; };
	        this.resultIfResolved = function () { return _this._hijackedToResolve || _this._toResolve; };
	        this.errorIfRejected = function () { return _this._hijackedToReject || _this._toReject; };
	        this._thenResolver = function (resolve, reject) {
	            if (_this._hijackedToResolve) {
	                resolve(_this._hijackedToResolve);
	            }
	            else if (_this._hijackedToReject) {
	                reject(_this._hijackedToReject);
	            }
	            else {
	                // we retain the origin, and check if stays the same as resolved
	                var retainedInvocator_1 = _this.origin;
	                _this.origin.then(function (result) {
	                    if (_this.isHijacked()) {
	                        return;
	                    }
	                    // origin was switched during invocation, discard the result and follow the chain
	                    if (retainedInvocator_1 !== _this.origin) {
	                        _this._thenResolver(resolve, reject);
	                    }
	                    else {
	                        _this._toResolve = result;
	                        resolve(result);
	                    }
	                }).catch(function (error) {
	                    if (_this.isHijacked()) {
	                        return;
	                    }
	                    // origin was switched during invocation, discard the result and follow the chain
	                    if (retainedInvocator_1 !== _this.origin) {
	                        _this._thenResolver(resolve, reject);
	                    }
	                    else {
	                        _this._toReject = error;
	                        reject(error);
	                    }
	                });
	            }
	        };
	        this.origin = origin;
	        this[Symbol.toStringTag] = this.origin[Symbol.toStringTag];
	    }
	    HijackablePromise.resolve = function (value) {
	        return new HijackablePromise(Promise.resolve(value));
	    };
	    HijackablePromise.reject = function (error) {
	        return new HijackablePromise(Promise.reject(error));
	    };
	    HijackablePromise.prototype.then = function (onfulfilled, onrejected) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	            _this._thenResolver(resolve, reject);
	        }).then(onfulfilled, onrejected);
	    };
	    // tslint:disable-next-line: no-reserved-keywords
	    HijackablePromise.prototype.catch = function (onrejected) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	            _this._thenResolver(resolve, reject);
	        }).catch(onrejected);
	    };
	    // tslint:disable-next-line: no-reserved-keywords
	    HijackablePromise.prototype.finally = function (onfinally) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	            _this._thenResolver(resolve, reject);
	        }).finally(onfinally);
	    };
	    HijackablePromise.prototype.hijackAndResolve = function (value) {
	        this._hijackedToResolve = value;
	        if (this._resolve) {
	            this._resolve(value);
	        }
	    };
	    HijackablePromise.prototype.hijackAndReject = function (error) {
	        this._hijackedToReject = error;
	        if (this._reject) {
	            this._reject(error);
	        }
	    };
	    HijackablePromise.prototype.switchWith = function (promise) {
	        // switching the origin will discard the original in-progress promise result, as well any resolved non-hijacked state
	        this.origin = promise;
	        this._toResolve = undefined;
	        this._toReject = undefined;
	    };
	    return HijackablePromise;
	}());

	var styleNamesMap = {
	    road: "Road",
	    satellite: "Satellite",
	    satellite_road_labels: "Hybrid",
	    grayscale_dark: "Grayscale (Dark)",
	    grayscale_light: "Grayscale (Light)",
	    night: "Night",
	    road_shaded_relief: "Terra",
	    blank: "Blank",
	    blank_accessible: "Blank (Accessible)",
	    high_contrast_dark: "High contrast (Dark)",
	    high_contrast_light: "High contrast (Light)"
	};

	var __assign$1 = (window && window.__assign) || function () {
	    __assign$1 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1.apply(this, arguments);
	};
	var __awaiter$1 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$1 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$2 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$2 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var __values$2 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * @private
	 */
	var StyleManager = /** @class */ (function () {
	    /**
	     * Constructs the style manager to be exposed only through the styles property of the Map class.
	     * @param map The map whose styles are being managed by this.
	     * @param serviceOptions Service options contain domain to use for requesting style resources.
	     * @internal
	     */
	    function StyleManager(map, serviceOptions) {
	        var _this = this;
	        this.definitions = function () {
	            var resultPromise;
	            if (_this.initPromise) {
	                resultPromise = _this.initPromise;
	            }
	            else {
	                resultPromise = _this.initStyleset();
	            }
	            return resultPromise;
	        };
	        /**
	         * Compatibility indoor state used in styleDefinition filtering.
	         * Legacy indoor module (2.0.6) will not set tilesetId
	         */
	        this.indoorState = undefined;
	        /**
	         * Preserve the map configuration that was used before the indoor map configuration was set
	         */
	        this.preservedPreindoorMapConfiguration = undefined;
	        /**
	         * The state of the progressive loading
	         */
	        this._progressiveLoadingState = {
	            mapStyle: undefined,
	            pendingVisibilityChange: undefined,
	        };
	        this._deferLayerGroupVisibilities = function (layerGroupLayers, initLayerGroups) {
	            var validInitLayerGroups = initLayerGroups.filter(function (groupName) { return groupName in layerGroupLayers; });
	            // If the initial layer groups are invalid, skip the progressive loading.
	            if (validInitLayerGroups.length === 0)
	                return;
	            var map = _this.map._getMap();
	            var currentZoomLevel = map.getZoom();
	            var currentMapStyle = _this.map.getStyle().style;
	            // Cancel and release previous pending callback, if any.
	            if (_this._progressiveLoadingState.pendingVisibilityChange) {
	                _this.map.events.remove('load', _this._progressiveLoadingState.pendingVisibilityChange);
	                _this._progressiveLoadingState.pendingVisibilityChange = null;
	            }
	            // Keep the current map style for future comparison.
	            _this._progressiveLoadingState.mapStyle = currentMapStyle;
	            // Select deferrable layers
	            var deferredLayers = Object.entries(layerGroupLayers).reduce(function (deferred, _a) {
	                var _b = __read$2(_a, 2), groupName = _b[0], layers = _b[1];
	                var isInInitialLayerGroup = validInitLayerGroups.includes(groupName);
	                return __spreadArray$2(__spreadArray$2([], __read$2(deferred), false), __read$2(layers.filter(function (layer) {
	                    var _a;
	                    // Exclude custom layers
	                    if (layer.type === 'custom')
	                        return false;
	                    // Exclude visible layers from initial layer groups
	                    if (isInInitialLayerGroup) {
	                        if (typeof layer.maxzoom === 'number' && typeof layer.minzoom === 'number') {
	                            if (currentZoomLevel <= layer.maxzoom && currentZoomLevel >= layer.minzoom)
	                                return false;
	                        }
	                        else if (typeof layer.minzoom === 'number') {
	                            if (currentZoomLevel >= layer.minzoom)
	                                return false;
	                        }
	                        else if (typeof layer.maxzoom === 'number') {
	                            if (currentZoomLevel <= layer.maxzoom)
	                                return false;
	                        }
	                        else {
	                            return false;
	                        }
	                    }
	                    // Select visible layers only.
	                    return ((_a = layer.layout) === null || _a === void 0 ? void 0 : _a.visibility) !== 'none';
	                })), false);
	            }, []);
	            // Hide the deferrable layers at initial load, therefore we can save the render time.
	            deferredLayers.forEach(function (layer) {
	                // Since this happens before sending style object into the map rendering,
	                // we only need to update the style object, but not necessary to update maplibre's layout properties.
	                layer.layout = layer.layout || {};
	                layer.layout.visibility = 'none';
	            });
	            // Make the deferred layers visible once the map instance is fully loaded.
	            _this._progressiveLoadingState.pendingVisibilityChange = function () {
	                var _a;
	                // Release the callback.
	                _this._progressiveLoadingState.pendingVisibilityChange = null;
	                // Bail out the callback once map style has changed.
	                var nextMapStyle = _this.map.getStyle().style;
	                if (currentMapStyle !== nextMapStyle)
	                    return;
	                // Make deferred layers visible
	                deferredLayers.forEach(function (layer) {
	                    // This happens after the map rendering; Therefore, we need to update
	                    // both the style object and the maplibre's layout properties.
	                    layer.layout.visibility = 'visible';
	                    map.setLayoutProperty(layer.id, 'visibility', 'visible');
	                });
	                // Reload attribution after the deferred layers are visible.
	                (_a = _this.map.copyrightDelegate) === null || _a === void 0 ? void 0 : _a.reloadAttribution();
	            };
	            _this.map.events.addOnce('load', _this._progressiveLoadingState.pendingVisibilityChange);
	        };
	        this._onStyleData = function (definition) {
	            _this.map.events.invoke("stylechanged", {
	                style: definition.name,
	                map: _this.map,
	                type: "stylechanged"
	            });
	        };
	        /**
	         * Looks up the style type info from the style definitions: this is async unsafe
	         */
	        this._lookUp = function (options) {
	            var e_1, _a;
	            var definitionsPromise = _this.definitions();
	            var definitionsFetchError = definitionsPromise.errorIfRejected();
	            var definitions = definitionsPromise.resultIfResolved();
	            if (definitionsFetchError) {
	                return null;
	            }
	            else if (!definitions) {
	                return null;
	            }
	            else {
	                var configrationsArray = definitions.configurations;
	                // retrieve default style definition unless option.style's one was found
	                var result = void 0;
	                try {
	                    for (var configrationsArray_1 = __values$2(configrationsArray), configrationsArray_1_1 = configrationsArray_1.next(); !configrationsArray_1_1.done; configrationsArray_1_1 = configrationsArray_1.next()) {
	                        var style = configrationsArray_1_1.value;
	                        if (style.name === options.style) {
	                            // this result is the highest priority, can immediately return
	                            return style;
	                        }
	                        if (style.name === definitions.defaultConfiguration && !result) {
	                            // backup result, so dont break here yet.
	                            // Later in the loop there might be another one matching options.style
	                            result = style;
	                        }
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (configrationsArray_1_1 && !configrationsArray_1_1.done && (_a = configrationsArray_1.return)) _a.call(configrationsArray_1);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	                // no default style in the mapConfiguration, pick the first style
	                if (!result) {
	                    result = configrationsArray[0];
	                }
	                return result;
	            }
	        };
	        this._lookUpAsync = function (options) { return __awaiter$1(_this, void 0, void 0, function () {
	            var definitions, result;
	            return __generator$1(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.definitions()];
	                    case 1:
	                        definitions = _a.sent();
	                        result = definitions.configurations.find(function (style) { return style.name === (options.style || definitions.defaultConfiguration); })
	                            // retrieve default style definition unless option.style's one was found
	                            || definitions.configurations.find(function (style) { return style.name === definitions.defaultConfiguration; })
	                            // no default style in the mapConfiguration -> pick the first style
	                            || definitions.configurations[0];
	                        return [2 /*return*/, result];
	                }
	            });
	        }); };
	        this.map = map;
	        this.serviceOptions = serviceOptions;
	    }
	    StyleManager.prototype.updateIndoorState = function (theme, tilesetId) {
	        var _this = this;
	        var _a;
	        var mapConfiguration = this.map.styles.getMapConfiguration();
	        if (mapConfiguration) {
	            this.preservedPreindoorMapConfiguration = mapConfiguration;
	            // tilesetId fallback
	            // MAGIC: if we are on a default style set - match existing style to the one in the default indoor style set
	            var desiredIndoorStyle = this.map.getStyle().style ? "".concat(this.map.getStyle().style, "_indoor").concat(theme === 'dark' ? '_dark' : '', "_tileset_").concat(tilesetId) : undefined;
	            this.map.styles.setMapConfiguration("defaultIndoor_".concat(tilesetId), mapConfiguration === 'microsoft-maps:default' ? desiredIndoorStyle : undefined);
	        }
	        else {
	            var didTilesetIdChange_1 = ((_a = this.indoorState) === null || _a === void 0 ? void 0 : _a.tilesetId) !== tilesetId;
	            this.indoorState = {
	                tilesetId: tilesetId,
	                theme: theme
	            };
	            this.initStyleset();
	            this.definitions().then(function (definitions) {
	                var currentStyle = (_this.map.getStyle().style || definitions.defaultConfiguration)
	                    .replace('_indoor_dark', '')
	                    .replace('_indoor', '');
	                // we cannot compose the precise style name for auto theme, search for prefix style name match
	                var targetStylePrefix = "".concat(currentStyle, "_indoor");
	                var candidateStyle = definitions.configurations.find(function (style) { return style.name.startsWith(targetStylePrefix); });
	                if (candidateStyle) {
	                    // force style reload if tileset id has changed to make sure the tiles will be re-requested with new tileset applied in indoor source placeholder
	                    _this.map.setStyle({ style: candidateStyle.name }, !didTilesetIdChange_1);
	                }
	            });
	        }
	    };
	    StyleManager.prototype.unsetIndoorState = function () {
	        var _this = this;
	        var mapConfiguration = this.preservedPreindoorMapConfiguration;
	        if (mapConfiguration) {
	            // we need to revert to the styleset that was ap
	            this.map.styles.setMapConfiguration(mapConfiguration);
	        }
	        else {
	            this.indoorState = undefined;
	            this.initStyleset();
	            this.definitions().then(function (definitions) {
	                var currentStyle = _this.map.getStyle().style;
	                if (currentStyle.includes('_indoor') && currentStyle.split('_indoor')[0]) {
	                    _this.map.setStyle({ style: currentStyle.split('_indoor')[0] });
	                }
	                else {
	                    _this.map.setStyle({ style: undefined });
	                }
	            });
	        }
	    };
	    /**
	     * If this method has been called before then the original promise is returned.
	     * Promise is resolved once the style set is successfully fetched and stored.
	     */
	    StyleManager.prototype.initStyleset = function () {
	        var _this = this;
	        var newPromise;
	        var mapStyleNameToFriendyWhenAvailable = function (styleName) {
	            var baseName = _this.indoorState && styleName.includes('_indoor') ? styleName.split('_indoor')[0] : styleName;
	            return baseName in styleNamesMap ? styleNamesMap[baseName] : baseName;
	        };
	        if (!this.serviceOptions.mapConfiguration) {
	            var ensureAuthentication = this.map.authentication ? this.map.authentication.initialize() : Promise.resolve();
	            newPromise = new HijackablePromise(ensureAuthentication.then(function () { return _this._request(_this.serviceOptions.staticAssetsDomain, "".concat(constants.stylePath, "/").concat(constants.styleResourcePath), "StyleDefinitions", {
	                version: _this.serviceOptions.styleDefinitionsVersion,
	                // add MapControlVersion to make sure we have different local cache between map control versions
	                mcv: version$2.replace(/\./g, ''),
	            }).then(function (definitions) { return ({
	                version: isNaN(definitions.version) ? 0 : parseFloat(definitions.version),
	                defaultConfiguration: definitions.defaultStyle,
	                configurations: definitions.styles
	                    .filter(function (style) {
	                    if (!_this.indoorState) {
	                        return !style.name.includes('indoor');
	                        // NOTE: azure-maps-indoor prior to 2.0.7 will not pass theme auto
	                        // the IndoorModule will request getTheme() from StyleManager and will call StyleManager.setStyleSet(theme == 'dark ? 'indoor_dark' : 'indoor') as approperaite
	                    }
	                    else if (_this.indoorState.theme === 'auto') {
	                        return style.name.endsWith(style.theme === 'dark' ? '_indoor_dark' : '_indoor');
	                    }
	                    else {
	                        return style.name.endsWith(_this.indoorState.theme === 'dark' ? '_indoor_dark' : '_indoor');
	                    }
	                })
	                    .map(function (style) { return ({
	                    copyright: style.copyright.join(' '),
	                    name: style.name,
	                    displayName: mapStyleNameToFriendyWhenAvailable(style.name),
	                    theme: style.theme,
	                    thumbnail: new Url({ domain: _this.serviceOptions.staticAssetsDomain, path: style.thumbnail, protocol: "https" }).toString(),
	                    url: new Url({
	                        domain: _this.serviceOptions.staticAssetsDomain,
	                        path: "".concat(constants.stylePath, "/").concat(constants.styleResourcePath, "/").concat(style.name),
	                        queryParams: {
	                            // Use the style version from the API response if it's available,
	                            // otherwise fallback to the version specified in the serviceOptions.
	                            // This is needed for flight testing the 2023-01-01 style version.
	                            styleVersion: definitions.version !== undefined && definitions.version !== null
	                                ? definitions.version
	                                : _this.serviceOptions.styleDefinitionsVersion,
	                            // thus far we don't need to differentiate based on parameter here, as stylePatch will be called on cached styles as well
	                            //language: styleOptions.language
	                            // add MapControlVersion to make sure we have different local cache between map control versions
	                            mcv: version$2.replace(/\./g, '')
	                        },
	                        protocol: "https"
	                    }).toString(),
	                }); })
	            }); }); }));
	        }
	        else if (typeof this.serviceOptions.mapConfiguration === 'string') {
	            var ensureAuthentication = this.map.authentication ? this.map.authentication.initialize() : Promise.resolve();
	            newPromise = new HijackablePromise(ensureAuthentication.then(function () { return _this._request(_this.serviceOptions.domain, "".concat(constants.styleResourcePath, "/mapconfigurations/metadata/").concat(_this.serviceOptions.mapConfiguration), "StyleDefinitions"
	            // reassign properties from legacy mapConfiguration to new structure if needed
	            ).then(function (definitions) { return (__assign$1(__assign$1({}, definitions), { defaultConfiguration: definitions.defaultConfiguration || definitions['defaultStyle'], configurations: definitions.configurations || definitions['styles'] })); }); }));
	        }
	        else {
	            newPromise = HijackablePromise.resolve(this.serviceOptions.mapConfiguration);
	        }
	        if (this.initPromise) {
	            this.initPromise.switchWith(newPromise);
	            this.initPromise = newPromise;
	        }
	        else {
	            this.initPromise = newPromise;
	        }
	        // propagate styleset change
	        this.initPromise.then(function (styleset) { return _this.map._invokeEvent("mapconfigurationchanged", styleset); });
	        return this.initPromise;
	    };
	    /**
	     * Gets URL or object of the style listed in style definition. Style definition's default style is used if
	     * styleOptions.style is not provided or if styleOptions.style is not present in the style definition.
	     */
	    StyleManager.prototype.getStyle = function (styleOptions) {
	        var styleDefinition = this._lookUp(styleOptions);
	        if (!styleDefinition) {
	            throw Error("Style definition is not available.");
	        }
	        if (styleDefinition.url) {
	            return styleDefinition.url;
	        }
	        if (styleDefinition.style) {
	            return styleDefinition.style;
	        }
	        throw Error("Style definition neither contains URL nor style object.");
	    };
	    StyleManager.prototype.deriveNewStyleAndLayerGroups = function (previousStyle, nextStyle) {
	        var _a, _b, _c, _d, _e, _f;
	        // Layers in the next style with default properties that do not align with current StyleOptions
	        // should be modified before they are applied to the map.
	        var styleOptions = this.map.getStyle();
	        var trafficOptions = this.map.getTraffic();
	        var layersGroups = {};
	        for (var i = 0; i < nextStyle.layers.length; i++) {
	            var nextLayer = nextStyle.layers[i];
	            var layerGroup = LayerGroupComparator.getLayerGroup(nextLayer);
	            if (!layerGroup) {
	                layersGroups[nextLayer.id] = [nextLayer];
	                continue;
	            }
	            if (!layersGroups[layerGroup]) {
	                layersGroups[layerGroup] = [];
	            }
	            var layerGroupLayers = layersGroups[layerGroup];
	            layerGroupLayers.push(nextLayer);
	            // 1. Set visiblity of fill-extrusion layers according to StyleOptions.showBuildingModels
	            if (!styleOptions.showBuildingModels && nextLayer.type === "fill-extrusion") {
	                nextLayer.layout = (_a = nextLayer.layout) !== null && _a !== void 0 ? _a : {};
	                nextLayer.layout.visibility = "none";
	            }
	            else if (nextLayer.type === "fill-extrusion") {
	                nextLayer.layout = (_b = nextLayer.layout) !== null && _b !== void 0 ? _b : {};
	                nextLayer.layout.visibility = "visible";
	            }
	            // 2. Set visibility of traffic layers depending on traffic settings.
	            if (trafficOptions.flow !== "none" && layerGroup) {
	                if (layerGroup === "traffic_".concat(trafficOptions.flow) && nextLayer.type == "line") {
	                    nextLayer.layout = (_c = nextLayer.layout) !== null && _c !== void 0 ? _c : {};
	                    nextLayer.layout.visibility = "visible";
	                }
	            }
	            // 3. Set visibility of labels
	            var isLabelLayerGroup = layerGroup === 'labels' || layerGroup === 'labels_places' || layerGroup === 'labels_indoor';
	            if (isLabelLayerGroup && nextLayer.type === 'symbol') {
	                if (styleOptions.showLabels && ((_d = nextLayer.layout) === null || _d === void 0 ? void 0 : _d.visibility) !== "none") {
	                    nextLayer.layout = (_e = nextLayer.layout) !== null && _e !== void 0 ? _e : {};
	                    nextLayer.layout.visibility = "visible";
	                }
	                else {
	                    nextLayer.layout = (_f = nextLayer.layout) !== null && _f !== void 0 ? _f : {};
	                    nextLayer.layout.visibility = "none";
	                }
	            }
	        }
	        return [nextStyle, layersGroups];
	    };
	    StyleManager.prototype.injectUserLayersIntoStyle = function (previousStyle, nextStyle, layerGroupLayers) {
	        // Custom layers added to mapbox through this SDK should be carried over to the next style.
	        return !previousStyle
	            ? nextStyle
	            : this.map.layers._getUserLayers().reduce(function (style, userLayer) {
	                var _a, _b;
	                if (userLayer.layer instanceof WebGLLayer) {
	                    // mapbox custom layers cannot be serialized and preserved,
	                    // return to continue to the next user layer.
	                    return style;
	                }
	                var beforeLayerId = ((_b = (_a = layerGroupLayers === null || layerGroupLayers === void 0 ? void 0 : layerGroupLayers[userLayer.before]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.id) || userLayer.before;
	                var layer = previousStyle.layers.find(function (layer) { return layer.id === userLayer.layer.getId(); });
	                // when setStyle diff attempt is unsuccesful, _load will be called on the style that may have already injected user layers -> clean it up
	                var existingLayerIdx = nextStyle.layers.findIndex(function (layer) { return layer.id === userLayer.layer.getId(); });
	                if (existingLayerIdx > -1) {
	                    nextStyle.layers.splice(existingLayerIdx, 1);
	                }
	                if (layer) {
	                    var sourcesToCopy = new Set(Array.from(userLayer.layer._getSourceIds())
	                        .map(function (sourceId) {
	                        // If source is already present in the target style, skip copy
	                        if (style.sources[sourceId]) {
	                            return undefined;
	                        }
	                        var source = previousStyle.sources[sourceId];
	                        return source ? { source: source, id: sourceId } : undefined;
	                    })
	                        .filter(function (source) { return source !== undefined; }));
	                    var insertIdx = beforeLayerId ? style.layers.findIndex(function (layer) { return layer.id === beforeLayerId; }) : -1;
	                    if (insertIdx > -1) {
	                        style.layers.splice(insertIdx, 0, layer);
	                    }
	                    else {
	                        style.layers.push(layer);
	                    }
	                    sourcesToCopy.forEach(function (_a) {
	                        var source = _a.source, id = _a.id;
	                        style.sources[id] = source;
	                    });
	                }
	                return style;
	            }, __assign$1({}, nextStyle));
	    };
	    /**
	     * @internal
	     */
	    StyleManager.prototype.setStyle = function (styleOptions, diff) {
	        var _this = this;
	        if (diff === void 0) { diff = true; }
	        var transformStyleFunc;
	        var targetDefinition = this._lookUp(styleOptions);
	        if (!targetDefinition) {
	            throw Error("Style definition ".concat(styleOptions.style, " is not available."));
	        }
	        if (!targetDefinition.url && !targetDefinition.style) {
	            throw Error("Style definition neither contains URL nor style object.");
	        }
	        var styleDataCallback = function () { return _this._onStyleData(targetDefinition); };
	        var patchStyleEvent = function () {
	            // FIXME: below diffing will be soon fixed on the maplibre side
	            // If there was a previous styledata change event attached, remove it.
	            // When the sprite url changes between style changes then maplibre can't perform the diff
	            // In such cases it recalculate the style again. Removing previous attached
	            // event listener makes sure that style changed event is not fired twice in these cases.
	            _this.map.events.remove("styledata", styleDataCallback);
	            _this.map.events.addOnce("styledata", styleDataCallback);
	        };
	        if (styleOptions && styleOptions.customStyleTransform) {
	            transformStyleFunc = function (prev, next) {
	                var target = styleOptions.customStyleTransform(prev, next);
	                patchStyleEvent();
	                return target;
	            };
	        }
	        else {
	            transformStyleFunc = function (previousStyle, style) {
	                // make sure we always have a shallow clone to prevent mutating explicit json(rather then url) styles being set
	                var nextStyle = __assign$1(__assign$1({}, style), { layers: __spreadArray$2([], __read$2(style.layers), false), sources: __assign$1({}, style.sources) });
	                var shouldProgressiveLoading = (styleOptions.progressiveLoading &&
	                    // The feature only effective at the initial load.
	                    !_this.map._isLoaded());
	                // Shallow-clone the style object and duplicate layer.layout properties to avoid side-effects.
	                if (shouldProgressiveLoading && Array.isArray(style === null || style === void 0 ? void 0 : style.layers)) {
	                    nextStyle = __assign$1({}, style);
	                    nextStyle.layers = nextStyle.layers.map(function (layer) {
	                        var nextLayer = __assign$1({}, layer);
	                        if (layer.layout) {
	                            nextLayer.layout = __assign$1({}, layer.layout);
	                        }
	                        return nextLayer;
	                    });
	                }
	                // 1. derive the base new style (without user layers) and layer groups
	                var _a = __read$2(_this.deriveNewStyleAndLayerGroups(previousStyle, nextStyle), 2), targetStyle = _a[0], layerGroupLayers = _a[1];
	                // 2. side effect: progressively render map layers to the canvas to shorten the time to the first meaningful render.
	                if (shouldProgressiveLoading) {
	                    var initLayerGroups = styleOptions.progressiveLoadingInitialLayerGroups;
	                    if (Array.isArray(initLayerGroups) && initLayerGroups.length > 0) {
	                        _this._deferLayerGroupVisibilities(layerGroupLayers, initLayerGroups);
	                    }
	                }
	                // 3. copy user layers and sources from previous style into new one
	                var targetStyleWithUserLayers = _this.injectUserLayersIntoStyle(previousStyle, targetStyle, layerGroupLayers);
	                // 4. side effects: sync our control's LayerManager and SourceManager
	                var nextFundamentalLayers = Object.entries(layerGroupLayers).map(function (_a) {
	                    var _b = __read$2(_a, 2), layerGroupId = _b[0], layers = _b[1];
	                    return _this._buildFundamentalLayerFrom(layers, layerGroupId);
	                });
	                var layerIndex = _this.map.layers._getUserLayers().reduce(function (layerIndex, userLayer) {
	                    var layerInsertIndex = userLayer.before ? layerIndex.findIndex(function (layer) { return layer.getId() === userLayer.before; }) : -1;
	                    if (layerInsertIndex > -1) {
	                        layerIndex.splice(layerInsertIndex, 0, userLayer.layer);
	                    }
	                    else {
	                        layerIndex.push(userLayer.layer);
	                    }
	                    return layerIndex;
	                }, nextFundamentalLayers);
	                _this.map.layers['layerIndex'] = layerIndex;
	                _this.map.sources._syncSources(targetStyleWithUserLayers.sources);
	                // 5. temporarily patch style data event
	                patchStyleEvent();
	                return targetStyleWithUserLayers;
	            };
	        }
	        this.map._getMap().setStyle(targetDefinition.url || targetDefinition.style, {
	            diff: diff,
	            validate: this.serviceOptions.validateStyle,
	            transformStyle: transformStyleFunc
	        });
	    };
	    /**
	     * Gets the color theme (light/dark) for the style type specified by the style options.
	     */
	    StyleManager.prototype.getTheme = function (styleOptions) {
	        var style = this._lookUp(styleOptions);
	        if (!style) {
	            return undefined;
	        }
	        return style.theme.toLowerCase();
	    };
	    StyleManager.prototype.getThemeAsync = function (styleOptions) {
	        return __awaiter$1(this, void 0, void 0, function () {
	            return __generator$1(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this._lookUpAsync(styleOptions)];
	                    case 1: return [2 /*return*/, (_a.sent()).theme];
	                }
	            });
	        });
	    };
	    /**
	     * Replaces the style set used. Very costly as it reloads all controls and resources.
	     */
	    StyleManager.prototype.setMapConfiguration = function (mapConfiguration, styleName) {
	        var _this = this;
	        this.serviceOptions.mapConfiguration = mapConfiguration;
	        if (typeof mapConfiguration === 'string') {
	            this.initStyleset();
	        }
	        else {
	            if (this.initPromise) {
	                this.initPromise.hijackAndResolve(mapConfiguration);
	            }
	            else {
	                this.initPromise = HijackablePromise.resolve(mapConfiguration);
	            }
	        }
	        this.definitions().then(function (definitions) {
	            var targetStyleName = definitions.defaultConfiguration;
	            if (definitions.configurations.find(function (s) { return s.name === styleName; })) {
	                targetStyleName = styleName;
	            }
	            _this.map.setStyle({ style: targetStyleName });
	        });
	    };
	    StyleManager.prototype.getMapConfiguration = function () {
	        return this.serviceOptions.mapConfiguration;
	    };
	    // backward-compatibility: this method preserves the interface that azure-maps-indoor@2.0.6 assumes
	    StyleManager.prototype.setStyleSet = function (styleSet) {
	        this.updateIndoorState(styleSet === 'indoor_dark' ? 'dark' : 'light', null);
	    };
	    // backward-compatibility: this method preserves the interface that azure-maps-indoor@2.0.6 assumes
	    StyleManager.prototype.getStyleSet = function () {
	        var legacyStyleset = this.indoorState !== undefined
	            ? (this.indoorState.theme === 'dark' ? 'indoor_dark' : 'indoor')
	            : 'base';
	        return legacyStyleset;
	    };
	    // backward-compatibility: this method preserves the interface that azure-maps-indoor@2.0.6 assumes
	    StyleManager.prototype.clearStyleSet = function () {
	        this.unsetIndoorState();
	    };
	    StyleManager.prototype._buildFundamentalLayerFrom = function (layers, id) {
	        if (layers && layers.length > 0) {
	            var newLayer = new FundamentalMapLayer(layers, id);
	            newLayer.onAdd(this.map);
	            return newLayer;
	        }
	        throw new Error("Unable to construct fundamental map layer for ID: ".concat(id, "."));
	    };
	    /**
	     * Replace URL placeholders and add StyleManager API version to requests made for style resources.
	     * @param params RequestParameters to modify.
	     * @returns Valid style RequestParameters.
	     * @internal
	     */
	    StyleManager.prototype._transformStyleRequest = function (url, params) {
	        var _a;
	        if (url.includes(constants.domainPlaceHolder)) {
	            params.url = params.url.replace(constants.domainPlaceHolder, this.serviceOptions.domain);
	        }
	        if (url.includes(constants.stylePathHolder)) {
	            params.url = params.url.replace(constants.stylePathHolder, constants.stylePath);
	        }
	        if (url.includes(constants.styleResourcePlaceholder)) {
	            params.url = params.url.replace(constants.styleResourcePlaceholder, constants.styleResourcePath);
	        }
	        if (params.url.toLocaleLowerCase().includes(this.serviceOptions.domain.toLocaleLowerCase()) ||
	            params.url.toLocaleLowerCase().includes(this.serviceOptions.staticAssetsDomain.toLocaleLowerCase())) {
	            // Only add API version param for Azure maps domain requests
	            var targetUrl = new URL(params.url);
	            if (!targetUrl.searchParams.get(constants.apiVersionQueryParameter)) {
	                targetUrl.searchParams.set(constants.apiVersionQueryParameter, this.serviceOptions.styleAPIVersion);
	                params.url = targetUrl.href;
	            }
	            (_a = this.map.authentication) === null || _a === void 0 ? void 0 : _a.signRequest(params);
	            // Delete auth token for static assets to allow AFD caching
	            this._deleteAuthTokenForStaticAssets(params);
	        }
	    };
	    /**
	     * Fetches a json resource at the specified domain and path.
	     */
	    StyleManager.prototype._request = function (domain, path, resourceType, customQueryParams) {
	        var _a;
	        if (customQueryParams === void 0) { customQueryParams = {}; }
	        return __awaiter$1(this, void 0, void 0, function () {
	            var requestParams, fetchOptions;
	            var _b;
	            return __generator$1(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        requestParams = {
	                            url: new Url({
	                                protocol: "https",
	                                domain: domain,
	                                path: path,
	                                queryParams: __assign$1((_b = {}, _b[constants.apiVersionQueryParameter] = this.serviceOptions.styleAPIVersion, _b), customQueryParams)
	                            }).toString()
	                        };
	                        if (typeof this.serviceOptions.transformRequest === "function" && resourceType) {
	                            // If a transformRequest(...) was specified use it.
	                            requestParams = this.serviceOptions.transformRequest(requestParams.url, resourceType);
	                        }
	                        (_a = this.map.authentication) === null || _a === void 0 ? void 0 : _a.signRequest(requestParams);
	                        // Delete auth token for static assets to allow AFD caching
	                        this._deleteAuthTokenForStaticAssets(requestParams);
	                        fetchOptions = {
	                            method: "GET",
	                            mode: "cors",
	                        };
	                        requestParams.credentials &&
	                            (fetchOptions.credentials = requestParams.credentials);
	                        requestParams.headers &&
	                            (fetchOptions.headers = requestParams.headers);
	                        return [4 /*yield*/, fetch(requestParams.url, fetchOptions).then(function (response) {
	                                if (response.ok) {
	                                    return response.json();
	                                }
	                                else {
	                                    throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText, " "));
	                                }
	                            })];
	                    case 1: return [2 /*return*/, _c.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Delete auth token for static assets to allow AFD caching.
	     */
	    StyleManager.prototype._deleteAuthTokenForStaticAssets = function (params) {
	        // The following resources are considered as static assets.
	        // StyleSet    /styling/styles
	        // Style       /styling/styles/*
	        // Thumbnail   /styling/styles/*/thumbnail.png
	        // Sprite PNG  /styling/sprites/*/sprite@2x.png
	        // Sprite JSON /styling/sprites/*/sprite@2x.json
	        // Glyph       /styling/glyphs/*/0-255.pbf
	        if (params.url.startsWith("https://".concat(this.serviceOptions.staticAssetsDomain, "/").concat(constants.stylePath))) {
	            delete params.headers[constants.msClientIdHeaderName];
	            delete params.headers[constants.authorizationHeaderName];
	        }
	    };
	    return StyleManager;
	}());

	/**
	 * @private
	 */
	var isHMREnabled = function () { return 'ENVIRONMENT' in window && !!window['ENVIRONMENT']['hmr']; };

	var __values$1 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * @internal
	 * A manager for the map control's hidden indicators.
	 * Exposed through the `indicators` property of the `atlas.Map` class.
	 * Cannot be instantiated by the user.
	 */
	var AccessibleIndicatorManager = /** @class */ (function () {
	    /**
	     * Constructs the indicator manager to be exposed only through the `indicators` property of the `Map` class.
	     * @param map The map whose indicators are being managed by this.
	     * @internal
	     */
	    function AccessibleIndicatorManager(map) {
	        this.map = map;
	        this.indicators = new Set();
	    }
	    /**
	     * Adds an indicator to the map
	     * @param indicator The indicator(s) to add.
	     */
	    AccessibleIndicatorManager.prototype.add = function (indicator) {
	        var e_1, _a;
	        indicator = Array.isArray(indicator) ? indicator : [indicator];
	        try {
	            for (var indicator_1 = __values$1(indicator), indicator_1_1 = indicator_1.next(); !indicator_1_1.done; indicator_1_1 = indicator_1.next()) {
	                var i = indicator_1_1.value;
	                if (!this.indicators.has(i)) {
	                    this.indicators.add(i);
	                    i.attach(this.map);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (indicator_1_1 && !indicator_1_1.done && (_a = indicator_1.return)) _a.call(indicator_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * Removes all indicators from the map.
	     */
	    AccessibleIndicatorManager.prototype.clear = function () {
	        var _this = this;
	        this.indicators.forEach(function (indicator) {
	            _this.indicators.delete(indicator);
	            indicator.remove();
	        });
	    };
	    /**
	     * Removes an indicator from the map
	     * @param indicator The indicator(s) to remove.
	     */
	    AccessibleIndicatorManager.prototype.remove = function (indicator) {
	        var e_2, _a;
	        indicator = Array.isArray(indicator) ? indicator : [indicator];
	        try {
	            for (var indicator_2 = __values$1(indicator), indicator_2_1 = indicator_2.next(); !indicator_2_1.done; indicator_2_1 = indicator_2.next()) {
	                var i = indicator_2_1.value;
	                if (this.indicators.has(i)) {
	                    this.indicators.delete(i);
	                    i.remove();
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (indicator_2_1 && !indicator_2_1.done && (_a = indicator_2.return)) _a.call(indicator_2);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	    };
	    /**
	     * Returns the indicators currently attached to the map.
	     */
	    AccessibleIndicatorManager.prototype.getIndicators = function () {
	        return Array.from(this.indicators);
	    };
	    /**
	     * Returns the div element that should contain all the indicator containers.
	     * Creates it if it doesn't already exist.
	     * @internal
	     */
	    AccessibleIndicatorManager.prototype._getCollectionDiv = function () {
	        var collection = this.map.getMapContainer()
	            .querySelector(".".concat(AccessibleIndicatorManager.Css.collection));
	        if (!collection) {
	            // If the collection div doesn't exist create it.
	            collection = document.createElement("div");
	            collection.setAttribute("aria-label", "map data");
	            // Set the container role to listbox, and the descents' role to option, so the reader will read the listbox as a list.
	            // For example, NVDA will read "data point, 1 of 1" when the indicator is focused.
	            collection.setAttribute("role", "listbox");
	            collection.classList.add(AccessibleIndicatorManager.Css.collection);
	            this.map.getMapContainer().appendChild(collection);
	        }
	        return collection;
	    };
	    AccessibleIndicatorManager.Css = {
	        collection: "accessible-indicator-collection-container"
	    };
	    return AccessibleIndicatorManager;
	}());

	var __extends = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (window && window.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __awaiter = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$1 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$1 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var __values = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * The control for a visual and interactive web map.
	 */
	var Map$1 = /** @class */ (function (_super) {
	    __extends(Map, _super);
	    /**
	     * Displays a map in the specified container.
	     * @param container The id of the element where the map should be displayed.
	     * @param options Options for the initial display and interactability with the map.
	     */
	    function Map(container, options) {
	        var _this = _super.call(this) || this;
	        // Map state trackers
	        _this.removed = false;
	        _this.loaded = false;
	        _this.ready = false;
	        /**
	         * The callback used when styleOptions.autoResize is true.
	         */
	        _this._resizeCallback = function () { return _this.resize(); };
	        // Update global defaults based on which options were specified to this constructor.
	        _this._updateGlobalDefaults(options);
	        _this.serviceOptions = new ServiceOptions().merge(options);
	        _this.styleOptions = new StyleOptions().merge(options);
	        _this.trafficOptions = new TrafficOptions();
	        _this.styles = new StyleManager(_this, _this.serviceOptions);
	        if (_this.serviceOptions.authOptions.subscriptionKey) {
	            _this.serviceOptions.authOptions.subscriptionKey = encodeURIComponent(_this.serviceOptions.authOptions.subscriptionKey);
	        }
	        // If a client id is available use that for telemetry, fallback to subscription key if necessary.
	        // Only keep the last 3 characters of the subscription key.
	        var accountId;
	        if (_this.serviceOptions.authOptions.clientId) {
	            accountId = _this.serviceOptions.authOptions.clientId;
	        }
	        else if (_this.serviceOptions.authOptions.subscriptionKey) {
	            accountId = _this.serviceOptions.authOptions.subscriptionKey.replace(/.(?=.{3,}$)/g, "*");
	        }
	        else {
	            accountId = "invalid-setting";
	        }
	        if (_this.insights) {
	            _this.insights.setAuthenticatedUserContext(_this.serviceOptions.sessionId, accountId);
	        }
	        var mapboxMap;
	        if (arguments[2] && isHMREnabled()) {
	            mapboxMap = arguments[2];
	            _this.ready = true;
	            _this.loaded = true;
	        }
	        else {
	            var mapboxMapOptions = {
	                antialias: _this.styleOptions.antialias,
	                attributionControl: false,
	                container: container,
	                fadeDuration: _this.serviceOptions.fadeDuration,
	                localIdeographFontFamily: _this.serviceOptions.localIdeographFontFamily,
	                preserveDrawingBuffer: _this.styleOptions.preserveDrawingBuffer,
	                refreshExpiredTiles: _this.serviceOptions.refreshExpiredTiles,
	                renderWorldCopies: _this.styleOptions.renderWorldCopies,
	                trackResize: false,
	                transformRequest: function (url, resourceType) {
	                    var requestParams = {
	                        url: url
	                    };
	                    if (resourceType === "Tile" || resourceType === "Source") {
	                        // Note: if url includes legacyDomainPlaceHolder it will also include domainPlaceHolder
	                        //                       {azMapsDomain}                               {{azMapsDomain}}
	                        if (url.includes(constants.legacyDomainPlaceHolder) && _this.insights) {
	                            _this.insights.trackEvent({ name: "TileLoad" });
	                        }
	                        _this._substituteDomainLanguageViewAndSignInRequest(url, requestParams);
	                    }
	                    else if (resourceType === "Style" || resourceType === "SpriteJSON" || resourceType === "SpriteImage" || resourceType === "Glyphs") {
	                        _this.styles._transformStyleRequest(url, requestParams);
	                    }
	                    // Apply the users specified transform after ours
	                    if (_this.serviceOptions.transformRequest) {
	                        merge$1(requestParams, _this.serviceOptions.transformRequest(requestParams.url, resourceType));
	                    }
	                    // TODO: fix type variation
	                    return requestParams;
	                }
	            };
	            mapboxMap = new maplibregl.Map(mapboxMapOptions);
	        }
	        try {
	            _this.map = mapboxMap;
	            // Initialize managers
	            {
	                _this.authentication = new AuthenticationManager(_this);
	            }
	            _this.controls = new ControlManager(_this);
	            _this.events = new EventManager(_this);
	            _this.imageSprite = new ImageSpriteManager(_this);
	            _this.layers = new LayerManager(_this);
	            _this.markers = new HtmlMarkerManager(_this);
	            _this.sources = new SourceManager(_this);
	            _this.popups = new PopupManager(_this);
	            _this.indicators = new AccessibleIndicatorManager(_this);
	            // Add CSS classes and set attributes for DOM elements.
	            _this.map.getContainer().classList.add(Map.Css.container);
	            _this.map.getCanvasContainer().classList.add(Map.Css.canvasContainer);
	            _this.map.getCanvas().classList.add(Map.Css.canvas);
	            _this._detectHighContrast();
	            // Always add the copyright label.
	            _this.copyrightControl = new CopyrightControl({
	                showFeedbackLink: _this.styleOptions.showFeedbackLink,
	                showLogo: _this.styleOptions.showLogo,
	                customAttribution: _this.styleOptions.customAttribution
	            });
	            _this.controls.add(_this.copyrightControl, {
	                position: exports.ControlPosition.NonFixed
	            });
	            // Add logo control to occupy the bottom left corner of the map.
	            _this.logoControl = new LogoControl({
	                showLogo: _this.styleOptions.showLogo
	            });
	            _this.controls.add(_this.logoControl, {
	                position: exports.ControlPosition.BottomLeft
	            });
	            // Initialize state of map
	            // --> Initialize the authentication manager
	            var authManInit = _this.authentication ?
	                _this.authentication.initialize() : Promise.resolve();
	            if (_this.removed) {
	                return _this;
	            }
	            // --> Track if the map has completed its first load
	            var setLoaded_1 = function () {
	                _this.loaded = true;
	                _this.map.off("load", setLoaded_1);
	            };
	            _this.map.on("load", setLoaded_1);
	            // --> Track if the map has set its initial style
	            var setReady_1 = function () {
	                _this.ready = true;
	                _this.map.off("styledata", setReady_1);
	                // Manually invoke the ready event the first time styledata fires.
	                var readyData = { map: _this, type: "ready" };
	                _this.events.invoke("ready", readyData);
	            };
	            _this.map.on("styledata", setReady_1);
	            // --> Set initial style including downloading style definitions and restyle map
	            _this._setAutoResize(_this.styleOptions.autoResize);
	            _this.map.showTileBoundaries = _this.styleOptions.showTileBoundaries;
	            _this.localizedStringsPromise = Localizer.getStrings(_this.styleOptions.language);
	            authManInit
	                // reuses this.styles.initPromise if initStyleset is already called
	                .then(function () { return _this.styles.definitions(); })
	                .then(function (definitions) {
	                // Check that the map hasn't been removed for any reason.
	                // If so no need to finish styling the map.
	                if (_this.removed) {
	                    return;
	                }
	                if (_this.authentication && !_this.authentication.getToken()) {
	                    throw new Error("AuthenticationManager finished initializing, but no token is available");
	                }
	                // Add the accessibility delegate to the map here
	                // so that the auth mechanism is setup before any calls are made.
	                if (_this.serviceOptions["enable-accessibility"]) {
	                    _this.accessibleMapDelegate.addToMap();
	                }
	                _this._setStyleComponents(_this.styleOptions);
	                _this.copyrightDelegate && _this.copyrightDelegate.addToMap();
	            }).catch(function (reason) {
	                var error = reason instanceof Error ? reason : new Error(reason);
	                // Invoke the error event to report any errors initializing the styles or auth.
	                var errorData = {
	                    map: _this,
	                    type: "error",
	                    error: error
	                };
	                _this.events.invoke("error", errorData);
	            });
	            // --> Set initial camera state of map
	            _this.setCamera(__assign(__assign({ 
	                // Default minZoom to ensure the map doesn't zoom out to unsupported zoom levels.
	                minZoom: 1 }, options), { type: "jump", duration: 0 }));
	            // Add delegates to map
	            {
	                _this.incidentDelegate = new IncidentServiceDelegate(_this);
	            }
	            _this.flowDelegate = new FlowServiceDelegate(_this);
	            _this.accessibleMapDelegate = new AccessibleMapDelegate(_this);
	            _this.userInteractionDelegate = new UserInteractionDelegate(_this, options);
	            _this.userInteractionDelegate.addToMap();
	            {
	                _this.copyrightDelegate = new CopyrightDelegate(_this, _this.copyrightControl, _this.styleOptions);
	            }
	        }
	        catch (err) {
	            throw err;
	        }
	        finally {
	        }
	        return _this;
	    }
	    Object.defineProperty(Map.prototype, "isDisposed", {
	        /**
	         * Returns true if the map has been disposed.
	         */
	        get: function () {
	            return this.removed;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Returns the HTMLCanvasElement that the map is drawn to.
	     */
	    Map.prototype.getCanvas = function () {
	        return this.map.getCanvas();
	    };
	    /**
	     * Returns the HTMLElement that contains the map's HTMLCanvasElement. The map's events (e.g. panning and zooming)
	     * are attached to this element.
	     */
	    Map.prototype.getCanvasContainer = function () {
	        return this.map.getCanvasContainer();
	    };
	    /**
	     * Returns the HTMLElement that contains the map.
	     */
	    Map.prototype.getMapContainer = function () {
	        return this.map.getContainer();
	    };
	    /**
	     * Returns the service options with which the map control was initialized.
	     */
	    Map.prototype.getServiceOptions = function () {
	        return cloneDeepWith$1(this.serviceOptions, ServiceOptions._cloneCustomizer);
	    };
	    /**
	     * Set the service options.
	     */
	    Map.prototype.setServiceOptions = function (options) {
	        this.serviceOptions = new ServiceOptions().merge(this.serviceOptions, options);
	        if (this.serviceOptions["enable-accessibility"]) {
	            this.accessibleMapDelegate.addToMap();
	        }
	        else {
	            this.accessibleMapDelegate.removeFromMap();
	        }
	        var shouldReloadStyle = this.styles.serviceOptions.mapConfiguration !== this.serviceOptions.mapConfiguration
	            || this.styles.serviceOptions.staticAssetsDomain !== this.serviceOptions.staticAssetsDomain
	            || this.styles.serviceOptions.styleDefinitionsVersion !== this.serviceOptions.styleDefinitionsVersion
	            || this.styles.serviceOptions.domain !== this.serviceOptions.domain
	            || this.styles.serviceOptions.styleAPIVersion !== this.serviceOptions.styleAPIVersion;
	        // NOTE: only perform a reload when the style dependent properties are changed
	        //|| this.styles.serviceOptions.validateStyle !== this.serviceOptions.validateStyle
	        //|| this.styles.serviceOptions.transformRequest !== this.serviceOptions.transformRequest
	        this.styles.serviceOptions = this.serviceOptions;
	        if (shouldReloadStyle) {
	            this.styles.initPromise = null;
	            this.setStyle({});
	        }
	    };
	    /**
	     * Adds request transformer
	     * @param transformer provides custom request parameters for loading a tile.
	     */
	    Map.prototype.addRequestTransformer = function (transformer) { this.serviceOptions.addTransformer(transformer); };
	    /**
	     * Removes request transformer
	     * @param transformer transformer to remove (provides custom request parameters for loading a tile)
	     */
	    Map.prototype.removeRequestTransformer = function (transformer) { this.serviceOptions.removeTransformer(transformer); };
	    Map.prototype.setCamera = function (options, fromControl) {
	        var _a;
	        if (fromControl === void 0) { fromControl = false; }
	        var mapboxCameraOptions;
	        var maxBounds;
	        // Test between CameraOptions and CameraBoundsOptions
	        if ("padding" in options || "offset" in options || "bounds" in options) {
	            var cameraBoundsOptions = new CameraBoundsOptions()
	                .merge({ maxZoom: this.getCamera().maxZoom }, options);
	            var bounds = this._generateSafeBounds(cameraBoundsOptions.bounds);
	            var cameraForBoundsOptions = {
	                padding: cameraBoundsOptions.padding,
	                offset: cameraBoundsOptions.offset,
	                maxZoom: cameraBoundsOptions.maxZoom
	            };
	            mapboxCameraOptions = this.map.cameraForBounds(bounds, cameraForBoundsOptions);
	            if (!mapboxCameraOptions) {
	                var currentContainer = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getContainer();
	                var errorDetails = {
	                    message: "The map cannot be fit to the current canvas with the given CameraBoundsOptions.",
	                    containerWidth: currentContainer === null || currentContainer === void 0 ? void 0 : currentContainer.clientWidth,
	                    containerHeight: currentContainer === null || currentContainer === void 0 ? void 0 : currentContainer.clientHeight,
	                    safeBounds: bounds,
	                    cameraForBoundsOptions: cameraForBoundsOptions
	                };
	                throw new Error(JSON.stringify(errorDetails));
	            }
	            if ('pitch' in options) {
	                mapboxCameraOptions.pitch = options.pitch;
	            }
	            if ('bearing' in options) {
	                mapboxCameraOptions.bearing = options.bearing;
	            }
	            if ('minPitch' in options) {
	                this.map.setMinPitch(options.minPitch);
	            }
	            if ('maxPitch' in options) {
	                this.map.setMaxPitch(options.maxPitch);
	            }
	            if ('minZoom' in options) {
	                this.map.setMinZoom(options.minZoom);
	            }
	            maxBounds = this._generateSafeBounds(cameraBoundsOptions.maxBounds);
	        }
	        else {
	            var cameraOptions = new CameraOptions().merge(this.getCamera(), options);
	            // adjust for center offset
	            if (cameraOptions.centerOffset && cameraOptions.centerOffset.length >= 2) {
	                var centerOffset = cameraOptions.centerOffset;
	                // Calculate a new center which accounts for the offset at the specified zoom level.
	                var p = mercatorPositionsToPixels([cameraOptions.center], cameraOptions.zoom);
	                p[0][0] += centerOffset[0];
	                p[0][1] += centerOffset[1];
	                cameraOptions.center = mercatorPixelsToPositions(p, cameraOptions.zoom)[0];
	            }
	            mapboxCameraOptions = {
	                center: cameraOptions.center,
	                zoom: cameraOptions.zoom,
	                bearing: cameraOptions.bearing,
	                pitch: cameraOptions.pitch,
	                around: undefined
	            };
	            if (cameraOptions.minZoom < 1) {
	                console.warn("Setting minZoom below 1 may result in an empty map when the zoom level is less than 1.");
	            }
	            this.map.setMinZoom(cameraOptions.minZoom);
	            this.map.setMaxZoom(cameraOptions.maxZoom);
	            if (cameraOptions.minPitch) {
	                this.map.setMinPitch(cameraOptions.minPitch);
	            }
	            if (cameraOptions.maxPitch) {
	                this.map.setMaxPitch(cameraOptions.maxPitch);
	            }
	            this._invokeEvent("minzoomchanged", this.map.getMinZoom());
	            this._invokeEvent("maxzoomchanged", this.map.getMaxZoom());
	            maxBounds = this._generateSafeBounds(cameraOptions.maxBounds);
	        }
	        // set maxBounds. maxBounds will be removed if null or undefined is provided.
	        if (maxBounds) {
	            this.map.setMaxBounds(maxBounds);
	        }
	        else {
	            this.map.setMaxBounds(null);
	        }
	        var animOptions = new AnimationOptions().merge(options);
	        var mapboxAnimationOptions = {
	            duration: animOptions.duration,
	            easing: function (t) { return t; },
	            offset: [0, 0],
	            animate: true
	        };
	        // Supply event data regarding if a control caused this camera change.
	        var eventData = { fromControl: fromControl };
	        if (animOptions.type === "jump") {
	            this.map.jumpTo(mapboxCameraOptions, eventData);
	        }
	        else if (animOptions.type === "ease") {
	            this.map.easeTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	        else if (animOptions.type === "fly") {
	            this.map.flyTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	    };
	    /**
	     * Set the camera bounds of the map control.
	     * @param options The options for setting the map's camera bounds.
	     * @deprecated recommend setCamera.
	     */
	    Map.prototype.setCameraBounds = function (options) {
	        this.setCamera(options);
	    };
	    /**
	     * Returns the camera's current properties.
	     */
	    Map.prototype.getCamera = function () {
	        var southWest = this.map.getBounds().getSouthWest().toArray();
	        var northEast = this.map.getBounds().getNorthEast().toArray();
	        var cameraOptions = {
	            zoom: this.map.getZoom(),
	            center: this.map.getCenter().toArray(),
	            bearing: this.map.getBearing(),
	            pitch: this.map.getPitch(),
	            bounds: new BoundingBox(southWest, northEast),
	            minZoom: this.map.getMinZoom(),
	            maxZoom: this.map.getMaxZoom()
	        };
	        return cameraOptions;
	    };
	    /**
	     * Set the map control's style options. Any options not specified will default to their current values.
	     * @param options The options for setting the style of the map control.
	     * @param diff [true] If false, forces a 'full' style update, removing the current style and building the given one instead of attempting a diff-based update. Defaults to true.
	     */
	    Map.prototype.setStyle = function (options, diff) {
	        if (diff === void 0) { diff = true; }
	        // This option may only be set when initializing the map.
	        // The delete operation will handle non-exist property.
	        delete options.preserveDrawingBuffer;
	        var newOptions = new StyleOptions().merge(this.styleOptions, options);
	        // Add or remove the autoResize listener if needed.
	        if (newOptions.autoResize !== this.styleOptions.autoResize) {
	            this._setAutoResize(newOptions.autoResize);
	        }
	        // Update the localized strings promise if needed.
	        if (newOptions.language !== this.styleOptions.language) {
	            this.localizedStringsPromise = Localizer.getStrings(newOptions.language);
	        }
	        // Update rendering of world copies if needed.
	        if (newOptions.renderWorldCopies !== this.styleOptions.renderWorldCopies) {
	            this.map.setRenderWorldCopies(newOptions.renderWorldCopies);
	        }
	        // Add or remove the feedback link if needed.
	        if (newOptions.showFeedbackLink !== this.styleOptions.showFeedbackLink) {
	            this.copyrightControl.setOptions({ showFeedbackLink: newOptions.showFeedbackLink });
	        }
	        // Add or remove custom attribution if needed
	        if (newOptions.customAttribution !== this.styleOptions.customAttribution) {
	            this.copyrightControl.setOptions({ customAttribution: newOptions.customAttribution });
	        }
	        // Add or remove the logo if needed.
	        if (newOptions.showLogo !== this.styleOptions.showLogo) {
	            this.copyrightControl.setOptions({ showLogo: newOptions.showLogo });
	            this.logoControl.setOptions({ showLogo: newOptions.showLogo });
	        }
	        // Update showing tile boundaries if needed.
	        if (newOptions.showTileBoundaries !== this.styleOptions.showTileBoundaries) {
	            this.map.showTileBoundaries = newOptions.showTileBoundaries;
	        }
	        if (newOptions.showBuildingModels) {
	            console.warn("showBuildingModels is deprecated.");
	        }
	        // Some delegates may rely on a styledata event to know when to check if the language changes.
	        // If this function is restructured such that a styledata event won't always trigger
	        // if the language is changed, then either those delegates need changed
	        // or the styledata event manually invoked.
	        var noDiffOnLanguageViewChange = diff && (this.styleOptions.language === newOptions.language && this.styleOptions.view === newOptions.view);
	        this.styleOptions = newOptions;
	        this._setStyleComponents(newOptions, noDiffOnLanguageViewChange);
	    };
	    /**
	     * Returns the map control's current style settings.
	     */
	    Map.prototype.getStyle = function () {
	        return cloneDeep$1(this.styleOptions);
	    };
	    /**
	     * Add an icon to the map to use for pins.
	     * Map must be ready and the image must be fully loaded before the icon can be added.
	     * Use the events.add method with event type 'ready'.
	     * @param id The identifier of the icon.
	     * @param icon The icon image.
	     * @deprecated Use map.imageSprite.add instead.
	     */
	    Map.prototype.addIcon = function (id, icon) {
	        this.imageSprite.add(id, icon);
	    };
	    /**
	     * Add a collection of points to a layer of the map as pins. The layer and its options can be specified through a
	     * PinLayerOptions object. Options for the layer can
	     * only be specified upon the layer's initial creation. Map must be ready before the pins can be added. Use
	     * the events.add method with event type 'ready'.
	     * @param pins The points to add.
	     * @param options The layer options for the pins.
	     * @deprecated Use atlas.layer.SymbolLayer instead.
	     */
	    Map.prototype.addPins = function (pins, options) {
	        var layerOptions = new PinLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new SymbolLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                iconOptions: {
	                    anchor: "center",
	                    size: layerOptions.iconSize,
	                    image: ["case",
	                        ["has", "icon"], ["get", "icon"],
	                        layerOptions.icon
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity
	                },
	                textOptions: {
	                    anchor: "center",
	                    textField: ["case",
	                        ["has", "point_count"], ["to-string", ["get", "point_count"]],
	                        ["has", "title"], ["to-string", ["get", "title"]],
	                        layerOptions.title
	                    ],
	                    font: ["case",
	                        ["has", "point_count"], ["literal", ["StandardFontCondensed-Bold"]],
	                        ["literal", [layerOptions.textFont]]
	                    ],
	                    size: ["case",
	                        ["has", "point_count"], 20,
	                        layerOptions.fontSize
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity,
	                    offset: ["case",
	                        ["has", "point_count"], ["literal", [0.50, -0.45]],
	                        ["literal", [layerOptions.textOffset[0] / 16, layerOptions.textOffset[1] / 16]]
	                    ],
	                    color: layerOptions.fontColor
	                }
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof SymbolLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a SymbolLayer.") +
	                "A SymbolLayer should be used for rendering pins.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId, {
	                cluster: layerOptions.cluster
	            });
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var pinCollection = new FeatureCollection(pins);
	        if (layerOptions.overwrite) {
	            source.setShapes(pinCollection);
	        }
	        else {
	            source.add(pinCollection);
	        }
	    };
	    /**
	     * Add a collection of points to a layer of the map as circles. The layer and its options can be specified through a
	     * CircleLayerOptions object. Options for the layer
	     * can only be specified upon the layer's initial creation. Map must be ready before the circles can be
	     * added. Use the events.add method with event type 'ready'.
	     * @param circles The circles to add.
	     * @param options The layer options for the circles.
	     * @deprecated Use atlas.layer.BubbleLayer instead.
	     */
	    Map.prototype.addCircles = function (circles, options) {
	        var layerOptions = new CircleLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new BubbleLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                opacity: layerOptions.opacity,
	                radius: ["case",
	                    ["has", "radius"], ["get", "radius"],
	                    layerOptions.radius
	                ],
	                color: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeColor: ["case",
	                    ["has", "outlineColor"], ["get", "outlineColor"],
	                    layerOptions.outlineColor
	                ],
	                strokeWidth: ["case",
	                    ["has", "outlineWidth"], ["get", "outlineWidth"],
	                    layerOptions.outlineWidth
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof BubbleLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a BubbleLayer.") +
	                "A BubbleLayer should be used for rendering circles.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var circleCollection = new FeatureCollection(circles);
	        if (layerOptions.overwrite) {
	            source.setShapes(circleCollection);
	        }
	        else {
	            source.add(circleCollection);
	        }
	    };
	    /**
	     * Add a collection of linestrings to a layer of the map. The layer and its options can be specified through a
	     * LinestringLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the
	     * linestrings can be added. Use the events.add method with event type 'ready'.
	     * @param linestrings The linestrings to add.
	     * @param options The layer options for the linestrings.
	     * @deprecated Use atlas.layer.LineLayer instead.
	     */
	    Map.prototype.addLinestrings = function (linestrings, options) {
	        var layerOptions = new LinestringLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new LineLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                lineCap: layerOptions.cap,
	                lineJoin: layerOptions.join,
	                strokeOpacity: layerOptions.opacity,
	                strokeColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeWidth: ["case",
	                    ["has", "width"], ["get", "width"],
	                    layerOptions.width
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof LineLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a LineLayer.") +
	                "A LineLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var lineCollection = new FeatureCollection(linestrings);
	        if (layerOptions.overwrite) {
	            source.setShapes(lineCollection);
	        }
	        else {
	            source.add(lineCollection);
	        }
	    };
	    /**
	     * Add a collection of polygons to a layer of the map. The layer and its options can be specified through a
	     * PolygonLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the polygons
	     * can be added. Use the events.add method with event type 'ready'.
	     * @param polygons The polygons to add.
	     * @param options The layer options for the polygons.
	     * @deprecated Use atlas.layer.PolygonLayer instead.
	     */
	    Map.prototype.addPolygons = function (polygons, options) {
	        var layerOptions = new PolygonLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new PolygonLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                fillOpacity: layerOptions.opacity,
	                fillColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof PolygonLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a PolygonLayer.") +
	                "A PolygonLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var polygonCollection = new FeatureCollection(polygons);
	        if (layerOptions.overwrite) {
	            source.setShapes(polygonCollection);
	        }
	        else {
	            source.add(polygonCollection);
	        }
	    };
	    /**
	     * Adds a raster layer to the map. The layer and its options can be specified through a
	     * RasterLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation.
	     * @param tileSources  A list of endpoints specified as strings from which raster images can be requested. The
	     * endpoints can be parameterized with the tags '{z}', '{x}' and '{y}' to specify the zoom, x-index, and y-index of
	     * the needed tile respectively. The map control will request and place the tiles that are contained in the map's
	     * viewport.
	     * @param options The options for the raster layer.
	     * @deprecated Use atlas.layer.TileLayer instead.
	     */
	    Map.prototype.addRaster = function (tileSources, options) {
	        var layerOptions = new RasterLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        if (!layer) {
	            layer = new TileLayer({
	                maxZoom: layerOptions.maxZoom,
	                minZoom: layerOptions.minZoom,
	                opacity: layerOptions.opacity,
	                tileSize: 256,
	                tileUrl: "{subdomain}"
	            }, layerOptions.name);
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof TileLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a TileLayer.") +
	                "A TileLayer should be used for rendering raster images.");
	        }
	        // Multiple tile urls are made possible by the {subdomain} substitution
	        // If a layer doesn't use "{subdomain}" as its tileUrl it must have be created with new TileLayer(...)
	        // In that case throw an error.
	        if (layer.getOptions().tileUrl !== "{subdomain}") {
	            throw new Error("A TileLayer with name '".concat(layerOptions.name, "' already exists but was configured ") +
	                "for a single tile url [default for new TileLayer(...)].");
	        }
	        // Get the new tile urls.
	        var urls;
	        if (layerOptions.overwrite) {
	            urls = [];
	        }
	        else {
	            urls = layer.getOptions().subdomains || [];
	        }
	        // Add the tile urls to the layer, but don't update the map yet.
	        urls.push.apply(urls, __spreadArray$1([], __read$1(tileSources), false));
	        layer._setOptionsNoUpdate({
	            subdomains: urls
	        });
	        this.layers.add(layer, layerOptions.before);
	    };
	    /**
	     * Returns a list of the map's layers from bottom to top.
	     * @deprecated Use layers.getLayers() instead.
	     */
	    Map.prototype.getLayers = function () {
	        return this.layers.getLayers().map(function (l) { return l.getId(); });
	    };
	    /**
	     * Removes a collection of layers from the map.
	     * For each layer if a source by the name of "<layerName>-source" exists it will be removed too.
	     * @param layerNames An array of layer names to remove from the map.
	     * @deprecated Use layers.remove instead.
	     */
	    Map.prototype.removeLayers = function (layerNames) {
	        var e_1, _a;
	        try {
	            for (var layerNames_1 = __values(layerNames), layerNames_1_1 = layerNames_1.next(); !layerNames_1_1.done; layerNames_1_1 = layerNames_1.next()) {
	                var layerName = layerNames_1_1.value;
	                // Previously calling removeLayers for layers that didn't exist in the map just did nothing.
	                // Now, LayerManager will throw an error, so we need to check if the layer exists before calling remove.
	                if (this.layers.getLayerById(layerName)) {
	                    this.layers.remove(layerName);
	                    // Previously adding a layer also added a source with the name "<layerName>-source".
	                    // Calling removeLayers would also remove that source, so we attempt to do this too.
	                    var sourceName = "".concat(layerName, "-source");
	                    if (this.sources.getById(sourceName)) {
	                        this.sources.remove(sourceName);
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (layerNames_1_1 && !layerNames_1_1.done && (_a = layerNames_1.return)) _a.call(layerNames_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * @deprecated recommend map.markers.add
	     * Adds a custom HTMLElement to the map at a specified position.
	     * @param element The HTMLElement to add.
	     * @param position The position to place the element.
	     */
	    Map.prototype.addHtml = function (element, position) {
	        if (!element.id) {
	            element.id = "marker_".concat(uuid());
	        }
	        var marker = new HtmlMarker({
	            htmlContent: element,
	        });
	        this.markers.add(marker, position);
	        return element.id;
	    };
	    /**
	     * @deprecated recommend map.markers.remove
	     * Removes a custom HTMLElement from the map.
	     * @param elementId The id of element to remove.
	     */
	    Map.prototype.removeHtml = function (elementId) {
	        this.markers.remove(elementId);
	    };
	    Map.prototype.addEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._addLegacy(eventType, layerOrCallback, callback);
	    };
	    Map.prototype.removeEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._removeLegacy(eventType, layerOrCallback, callback);
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    Map.prototype.setUserInteraction = function (options) {
	        this.userInteractionDelegate.setOptions(options);
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    Map.prototype.getUserInteraction = function () {
	        return this.userInteractionDelegate.getOptions();
	    };
	    /**
	     * Add a control to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     * @deprecated Use map.controls.add instead.
	     */
	    Map.prototype.addControl = function (control, options) {
	        this.controls.add(control, options);
	    };
	    /**
	     * Remove a control from the map.
	     * @param control The control to remove.
	     * @deprecated Use map.controls.remove instead.
	     */
	    Map.prototype.removeControl = function (control) {
	        this.controls.remove(control);
	    };
	    /**
	     * Set the traffic options for the map. Any options not specified will default to their current values.
	     * @param options The options for defining the map's traffic display.
	     */
	    Map.prototype.setTraffic = function (options) {
	        var previousIncidentsOption = this.trafficOptions.incidents;
	        var previousFlowOption = this.trafficOptions.flow;
	        this.trafficOptions = new TrafficOptions().merge(this.trafficOptions, options);
	        this.controls.getControls().filter(function (control) { return control instanceof TrafficControl; }).forEach(function (control) {
	            return control.updateButtonState();
	        });
	        if (this.incidentDelegate) {
	            if (this.trafficOptions.incidents) {
	                if (!previousIncidentsOption) {
	                    this.incidentDelegate.addToMap();
	                }
	            }
	            else {
	                this.incidentDelegate.removeFromMap();
	            }
	        }
	        if (this.trafficOptions.flow && this.trafficOptions.flow !== "none") {
	            if (["absolute", "relative-delay"].includes(this.trafficOptions.flow)) {
	                console.warn("The 'absolute' and 'relative-delay' flow options are deprecated. Please use 'relative' instead.");
	            }
	            try {
	                if (this.trafficOptions.flow !== previousFlowOption) {
	                    this.flowDelegate.addToMap();
	                }
	            }
	            catch (error) {
	                this.trafficOptions.flow = previousFlowOption;
	                throw error;
	            }
	        }
	        else {
	            this.flowDelegate.removeFromMap();
	        }
	    };
	    /**
	     * Return the map control's current traffic settings.
	     */
	    Map.prototype.getTraffic = function () {
	        return cloneDeep$1(this.trafficOptions);
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     * @deprecated use map.dispose()
	     */
	    Map.prototype.remove = function () {
	        this.dispose();
	    };
	    /**
	     * Removes all sources, layers, markers, and popups from the map.
	     * User added images are preserved.
	     */
	    Map.prototype.clear = function () {
	        // Clear the layers, sources, and marker via their managers.
	        this.popups.clear();
	        this.layers.clear();
	        this.sources.clear();
	        this.markers.clear();
	        this.indicators.clear();
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     */
	    Map.prototype.dispose = function () {
	        var _a, _b;
	        this.clear();
	        this.map.remove();
	        (_a = this.authentication) === null || _a === void 0 ? void 0 : _a.dispose();
	        this.removed = true;
	        // Remove event listeners
	        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
	        this.resizeObserver = null;
	        while (this.getMapContainer().firstChild) {
	            var currChild = this.getMapContainer().firstChild;
	            this.getMapContainer().removeChild(currChild);
	        }
	    };
	    Map.prototype.resize = function (heightOrData, width, eventData) {
	        if ((typeof heightOrData === "number" || typeof heightOrData === "string") &&
	            (typeof width === "number" || typeof width === "string")) {
	            var height = heightOrData;
	            this.getMapContainer().style.height = typeof height === "number" ? "".concat(height, "px") : height;
	            this.getMapContainer().style.width = typeof width === "number" ? "".concat(width, "px") : width;
	        }
	        else {
	            eventData = heightOrData;
	        }
	        // Occasionally, when resizing the window causes the map container to also resize, the canvas will re-resized
	        // as if expecting a scroll bar to be drawn for the canvas container.
	        // This leaves some whitespace gap on the bottom and right sides of the canvas.
	        // No actual scrollbars will be shown.
	        //
	        // This is because the canvas container and map container are resized before the canvas,
	        // so for a small fraction of time the canvas is bigger than its containers and a scroll bar would be required.
	        //
	        // To prevent this first the canvas container has overflow set to hidden.
	        // This ensures that scroll bars would never be needed.
	        // Then the Mapbox resize function is called, and the canvas should be the full, correct size.
	        // Finally the canvas container has overflow set back to the original value.
	        var oldOverflow = this.getMapContainer().style.overflow;
	        this.getMapContainer().style.overflow = "hidden";
	        this.map.resize(eventData);
	        this.getMapContainer().style.overflow = oldOverflow;
	    };
	    /**
	     * Converts an array of Pixel objects to an array of geographic Positions objects on the map.
	     * @param pixels The pixels to be converted.
	     */
	    Map.prototype.pixelsToPositions = function (pixels) {
	        var e_2, _a;
	        var positions = [];
	        try {
	            for (var pixels_1 = __values(pixels), pixels_1_1 = pixels_1.next(); !pixels_1_1.done; pixels_1_1 = pixels_1.next()) {
	                var pixel = pixels_1_1.value;
	                var lngLat = this.map.unproject(pixel);
	                positions.push(new Position(lngLat.lng, lngLat.lat));
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (pixels_1_1 && !pixels_1_1.done && (_a = pixels_1.return)) _a.call(pixels_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        return positions;
	    };
	    /**
	     * Converts an array of Positions objects to an array of Pixel objects relative to the map container.
	     * @param positions The positions to be converted.
	     */
	    Map.prototype.positionsToPixels = function (positions) {
	        var e_3, _a;
	        var pixels = [];
	        try {
	            for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
	                var position = positions_1_1.value;
	                var point = this.map.project(position);
	                pixels.push(new Pixel(point.x, point.y));
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return pixels;
	    };
	    /**
	     * Returns a boolean indicating if all tiles in the current viewport for all sources have loaded or not.
	     */
	    Map.prototype.areTilesLoaded = function () {
	        return this.map.areTilesLoaded();
	    };
	    /**
	     * Stops any animated transition that is currently underway.
	     */
	    Map.prototype.stop = function () {
	        this.map.stop();
	    };
	    /**
	     * Trigger the rendering of a single frame.
	     * Use this method with WebGL layers to repaint the map when the layer's
	     * properties or properties associated with the layer's source change.
	     * Calling this multiple times before the next frame is rendered will still
	     * result in only a single frame being rendered.
	     */
	    Map.prototype.triggerRepaint = function () {
	        this.map.triggerRepaint();
	    };
	    /**
	     * Loads a 3D terrain mesh, based on a "raster-dem" source.
	     *
	     * @param elevationSource elevation tile source
	     * @param exaggeration the elevation exaggeration factor
	     */
	    Map.prototype.enableElevation = function (elevationSource, exaggeration) {
	        this.map.setTerrain(typeof elevationSource === 'string' ? { source: elevationSource, exaggeration: exaggeration } : { source: elevationSource.getId(), exaggeration: exaggeration });
	    };
	    /**
	     * Disables the 3D terrain mesh.
	     */
	    Map.prototype.disableElevation = function () {
	        this.map.setTerrain(null);
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._getMap = function () {
	        return this.map;
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._rebuildStyle = function (diff) {
	        if (diff === void 0) { diff = true; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                this.styles.setStyle(this.styleOptions, diff);
	                this.imageSprite._restoreImages();
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Returns true if the map has completed loading for the first time.
	     * Will always return true after the initial load is completed.
	     * @internal
	     */
	    Map.prototype._isLoaded = function () {
	        return this.loaded;
	    };
	    /**
	     * Returns true if the map has set its style for the first time.
	     * Will always return true after the style has been set.
	     * @internal
	     */
	    Map.prototype._isReady = function () {
	        return this.ready;
	    };
	    /**
	     * Returns a promise which will resolve to a collection of localized strings based on the map's current language.
	     * @internal
	     */
	    Map.prototype._getLocalizedStrings = function () {
	        return this.localizedStringsPromise;
	    };
	    /**
	     * Sends a fetch request to the specified url with the specified headers.
	     * Processes the request through transformRequest(...) first before sending.
	     * @internal
	     */
	    Map.prototype._sendRequest = function (url, resourceType, headers) {
	        var requestParams;
	        if (typeof this.serviceOptions.transformRequest === "function") {
	            // If a transformRequest(...) was specified use it.
	            requestParams = this.serviceOptions.transformRequest(url, resourceType);
	        }
	        if (requestParams) {
	            // Send the fetch using the transformed parameters.
	            return fetch(requestParams.url || url, {
	                credentials: requestParams.credentials,
	                headers: __assign(__assign({}, headers), requestParams.headers),
	                method: "GET",
	                mode: "cors",
	            });
	        }
	        else {
	            // If not transformRequest has been supplied just make the request as specified.
	            return fetch(url, {
	                headers: headers,
	                method: "GET",
	                mode: "cors"
	            });
	        }
	    };
	    /**
	     * replaces the domain, view and language placeholders and signs request as needed
	     * @internal
	     */
	    Map.prototype._substituteDomainLanguageViewAndSignInRequest = function (url, requestParams) {
	        var _a;
	        if (url.includes(constants.legacyDomainPlaceHolder) || url.includes(constants.domainPlaceHolder)) {
	            // Update legacy domain placeholder if found
	            var isLegacy = new RegExp("[^{]".concat(constants.legacyDomainPlaceHolder, "[^}]"));
	            if (url.match(isLegacy)) {
	                requestParams.url = requestParams.url.replace(constants.legacyDomainPlaceHolder, constants.domainPlaceHolder);
	            }
	            if (Url.protoRegEx.test(this.serviceOptions.domain)) {
	                // If the user specified domain includes a protocol replace that in the url too.
	                var idx = requestParams.url.indexOf(constants.domainPlaceHolder);
	                requestParams.url = this.serviceOptions.domain +
	                    requestParams.url.substring(idx + constants.domainPlaceHolder.length);
	            }
	            else {
	                // If the user specified domain doesn't include a protocol keep the original.
	                requestParams.url = requestParams.url.replace(constants.domainPlaceHolder, this.serviceOptions.domain);
	            }
	        }
	        if (requestParams.url.toLocaleLowerCase().includes(this.serviceOptions.domain.toLocaleLowerCase()) ||
	            requestParams.url.toLocaleLowerCase().includes(this.serviceOptions.staticAssetsDomain.toLocaleLowerCase())) {
	            (_a = this.authentication) === null || _a === void 0 ? void 0 : _a.signRequest(requestParams);
	        }
	        if (url.includes(constants.languagePlaceHolder)) {
	            requestParams.url = requestParams.url.replace(constants.languagePlaceHolder, this.styleOptions.language);
	        }
	        if (url.includes(constants.viewPlaceHolder)) {
	            requestParams.url = this.styleOptions.view ?
	                requestParams.url.replace(constants.viewPlaceHolder, this.styleOptions.view) :
	                requestParams.url.replace(constants.viewPlaceHolder, "").replace("&".concat(constants.viewParameter, "="), "");
	        }
	    };
	    /**
	     * Sets whether the map will automatically resize when the browser window resizes.
	     * @private
	     */
	    Map.prototype._setAutoResize = function (autoResize) {
	        if (autoResize) {
	            if (!this.resizeObserver) {
	                this.resizeObserver = new ResizeObserver(this._resizeCallback);
	            }
	            this.resizeObserver.observe(this.map.getContainer());
	        }
	        else {
	            if (this.resizeObserver) {
	                this.resizeObserver.unobserve(this.map.getContainer());
	            }
	        }
	    };
	    /**
	     * Adds or replaces the relevant fundamental map components (layers and sources) based on the input options.
	     * Removes sources and layers that aren't used by the new style or any remaining layers.
	     * @private
	     */
	    Map.prototype._setStyleComponents = function (styleOptions, diff) {
	        var _this = this;
	        if (diff === void 0) { diff = true; }
	        if (this.removed) {
	            return;
	        }
	        var styleDefinitionPromise = this.styles.definitions();
	        styleDefinitionPromise.then(function (mapConfiguration) {
	            var e_4, _a;
	            // a flag indicating if need to set this.styleOptions.style
	            var needSetStyleOptionStyle = true;
	            // Check if the default style is set by the client and if it exists in the current style set
	            if (_this.styleOptions.style) {
	                try {
	                    for (var _b = __values(mapConfiguration.configurations), _c = _b.next(); !_c.done; _c = _b.next()) {
	                        var mapConfigurationStyle = _c.value;
	                        if (_this.styleOptions.style === mapConfigurationStyle.name) {
	                            needSetStyleOptionStyle = false;
	                            break;
	                        }
	                    }
	                }
	                catch (e_4_1) { e_4 = { error: e_4_1 }; }
	                finally {
	                    try {
	                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                    }
	                    finally { if (e_4) throw e_4.error; }
	                }
	            }
	            if (needSetStyleOptionStyle) {
	                // FIXME: this is very counter intuitive and unstable
	                // see details: https://msazure.visualstudio.com/One/_workitems/edit/19409195
	                _this.styleOptions.style = mapConfiguration.defaultConfiguration;
	            }
	            // it appears this line is overwriting everything done above
	            // but "styleOptions" has actually been changed by line 1578.
	            // NEED BETTER logic
	            _this.styleOptions = styleOptions;
	            _this._rebuildStyle(diff);
	        });
	        return;
	    };
	    /**
	     * Set the default service/style options.
	     * Only set defaults if the users provided a value for them and no other default have been set.
	     */
	    Map.prototype._updateGlobalDefaults = function (options) {
	        if (options) {
	            // Must account for deprecated property names because these checks occur before the merge operations.
	            if (options.authOptions && !_hasSetAuthenticationOptions()) {
	                setAuthenticationOptions(options.authOptions);
	            }
	            if (options.domain && !_hasSetDomain()) {
	                setDomain(options.domain);
	            }
	            if (options.styleDefinitionsPath && !_hasSetStyleDefinitionsPath()) {
	                setStyleDefinitionsPath(options.styleDefinitionsPath);
	            }
	            if (options.workerCount && !_hasWorkerCount()) {
	                setWorkerCount(options.workerCount);
	            }
	            if (options.maxParallelImageRequests && !_hasMaxParallelImageRequests()) {
	                setMaxParallelImageRequests(options.maxParallelImageRequests);
	            }
	            if ((options.subscriptionKey || options["subscription-key"]) && !_hasSetAuthenticationOptions()) {
	                setSubscriptionKey(options.subscriptionKey || options["subscription-key"]);
	            }
	            if ((options.sessionId || options["session-id"]) && !_hasSetSessionId()) {
	                setSessionId(options.sessionId || options["session-id"]);
	            }
	            if (options.language && !_hasSetLanguage()) {
	                setLanguage(options.language);
	            }
	            if ((options.userRegion || options.view) && !_hasSetView()) {
	                setUserRegion(options.userRegion || options.view);
	            }
	        }
	    };
	    Map.prototype._generateSafeBounds = function (bounds) {
	        if (bounds) {
	            var s = BoundingBox.getSouth(bounds);
	            var w = BoundingBox.getWest(bounds);
	            var n = BoundingBox.getNorth(bounds);
	            var e = BoundingBox.getEast(bounds);
	            if (!isFinite(s) || !isFinite(w) || !isFinite(n) || !isFinite(e)) {
	                throw new Error("The bounds specified are invalid: [".concat(bounds, "]"));
	            }
	            while (w > e) {
	                e += 360;
	            }
	            return new BoundingBox([w, s, e, n]);
	        }
	        return bounds;
	    };
	    Map.prototype._detectHighContrast = function () {
	        var hcType = Media.getHighContrastMode();
	        var hcClass;
	        var hcStyle;
	        switch (hcType) {
	            case "invert":
	                hcClass = Map.Css.hcLight;
	                hcStyle = "high_contrast_light";
	                break;
	            case "light":
	                hcClass = Map.Css.hcLight;
	                hcStyle = "high_contrast_light";
	                break;
	            case "dark":
	                hcClass = Map.Css.hcDark;
	                hcStyle = "high_contrast_dark";
	                break;
	        }
	        if (hcClass) {
	            this.map.getContainer().classList.add(hcClass);
	        }
	        if (hcStyle && this.styleOptions.style === "road") {
	            this.styleOptions.style = hcStyle;
	        }
	    };
	    // Static CSS classes
	    Map.Css = {
	        canvasContainer: "atlas-map-canvas-container",
	        canvas: "atlas-map-canvas",
	        container: "atlas-map",
	        hcDark: "high-contrast-dark",
	        hcLight: "high-contrast-light"
	    };
	    return Map;
	}(EventEmitter));

	var __read = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/** A layout template for a popup. */
	var PopupTemplate = /** @class */ (function () {
	    function PopupTemplate() {
	        //////////////////////
	        /// Properties
	        //////////////////////
	        /**
	         * Specifies if hyperlinks and email addresses should automatically be detected and rendered as clickable links.
	         * Default: `true`
	         * @default true
	         */
	        this.detectHyperlinks = true;
	        /**
	         * Specifies if property paths should be parsed using forward slashes "/" as sub-property dividers,
	         * or if the whole path should be treated as one property name.
	         * Default: `true`
	         * @default true
	         */
	        this.parsePropertyPaths = true;
	    }
	    //////////////////////
	    /// Public static functions
	    //////////////////////
	    /**
	     * Generates popup content by applying a template to a set of properties.
	     * If no template is specified, `title` or `name` properties will be used as fallbacks for the title if available.
	     * For content, a `description` property will be used or else all properties will be converted into a table.
	     * @param prop The properties object generate the popup content from.
	     * @param template The template to apply.
	     */
	    PopupTemplate.applyTemplate = function (prop, template) {
	        var _this = this;
	        var container = document.createElement("div");
	        container.classList.add(PopupTemplate.Css.template);
	        if (prop) {
	            if (!template) {
	                template = {};
	            }
	            if (typeof template.singleDescription !== "boolean") {
	                template.singleDescription = true;
	            }
	            template.sandboxContent = (typeof template.sandboxContent === "boolean") ? template.sandboxContent : true;
	            if (!(template.title && typeof template.content === "string" &&
	                (template.content.includes("{title}") || template.content.includes("{name}")))) {
	                if (prop.title) {
	                    template.title = "{title}";
	                }
	                else if (prop.name) {
	                    template.title = "{name}";
	                }
	            }
	            if (typeof template.detectHyperlinks !== "boolean") {
	                template.detectHyperlinks = true;
	            }
	            if (typeof template.parsePropertyPaths !== "boolean") {
	                template.parsePropertyPaths = true;
	            }
	            if (template.textColor) {
	                container.style.color = template.textColor;
	            }
	            if (template.fillColor) {
	                container.style.backgroundColor = template.fillColor;
	            }
	            if (template.title) {
	                // For security, strip out all HTML from the title and use the popup templates styling.
	                var c = this._applyStringTemplate(prop, template.title, template);
	                c.innerText = c.textContent || c.innerText || "";
	                this._appendChild(container, c, PopupTemplate.Css.title);
	            }
	            var contentItems_1 = document.createElement("div");
	            contentItems_1.classList.add(PopupTemplate.Css.content);
	            if (Array.isArray(template.content)) {
	                // Check to see if content is a PropertyInfo array.
	                if (template.content.length > 0 && template.content[0]["propertyPath"]) {
	                    this._appendChild(contentItems_1, this._generateContent(prop, template.content, template), PopupTemplate.Css.item);
	                }
	                else {
	                    template.content.forEach(function (x) {
	                        _this._appendChild(contentItems_1, _this._generateContent(prop, x, template), PopupTemplate.Css.item);
	                    });
	                }
	            }
	            else {
	                // If there is a description property, and no other properties, don't generate a table.
	                var propCount_1 = 0;
	                if (prop.description) {
	                    Object.keys(prop).forEach(function (k) {
	                        if (!_this._ignoreProperty(k, prop[k])) {
	                            propCount_1++;
	                        }
	                    });
	                }
	                var c = void 0;
	                // If there is only one property (description), or two (description + Snippet (KML)),
	                // or a flag to only display description, only add the description to the content.
	                if (propCount_1 === 1 ||
	                    (template.singleDescription && prop.description) ||
	                    (propCount_1 === 2 && prop.Snippet)) {
	                    c = document.createElement("div");
	                    c.innerHTML = prop.description;
	                }
	                else {
	                    c = this._generateContent(prop, template.content, template);
	                }
	                this._appendChild(contentItems_1, c, PopupTemplate.Css.item);
	            }
	            if (contentItems_1.innerHTML !== "") {
	                if (template.sandboxContent) {
	                    container.appendChild(PopupTemplate._createSandboxedIframe(contentItems_1, template));
	                }
	                else {
	                    container.appendChild(contentItems_1);
	                }
	            }
	        }
	        return container;
	    };
	    //////////////////////
	    /// Private functions
	    //////////////////////
	    /**
	     * Generates a sandboxed iframe that contains the specified content.
	     * @param content The content to sandbox.
	     */
	    PopupTemplate._createSandboxedIframe = function (content, template) {
	        var iframe = document.createElement("iframe");
	        iframe.sandbox.add("allow-popups");
	        var c = content.innerHTML;
	        // Need to estimate size of content and defined iframe size accordingly.
	        // Can't measure content in iframe without using cross-site scripting,
	        // so analyzing content HTML string instead for safety.
	        var hasMedia = false;
	        var lineLength = 100;
	        var width = 550;
	        var height = 10;
	        var longestStringLength = 0;
	        if (document.body.scrollWidth <= 340) {
	            width = 300;
	            lineLength = 50;
	        }
	        var lines = c.split(/<(tr|div|br|li|h[0-9]|p>)/);
	        longestStringLength = Math.max.apply(Math, __spreadArray([], __read((lines.map(function (el) { return el.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length; }))), false)) - 1;
	        var w = Math.ceil(longestStringLength * 3.5);
	        if (w < width) {
	            width = w;
	            lineLength = longestStringLength;
	        }
	        // Check to see if the content contains an image.
	        if (c.includes("<img") || c.includes("<video")) {
	            hasMedia = true;
	            iframe.width = "550px";
	        }
	        else {
	            var rowHeight = (c.indexOf(PopupTemplate.Css.table) > -1) ? 25 : 20;
	            height += Math.max(lines.length * 0.5 * rowHeight, Math.ceil(c.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length / lineLength) * rowHeight);
	        }
	        iframe.width = width + "px";
	        if (hasMedia || height > 280) {
	            // If there is an image in the content, then max out content height.
	            iframe.height = "280px";
	        }
	        else {
	            iframe.height = height + "px";
	        }
	        var textColor = (template.textColor) ? "color:".concat(template.textColor, ";") : "";
	        var bgColor = (template.fillColor) ? "background-color:".concat(template.fillColor, ";") : "";
	        // Wrap content with some HTML and CSS.
	        var doc = '<html><head><title></title><meta charset="utf-8" /><meta http-equiv="x-ua-compatible" content="IE=Edge" />' +
	            "<link rel=\"stylesheet\" href=\"".concat(PopupTemplate._cssUrl, "\" type=\"text/css\"/>") +
	            "<style>html, body{margin:0;padding:0;".concat(textColor).concat(bgColor, "}</style></head>") +
	            "<body><div class=\"".concat(PopupTemplate.Css.template, "\" style=\"padding:0;width:").concat(width - 20, "px\">").concat(c, "</div></body></html>");
	        // Check to see if srcdoc of iframe is supported (versions of Edge, pre-chromium, do not support srcdoc)
	        if (iframe.srcdoc === undefined) {
	            // Non-chromium versions of Edge do not support srcdoc property on iframes.
	            // In order to inject inline HTML into an iframe in a secure way, we have to pass in an encoded string.
	            // This has a limitation of only working with shorter strings
	            // (< 1,600 characters when encoded, assuming our CSS doesn't increase in size).
	            iframe.src = "data:text/html;charset=utf-8," + encodeURI(doc);
	        }
	        else {
	            iframe.srcdoc = doc;
	        }
	        return iframe;
	    };
	    /**
	     * Appends an HTML element as a child of another element and adds a class name to the child if specified.
	     * @param container The container to add the child element to.
	     * @param child The child element to add.
	     * @param className The class name to add to the child element.
	     */
	    PopupTemplate._appendChild = function (container, child, className) {
	        if (child) {
	            if (className) {
	                child.className = ((child.className) ? child.className + " " : "") + className;
	            }
	            container.appendChild(child);
	        }
	    };
	    /**
	     * Generates the popup content based on the template and available properties.
	     * @param properties The properties to apply to the template.
	     * @param content The template content.
	     * @param template The templates.
	     */
	    PopupTemplate._generateContent = function (properties, content, template) {
	        if (content) {
	            if (Array.isArray(content)) {
	                // Content is an array of PropertyInfo.
	                return this._generatePropertyInfoTable(properties, content, template);
	            }
	            else {
	                return this._applyStringTemplate(properties, content, template);
	            }
	        }
	        var t = this._generateDynamicTableHtml(properties, null, template);
	        if (t) {
	            var d = document.createElement("div");
	            d.innerHTML = t;
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Replaces placeholders with the property values in a string template.
	     * @param properties The properties to use.
	     * @param stringTemplate The string template to apply.
	     * @param template The template.
	     */
	    PopupTemplate._applyStringTemplate = function (properties, stringTemplate, template) {
	        if (stringTemplate) {
	            var content = stringTemplate;
	            var matches = this._placeholderRx.exec(stringTemplate);
	            // Search the template string using a regular expression.
	            while (matches) {
	                if (matches.length >= 2) {
	                    // Get the property path within a placeholder.
	                    var propValue = this._getPropertyValue(properties, matches[1], template);
	                    content = content.replace(matches[0], propValue);
	                }
	                matches = this._placeholderRx.exec(stringTemplate);
	            }
	            if (content) {
	                content = content.trim();
	                // If there is no HTML tags, replace newline characters with HTML line breaks.
	                if (content.includes("<")) {
	                    content = content.replace(/[\r\n]+/g, "<br/>");
	                }
	                var d = document.createElement("div");
	                d.innerHTML = content;
	                return d;
	            }
	        }
	        return null;
	    };
	    /**
	     * Retrieves the value of a property using its path.
	     * @param properties The set of properties to search from.
	     * @param propertyPath The path of the property.
	     * @param template The template.
	     * @param propertyInfo Property info to apply which specifies how the values should be displayed.
	     */
	    PopupTemplate._getPropertyValue = function (properties, propertyPath, template, propertyInfo) {
	        var path = template.parsePropertyPaths ? propertyPath.split("/") : [propertyPath];
	        var len = path.length;
	        if (len > 0 && properties) {
	            var key = path[0];
	            var obj = properties[key];
	            // Special case where a link may be a flattened link value from a atom feed.
	            if (template.detectHyperlinks && propertyPath === "link" &&
	                (!propertyInfo || propertyInfo.hyperlinkFormat)) {
	                var links_1 = [];
	                if (Array.isArray(obj)) {
	                    obj.forEach(function (l) {
	                        if (l.href) {
	                            links_1.push(l);
	                        }
	                        else if (typeof l === "string") {
	                            links_1.push({
	                                href: l
	                            });
	                        }
	                    });
	                }
	                else if (obj.href) {
	                    links_1.push(obj);
	                }
	                if (links_1.length > 0) {
	                    var f_1;
	                    if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                        f_1 = propertyInfo.hyperlinkFormat;
	                    }
	                    else if (template && template.hyperlinkFormat) {
	                        f_1 = template.hyperlinkFormat;
	                    }
	                    var t_1;
	                    if (f_1 && f_1.target) {
	                        t_1 = f_1.target;
	                    }
	                    else {
	                        t_1 = "_blank";
	                    }
	                    var html_1 = [];
	                    links_1.forEach(function (l) {
	                        if (!l.title && (!f_1 || !f_1.label) && l.rel) {
	                            html_1.push(l.rel, " - ");
	                        }
	                        html_1.push('<a href="', l.href, '" target="', t_1, '">');
	                        if (l.title) {
	                            html_1.push(l.title);
	                        }
	                        else if (f_1 && f_1.label) {
	                            html_1.push(f_1.label);
	                        }
	                        else {
	                            html_1.push(l.href);
	                        }
	                        html_1.push("</a>", "<br/>");
	                    });
	                    // Remove trailing <br/>
	                    html_1.pop();
	                    return html_1.join("");
	                }
	            }
	            if (obj != null) {
	                var i = void 0;
	                // Step through the property.
	                for (i = 1; i < len; i++) {
	                    obj = obj[path[i]];
	                    key = path[i];
	                    if (obj == null) {
	                        break;
	                    }
	                }
	                // Make sure that all properties were stepped through.
	                if (i === len && obj != null) {
	                    var propValue = void 0;
	                    if (typeof obj.value !== "undefined") {
	                        // Object is a SimpleField
	                        propValue = obj.value;
	                    }
	                    else {
	                        propValue = obj;
	                    }
	                    if (propValue instanceof Date) {
	                        if (propertyInfo && propertyInfo.dateFormat) {
	                            return propValue.toLocaleString(undefined, propertyInfo.dateFormat);
	                        }
	                        if (template.dateFormat) {
	                            return propValue.toLocaleString(undefined, template.dateFormat);
	                        }
	                        return propValue.toISOString();
	                    }
	                    else if (typeof propValue === "object") {
	                        // If the value of the property is an object, create a sub-table recursively.
	                        var t = this._generateDynamicTableHtml(propValue, path.slice(1), template);
	                        return (t) ? t : "";
	                    }
	                    else if (typeof propValue === "number") {
	                        if (propertyInfo) {
	                            if (propertyInfo.dateFormat) {
	                                // If the user assigned a date format to the field and the value is a number,
	                                // then assume that the number is the number of milliseconds.
	                                return new Date(propValue).toLocaleString(undefined, propertyInfo.dateFormat);
	                            }
	                            if (propertyInfo.numberFormat) {
	                                return propValue.toLocaleString(undefined, propertyInfo.numberFormat);
	                            }
	                        }
	                        else if (/(timestamp|date)/gi.test(key)) {
	                            // If the property name includes "timestamp" or "date" in it assume the number represents a Date object.
	                            return new Date(propValue).toISOString();
	                        }
	                        return propValue.toLocaleString(undefined, template.numberFormat);
	                    }
	                    else if (typeof propValue === "string" && propValue !== "" && !(/[\n\r<>\s]/g.test(propValue)) &&
	                        (template.detectHyperlinks || (propertyInfo && propertyInfo.hyperlinkFormat))) {
	                        // If the value is a string and doesn't include newline, spaces or xml <> characters,
	                        // then consider rendering as a hyperlink.
	                        propValue = propValue.trim();
	                        var isLink = this._isUrlRx.test(propValue) || (propertyInfo && propertyInfo.hyperlinkFormat);
	                        var isImage = this._isImageUrlRx.test(propValue) && (isLink || propValue.startsWith("data:image"));
	                        var isEmail = this._emailRx.test(propValue);
	                        if (isLink || isImage || isEmail) {
	                            var h = void 0;
	                            if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                                h = propertyInfo.hyperlinkFormat;
	                            }
	                            else if (template && template.hyperlinkFormat) {
	                                h = template.hyperlinkFormat;
	                            }
	                            var t = void 0;
	                            if (h && h.target) {
	                                t = " target=\"".concat(h.target, "\"");
	                            }
	                            else {
	                                t = ' target="_blank"';
	                            }
	                            var c = "".concat(h && h.label ? h.label : propValue);
	                            if (h && h.scheme) {
	                                propValue = h.scheme + propValue;
	                            }
	                            else if (isEmail) {
	                                propValue = "mailto:" + propValue;
	                            }
	                            var alt = h && h.label ? " alt=\"".concat(h.label, "\"") : "";
	                            if ((h && h.isImage) || isImage) {
	                                c = "<img src=\"".concat(propValue, "\" style=\"max-width:100%\"").concat(alt, "\"/>");
	                            }
	                            return "<a href=\"".concat(propValue, "\"").concat(t, ">").concat(c, "</a>");
	                        }
	                    }
	                    var p = propValue.toString();
	                    return p;
	                }
	            }
	        }
	        return "";
	    };
	    /**
	     * Generates a table from a set of properties filtered on an array of property info values.
	     * @param properties The properties.
	     * @param propertyInfo The property info values that specify which properties to display and how to display them.
	     * @param template The template.
	     */
	    PopupTemplate._generatePropertyInfoTable = function (properties, propertyInfo, template) {
	        if (properties && propertyInfo && propertyInfo.length > 0) {
	            var html_2 = [];
	            var self_1 = this;
	            // Create a HTML table from an objects property names and values.
	            html_2.push("<table class=\"".concat(self_1.Css.table, "\">"));
	            propertyInfo.forEach(function (pi) {
	                var c = self_1._getPropertyValue(properties, pi.propertyPath, template, pi);
	                if (pi.hideLabel) {
	                    html_2.push('<tr><td colspan="2">', c, "</td></tr>");
	                }
	                else {
	                    var l = pi.label || pi.propertyPath.split("/")[0];
	                    html_2.push("<tr><th>", l, "</th><td>", c, "</td></tr>");
	                }
	            });
	            html_2.push("</table>");
	            var d = document.createElement("div");
	            d.innerHTML = html_2.join("");
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Dynamically creates a table from the property information. Recursively steps through the property tree.
	     * @param properties The properties to generate a table for.
	     * @param subPath The sub-path within the properties to generate the table for.
	     * @param template The template.
	     */
	    PopupTemplate._generateDynamicTableHtml = function (properties, subPath, template) {
	        var _this = this;
	        if (properties) {
	            var html_3 = [];
	            var self_2 = this;
	            // Create a HTML table from an objects property names and values.
	            html_3.push("<table class=\"".concat(self_2.Css.table, "\">"));
	            var sp_1 = (subPath && subPath.length > 0) ? subPath.join("/") + "/" : "";
	            // Count the number of rows actually added to table.
	            var cnt_1 = 0;
	            Object.keys(properties).forEach(function (key) {
	                // Ignore private properties which are commonly denoted using an underscore, and style properties.
	                if (!_this._ignoreProperty(key, properties[key])) {
	                    html_3.push("<tr><th>", key, "</th><td>", self_2._getPropertyValue(properties, sp_1 + key, template), "</td></tr>");
	                    cnt_1++;
	                }
	            });
	            // If no rows added, don't return a table.
	            if (cnt_1 === 0) {
	                return null;
	            }
	            html_3.push("</table>");
	            return html_3.join("");
	        }
	        return null;
	    };
	    /**
	     * Checks to see if the property should be ignored based on the key or value.
	     * @param key The property name key.
	     * @param value The value of the property.
	     */
	    PopupTemplate._ignoreProperty = function (key, value) {
	        switch (key) {
	            // Ignore style and title properties.
	            case "title":
	            case "name":
	            case "base":
	            case "popupTemplate":
	            case "anchor":
	            case "icon":
	            case "image":
	            case "imageUrl":
	            case "rotation":
	            case "color":
	            case "size":
	            case "offset":
	            case "strokeColor":
	            case "strokeWidth":
	            case "strokeOpacity":
	            case "subType":
	            case "fillColor":
	            case "fillOpacity":
	            case "visibility":
	            case "visible":
	                return true;
	            default:
	                if (key.indexOf("_") === 0 || value == null || value === "") {
	                    return true;
	                }
	                break;
	        }
	        return false;
	    };
	    //////////////////////
	    /// Private properties
	    //////////////////////
	    /** Regular expression for content property placeholders. */
	    PopupTemplate._placeholderRx = /\{([a-zA-Z0-9_\/\s]+)\}/gi;
	    /** Regular expression for external URLs. */
	    PopupTemplate._isUrlRx = /^(http|https|ftp|tel|mailto):\/\//i;
	    /** Regular expression for image urls. */
	    PopupTemplate._isImageUrlRx = /(^data:image|.png$|.jpg$|.jpeg$|.gif$|.bmp$|.svg|.tif|.tiff$)/i;
	    /** Regular expression for email addresses. */
	    PopupTemplate._emailRx = /^[^\.\s@:](?:[^\s@:]*[^\s@:\.])?@[^\.\s@]+(?:\.[^\.\s@]+)*$/;
	    /** The URL to load our CSS from for iframed popups. */
	    PopupTemplate._cssUrl = new Url({
	        domain: env.staticAssetsDomain,
	        path: "sdk/javascript/mapcontrol/".concat(Version.getEndpointVersion(), "/atlas.min.css")
	    }).toString();
	    PopupTemplate.Css = {
	        template: "azure-maps-control-popup-template",
	        title: "azure-maps-control-popup-template-title",
	        content: "azure-maps-control-popup-template-content",
	        item: "azure-maps-control-popup-template-content-item",
	        table: "azure-maps-control-popup-template-table"
	    };
	    return PopupTemplate;
	}());

	{
	    // Enable the Right-To-Left Text Plugin
	    _enableRTLTextPlugin();
	}

	exports.HtmlMarker = HtmlMarker;
	exports.Map = Map$1;
	exports.Pixel = Pixel;
	exports.Popup = Popup;
	exports.PopupTemplate = PopupTemplate;
	exports.Shape = Shape;
	exports._enableRTLTextPlugin = _enableRTLTextPlugin;
	exports._getAssetDomain = _getAssetDomain;
	exports._getDomain = _getDomain;
	exports._hasMaxParallelImageRequests = _hasMaxParallelImageRequests;
	exports._hasSetAuthenticationOptions = _hasSetAuthenticationOptions;
	exports._hasSetDomain = _hasSetDomain;
	exports._hasSetLanguage = _hasSetLanguage;
	exports._hasSetSessionId = _hasSetSessionId;
	exports._hasSetStyleDefinitionsPath = _hasSetStyleDefinitionsPath;
	exports._hasSetStyleDefinitionsVersion = _hasSetStyleDefinitionsVersion;
	exports._hasSetView = _hasSetView;
	exports._hasWorkerCount = _hasWorkerCount;
	exports.addImageTemplate = addImageTemplate;
	exports.addProtocol = addProtocol;
	exports.clearPrewarmedResources = clearPrewarmedResources;
	exports.control = index$2;
	exports.data = index$4;
	exports.getAllImageTemplateNames = getAllImageTemplateNames;
	exports.getAuthenticationOptions = getAuthenticationOptions;
	exports.getDomain = getDomain;
	exports.getImageTemplate = getImageTemplate;
	exports.getLanguage = getLanguage;
	exports.getMaxParallelImageRequests = getMaxParallelImageRequests;
	exports.getSessionId = getSessionId;
	exports.getStaticAssetsDomain = getStaticAssetsDomain;
	exports.getStyleAPIVersion = getStyleAPIVersion;
	exports.getStyleDefinitionsPath = getStyleDefinitionsPath;
	exports.getStyleDefinitionsVersion = getStyleDefinitionsVersion;
	exports.getSubscriptionKey = getSubscriptionKey;
	exports.getUserRegion = getUserRegion;
	exports.getVersion = getVersion;
	exports.getView = getView;
	exports.getWorkerCount = getWorkerCount;
	exports.internal = index$5;
	exports.isSupported = isSupported;
	exports.layer = index;
	exports.math = index$3;
	exports.prewarm = prewarm;
	exports.removeProtocol = removeProtocol;
	exports.setAuthenticationOptions = setAuthenticationOptions;
	exports.setDomain = setDomain;
	exports.setLanguage = setLanguage;
	exports.setMaxParallelImageRequests = setMaxParallelImageRequests;
	exports.setSessionId = setSessionId;
	exports.setStyleAPIVersion = setStyleAPIVersion;
	exports.setStyleDefinitionsPath = setStyleDefinitionsPath;
	exports.setStyleDefinitionsVersion = setStyleDefinitionsVersion;
	exports.setSubscriptionKey = setSubscriptionKey;
	exports.setUserRegion = setUserRegion;
	exports.setView = setView;
	exports.setWorkerCount = setWorkerCount;
	exports.source = index$1;

}));
