/*!
MICROSOFT SOFTWARE LICENSE TERMS
MICROSOFT AZURE MAPS WEB SDK
These license terms are an agreement between you and Microsoft Corporation (or one of its affiliates). They apply to the software named above and any Microsoft services or software updates (except to the extent such services or updates are accompanied by new or additional terms, in which case those different terms apply prospectively and do not alter your or Microsoft’s rights relating to pre-updated software or services). IF YOU COMPLY WITH THESE LICENSE TERMS, YOU HAVE THE RIGHTS BELOW.  BY USING THE SOFTWARE, YOU ACCEPT THESE TERMS.
1. INSTALLATION AND USE RIGHTS.
  a) General. You may install and use any number of copies of the software to develop and test your applications.
  b) User Region Parameters. The software will allow you to select from a View list to set the map view within your application for a given customer. By default the View parameter (also referred to as “user region parameter” is set to “Unified”.  Countries/Regions that are not on the View list will default to the “Unified” View. It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter must be used in compliance with applicable laws, including those regarding mapping, of the country where maps, images and other data and third party content that You are authorized to access via the software is made available. 
  c) Third Party Software. The software may include third party applications that Microsoft, not the third party, licenses to you under this agreement. Any included notices for third party applications are for your information only.
  d) Microsoft Online Subscription Agreement. Some features of the software provide access to, or rely on, Microsoft Azure Services. The use of those services (but not the software) is governed by the separate terms and privacy policies associated with your Microsoft Azure subscription. The services may not be available in all regions. For more information see https://go.microsoft.com/fwLink/?LinkID=522330&amp;clcid=0x9.
2. DISTRIBUTABLE CODE. The software is comprised of “Distributable Code”. “Distributable Code” is code that you are permitted to distribute in applications you develop if you comply with the terms below and otherwise set forth in these license terms. 
  a) Distribution Rights. 
    i. You may copy and distribute the object code form of the software.
    i. Third Party Distribution. You may permit distributors of your applications to copy and distribute any of this distributable code you elect to distribute with your applications.
  b) Distribution Requirements. For any code you distribute, you must:
    i. add significant primary functionality to it in your applications;
    ii. require distributors and external end users to agree to terms that protect it and Microsoft at least as much as this agreement; and
    iii. indemnify, defend, and hold harmless Microsoft from any claims, including attorneys’ fees, related to the distribution or use of your applications, except to the extent that any claim is based solely on the unmodified distributable code.
  c) Distribution Restrictions. You may not:
    i. use Microsoft’s trademarks or trade dress in your application in any way that suggests your application comes from or is endorsed by Microsoft; or
    ii. modify or distribute the source code of any distributable code so that any part of it becomes subject to any license that requires that the distributable code, any other part of the software, or any of Microsoft’s other intellectual property be disclosed or distributed in source code form, or that others have the right to modify it.
3. DATA COLLECTION. The software may collect information about you and your use of the software and send that to Microsoft. Microsoft may use this information to provide services and improve Microsoft’s products and services. Your opt-out rights, if any, are described in the product documentation. Some features in the software may enable collection of data from users of your applications that access or use the software. If you use these features to enable data collection in your applications, you must comply with applicable law, including getting any required user consent, and maintain a prominent privacy policy that accurately informs users about how you use, collect, and share their data. You can learn more about Microsoft’s data collection and use in the product documentation and the Microsoft Privacy Statement at https://go.microsoft.com/fwlink/?LinkId=512132. You agree to comply with all applicable provisions of the Microsoft Privacy Statement.
4. SCOPE OF LICENSE. The software is licensed, not sold. Microsoft reserves all other rights. Unless applicable law gives you more rights despite this limitation, you will not (and have no right to):
  a) work around any technical limitations in the software that only allow you to use it in certain ways;
  b) reverse engineer, decompile, or disassemble the software, or attempt to do so, except and only to the extent permitted by licensing terms governing the use of open-source components that may be included with the software;
  c) remove, minimize, block, or modify any notices of Microsoft or its suppliers in the software;
  d) use the software in any way that is against the law or to create or propagate malware; or
  e) share, publish, distribute, or lend the software (except for any distributable code, subject to the terms above), provide the software as a stand-alone hosted solution for others to use, or transfer the software or this agreement to any third party.
5. EXPORT RESTRICTIONS. You must comply with all domestic and international export laws and regulations that apply to the software, which include restrictions on destinations, end users, and end use. For further information on export restrictions, visit http://aka.ms/exporting.
6. SUPPORT SERVICES. Microsoft is not obligated under this agreement to provide any support services for the software. Any support provided is “as is”, “with all faults”, and without warranty of any kind.
7. UPDATES. The software may periodically check for updates, and download and install them for you. You may obtain updates only from Microsoft or authorized sources. Microsoft may need to update your system to provide you with updates. You agree to receive these automatic updates without any additional notice. Updates may not include or support all existing software features, services, or peripheral devices.
8. ENTIRE AGREEMENT. This agreement, and any other terms Microsoft may provide for supplements, updates, or third-party applications, is the entire agreement for the software.
9. APPLICABLE LAW AND PLACE TO RESOLVE DISPUTES. If you acquired the software in the United States or Canada, the laws of the state or province where you live (or, if a business, where your principal place of business is located) govern the interpretation of this agreement, claims for its breach, and all other claims (including consumer protection, unfair competition, and tort claims), regardless of conflict of laws principles. If you acquired the software in any other country, its laws apply. If U.S. federal jurisdiction exists, you and Microsoft consent to exclusive jurisdiction and venue in the federal court in King County, Washington for all disputes heard in court. If not, you and Microsoft consent to exclusive jurisdiction and venue in the Superior Court of King County, Washington for all disputes heard in court.
10. CONSUMER RIGHTS; REGIONAL VARIATIONS. This agreement describes certain legal rights. You may have other rights, including consumer rights, under the laws of your state or country. Separate and apart from your relationship with Microsoft, you may also have rights with respect to the party from which you acquired the software. This agreement does not change those other rights if the laws of your state or country do not permit it to do so. For example, if you acquired the software in one of the below regions, or mandatory country law applies, then the following provisions apply to you:
  a) Australia. You have statutory guarantees under the Australian Consumer Law and nothing in this agreement is intended to affect those rights.
  b) Canada. If you acquired this software in Canada, you may stop receiving updates by turning off the automatic update feature, disconnecting your device from the Internet (if and when you re-connect to the Internet, however, the software will resume checking for and installing updates), or uninstalling the software. The product documentation, if any, may also specify how to turn off updates for your specific device or software.
  c) Germany and Austria.
    i. Warranty. The properly licensed software will perform substantially as described in any Microsoft materials that accompany the software. However, Microsoft gives no contractual guarantee in relation to the licensed software.
    ii. Limitation of Liability. In case of intentional conduct, gross negligence, claims based on the Product Liability Act, as well as, in case of death or personal or physical injury, Microsoft is liable according to the statutory law.
  Subject to the foregoing clause ii., Microsoft will only be liable for slight negligence if Microsoft is in breach of such material contractual obligations, the fulfillment of which facilitate the due performance of this agreement, the breach of which would endanger the purpose of this agreement and the compliance with which a party may constantly trust in (so-called "cardinal obligations"). In other cases of slight negligence, Microsoft will not be liable for slight negligence.
11. DISCLAIMER OF WARRANTY. THE SOFTWARE IS LICENSED “AS IS.” YOU BEAR THE RISK OF USING IT. MICROSOFT GIVES NO EXPRESS WARRANTIES, GUARANTEES, OR CONDITIONS. TO THE EXTENT PERMITTED UNDER APPLICABLE LAWS, MICROSOFT EXCLUDES ALL IMPLIED WARRANTIES, INCLUDING MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
12. LIMITATION ON AND EXCLUSION OF DAMAGES. IF YOU HAVE ANY BASIS FOR RECOVERING DAMAGES DESPITE THE PRECEDING DISCLAIMER OF WARRANTY, YOU CAN RECOVER FROM MICROSOFT AND ITS SUPPLIERS ONLY DIRECT DAMAGES UP TO U.S. $5.00. YOU CANNOT RECOVER ANY OTHER DAMAGES, INCLUDING CONSEQUENTIAL, LOST PROFITS, SPECIAL, INDIRECT, OR INCIDENTAL DAMAGES.
This limitation applies to (a) anything related to the software, services, content (including code) on third party Internet sites, or third party applications; and (b) claims for breach of contract, warranty, guarantee, or condition; strict liability, negligence, or other tort; or any other claim; in each case to the extent permitted by applicable law.
It also applies even if Microsoft knew or should have known about the possibility of the damages. The above limitation or exclusion may not apply to you because your state, province, or country may not allow the exclusion or limitation of incidental, consequential, or other damages.
Please note: As this software is distributed in Canada, some of the clauses in this agreement are provided below in French.
Remarque: Ce logiciel étant distribué au Canada, certaines des clauses dans ce contrat sont fournies ci-dessous en français.
EXONÉRATION DE GARANTIE. Le logiciel visé par une licence est offert « tel quel ». Toute utilisation de ce logiciel est à votre seule risque et péril. Microsoft n’accorde aucune autre garantie expresse. Vous pouvez bénéficier de droits additionnels en vertu du droit local sur la protection des consommateurs, que ce contrat ne peut modifier. La ou elles sont permises par le droit locale, les garanties implicites de qualité marchande, d’adéquation à un usage particulier et d’absence de contrefaçon sont exclues.
LIMITATION DES DOMMAGES-INTÉRÊTS ET EXCLUSION DE RESPONSABILITÉ POUR LES DOMMAGES. Vous pouvez obtenir de Microsoft et de ses fournisseurs une indemnisation en cas de dommages directs uniquement à hauteur de 5,00 $ US. Vous ne pouvez prétendre à aucune indemnisation pour les autres dommages, y compris les dommages spéciaux, indirects ou accessoires et pertes de bénéfices.
Cette limitation concerne:
• tout ce qui est relié au logiciel, aux services ou au contenu (y compris le code) figurant sur des sites Internet tiers ou dans des programmes tiers; et
• les réclamations au titre de violation de contrat ou de garantie, ou au titre de responsabilité stricte, de négligence ou d’une autre faute dans la limite autorisée par la loi en vigueur.
Elle s’applique également, même si Microsoft connaissait ou devrait connaître l’éventualité d’un tel dommage. Si votre pays n’autorise pas l’exclusion ou la limitation de responsabilité pour les dommages indirects, accessoires ou de quelque nature que ce soit, il se peut que la limitation ou l’exclusion ci-dessus ne s’appliquera pas à votre égard.
EFFET JURIDIQUE. Le présent contrat décrit certains droits juridiques. Vous pourriez avoir d’autres droits prévus par les lois de votre pays. Le présent contrat ne modifie pas les droits que vous confèrent les lois de votre pays si celles-ci ne le permettent pas.
*/

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('azuremaps-maplibre-gl')) :
	typeof define === 'function' && define.amd ? define(['exports', 'azuremaps-maplibre-gl'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.atlas = global.atlas || {}, global.maplibregl));
})(this, (function (exports, maplibregl) { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getAugmentedNamespace(n) {
	  if (n.__esModule) return n;
	  var f = n.default;
		if (typeof f == "function") {
			var a = function a () {
				if (this instanceof a) {
	        return Reflect.construct(f, arguments, this.constructor);
				}
				return f.apply(this, arguments);
			};
			a.prototype = f.prototype;
	  } else a = {};
	  Object.defineProperty(a, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var uuidRandom = {exports: {}};

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		default: _nodeResolve_empty
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

	(function (module) {

		(function(){

		  var
		    buf,
		    bufIdx = 0,
		    hexBytes = [],
		    i
		  ;

		  // Pre-calculate toString(16) for speed
		  for (i = 0; i < 256; i++) {
		    hexBytes[i] = (i + 0x100).toString(16).substr(1);
		  }

		  // Buffer random numbers for speed
		  // Reduce memory usage by decreasing this number (min 16)
		  // or improve speed by increasing this number (try 16384)
		  uuid.BUFFER_SIZE = 4096;

		  // Binary uuids
		  uuid.bin = uuidBin;

		  // Clear buffer
		  uuid.clearBuffer = function() {
		    buf = null;
		    bufIdx = 0;
		  };

		  // Test for uuid
		  uuid.test = function(uuid) {
		    if (typeof uuid === 'string') {
		      return /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(uuid);
		    }
		    return false;
		  };

		  // Node & Browser support
		  var crypt0;
		  if (typeof crypto !== 'undefined') {
		    crypt0 = crypto;
		  } else if( (typeof window !== 'undefined') && (typeof window.msCrypto !== 'undefined')) {
		    crypt0 = window.msCrypto; // IE11
		  }

		  if ((typeof commonjsRequire === 'function')) {
		    crypt0 = crypt0 || require$$0;
		    module.exports = uuid;
		  } else if (typeof window !== 'undefined') {
		    window.uuid = uuid;
		  }

		  // Use best available PRNG
		  // Also expose this so you can override it.
		  uuid.randomBytes = (function(){
		    if (crypt0) {
		      if (crypt0.randomBytes) {
		        return crypt0.randomBytes;
		      }
		      if (crypt0.getRandomValues) {
		        if (typeof Uint8Array.prototype.slice !== 'function') {
		          return function(n) {
		            var bytes = new Uint8Array(n);
		            crypt0.getRandomValues(bytes);
		            return Array.from(bytes);
		          };
		        }
		        return function(n) {
		          var bytes = new Uint8Array(n);
		          crypt0.getRandomValues(bytes);
		          return bytes;
		        };
		      }
		    }
		    return function(n) {
		      var i, r = [];
		      for (i = 0; i < n; i++) {
		        r.push(Math.floor(Math.random() * 256));
		      }
		      return r;
		    };
		  })();

		  // Buffer some random bytes for speed
		  function randomBytesBuffered(n) {
		    if (!buf || ((bufIdx + n) > uuid.BUFFER_SIZE)) {
		      bufIdx = 0;
		      buf = uuid.randomBytes(uuid.BUFFER_SIZE);
		    }
		    return buf.slice(bufIdx, bufIdx += n);
		  }

		  // uuid.bin
		  function uuidBin() {
		    var b = randomBytesBuffered(16);
		    b[6] = (b[6] & 0x0f) | 0x40;
		    b[8] = (b[8] & 0x3f) | 0x80;
		    return b;
		  }

		  // String UUIDv4 (Random)
		  function uuid() {
		    var b = uuidBin();
		    return hexBytes[b[0]] + hexBytes[b[1]] +
		      hexBytes[b[2]] + hexBytes[b[3]] + '-' +
		      hexBytes[b[4]] + hexBytes[b[5]] + '-' +
		      hexBytes[b[6]] + hexBytes[b[7]] + '-' +
		      hexBytes[b[8]] + hexBytes[b[9]] + '-' +
		      hexBytes[b[10]] + hexBytes[b[11]] +
		      hexBytes[b[12]] + hexBytes[b[13]] +
		      hexBytes[b[14]] + hexBytes[b[15]]
		    ;
		  }

		})(); 
	} (uuidRandom));

	var uuidRandomExports = uuidRandom.exports;
	var uuid = /*@__PURE__*/getDefaultExportFromCjs(uuidRandomExports);

	var env = {
		domain: "atlas.microsoft.com",
		staticAssetsDomain: "atlas.microsoft.com",
		stylePath: "styling",
		styleDefinitionsVersion: "2023-01-01",
		appInsightsKey: "e96cb745-c6f5-409c-a775-c4313e468c1d",
		aadInstance: "https://login.windows.net/"
	};
	var constants = {
		apiVersionQueryParameter: "api-version",
		authorizationHeaderName: "Authorization",
		authorizationTokenPrefix: "Bearer ",
		jwtSasPrefix: "jwt-sas ",
		domainPlaceHolder: "{{azMapsDomain}}",
		legacyDomainPlaceHolder: "{azMapsDomain}",
		viewPlaceHolder: "{{azMapsView}}",
		viewParameter: "view",
		languagePlaceHolder: "{{azMapsLanguage}}",
		stylePathHolder: "{{azMapsStylingPath}}",
		styleResourcePlaceholder: "{{azMapsStylePath}}",
		stylePath: "styling",
		styleResourcePath: "styles",
		styleApiVersion: "2.0",
		mapAgentHeaderName: "Map-Agent",
		msClientIdHeaderName: "x-ms-client-id",
		msOriginHeaderName: "Ms-Am-Request-Origin",
		msOriginHeaderValue: "MapControl",
		aadResourceId: "https://atlas.microsoft.com/.default",
		sessionIdHeaderName: "Session-Id"
	};

	var __values$k = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * @private
	 */
	var Options = /** @class */ (function () {
	    function Options() {
	    }
	    /**
	     * @internal
	     */
	    Options.prototype.merge = function () {
	        var e_1, _a;
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        var defaults;
	        try {
	            for (var valuesList_1 = __values$k(valuesList), valuesList_1_1 = valuesList_1.next(); !valuesList_1_1.done; valuesList_1_1 = valuesList_1.next()) {
	                var values = valuesList_1_1.value;
	                if (!values) {
	                    continue;
	                }
	                for (var property in values) {
	                    if (values.hasOwnProperty(property) && this.hasOwnProperty(property)) {
	                        if (values[property] !== undefined && values[property] != null) {
	                            // Check for nested options and merge them rather than simply overwriting.
	                            if (this[property] instanceof Options) {
	                                this[property].merge(values[property]);
	                            }
	                            else {
	                                this[property] = values[property];
	                            }
	                        }
	                        else {
	                            // Assume a value of undefined or null intends to take the default value.
	                            // Create a new object to access its defaults.
	                            if (!defaults) {
	                                defaults = new (Object.getPrototypeOf(this).constructor)();
	                            }
	                            this[property] = defaults[property];
	                        }
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valuesList_1_1 && !valuesList_1_1.done && (_a = valuesList_1.return)) _a.call(valuesList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return this;
	    };
	    return Options;
	}());

	var __extends$1k = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __read$d = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * @private
	 */
	var UrlOptions = /** @class */ (function (_super) {
	    __extends$1k(UrlOptions, _super);
	    function UrlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.domain = undefined;
	        _this.headers = {};
	        _this.path = "";
	        _this.protocol = "https";
	        _this.queryParams = {};
	        _this.subdomain = "";
	        return _this;
	    }
	    return UrlOptions;
	}(Options));
	/**
	 * @private
	 */
	// tslint:disable-next-line:max-classes-per-file
	var Url = /** @class */ (function () {
	    function Url(options) {
	        this.options = new UrlOptions().merge(options);
	    }
	    // tslint:disable-next-line:no-reserved-keywords
	    Url.prototype.get = function () {
	        return fetch(this.toString(), {
	            method: "GET",
	            mode: "cors",
	            headers: new Headers(this.options.headers),
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
	            }
	        });
	    };
	    Url.prototype.toString = function () {
	        var self = this;
	        var queryParamsString = Object.entries(self.options.queryParams)
	            .map(function (_a) {
	            var _b = __read$d(_a, 2), key = _b[0], value = _b[1];
	            return "".concat(key, "=").concat(value);
	        })
	            .join("&");
	        var url = [];
	        var path = self.options.path || "";
	        // If path contains the protocol, don't add domain to the url.
	        if (Url.protoRegEx.test(path)) {
	            url.push(path);
	        }
	        else {
	            // domain may be empty for absolute paths or
	            // path itself might start with '/' for absolute paths
	            if (self.options.domain) {
	                if (!Url.protoRegEx.test(self.options.domain)) {
	                    // If the domain doesn't include a protocol use the separate protocol and subdomain properties.
	                    // If the domain includes a protocol assume it also includes the subdomain.
	                    url.push("".concat(self.options.protocol, "://"));
	                    url.push(self.options.subdomain ? "".concat(self.options.subdomain, ".") : "");
	                }
	                url.push(self.options.domain);
	            }
	            url.push(self.options.path ? "/".concat(path) : "");
	        }
	        url.push(queryParamsString ? "?".concat(queryParamsString) : "");
	        return url.join("");
	    };
	    Url.protoRegEx = new RegExp(/^(((file|http|https):\/\/)|blob:)/i);
	    return Url;
	}());

	/**
	 * A helper class that will parses and splits a culture code into its language and region parts.
	 */
	var CultureCode = /** @class */ (function () {
	    function CultureCode() {
	    }
	    /**
	     * Parses and splits the specified culture code.
	     * Splits based on the last index of "-".
	     * If a split can not be made the specified code will be considered just the language leaving region undefined.
	     * All string properties will be in lowercase for simplified string matching.
	     * @param code The culture code.
	     */
	    CultureCode.parse = function (code) {
	        code = code.toLowerCase();
	        var index = code.lastIndexOf("-");
	        if (index !== -1) {
	            return {
	                code: code,
	                language: code.substring(0, index),
	                region: code.substring(index + 1)
	            };
	        }
	        return {
	            code: code,
	            language: code,
	        };
	    };
	    return CultureCode;
	}());

	/**
	 * A specific implementation of the LocaleIndex interface.
	 * Contains real information about the available/supported locales.
	 */
	var localeIndex = {
	    localizationsPath: "locs/mapcontrol/2019-3-12",
	    sensitiveUserRegions: ["il", "kr", "pk", "in", "cn", "ar", "bh", "eg", "jo", "sa", "kw", "om", "qa", "ma", "ae"],
	    locales: {
	        defaultLanguage: {
	            defaultRegion: {
	                code: "NGT",
	                strings: "en/resource.json"
	            },
	            latn: {
	                code: "NGT-Latn",
	                strings: "en/resource.json"
	            }
	        },
	        ar: {
	            defaultRegion: {
	                code: "ar",
	                strings: "ar-sa/resource.json"
	            }
	        },
	        bg: {
	            defaultRegion: {
	                code: "bg-BG",
	                strings: "bg-bg/resource.json"
	            }
	        },
	        cs: {
	            defaultRegion: {
	                code: "cs-CZ",
	                strings: "cs-cz/resource.json"
	            }
	        },
	        da: {
	            defaultRegion: {
	                code: "da-DK",
	                strings: "da-dk/resource.json"
	            }
	        },
	        de: {
	            defaultRegion: {
	                code: "de-DE",
	                strings: "de-de/resource.json"
	            }
	        },
	        el: {
	            defaultRegion: {
	                code: "el-GR",
	                strings: "el-gr/resource.json"
	            }
	        },
	        en: {
	            defaultRegion: {
	                code: "en",
	                strings: "en/resource.json"
	            },
	            us: {
	                code: "en-US",
	                strings: "en/resource.json"
	            },
	            au: {
	                code: "en-AU",
	                strings: "en/resource.json"
	            },
	            gb: {
	                code: "en-GB",
	                strings: "en/resource.json"
	            },
	            nz: {
	                code: "en-NZ",
	                strings: "en/resource.json"
	            }
	        },
	        es: {
	            defaultRegion: {
	                code: "es-ES",
	                strings: "es-es/resource.json"
	            },
	            mx: {
	                code: "es-MX",
	                strings: "es-mx/resource.json"
	            }
	        },
	        fi: {
	            defaultRegion: {
	                code: "fi-FI",
	                strings: "fi-fi/resource.json"
	            }
	        },
	        fr: {
	            defaultRegion: {
	                code: "fr-FR",
	                strings: "fr-fr/resource.json"
	            }
	        },
	        hu: {
	            defaultRegion: {
	                code: "hu-HU",
	                strings: "hu-hu/resource.json"
	            }
	        },
	        id: {
	            defaultRegion: {
	                code: "id-ID",
	                strings: "id-id/resource.json"
	            }
	        },
	        it: {
	            defaultRegion: {
	                code: "it-IT",
	                strings: "it-it/resource.json"
	            }
	        },
	        ko: {
	            defaultRegion: {
	                code: "ko-KR",
	                strings: "ko-kr/resource.json"
	            }
	        },
	        lt: {
	            defaultRegion: {
	                code: "lt-LT",
	                strings: "lt-lt/resource.json"
	            }
	        },
	        ms: {
	            defaultRegion: {
	                code: "ms-MY",
	                strings: "ms-my/resource.json"
	            }
	        },
	        nb: {
	            defaultRegion: {
	                code: "nb-NO",
	                strings: "nb-no/resource.json"
	            }
	        },
	        nl: {
	            defaultRegion: {
	                code: "nl-NL",
	                strings: "nl-nl/resource.json"
	            }
	        },
	        pl: {
	            defaultRegion: {
	                code: "pl-PL",
	                strings: "pl-pl/resource.json"
	            }
	        },
	        pt: {
	            defaultRegion: {
	                code: "pt-PT",
	                strings: "pt-pt/resource.json"
	            },
	            br: {
	                code: "pt-BR",
	                strings: "pt-br/resource.json"
	            }
	        },
	        ru: {
	            defaultRegion: {
	                code: "ru-RU",
	                strings: "ru-ru/resource.json"
	            }
	        },
	        sk: {
	            defaultRegion: {
	                code: "sk-SK",
	                strings: "sk-sk/resource.json"
	            }
	        },
	        sl: {
	            defaultRegion: {
	                code: "sl-SL",
	                strings: "sl-sl/resource.json"
	            }
	        },
	        sv: {
	            defaultRegion: {
	                code: "sv-SE",
	                strings: "sv-se/resource.json"
	            }
	        },
	        th: {
	            defaultRegion: {
	                code: "th-TH",
	                strings: "th-th/resource.json"
	            }
	        },
	        tr: {
	            defaultRegion: {
	                code: "tr-TR",
	                strings: "tr-tr/resource.json"
	            }
	        },
	        zh: {
	            // per https://microsoft.sharepoint.com/sites/globalreadiness/SitePages/Language-fallback.aspx
	            // Chinese - Neutral (zh) fallbacks to en-US
	            defaultRegion: {
	                code: "zh",
	                strings: "en/resource.json"
	            }
	        },
	        "zh-hans": {
	            defaultRegion: {
	                code: "zh-Hans",
	                strings: "zh-cn/resource.json"
	            },
	            cn: {
	                code: "zh-Hans-CN",
	                strings: "zh-cn/resource.json"
	            }
	        },
	        "zh-hant": {
	            // per discussion with global readiness team, we were explicitly asked to not fallback zh-hant to zh-tw
	            defaultRegion: {
	                code: "zh-Hant",
	                strings: "en/resource.json"
	            },
	            tw: {
	                code: "zh-Hant-TW",
	                strings: "zh-tw/resource.json"
	            }
	        }
	    }
	};

	/**
	 * An interface defining the contents of a specific localized strings json.
	 */
	var LocalizedStrings = /** @class */ (function () {
	    function LocalizedStrings() {
	        /**
	         * A localized version of `"Unknown"`.
	         */
	        this.Unknown = "Unknown";
	        /**
	         * A localized version of `"Accident"`.
	         */
	        this.Accident = "Accident";
	        /**
	         * A localized version of `"Fog"`.
	         */
	        this.Fog = "Fog";
	        /**
	         * A localized version of `"Danger"`.
	         */
	        this.Danger = "Danger";
	        /**
	         * A localized version of `"Rain"`.
	         */
	        this.Rain = "Rain";
	        /**
	         * A localized version of `"Ice"`.
	         */
	        this.Ice = "Ice";
	        /**
	         * A localized version of `"Jam"`.
	         */
	        this.Jam = "Jam";
	        /**
	         * A localized version of `"Lane Closed"`.
	         */
	        this.LaneClosed = "Lane Closed";
	        /**
	         * A localized version of `"Road Closed"`.
	         */
	        this.RoadClosed = "Road Closed";
	        /**
	         * A localized version of `"Road Works"`.
	         */
	        this.RoadWorks = "Road Works";
	        /**
	         * A localized version of `"Wind"`.
	         */
	        this.Wind = "Wind";
	        /**
	         * A localized version of `"Flood"`.
	         */
	        this.Flood = "Flood";
	        /**
	         * A localized version of `"Detour"`.
	         */
	        this.Detour = "Detour";
	    }
	    return LocalizedStrings;
	}());

	/**
	 * A static class used for fetching localized strings and validating supported language codes.
	 */
	var Localizer = /** @class */ (function () {
	    function Localizer() {
	    }
	    /**
	     * Returns a supported culture code that best fits the requested one.
	     * @param locale The requested culture code.
	     */
	    Localizer.getCode = function (locale) {
	        var code = CultureCode.parse(locale);
	        // If the requested culture code includes a sensitive region simply return the original code.
	        // This is to hopefully reduce the risk or providing bad content to users in a sensitive region.
	        return (localeIndex.sensitiveUserRegions.indexOf(code.region) === -1) ?
	            this.getLocaleData(code).code :
	            locale;
	    };
	    /**
	     * Returns a collection of localized strings that best fits the requested culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getStrings = function (locale) {
	        var localeData = this.getLocaleData(locale);
	        // For default locale no need to make a network request
	        // Its value is already defined in LocalizedStrings
	        // This will also make sure that request is not made for Bing maps
	        if (localeIndex.locales.defaultLanguage.defaultRegion.code === localeData.code) {
	            return new Promise(function (resolve) {
	                resolve(new LocalizedStrings());
	            });
	        }
	        else {
	            // Start a GET request
	            var request = new Url({
	                domain: env.staticAssetsDomain,
	                path: "".concat(localeIndex.localizationsPath, "/").concat(localeData.strings)
	            }).get();
	            // Return the response as a LocalizedStrings object.
	            return request.then(function (response) {
	                return response;
	            }, function () {
	                // If the request for the localized strings json fails return a default localization in English.
	                return new LocalizedStrings();
	            });
	        }
	    };
	    /**
	     * Gets the best fit locale data based on the specified culture code.
	     * @param locale The requested culture code.
	     */
	    Localizer.getLocaleData = function (locale) {
	        // Convert the locale to a culture code if one wasn't already provided.
	        if (typeof locale === "string") {
	            locale = CultureCode.parse(locale);
	        }
	        // Check if the locale could be just the language.
	        // If so return the default locale data for that language.
	        if (localeIndex.locales[locale.code]) {
	            return localeIndex.locales[locale.code].defaultRegion;
	        }
	        // Check if the language is supported.
	        // If not use the default language.
	        var regionIndex;
	        if (localeIndex.locales[locale.language]) {
	            regionIndex = localeIndex.locales[locale.language];
	        }
	        else if (locale.language.indexOf("-") !== -1) {
	            // If the current language can't be matched but there is another "-"
	            // Try to use the language as if it is a full culture code.
	            return this.getLocaleData(locale.language);
	        }
	        else {
	            regionIndex = localeIndex.locales.defaultLanguage;
	        }
	        // Check if the region is supported for the chosen language.
	        // If not use the default region for the chosen language.
	        if (locale.region && regionIndex[locale.region]) {
	            return regionIndex[locale.region];
	        }
	        else {
	            return regionIndex.defaultRegion;
	        }
	    };
	    return Localizer;
	}());

	var UserAgent = /** @class */ (function () {
	    function UserAgent() {
	    }
	    /**
	     * Returns the Edge or IE browser version number.
	     * Edge will be version 12 or greater.
	     * IE will be version 11 or less.
	     * If the browser is not Edge or IE -1 will be returned.
	     */
	    UserAgent.getEdgeOrIEVersion = function () {
	        var ua = window.navigator.userAgent;
	        var msie = ua.indexOf("MSIE ");
	        if (msie > 0) {
	            // IE 10 or older
	            return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
	        }
	        var trident = ua.indexOf("Trident/");
	        if (trident > 0) {
	            // IE 11
	            var rv = ua.indexOf("rv:");
	            return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
	        }
	        var edge = ua.indexOf("Edge/");
	        if (edge > 0) {
	            // Edge (IE 12+)
	            return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
	        }
	        // other browser
	        return -1;
	    };
	    /**
	     * Detects if the browser is IE or Edge.
	     */
	    UserAgent.isEdgeOrIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1;
	    };
	    /**
	     * Detects if the browser is IE but not Edge.
	     */
	    UserAgent.isIE = function () {
	        var version = this.getEdgeOrIEVersion();
	        return version !== -1 && version <= 11;
	    };
	    return UserAgent;
	}());

	var version = "3.5.0";

	/**
	 * A helper class that provides methods for getting various forms of the map controls current version.
	 */
	var Version = /** @class */ (function () {
	    function Version() {
	    }
	    /**
	     * Returns the full version string for the map control.
	     * For example, `"1.3.5"`.
	     */
	    Version.getFullVersion = function () {
	        return version;
	    };
	    /**
	     * Returns the endpoint compatible version string for the map control.
	     * For example, `"1.3.5"` becomes `"1.3"`.
	     */
	    Version.getEndpointVersion = function () {
	        // Get the index of the second "."
	        var index = version.indexOf(".");
	        index = version.indexOf(".", index + 1);
	        // If the index of the second "." can't be found just return the whole version string.
	        if (index === -1) {
	            return version;
	        }
	        return version.substring(0, index);
	    };
	    return Version;
	}());

	var __extends$1j = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __read$c = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$8 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * An enumeration used to specify the type of authentication mechanism to use.
	 */
	exports.AuthenticationType = void 0;
	(function (AuthenticationType) {
	    /**
	     * The subscription key authentication mechanism.
	     * Literal value `"subscriptionKey"`
	     */
	    AuthenticationType["subscriptionKey"] = "subscriptionKey";
	    /**
	     * The AAD implicit grant mechanism. Recommended for pages protected by a sign-in.
	     * By default the page will be redirected to the AAD login when the map control initializes.
	     * Specify a logged-in `PublicClientApplication` in the `AuthenticationOptions`
	     * for greater control over when/how the users signs in.
	     * Literal value `"aad"`
	     */
	    AuthenticationType["aad"] = "aad";
	    /**
	     * The anonymous authentication mechanism. Recommended for public pages.
	     * Allows a callback responsible for acquiring an authentication token to be provided.
	     * Literal value `"anonymous"`
	     */
	    AuthenticationType["anonymous"] = "anonymous";
	    /**
	     * The shared access signature authentication mechanism. Allows a callback responsible for acquiring a token to be provided on requests.
	     * Literal value `"sas"`.
	     */
	    AuthenticationType["sas"] = "sas";
	})(exports.AuthenticationType || (exports.AuthenticationType = {}));
	/**
	 * Options for specifying how the map control should authenticate with the Azure Maps services.
	 */
	var AuthenticationOptions = /** @class */ (function (_super) {
	    __extends$1j(AuthenticationOptions, _super);
	    function AuthenticationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication mechanism to be used.
	         */
	        _this.authType = undefined;
	        /**
	         * Subscription key from your Azure Maps account.
	         * Must be specified for subscription key authentication type.
	         */
	        _this.subscriptionKey = undefined;
	        /**
	         * The Azure Maps client ID, This is an unique identifier used to identify the maps account.
	         * Preferred to always be specified, but must be specified for AAD and anonymous authentication types.
	         */
	        _this.clientId = undefined;
	        /**
	         * The Azure AD registered app ID. This is the app ID of an app registered in your Azure AD tenant.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadAppId = undefined;
	        /**
	         * The AAD tenant that owns the registered app specified by `aadAppId`.
	         * Must be specified for AAD authentication type.
	         */
	        _this.aadTenant = undefined;
	        /**
	         * The AAD instance to use for logging in.
	         * Can be optionally specified when using the AAD authentication type.
	         * By default the `https://login.microsoftonline.com/` instance will be used.
	         */
	        _this.aadInstance = undefined;
	        /**
	         * A callback to use with the anonymous/sas authentication mechanism.
	         * This callback will be responsible for resolving to a authentication token.
	         * E.g. fetching a CORS protected token from an endpoint.
	         */
	        _this.getToken = undefined;
	        /**
	         * Optionally provide an initial token for sas authentication.
	         */
	        _this.sasToken = undefined;
	        /**
	         * Optionally provide an existing `PublicClientApplication` from the MSAL.js library.
	         * This authentication context will be used to acquire the AAD token.
	         * Only used with the AAD authentication type.
	         * This auth context must be configured to use the same AAD app ID as `this.aadAppId`.
	         * If this is not provided all map instances will share their own private auth context.
	         */
	        _this.authContext = undefined;
	        return _this;
	    }
	    /**
	     * Sets the required options to configure the subscription key authentication mechanism.
	     * @param subscriptionKey Subscription Key from your azure maps account
	     */
	    AuthenticationOptions.prototype.setSubscriptionKey = function (key) {
	        this.authType = exports.AuthenticationType.subscriptionKey;
	        this.subscriptionKey = key;
	    };
	    /**
	     * Sets the required authentication options to configure the AAD implicit grant mechanism.
	     * @param clientId Client ID from your azure maps account
	     * @param aadAppId Azure AD App ID
	     * @param aadTenant Azure AD Tenant Name
	     * @param aadInstance An optional Azure AD Instance
	     * @param authContext An optional `PublicClientApplication` from the MSAL.js library
	     */
	    AuthenticationOptions.prototype.setAadProperties = function (clientId, aadAppId, aadTenant, aadInstance, authContext) {
	        this.authType = exports.AuthenticationType.aad;
	        this.authContext = authContext || this.authContext;
	        this.aadInstance = aadInstance || this.aadInstance;
	        this.clientId = clientId;
	        this.aadAppId = aadAppId;
	        this.aadTenant = aadTenant;
	    };
	    /**
	     * Sets the required options to configure the anonymous authentication method.
	     * @param getTokenCallback Callback function responsible for resolving to an authentication token.
	     */
	    AuthenticationOptions.prototype.setTokenCallbackFunction = function (getTokenCallback) {
	        this.authType = exports.AuthenticationType.anonymous;
	        this.getToken = getTokenCallback;
	    };
	    /**
	     * Sets the required options to configure the sas authentication method.
	     * @param getTokenCallback Callback function responsible for resolving to an authentication token.
	     */
	    AuthenticationOptions.prototype.setSasCallbackFunction = function (getTokenCallback) {
	        this.authType = exports.AuthenticationType.sas;
	        this.getToken = getTokenCallback;
	    };
	    /**
	     * Override the standard merge behavior to handle mutually exclusive options.
	     * @internal
	     */
	    AuthenticationOptions.prototype.merge = function () {
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var merged = _super.prototype.merge.apply(this, __spreadArray$8([], __read$c(valueList), false));
	        if (merged.authType === exports.AuthenticationType.subscriptionKey) {
	            merged.authContext = merged.aadAppId = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.aad) {
	            merged.subscriptionKey = merged.getToken = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.anonymous) {
	            merged.subscriptionKey = merged.authContext = merged.aadAppId = undefined;
	        }
	        else if (merged.authType === exports.AuthenticationType.sas) {
	            merged.authContext = merged.subscriptionKey = merged.aadAppId = undefined;
	        }
	        return merged;
	    };
	    return AuthenticationOptions;
	}(Options));

	/**
	 * Test whether the current browser supports Mapbox GL JS
	 * @param {Object} options
	 * @param {boolean} [options.failIfMajorPerformanceCaveat=false] Return `false`
	 *   if the performance of Mapbox GL JS would be dramatically worse than
	 *   expected (i.e. a software renderer is would be used)
	 * @return {boolean}
	 */
	function isSupported$1(options) {
	    return !notSupportedReason(options);
	}

	function notSupportedReason(options) {
	    if (!isBrowser()) return 'not a browser';
	    if (!isArraySupported()) return 'insufficent Array support';
	    if (!isFunctionSupported()) return 'insufficient Function support';
	    if (!isObjectSupported()) return 'insufficient Object support';
	    if (!isJSONSupported()) return 'insufficient JSON support';
	    if (!isWorkerSupported()) return 'insufficient worker support';
	    if (!isUint8ClampedArraySupported()) return 'insufficient Uint8ClampedArray support';
	    if (!isArrayBufferSupported()) return 'insufficient ArrayBuffer support';
	    if (!isCanvasGetImageDataSupported()) return 'insufficient Canvas/getImageData support';
	    if (!isWebGLSupportedCached(options && options.failIfMajorPerformanceCaveat)) return 'insufficient WebGL support';
	    if (!isNotIE()) return 'insufficient ECMAScript 6 support';
	}

	function isBrowser() {
	    return typeof window !== 'undefined' && typeof document !== 'undefined';
	}

	function isArraySupported() {
	    return (
	        Array.prototype &&
	        Array.prototype.every &&
	        Array.prototype.filter &&
	        Array.prototype.forEach &&
	        Array.prototype.indexOf &&
	        Array.prototype.lastIndexOf &&
	        Array.prototype.map &&
	        Array.prototype.some &&
	        Array.prototype.reduce &&
	        Array.prototype.reduceRight &&
	        Array.isArray
	    );
	}

	function isFunctionSupported() {
	    return Function.prototype && Function.prototype.bind;
	}

	function isObjectSupported() {
	    return (
	        Object.keys &&
	        Object.create &&
	        Object.getPrototypeOf &&
	        Object.getOwnPropertyNames &&
	        Object.isSealed &&
	        Object.isFrozen &&
	        Object.isExtensible &&
	        Object.getOwnPropertyDescriptor &&
	        Object.defineProperty &&
	        Object.defineProperties &&
	        Object.seal &&
	        Object.freeze &&
	        Object.preventExtensions
	    );
	}

	function isJSONSupported() {
	    return 'JSON' in window && 'parse' in JSON && 'stringify' in JSON;
	}

	function isWorkerSupported() {
	    if (!('Worker' in window && 'Blob' in window && 'URL' in window)) {
	        return false;
	    }

	    var blob = new Blob([''], { type: 'text/javascript' });
	    var workerURL = URL.createObjectURL(blob);
	    var supported;
	    var worker;

	    try {
	        worker = new Worker(workerURL);
	        supported = true;
	    } catch (e) {
	        supported = false;
	    }

	    if (worker) {
	        worker.terminate();
	    }
	    URL.revokeObjectURL(workerURL);

	    return supported;
	}

	// IE11 only supports `Uint8ClampedArray` as of version
	// [KB2929437](https://support.microsoft.com/en-us/kb/2929437)
	function isUint8ClampedArraySupported() {
	    return 'Uint8ClampedArray' in window;
	}

	// https://github.com/mapbox/mapbox-gl-supported/issues/19
	function isArrayBufferSupported() {
	    return ArrayBuffer.isView;
	}

	// Some browsers or browser extensions block access to canvas data to prevent fingerprinting.
	// Mapbox GL uses this API to load sprites and images in general.
	function isCanvasGetImageDataSupported() {
	    var canvas = document.createElement('canvas');
	    canvas.width = canvas.height = 1;
	    var context = canvas.getContext('2d');
	    if (!context) {
	        return false;
	    }
	    var imageData = context.getImageData(0, 0, 1, 1);
	    return imageData && imageData.width === canvas.width;
	}

	var isWebGLSupportedCache = {};
	function isWebGLSupportedCached(failIfMajorPerformanceCaveat) {

	    if (isWebGLSupportedCache[failIfMajorPerformanceCaveat] === undefined) {
	        isWebGLSupportedCache[failIfMajorPerformanceCaveat] = isWebGLSupported(failIfMajorPerformanceCaveat);
	    }

	    return isWebGLSupportedCache[failIfMajorPerformanceCaveat];
	}

	isSupported$1.webGLContextAttributes = {
	    antialias: false,
	    alpha: true,
	    stencil: true,
	    depth: true
	};

	function getWebGLContext(failIfMajorPerformanceCaveat) {
	    var canvas = document.createElement('canvas');

	    var attributes = Object.create(isSupported$1.webGLContextAttributes);
	    attributes.failIfMajorPerformanceCaveat = failIfMajorPerformanceCaveat;

	    return (
	        canvas.getContext('webgl', attributes) ||
	        canvas.getContext('experimental-webgl', attributes)
	    );
	}

	function isWebGLSupported(failIfMajorPerformanceCaveat) {
	    var gl = getWebGLContext(failIfMajorPerformanceCaveat);
	    if (!gl) {
	        return false;
	    }

	    // Try compiling a shader and get its compile status. Some browsers like Brave block this API
	    // to prevent fingerprinting. Unfortunately, this also means that Mapbox GL won't work.
	    var shader;
	    try {
	        shader = gl.createShader(gl.VERTEX_SHADER);
	    } catch (e) {
	        // some older browsers throw an exception that `createShader` is not defined
	        // so handle this separately from the case where browsers block `createShader`
	        // for security reasons
	        return false;
	    }

	    if (!shader || gl.isContextLost()) {
	        return false;
	    }
	    gl.shaderSource(shader, 'void main() {}');
	    gl.compileShader(shader);
	    return gl.getShaderParameter(shader, gl.COMPILE_STATUS) === true;
	}

	function isNotIE() {
	    return !document.documentMode;
	}

	var defaultView;
	var defaultLanguage = "NGT";
	var defaultSessionId = uuid();
	var defaultDomain = env.domain;
	var defaultStaticAssetsDomain = env.staticAssetsDomain;
	var defaultStyleDefinitionsPath = env.stylePath;
	var defaultStyleDefinitionsVersion = env.styleDefinitionsVersion;
	var defaultStyleAPIVersion = constants.styleApiVersion;
	var defaultAuthOptions = new AuthenticationOptions();
	var hasSetView = false;
	var hasSetDomain = false;
	var hasSetStyleDefinitionsPath = false;
	var hasSetStyleDefinitionsVersion = false;
	var hasWorkerCount = false;
	var hasMaxParallelImageRequests = false;
	var hasSetLanguage = false;
	var hasSetSessionId = false;
	var hasSetAuthenticationOptions = false;
	/**
	 * Gets the default authentication options that were provided.
	 * If not previously set all properties will be undefined.
	 */
	function getAuthenticationOptions() {
	    return Object.assign({}, defaultAuthOptions);
	}
	/**
	 * Getrs the defawult static assets domain.
	 * @internal
	 */
	function getStaticAssetsDomain() {
	    return defaultStaticAssetsDomain;
	}
	/**
	 * Gets the default domain that was provided.
	 * If not previously set the default value is `"atlas.microsoft.com"`.
	 */
	function getDomain() {
	    return defaultDomain;
	}
	/**
	 * Gets the default styleDefinitionsPath that was provided.
	 * @internal
	 */
	function getStyleDefinitionsPath() {
	    return defaultStyleDefinitionsPath;
	}
	/**
	 * Gets the default styleDefinitionsVersion that was provided.
	 * @internal
	 */
	function getStyleDefinitionsVersion() {
	    return defaultStyleDefinitionsVersion;
	}
	/**
	 * Gets the default styleAPI version that was provided
	 * @internal
	 */
	function getStyleAPIVersion() {
	    return defaultStyleAPIVersion;
	}
	/**
	 * Gets the worker count that will get created.
	 */
	function getWorkerCount() {
	    return maplibregl.getWorkerCount();
	}
	/**
	 * Gets the Maximum number of images (raster tiles, sprites, icons) to load in parallel
	 */
	function getMaxParallelImageRequests() {
	    return maplibregl.getMaxParallelImageRequests();
	}
	/**
	 * Gets the default language that was provided.
	 * If not previously set the default value is `"NGT"`.
	 */
	function getLanguage() {
	    return defaultLanguage;
	}
	/**
	 * Gets the default session id that was provided.
	 * If not previously set the default value is a random UUID.
	 */
	function getSessionId() {
	    return defaultSessionId;
	}
	/**
	 * Gets the default Azure Maps subscription key that was provided.
	 */
	function getSubscriptionKey() {
	    return defaultAuthOptions.authType === exports.AuthenticationType.subscriptionKey ?
	        defaultAuthOptions.subscriptionKey : undefined;
	}
	/**
	 * @deprecated use atlas.getView() instead
	 */
	function getUserRegion() {
	    return defaultView;
	}
	/**
	 * Gets the default view setting of the map control.
	 * If not previously set the default value is `undefined`.
	 */
	function getView() {
	    return defaultView;
	}
	/**
	 * Current API version number based on build number.
	 */
	function getVersion() {
	    return Version.getFullVersion();
	}
	/**
	 * Checks to see if the user's browser is supported by the map control.
	 * @param failIfMajorPerformanceCaveat If true the function will return false
	 * if the performance of the map control would be dramatically worse than expected
	 * (e.g. a software WebGL renderer would be used).
	 */
	function isSupported(failIfMajorPerformanceCaveat) {
	    var result;
	    // Always return false for IE since we don't support it ourselves.
	    result = !UserAgent.isIE();
	    return result;
	}
	/**
	 * Sets your authentication options as the default options in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the authentication options explicitly defined and
	 * setAuthenticationOptions hasn't previously been called it will automatically be called by the Map constructor.
	 * @param options The new default authentication options.
	 */
	function setAuthenticationOptions(options) {
	    defaultAuthOptions = new AuthenticationOptions().merge(defaultAuthOptions, options);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * Sets the default domain used by the map and service modules unless the
	 * domain is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the domain explicitly defined and
	 * setDomain hasn't previously been called it will automatically be called by the Map constructor.
	 * If the protocol is not specified `https` is assumed.
	 * @param domain The new default domain.
	 */
	function setDomain(domain) {
	    defaultDomain = domain;
	    hasSetDomain = true;
	}
	/**
	 * Sets the default styleDefinitionsPath to use for getting the map styles.
	 * If a Map is initialized with the styleDefinitionsPath explicitly defined and
	 * setStyleDefinitionsPath hasn't previously been called it will automatically be called by the Map constructor.
	 * @param styleDefinitionsPath The new default styleDefinitionsPath.
	 * @internal
	 */
	function setStyleDefinitionsPath(styleDefinitionsPath) {
	    defaultStyleDefinitionsPath = styleDefinitionsPath;
	    hasSetStyleDefinitionsPath = true;
	}
	/**
	 * Sets the default styleDefinitionsVersion to use when requesting style definitions
	 * from styleDefinitionsPath.  If a map is initialized with the with the styleDefinitionsVersion
	 * explicitly defined and setStyleDefinitionsVersion hasn't previously been called it will be
	 * automatically called by the Map constructor.
	 * @param styleDefinitionsVersion
	 */
	function setStyleDefinitionsVersion(styleDefinitionsVersion) {
	    defaultStyleDefinitionsVersion = styleDefinitionsVersion;
	    hasSetStyleDefinitionsVersion = true;
	}
	function setStyleAPIVersion(styleAPIVersion) {
	    defaultStyleAPIVersion = styleAPIVersion;
	}
	/**
	 * Sets number of web workers instantiated on a page.
	 * By default, it is set to half the number of CPU cores (capped at 6).
	 * @param workerCount worker count.
	 */
	function setWorkerCount(workerCount) {
	    if (workerCount > 0) {
	        maplibregl.setWorkerCount(workerCount);
	        hasWorkerCount = true;
	    }
	}
	/**
	 * Sets Maximum number of images (raster tiles, sprites, icons) to load in parallel,
	 * which affects performance in raster-heavy maps. 16 by default.
	 * @param maxParallelImageRequests Maximum number of images to load in parallel.
	 */
	function setMaxParallelImageRequests(maxParallelImageRequests) {
	    if (maxParallelImageRequests > 0) {
	        maplibregl.setMaxParallelImageRequests(maxParallelImageRequests);
	        hasMaxParallelImageRequests = true;
	    }
	}
	/**
	 * Sets the default language used by the map and service modules unless the
	 * language is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the language explicitly defined and
	 * setLanguage hasn't previously been called it will automatically be called by the Map constructor.
	 * @param language The new default language.
	 */
	function setLanguage(language) {
	    // Find the best fit supported language.
	    defaultLanguage = Localizer.getCode(language);
	    hasSetLanguage = true;
	}
	/**
	 * Sets the default session id used by the map and service modules unless the
	 * session id is explicitly specified when using those parts of the API.
	 * If a Map is initialized with the session ID explicitly defined and
	 * setSessionId hasn't previously been called it will automatically be called by the Map constructor.
	 * @param id The new default session id.
	 */
	function setSessionId(id) {
	    defaultSessionId = id;
	    hasSetSessionId = true;
	}
	/**
	 * Sets your Azure Maps subscription key as the default subscription key in the atlas namespace
	 * which is used by the map control and any modules that make requests to the Azure maps services.
	 * If a Map is initialized with the subscription key explicitly defined and
	 * setSubscriptionKey hasn't previously been called it will automatically be called by the Map constructor.
	 * @param key The new default subscription key.
	 */
	function setSubscriptionKey(key) {
	    defaultAuthOptions.setSubscriptionKey(key);
	    hasSetAuthenticationOptions = true;
	}
	/**
	 * @deprecated use atlas.setView(view: string) instead.
	 */
	function setUserRegion(userRegion) {
	    defaultView = userRegion;
	    hasSetView = true;
	}
	/**
	 * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	 * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews }.
	 * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country/region where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	 * @param view The new default view
	 */
	function setView(view) {
	    defaultView = view;
	    hasSetView = true;
	}
	/**
	 * Adds an image template to the atlas namespace.
	 * @param templateName The name of the template.
	 * @param template The SVG template to add. Supports {color}, {secondaryColor}, {scale}, {text}.
	 * @param override Specifies if it should override existing templates if one with the same name already exists.
	 */
	function addImageTemplate(templateName, template, override) {
	    if (override || !imageTemplates[templateName.toLowerCase()]) {
	        imageTemplates[templateName.toLowerCase()] = template;
	    }
	}
	/**
	 * Retrieves an SVG template by name.
	 * @param templateName The name of the template to retrieve.
	 * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	 */
	function getImageTemplate(templateName, scale) {
	    scale = Math.abs(scale || 1);
	    if (typeof templateName === "string" && imageTemplates[templateName.toLowerCase()]) {
	        var template = imageTemplates[templateName.toLowerCase()];
	        // Firefox/Edge don't support calc for inline SVG's. Need to manually calculate this.
	        var pattern = /calc\(([0-9.]+)[px]*\s*\*\s*\{scale\}\)/gi;
	        var t = template;
	        var match = pattern.exec(template);
	        while (match) {
	            t = t.replace(match[0], parseFloat(match[1]) * scale + "");
	            match = pattern.exec(template);
	        }
	        // Just for good measure incase the pattern doesn't match.
	        t = t.replace("{scale}", scale + "");
	        return t;
	    }
	    else {
	        throw new Error("Invalid templateName.");
	    }
	}
	/**
	 * Retrieves an array of names for all image templates that are available in the atlas namespace.
	 */
	function getAllImageTemplateNames() {
	    return Object.keys(imageTemplates);
	}
	/**
	 * Initializes resources like WebWorkers that can be shared across maps to lower load
	 * times in some situations. `atlas.setWorkerCount`, if being
	 * used, must be set before `prewarm()` is called to have an effect.
	 *
	 * By default, the lifecycle of these resources is managed automatically, and they are
	 * lazily initialized when a Map is first created. By invoking `prewarm()`, these
	 * resources will be created ahead of time, and will not be cleared when the last Map
	 * is removed from the page. This allows them to be re-used by new Map instances that
	 * are created later. They can be manually cleared by calling
	 * `atlas.clearPrewarmedResources()`. This is only necessary if your web page remains
	 * active but stops using maps altogether.
	 *
	 * This is primarily useful when using GL-JS maps in a single page app, wherein a user
	 * would navigate between various views that can cause Map instances to constantly be
	 * created and destroyed.
	 */
	function prewarm() {
	    maplibregl.prewarm();
	}
	/**
	 * Clears up resources that have previously been created by `atlas.prewarm()`.
	 * Note that this is typically not necessary. You should only call this function
	 * if you expect the user of your app to not return to a Map view at any point
	 * in your application.
	 */
	function clearPrewarmedResources() {
	    maplibregl.clearPrewarmedResources();
	}
	/**
	 * Adds a custom load resource function that will be called when using a URL that starts with a custom url schema.
	 * @param customProtocol - the protocol to hook, for example 'custom'
	 * @param loadFn - the function to use when trying to fetch a tile specified by the customProtocol
	 */
	function addProtocol(customProtocol, loadFn) {
	    maplibregl.addProtocol(customProtocol, loadFn);
	}
	/**
	 * Removes a previously added protocol in the main thread.
	 * @param customProtocol - the custom protocol to remove registration for
	 */
	function removeProtocol(customProtocol) {
	    maplibregl.removeProtocol(customProtocol);
	}
	/**
	 * Returns if authentication options are set.
	 * @internal
	 */
	function _hasSetAuthenticationOptions() {
	    return hasSetAuthenticationOptions;
	}
	/**
	 * Returns if the default domain has been set yet.
	 * @internal
	 */
	function _hasSetDomain() {
	    return hasSetDomain;
	}
	/**
	 * Returns if the default StyleDefinitionsPath has been set yet.
	 * @internal
	 */
	function _hasSetStyleDefinitionsPath() {
	    return hasSetStyleDefinitionsPath;
	}
	/**
	 * Returns if the default StyleDefinitionsVersion has been set yet.
	 * @internal
	 */
	function _hasSetStyleDefinitionsVersion() {
	    return hasSetStyleDefinitionsVersion;
	}
	/**
	 * Returns if the default workerCount has been set yet.
	 * @internal
	 */
	function _hasWorkerCount() {
	    return hasWorkerCount;
	}
	/**
	 * Returns if the default MaxParallelImageRequests has been set yet.
	 * @internal
	 */
	function _hasMaxParallelImageRequests() {
	    return hasMaxParallelImageRequests;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetLanguage() {
	    return hasSetLanguage;
	}
	/**
	 * Returns is a default session id has been set yet.
	 * @internal
	 */
	function _hasSetSessionId() {
	    return hasSetSessionId;
	}
	/**
	 * Returns is a default language has been set yet.
	 * @internal
	 */
	function _hasSetView() {
	    return hasSetView;
	}
	/**
	 * Gets the base domain used for asset retrieval.
	 * @internal
	 */
	function _getAssetDomain() {
	    return env.domain;
	}
	/**
	 * Gets the base domain used for general map services.
	 * @internal
	 */
	// TODO Remove once all internal dependencies of this function are gone.
	function _getDomain() {
	    return getDomain();
	}
	/**
	 * Enable the map's RTL text plugin. Necessary for supporting the Arabic and Hebrew languages, which are written right-to-left.
	 * @internal
	 */
	function _enableRTLTextPlugin() {
	    var rtlPluginUrl = new Url({
	        domain: env.staticAssetsDomain,
	        path: "sdk/javascript/mapcontrol/".concat(Version.getEndpointVersion(), "/mapbox-gl-rtl-text.min.js")
	    });
	    maplibregl.setRTLTextPlugin(rtlPluginUrl.toString(), true).catch(function (error) {
	        if (error) {
	            console.warn(error);
	        }
	    });
	}
	var imageTemplates = {
	    /**********************
	     * Marker templates
	     **********************/
	    // Default built in marker. Supports {color} and {secondaryColor}
	    "marker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 26 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><text x="12.5" y="17.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:2"/><text x="12.5" y="18.5" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-circle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(39 * {scale})" viewBox="-1 -1 27 38"><path d="M12.25.25a12.254 12.254 0 0 0-12 12.494c0 6.444 6.488 12.109 11.059 22.564.549 1.256 1.333 1.256 1.882 0C17.762 24.853 24.25 19.186 24.25 12.744A12.254 12.254 0 0 0 12.25.25Z" style="fill:{color};stroke:{secondaryColor};stroke-width:1"/><circle cx="12.5" cy="12.5" r="9" fill="{secondaryColor}"/><text x="12" y="17.5" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(24 * {scale})" height="calc(28 * {scale})" viewBox="0 0 24 28"><path d="m11.988 16.615a5.15 5.15 0 0 1-2.268-.525 4.909 4.909 0 0 1-2.805-4.442 5.019 5.019 0 0 1 5.072-4.936h.012a5.03 5.03 0 0 1 5.085 4.961 4.907 4.907 0 0 1-.549 2.224 5.114 5.114 0 0 1-4.548 2.718zm0-8.06a3.173 3.173 0 0 0-3.226 3.099 3.081 3.081 0 0 0 1.77 2.782 3.299 3.299 0 0 0 4.365-1.386 3.049 3.049 0 0 0 .342-1.381 3.184 3.184 0 0 0-3.239-3.114h-.012z" fill="{secondaryColor}"/><path d="m11.999.922a10.908 10.908 0 0 0-11.076 10.732 10.639 10.639 0 0 0 4.418 8.598l6.658 6.464 6.658-6.463a10.537 10.537 0 0 0 2.198-15.041 11.182 11.182 0 0 0-8.856-4.289zm1.873 14.341a4.221 4.221 0 0 1-5.589-1.789 3.945 3.945 0 0 1-.445-1.8 4.164 4.164 0 0 1 8.323-.037 4.028 4.028 0 0 1-2.289 3.626Z" fill="{color}"/><path d="m11.999 28-7.256-7.044a11.611 11.611 0 0 1-4.743-9.303 11.844 11.844 0 0 1 11.988-11.652.102 .102 0 0 1 .02 0 12.164 12.164 0 0 1 9.577 4.647 11.357 11.357 0 0 1 2.299 8.614 11.521 11.521 0 0 1-4.63 7.695zm-.01-26.157a9.997 9.997 0 0 0-10.143 9.812 9.769 9.769 0 0 0 4.04 7.853l.099.083 6.014 5.838 6.113-5.922a9.7 9.7 0 0 0 3.945-6.505 9.533 9.533 0 0 0-1.933-7.229 10.305 10.305 0 0 0-8.116-3.931h-.021zm.021 14.772a5.11 5.11 0 0 1-4.547-2.718 4.868 4.868 0 0 1 .932-5.743 5.118 5.118 0 0 1 3.58-1.46h.024a5.031 5.031 0 0 1 5.084 4.938 4.92 4.92 0 0 1-2.805 4.457h0a5.152 5.152 0 0 1-2.269.525zm-.011-8.079h-.015a3.277 3.277 0 0 0-2.295.933 3.029 3.029 0 0 0-.587 3.58 3.297 3.297 0 0 0 4.364 1.386h0a3.092 3.092 0 0 0 1.772-2.795 3.185 3.185 0 0 0-3.239-3.105z" fill="{secondaryColor}"/><text x="12" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    // Older pin-round style. (consider removing, although we could look at removing these icons from sprite and wrapping event that fires when missing icon is needed.)
	    "pin-round": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25 * {scale})" height="calc(25 * {scale})" viewBox="0 0 25 25"><g transform="translate(0 1)"><circle cx="12.25" cy="11.5833" r="11" fill="{color}"/><path d="m12.25 23.583a12 12 0 1 1 12-12 12 12 0 0 1-12 12zm0-22a10 10 0 1 0 10 10 10 10 0 0 0-10-10z" fill="{secondaryColor}"/><circle cx="12.25" cy="11.5833" r="4.2386" fill="{secondaryColor}"/></g><text x="12.5" y="17" style="font-size:14px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-flat": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(42.8 * {scale})"  viewBox="0 0 1600 2570"><g fill="{color}"><path d="M691 2419c-409-575-641-1086-683-1504-10-106-10-136 5-224 31-188 105-330 241-458 129-124 270-190 453-214 69-9 113-10 182-1 373 46 655 326 703 698 40 308-120 801-424 1309-134 224-348 535-369 535-4 0-53-63-108-141z"/></g><g fill="rgba(0,0,0,0.15)" style="transform:scale(-1,1);transform-origin:center"><path d="M691 2419c-407-571-639-1083-682-1498-14-139-3-249 37-371 69-208 254-402 459-481 68-27 217-59 271-59h24v160 180 940 635c0 349-2 635-5 635-2 0-49-63-104-141z"/></g><circle cx="800" cy="800" r="600" fill="{secondaryColor}"/><text x="800" y="1100" style="font-size:800px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "marker-arrow": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(25.47 * {scale})" height="calc(35.18 * {scale})" viewBox="0 0 4330 5980"><g fill="{color}"><path d="m2080 5969c-49-20-93-63-115-113-25-55-1928-5486-1953-5573-40-138 67-282 210-283 36 0 246 73 987 345 518 190 947 345 955 345 8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29-33 0-71-5-85-10z"/></g><g fill="{secondaryColor}"><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z"/><path d="m2200 1600c-36 10-83 2-484-84-243-53-451-94-461-91-11 4-22 18-25 31-5 19 114 371 436 1292 244 697 448 1273 454 1281 19 24 50 30 71 12z" style="transform:scale(-1,1);transform-origin:center"/></g><g fill="rgba(0,0,0,0.2)" ><path d="m2165 685c8 0 438-155 955-345 615-226 954-345 979-345 87 0 165 47 204 123 46 91 107-95-957 2942-537 1535-986 2805-997 2823-11 18-43 46-72 62-41 24-62 30-111 29z"/></g><text x="2165" y="3300" style="font-size:2500px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-ball-pin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15.67 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 235 452"><g transform="translate(-135 10)"><path fill="{secondaryColor}" d="m256 442 0 0c-13 0-18-11-18-24l-6-323c0-13 11-24 24-24h0c13 0 24 11 24 24l-6 323c0 13-5 24-18 24z"/><circle style="fill:{color};stroke-width:10;stroke:{secondaryColor}" cx="256" cy="112" r="111"/><ellipse transform="matrix(0.834 0.5518 -0.5518 0.834 65.7916 -97.18)" fill="rgba(255,255,255,0.3)" cx="194.399" cy="60.749" rx="19.076" ry="32.428"/></g><text x="117.5" y="160" style="font-size:160px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.67 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2000 2420"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M845 2152c-22-37-58-95-80-129-22-35-62-99-90-143l-50-80-312 0-313 0 0-900 0-900 900 0 900 0 0 900 0 900-313 0-313 0-34 58c-19 31-38 59-42 60-5 2-8 8-8 12 0 9-69 123-88 145-5 6-11 15-13 21-16 39-77 123-89 124-8 0-33-31-55-68z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(38.8 * {scale})" viewBox="0 0 2500 2910"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m866 2652c-17-31-37-68-46-82-9-14-32-54-51-90-19-36-50-92-70-125l-36-60-332-3-331-2 0-905 0-905 660 0 660 0 0-38c0-71 50-196 102-258 71-85 189-164 244-164 12 0 26-4 29-10 8-13 222-13 230 0 3 6 17 10 30 10 25 0 117 45 154 76 130 107 191 232 191 392 0 155-63 284-190 386-36 29-129 76-150 76-11 0-22 5-25 10-3 6-31 10-61 10l-54 0 0 660 0 660-332 2-332 3-29 50c-17 28-48 84-70 125-22 41-47 86-56 100-9 14-30 51-46 83-17 32-36 57-45 57-8 0-28-25-44-58z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(26.8 * {scale})" height="calc(32.27 * {scale})" viewBox="0 0 2010 2410"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="M856 2155c-20-30-36-59-36-65 0-5-4-10-10-10-5 0-10-5-10-11 0-5-18-37-40-69-22-32-40-64-40-69 0-6-4-11-10-11-5 0-10-5-10-10 0-6-15-33-32-60l-33-50-127 0c-74 0-129-4-133-10-3-5-17-10-30-10-25 0-116-45-155-76-87-69-142-151-178-265-15-46-17-1075-2-1084 5-3 10-17 10-30 0-13 5-27 10-30 6-3 10-13 10-22 0-22 83-135 122-168 57-46 62-50 112-75l50-25 585 0 586 0 63 34c84 46 169 133 212 218l35 68 0 565 0 565-28 59c-32 69-100 157-139 180-15 9-33 22-40 29-23 22-99 57-123 57-13 0-27 5-30 10-4 6-60 10-135 10l-128 0-128 205c-84 136-133 205-144 205-10 0-33-24-54-55z"/></g><text x="1000" y="1300" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "marker-square-rounded-cluster": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(33.33 * {scale})" height="calc(32.13 * {scale})" viewBox="0 0 2500 2900"><g transform="translate(100 100)" style="stroke:{secondaryColor};stroke-width:100;fill:{color}"><path d="m874 2669c-9-18-26-49-37-68-11-20-30-55-43-78-13-24-36-64-51-90-14-27-38-69-52-95l-26-48-142 0c-84 0-144-4-148-10-3-5-17-10-30-10-25 0-118-46-154-76-91-76-136-142-175-254-13-38-16-119-16-554 0-358 3-520 12-545 40-125 106-219 195-278 127-84 116-83 646-83l467 0 0-42c0-46 11-87 45-163 54-121 169-220 306-264 46-14 232-14 278 0 165 53 284 175 340 350 19 61 14 204-10 273-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-3 6-28 10-56 10l-49 0 0 462c0 446-1 464-21 522-32 91-94 178-169 240-38 31-130 76-155 76-13 0-27 5-30 10-4 6-65 10-149 10-138 0-143 1-154 23-12 23-62 114-112 202-16 28-44 79-63 115-42 77-67 88-93 39z"/></g><text x="1650" y="900" style="font-size:1000px;fill:#fff">+</text><text x="1000" y="1800" style="font-size:1000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(23.5 * {scale})" height="calc(40 * {scale})" viewBox="34 28 198 308"><path style="stroke:{secondaryColor};stroke-width:15;stroke-linecap:round;" d="M42 327l0 -291"/><path style="fill:{color};stroke:{secondaryColor};stroke-width:10;stroke-linejoin:round;" d="M49 50c70 30 104 28 178 2-21 42-21 74 0 116-72 25-101 25-178 0l0-118z"/><text x="130" y="165" style="font-size:100px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "flag-triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(27 * {scale})" height="calc(35.33 * {scale})" viewBox="0 0 40.5 53"><g transform="translate(-31 -20)"><path fill="{secondaryColor}" d="M34.7,73.3V48.4l34.6-10.1c0.7-0.2,1.2-0.8,1.2-1.5s-0.4-1.4-1-1.7L33.7,20.5c-0.5-0.2-1.1-0.2-1.6,0.2 c-0.5,0.3-0.7,0.8-0.7,1.4v51.2H34.7z"/><polygon points="34.7,24.5 66,36.5 34.7,45 34.7,10" fill="{color}"/></g><text x="11" y="21" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(34 * {scale})" height="calc(34 * {scale})" viewBox="0 0 34 34"><g transform="translate(2 2)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17" y="22" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "rounded-square-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(38 * {scale})" height="calc(38 * {scale})" viewBox="0 0 38 38"><g transform="translate(4 4)"><rect x="0" y="0" rx="8" ry="8" width="30" height="30" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19" y="24" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(36 * {scale})" height="calc(36 * {scale})" viewBox="0 0 36 36"><g transform="translate(2 2)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="30" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><g transform="translate(4 4)"><polygon points="16,0 32,32 0,32 16,0" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="32" style="font-size:12px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(35 * {scale})" height="calc(40 * {scale})" viewBox="0 0 35 40"><g transform="translate(2 2)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:2;fill:{color}"/></g><text x="17.5" y="25" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(39 * {scale})" height="calc(44 * {scale})" viewBox="0 0 39 44"><g transform="translate(4 4)"><path d="M31 9 15.5 0 0 9 0 27 15.5 36 31 27 31 9Z" style="stroke:{secondaryColor};stroke-width:4;fill:{color}"/></g><text x="19.5" y="27" style="font-size:14px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1100 1100"><g transform="translate(50 50)"><path style="stroke:{secondaryColor};stroke-width:50;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="550" y="700" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "hexagon-rounded-thick": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 1200 1200"><g transform="translate(100 100)"><path style="stroke:{secondaryColor};stroke-width:100;fill:{color}" d="M881 210 561 25c-33-19-88-19-121 0L119 210c-33 19-61 67-61 105v370c0 39 27 86 61 105l321 185c33 19 88 19 122 0l321-185c33-19 61-67 61-105V315C942 276 915 229 881 210z"/></g><text x="600" y="750" style="font-size:400px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="12,0 0,24 12,17 24,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="17" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "triangle-arrow-left": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(28 * {scale})" height="calc(28 * {scale})" viewBox="0 0 28 28"><g transform="translate(2 2)"><polygon points="24,12 0,0 7,12 0,24" stroke-width="2" stroke="{secondaryColor}" fill="{color}"/></g><text x="14" y="16.5" style="font-size:8px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    "arrow-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(12.16 * {scale})" height="calc(30.1 * {scale})" viewBox="0 0 902 364"><g fill="{color}" transform="matrix(0,2.4,-2.4,0,897,-930)"><polygon points="902,222 233,222 233,364 0,182 233,0 233,141 902,141 902,222"/></g><text x="450" y="700" style="font-size:900px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "arrow-up-thin": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(33.33 * {scale})" viewBox="0 0 12 25"><g transform="translate(-136.91823 -751.91998)"><path fill="{color}" d="m148.271 760.71c-1.641-.547-3.186-1.47-4.633-2.769l0 18.07-1.675 0 0-18.07c-1.447 1.299-2.986 2.222-4.616 2.769l0-1.231c2.325-1.596 4.006-3.812 5.043-6.65l.838 0c1.037 2.838 2.718 5.055 5.043 6.65l0 1.231z"/></g><text x="6" y="20" style="font-size:10px;fill:#000;text-anchor:middle">{text}</text></svg>',
	    "car": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(21.93 * {scale})" height="calc(40.9 * {scale})" viewBox="0 0 6580 12270"><g transform="translate(0 12270) rotate(-90)"><path fill="{secondaryColor}" d="M7045 6566c-42-13-105-44-105-51 0-2 23-105 50-228 28-123 50-230 50-236 0-8-241-11-907-11-855 0-1145 6-1513 30-85 6-189 13-230 15-41 3-133 10-205 15-286 21-430 32-705 50-953 63-1459 18-2335-205-304-77-746-209-799-238-131-72-221-408-285-1062-34-345-42-532-48-1130-16-1557 108-2532 336-2649 32-17 469-149 676-205 409-110 819-191 1205-238 116-14 224-18 540-18 395 1 494 5 1140 50 1124 79 1224 82 2496 78l641-3-53-237c-29-131-52-238-51-239 1-1 31-14 66-29 56-23 76-26 142-23 67 3 83 7 120 33 23 17 50 41 61 55 10 14 51 117 91 230l73 205 674 3 675 2 90-39c98-43 198-72 315-93 122-21 829-18 990 5 321 45 626 143 849 270 293 168 516 378 704 662 266 402 416 893 467 1527 15 174 8 882-9 998-6 41-18 127-27 190-69 502-253 969-523 1325-79 105-262 284-381 374-189 142-355 229-574 300-336 110-526 139-952 148-457 9-685-23-887-124l-47-24-678-6-678-6-64 179c-79 224-92 253-121 284-67 70-177 97-274 66zm-2752-5073c-23-2-64-2-90 0-26 2-7 3 42 3 50 0 71-1 48-3zm395 0c-21-2-55-2-75 0-21 2-4 4 37 4 41 0 58-2 38-4z"/><path fill="{color}" d="M7043 6498c-13-6-23-19-23-28 0-9 23-117 50-240 28-123 50-230 50-237 0-22-2126-13-2465 10-132 10-400 28-595 42-661 47-824 55-1160 62-435 7-656-8-1040-73-415-70-865-183-1447-365-168-53-272-556-325-1569-16-319-16-1311 0-1630 45-872 129-1366 257-1518 22-26 51-39 172-77 557-177 1122-310 1563-369 271-36 351-40 690-40 361 1 463 6 1165 54 1122 78 1288 83 2337 79 460-2 840-7 843-11 4-4-17-117-47-252l-55-245 39-16c76-30 180-8 224 47 10 13 54 124 98 246l79 222 709 0 709 0 47-24c74-37 219-83 322-101 122-22 606-32 802-16 374 29 658 102 933 238 124 62 271 155 361 230l61 51 6 100c19 278 103 497 247 643 88 89 173 136 278 152l70 11 41 131c116 369 159 673 168 1170 10 584-38 984-167 1397l-40 126-70 12c-193 33-348 175-441 405-56 139-89 302-89 445 0 43-3 47-58 91-290 235-644 384-1068 450-191 29-796 39-974 16-135-18-263-54-368-102l-75-35-701 0-701 0-79 223c-82 232-102 267-163 293-38 16-138 17-170 2zm-2023-820c332-15 1155-12 1835 6 308 8 563 12 566 8 4-4 10-21 13-38 7-30 6-31-92-77-518-244-1197-396-2112-474-295-25-1282-25-1579 0-231 20-473 46-479 51-6 7 49 110 93 171 160 226 416 335 855 365 142 10 539 5 900-12zm3304-263c525-111 899-887 934-1935 19-557-37-1023-172-1435-186-563-521-900-896-899-81 0-158 14-525 92-426 91-431 92-540 146-195 96-287 207-306 368-12 104-11 2985 1 3078 22 170 135 291 365 389 49 21 191 55 480 115 226 47 419 87 430 89 45 10 164 6 229-8zm-5570-485c112-43 197-156 216-291 12-83 13-2623 1-2706-23-158-125-273-270-304-44-9-100-1-542 75-272 47-514 91-539 98-266 68-487 424-594 958-56 280-70 548-40 800 56 484 207 878 414 1081 115 114 122 116 702 218 277 49 524 90 550 90 26 1 72-8 102-19zm2111-3440c1023-44 1884-213 2462-486l113-53-7-33c-3-18-8-35-10-37-2-3-236 1-521 7-993 24-1271 26-1708 11-541-18-1128-18-1249-1-377 56-588 181-734 437-32 55-41 79-32 84 12 8 246 32 491 51 356 28 815 36 1195 20z"/></g><text x="3250" y="8250" style="font-size:3000px;fill:#fff;text-anchor:middle">{text}</text></svg>',
	    /**********************
	     * Fill Patterns
	     **********************/
	    "checker": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 16 16"><pattern id="p" x="0" y="0" width="16" height="16" patternUnits="userSpaceOnUse"><rect fill="{color}" x="0" width="8" height="8" y="0"/><rect fill="{color}" x="8" width="8" height="8" y="8"/></pattern><rect x="0" y="0" width="16" height="16" fill="{secondaryColor}"/><rect x="0" y="0" width="16" height="16" fill="url(#p)"/></svg>',
	    "checker-rotated": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(16 * {scale})" height="calc(16 * {scale})" viewBox="0 0 60 60"><rect width="60" height="60" fill="{secondaryColor}"/><rect width="42.42" height="42.42" transform="translate(30 0) rotate(45)" fill="{color}"/></svg>',
	    "zig-zag": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 120 60 120 90 90 120 60 120 0 120 0 60 60 0 0 0 60 30 90 60 120 120 120"/></svg>',
	    "zig-zag-vertical": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(15 * {scale})" height="calc(15 * {scale})" viewBox="0 0 120 120"><rect x="0" y="0" width="120" height="120" fill="{secondaryColor}"/><polygon fill="{color}" points="120 0 120 60 90 30 60 0 0 0 0 0 60 60 0 120 60 120 90 90 120 60 120 0"/></svg>',
	    "circles-spaced": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="2" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "circles": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(7 * {scale})" height="calc(7 * {scale})" viewBox="0 0 20 20"><defs><pattern id="p" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="6" stroke="none" fill="{color}"/></pattern></defs><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><rect x="0" y="0" width="100" height="100" fill="url(#p)"/></svg>',
	    "diagonal-lines-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-lines-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "diagonal-stripes-up": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "diagonal-stripes-down": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(14 * {scale})" height="calc(14 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(45 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}" transform="rotate(-45 3 3)"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-lines": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(18 * {scale})" height="calc(18 * {scale})" viewBox="0 0 6 6"><rect x="0" y="0" width="6" height="6" fill="{secondaryColor}"/><g transform="rotate(90 3 3)" fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g><g fill="{color}"><path d="M5 0h1L0 6V5zM6 5v1H5z"/></g></svg>',
	    "rotated-grid-stripes": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(20 * {scale})" height="calc(20 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="40" height="40" fill="{secondaryColor}"/><g transform="rotate(90 20 20)" fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g><g fill="{color}"><path d="M0 40L40 0H20L0 20M40 40V20L20 40"/></g></svg>',
	    "x-fill": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(40 * {scale})" height="calc(40 * {scale})" viewBox="0 0 40 40"><rect x="0" y="0" width="45.3" height="45.3" fill="{secondaryColor}"/><g fill="{color}"><path d="M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z"/></g></svg>',
	    "dots": '<svg xmlns="http://www.w3.org/2000/svg" width="calc(13 * {scale})" height="calc(13 * {scale})" viewBox="0 0 20 20"><rect x="0" y="0" width="20" height="20" fill="{secondaryColor}"/><g fill="{color}"><circle cx="3" cy="3" r="3"/><circle cx="13" cy="13" r="3"/></g></svg>'
	};

	/** The vertical distance between the tooltip and its target */
	var tooltipVerticalOffset = 4;
	/**
	  * Creates tooltip content element
	  */
	var buildAccessibleTooltip = function (name) {
	    var tooltipContent = document.createElement("span");
	    tooltipContent.innerText = name;
	    tooltipContent.classList.add('tooltiptext');
	    if (navigator.userAgent.indexOf('Edg') != -1) {
	        tooltipContent.classList.add('edge');
	    }
	    else if (navigator.userAgent.indexOf('Chrome') != -1) {
	        tooltipContent.classList.add('chrome');
	    }
	    else if (navigator.userAgent.indexOf('Safari') != -1) {
	        tooltipContent.classList.add('safari');
	    }
	    else if (navigator.userAgent.indexOf('Firefox') != -1) {
	        tooltipContent.classList.add('firefox');
	    }
	    if (navigator.userAgent.indexOf('Windows') != -1) {
	        tooltipContent.classList.add('win');
	    }
	    else if (navigator.userAgent.indexOf('Macintosh') != -1) {
	        tooltipContent.classList.add('mac');
	    }
	    return tooltipContent;
	};
	/**
	 * Determines tooltip position
	 * @param tooltip tooltip to position
	 * @param eventTarget target element that tooltip is bound to
	 * @param forceAbsolute position:fixed is generally desired, however since tooltip is positioned alongside the target,
	 *  the runtime transform of the parent container(maplibre marker) will apply to tooltip as well, in such case resort to position:absolute
	 */
	var positionTooltip = function (tooltip, eventTarget, forceAbsolute) {
	    if (forceAbsolute === void 0) { forceAbsolute = false; }
	    var positionTooltip = function (event) {
	        var buttonRect = eventTarget.getBoundingClientRect();
	        var tooltipRect = tooltip.getBoundingClientRect();
	        var left, top;
	        if ((buttonRect.x + tooltipRect.width) > window.innerWidth) {
	            // the tooltip body may not fit the visible window width
	            left = window.innerWidth - tooltipRect.width;
	        }
	        else {
	            left = buttonRect.x;
	        }
	        if ((buttonRect.y + buttonRect.height + tooltipRect.height + tooltipVerticalOffset) > window.innerHeight) {
	            // the tooltip body may not fit the visible window height
	            // position above the target element
	            top = buttonRect.y - tooltipRect.height - tooltipVerticalOffset;
	        }
	        else {
	            top = buttonRect.y + buttonRect.height + tooltipVerticalOffset;
	        }
	        if (forceAbsolute && eventTarget.parentElement) {
	            var parentRect = eventTarget.parentElement ? eventTarget.parentElement.getBoundingClientRect() : null;
	            tooltip.style.position = 'absolute';
	            left = left - parentRect.x;
	            top = top - parentRect.y;
	        }
	        tooltip.style.transform = "translate(".concat(left, "px, ").concat(top, "px)");
	        tooltip.style.display = "block";
	    };
	    // Accessibility: tooltip should be dismissible with the escape key
	    var dismissTooltip = function (event) {
	        if ((event.key === "Escape" || event.key === "Esc") && tooltip.style.display === "block") {
	            event.stopPropagation();
	            tooltip.style.display = "none";
	        }
	    };
	    eventTarget.addEventListener("mouseover", positionTooltip);
	    eventTarget.addEventListener("focusin", positionTooltip);
	    eventTarget.addEventListener("keydown", dismissTooltip);
	};

	var __extends$1i = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Positions where the control can be placed on the map.
	 */
	exports.ControlPosition = void 0;
	(function (ControlPosition) {
	    /**
	     * Places the control in the top left of the map.
	     * Literal value `"top-left"`
	     */
	    ControlPosition["TopLeft"] = "top-left";
	    /**
	     * Places the control in the top right of the map.
	     * Literal value `"top-right"`
	     */
	    ControlPosition["TopRight"] = "top-right";
	    /**
	     * Places the control in the bottom left of the map.
	     * Literal value `"bottom-left"`
	     */
	    ControlPosition["BottomLeft"] = "bottom-left";
	    /**
	     * Places the control in the bottom right of the map.
	     * Literal value `"bottom-right"`
	     */
	    ControlPosition["BottomRight"] = "bottom-right";
	    /**
	     * The control will place itself in its default location.
	     * Literal value `"non-fixed"`
	     */
	    ControlPosition["NonFixed"] = "non-fixed";
	})(exports.ControlPosition || (exports.ControlPosition = {}));
	/**
	 * The options for adding a control to the map.
	 */
	var ControlOptions = /** @class */ (function (_super) {
	    __extends$1i(ControlOptions, _super);
	    function ControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The position the control will be placed on the map. If not specified, the control will be located at the
	         * default position it defines.
	         * default `ControlPosition.NonFixed`
	         * @default ControlPosition.NonFixed
	         */
	        _this.position = exports.ControlPosition.NonFixed;
	        return _this;
	    }
	    return ControlOptions;
	}(Options));

	/**
	 * Color helper class to get the RGBA and luminosity of the color
	 * @private
	 */
	var Color = /** @class */ (function () {
	    function Color(color) {
	        if (color) {
	            var rgba = void 0;
	            if (typeof color === "string") {
	                rgba = this.getRBGA(color);
	            }
	            else {
	                rgba = color;
	            }
	            if (rgba.length >= 3) {
	                this.r = rgba[0];
	                this.g = rgba[1];
	                this.b = rgba[2];
	                if (rgba.length > 3) {
	                    this.a = rgba[3];
	                }
	            }
	        }
	    }
	    /**
	     * Get Luminosity of color
	     */
	    Color.prototype.getLuminosity = function () {
	        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
	        var rgb = [this.r, this.g, this.b];
	        var luminosity = [];
	        for (var i = 0; i < rgb.length; i++) {
	            var chan = rgb[i] / 255;
	            luminosity[i] =
	                chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
	        }
	        return (0.2126 * luminosity[0] + 0.7152 * luminosity[1] + 0.0722 * luminosity[2]);
	    };
	    /**
	     * Get RGBA value of the color
	     */
	    Color.prototype.getRBGA = function (color) {
	        var canvas = document.createElement("canvas");
	        var ctx = canvas.getContext("2d");
	        ctx.globalAlpha = 1;
	        ctx.fillStyle = color;
	        ctx.fillRect(0, 0, 1, 1);
	        var data = ctx.getImageData(0, 0, 1, 1).data;
	        return [data[0], data[1], data[2], data[3]];
	    };
	    return Color;
	}());

	/**
	 * Available styles for a Control.
	 */
	exports.ControlStyle = void 0;
	(function (ControlStyle) {
	    /**
	     * The control will be in the light style.
	     * Literal value `"light"`
	     */
	    ControlStyle["light"] = "light";
	    /**
	     * The control will be in the dark style.
	     * Literal value `"dark"`
	     */
	    ControlStyle["dark"] = "dark";
	    /**
	     * The control will automatically switch styles based on the style of the map.
	     * If a control doesn't support automatic styling the light style will be used by default.
	     * Literal value `"auto"`
	     */
	    ControlStyle["auto"] = "auto";
	})(exports.ControlStyle || (exports.ControlStyle = {}));

	var Dictionary = Map;

	/**
	 * An internal abstract class that can be extended to provide event listening/firing.
	 * This class is for internal use only, and users will find little use with it.
	 * Not to be used by the Map class. MapCallbackHandler implements the more complex logic for handling map events.
	 */
	var EventEmitter = /** @class */ (function () {
	    function EventEmitter() {
	        // Event listeners.
	        this.listeners = new Dictionary();
	    }
	    EventEmitter.prototype._addEventListener = function (eventType, callback, once) {
	        if (!this.listeners.has(eventType)) {
	            this.listeners.set(eventType, new Dictionary());
	        }
	        this.listeners.get(eventType).set(callback, once);
	    };
	    EventEmitter.prototype._removeEventListener = function (eventType, callback) {
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).delete(callback);
	        }
	    };
	    /**
	     * Invokes a given event type.
	     * @param eventType The event name.
	     * @param eventData The data to pass to the listener callbacks.
	     */
	    EventEmitter.prototype._invokeEvent = function (eventType, eventData) {
	        var _this = this;
	        if (this.listeners.has(eventType)) {
	            this.listeners.get(eventType).forEach(function (once, callback) {
	                if (once) {
	                    _this._removeEventListener(eventType, callback);
	                }
	                try {
	                    callback(eventData);
	                }
	                catch (error) {
	                    // tslint:disable-next-line:no-console
	                    console.error(error);
	                }
	            });
	        }
	    };
	    return EventEmitter;
	}());

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		EventEmitter: EventEmitter
	});

	var __extends$1h = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * For internal use only.
	 * Implements control interface and provides support for automatic styling based on the map style.
	 */
	var ControlBase = /** @class */ (function (_super) {
	    __extends$1h(ControlBase, _super);
	    function ControlBase() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A callback for when the map's style changes.
	         * Used for auto styling.
	         */
	        _this._onStyleChange = function () {
	            if (_this._map.getStyle().style.toLowerCase().startsWith("blank")) {
	                // If the style is blank the div background should decide the theme.
	                if (!_this._observer) {
	                    // Add an observer to see changes to the background.
	                    _this._onBackgroundChange();
	                    _this._observer = new MutationObserver(_this._onBackgroundChange);
	                    _this._observer.observe(_this._map.getMapContainer(), { attributes: true, attributeFilter: ["style"] });
	                }
	            }
	            else {
	                if (_this._observer) {
	                    // Remove any existing observer for non-blank styles.
	                    _this._observer.disconnect();
	                    delete _this._observer;
	                }
	                // If the style is anything but blank the style definition should decide the theme.
	                _this._map.styles.getThemeAsync(_this._map.getStyle()).then(function (theme) {
	                    _this._setTheme(theme);
	                });
	            }
	        };
	        /**
	         * A callback for when the map's
	         */
	        _this._onBackgroundChange = function () {
	            // Calculate the luminosity of the map div's background to determine the theme.
	            // Try to parse the color, could fail if something complex like a gradient is used.
	            var color = new Color(_this._map.getMapContainer().style.backgroundColor);
	            var luminosity = color.getLuminosity();
	            // If the background color can't be parsed assume it is light.
	            var theme = isNaN(luminosity) || luminosity > 0.5
	                ? exports.ControlStyle.light
	                : exports.ControlStyle.dark;
	            _this._setTheme(theme);
	        };
	        return _this;
	    }
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    ControlBase.prototype.onRemove = function () {
	        if (this._container) {
	            this._container.remove();
	            delete this._container;
	        }
	        if (this._map) {
	            this._map.events.remove("stylechanged", this._onStyleChange);
	            delete this._map;
	        }
	        if (this._observer) {
	            this._observer.disconnect();
	            delete this._observer;
	        }
	        delete this._theme;
	    };
	    /**
	     * Build the outermost container for the control, applies styling including any listeners for auto styling.
	     */
	    ControlBase.prototype.buildContainer = function (map, style, ariaLabel, tagName) {
	        this._map = map;
	        this._container = document.createElement(tagName || "div");
	        this._container.classList.add("azure-maps-control-container");
	        if (typeof ariaLabel === "string") {
	            this._container.setAttribute("aria-label", ariaLabel);
	        }
	        // Set the style or add the auto listener.
	        if (style.toLowerCase() === exports.ControlStyle.auto) {
	            if (this._map) {
	                this._map.events.add("stylechanged", this._onStyleChange);
	            }
	        }
	        else {
	            this._container.classList.add(style);
	        }
	        return this._container;
	    };
	    /**
	     * Sets the control's theme (light/dark).
	     * Only applies changes if the theme is different than the previous.
	     */
	    ControlBase.prototype._setTheme = function (theme) {
	        // Only update if the theme is different.
	        if (this._theme !== theme) {
	            this._container.classList.remove(this._theme);
	            this._container.classList.add(theme);
	            this._theme = theme;
	        }
	    };
	    /** The delay between activating the control and when a click should occur, else assume it's a touch */
	    ControlBase.activateClickDelay = 100;
	    return ControlBase;
	}(EventEmitter));

	var __extends$1g = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a CompassControl object.
	 */
	var CompassControlOptions = /** @class */ (function (_super) {
	    __extends$1g(CompassControlOptions, _super);
	    function CompassControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will rotate with each click of the control.
	         * Default `15`.
	         * @default 15
	         */
	        _this.rotationDegreesDelta = 15;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Inverts the direction of map rotation controls.
	         * @default false
	         */
	        _this.inverted = false;
	        return _this;
	    }
	    return CompassControlOptions;
	}(Options));

	var __extends$1f = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control for changing the rotation of the map.
	 */
	var CompassControl = /** @class */ (function (_super) {
	    __extends$1f(CompassControl, _super);
	    /**
	     * Constructs a CompassControl.
	     * @param options The options for the control.
	     */
	    function CompassControl(options) {
	        var _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.options = new CompassControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    CompassControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Rotation Control");
	        var rotationButton = this.constructRotationButton(map);
	        var grid = this.constructRotationGrid(map, options);
	        var tooltip = buildAccessibleTooltip("Reset to Default Rotation");
	        var expandGrid = function (expanded) {
	            if (expanded) {
	                container.classList.add("in-use");
	                grid.setAttribute("aria-hidden", "false");
	                grid.classList.remove("hidden-accessible-element");
	            }
	            else {
	                container.classList.remove("in-use");
	                grid.setAttribute("aria-hidden", "true");
	                grid.classList.add("hidden-accessible-element");
	            }
	        };
	        container.addEventListener("mouseover", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasMouse = true;
	            expandGrid(true);
	        });
	        container.addEventListener("focusin", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasFocus = true;
	            expandGrid(true);
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                delete _this.lastActiveTime;
	                expandGrid(false);
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    delete _this.lastActiveTime;
	                    expandGrid(false);
	                }
	            }
	        });
	        // Keep the focus on this control when esc key is pressed on the grid
	        grid.addEventListener("keydown", function (event) {
	            if (event.key === "Escape" || event.key === "Esc") {
	                event.stopPropagation();
	                rotationButton.focus();
	                expandGrid(false);
	            }
	        });
	        // Dismiss the grid when esc key is pressed on the reset button and the tooltip is not visible
	        rotationButton.addEventListener("keydown", function (event) {
	            if ((event.key === "Escape" || event.key === "Esc") &&
	                (container === null || container === void 0 ? void 0 : container.classList.contains("in-use")) &&
	                (tooltip === null || tooltip === void 0 ? void 0 : tooltip.style.display) === "none") {
	                event.stopPropagation();
	                expandGrid(false);
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && CompassControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(grid);
	            container.appendChild(rotationButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, rotationButton);
	        }
	        else {
	            container.appendChild(rotationButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, rotationButton);
	            container.appendChild(grid);
	        }
	        return container;
	    };
	    CompassControl.prototype.constructRotationGrid = function (map, options) {
	        var grid = document.createElement("div");
	        grid.classList.add("sub-container");
	        grid.classList.add("hidden-accessible-element");
	        grid.setAttribute("aria-hidden", "true");
	        var rotationRightButton = this.constructRightRotationButton(map);
	        var rotationLeftButton = this.constructLeftRotationButton(map);
	        var tooltipLeft = buildAccessibleTooltip("Rotate Left");
	        var tooltipRight = buildAccessibleTooltip("Rotate Right");
	        if (options && CompassControl.InvertOrderPositions.includes(options.position)) {
	            grid.appendChild(rotationRightButton);
	            grid.appendChild(tooltipRight);
	            positionTooltip(tooltipRight, rotationRightButton);
	            grid.appendChild(rotationLeftButton);
	            grid.appendChild(tooltipLeft);
	            positionTooltip(tooltipLeft, rotationLeftButton);
	        }
	        else {
	            grid.appendChild(rotationLeftButton);
	            grid.appendChild(tooltipLeft);
	            positionTooltip(tooltipLeft, rotationLeftButton);
	            grid.appendChild(rotationRightButton);
	            grid.appendChild(tooltipRight);
	            positionTooltip(tooltipRight, rotationRightButton);
	        }
	        return grid;
	    };
	    CompassControl.prototype.constructRotationButton = function (map) {
	        var _this = this;
	        var rotationButton = document.createElement("button");
	        rotationButton.classList.add("azure-maps-control-button");
	        rotationButton.classList.add("rotation");
	        rotationButton.setAttribute("aria-label", "Reset to Default Rotation");
	        rotationButton.setAttribute("alt", "Reset to Default Rotation");
	        rotationButton.setAttribute("type", "button");
	        var icon = document.createElement("div");
	        rotationButton.appendChild(icon);
	        rotationButton.addEventListener("click", function (event) {
	            // If the click is happening just after the control became active assume it's a touch event from Edge.
	            if (event.timeStamp - _this.lastActiveTime > ControlBase.activateClickDelay) {
	                map.setCamera({
	                    bearing: CompassControl.DefaultRotation
	                }, true);
	            }
	        });
	        map.events.add("rotate", function (e) {
	            icon.style.transform = "rotate(".concat(-e.map.getCamera().bearing, "deg)");
	        });
	        return rotationButton;
	    };
	    CompassControl.prototype.constructRightRotationButton = function (map) {
	        var _this = this;
	        var rotationRightButton = document.createElement("button");
	        rotationRightButton.classList.add("azure-maps-control-button");
	        rotationRightButton.classList.add("rotation-right");
	        rotationRightButton.setAttribute("aria-label", "Rotate Right");
	        rotationRightButton.setAttribute("alt", "Rotate Right");
	        rotationRightButton.setAttribute("type", "button");
	        rotationRightButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing - (_this.options.inverted ? -1 : 1) * _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease",
	            }, true);
	        });
	        return rotationRightButton;
	    };
	    CompassControl.prototype.constructLeftRotationButton = function (map) {
	        var _this = this;
	        var rotationLeftButton = document.createElement("button");
	        rotationLeftButton.classList.add("azure-maps-control-button");
	        rotationLeftButton.classList.add("rotation-left");
	        rotationLeftButton.setAttribute("aria-label", "Rotate Left");
	        rotationLeftButton.setAttribute("alt", "Rotate Left");
	        rotationLeftButton.setAttribute("type", "button");
	        rotationLeftButton.addEventListener("click", function () {
	            map.setCamera({
	                bearing: map.getCamera().bearing + (_this.options.inverted ? -1 : 1) * _this.options.rotationDegreesDelta,
	                duration: CompassControl.RotationDuration,
	                type: "ease"
	            }, true);
	        });
	        return rotationLeftButton;
	    };
	    CompassControl.DefaultRotation = 0;
	    /** @internal */ CompassControl.RotationDuration = 100;
	    CompassControl.InvertOrderPositions = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return CompassControl;
	}(ControlBase));

	var __extends$1e = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a PitchControl object.
	 */
	var PitchControlOptions = /** @class */ (function (_super) {
	    __extends$1e(PitchControlOptions, _super);
	    function PitchControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The angle that the map will tilt with each click of the control.
	         * Default `10`.
	         * @default 10
	         */
	        _this.pitchDegreesDelta = 10;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Inverts the direction of map pitch controls.
	         * @default false
	         */
	        _this.inverted = false;
	        return _this;
	    }
	    return PitchControlOptions;
	}(Options));

	var __extends$1d = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control for changing the pitch of the map.
	 */
	var PitchControl = /** @class */ (function (_super) {
	    __extends$1d(PitchControl, _super);
	    /**
	     * Constructs a PitchControl.
	     * @param options The options for the control.
	     */
	    function PitchControl(options) {
	        var _this = _super.call(this) || this;
	        _this.container = null;
	        _this.map = null;
	        _this.pitchButton = null;
	        _this.pitchIncrementButton = null;
	        _this.pitchDecrementButton = null;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.pitchChanged = function (map) { return _this.updatePitchButtonsState(); };
	        _this.updatePitchButtonsState = function () {
	            var minPitchReached = _this.map.getCamera().pitch <= 0;
	            var maxPitchReached = _this.map.getCamera().pitch >= 60;
	            // Keep the focus on this control when max/min pitch is reached
	            if (_this.hasFocus && _this.pitchButton && (minPitchReached || maxPitchReached)) {
	                _this.pitchButton.focus();
	            }
	            if (_this.options.inverted) {
	                if (_this.pitchIncrementButton && _this.pitchIncrementButton.disabled != minPitchReached) {
	                    _this.pitchIncrementButton.disabled = minPitchReached;
	                }
	                if (_this.pitchDecrementButton && _this.pitchDecrementButton.disabled != maxPitchReached) {
	                    _this.pitchDecrementButton.disabled = maxPitchReached;
	                }
	            }
	            else {
	                if (_this.pitchIncrementButton && _this.pitchIncrementButton.disabled != maxPitchReached) {
	                    _this.pitchIncrementButton.disabled = maxPitchReached;
	                }
	                if (_this.pitchDecrementButton && _this.pitchDecrementButton.disabled != minPitchReached) {
	                    _this.pitchDecrementButton.disabled = minPitchReached;
	                }
	            }
	        };
	        _this.options = new PitchControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    PitchControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        var container = this.buildContainer(map, this.options.style, "Pitch Control");
	        var pitchButton = this.constructPitchButton(map);
	        var grid = this.constructPitchGrid(map, options);
	        var tooltip = buildAccessibleTooltip("Reset to Default Pitch");
	        var expandGrid = function (expanded) {
	            if (expanded) {
	                container.classList.add("in-use");
	                grid.setAttribute("aria-hidden", "false");
	                grid.classList.remove("hidden-accessible-element");
	            }
	            else {
	                container.classList.remove("in-use");
	                grid.setAttribute("aria-hidden", "true");
	                grid.classList.add("hidden-accessible-element");
	            }
	        };
	        container.addEventListener("mouseover", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasMouse = true;
	            expandGrid(true);
	        });
	        container.addEventListener("focusin", function (event) {
	            _this.lastActiveTime = _this.lastActiveTime || event.timeStamp;
	            _this.hasFocus = true;
	            expandGrid(true);
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                delete _this.lastActiveTime;
	                expandGrid(false);
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    delete _this.lastActiveTime;
	                    expandGrid(false);
	                }
	            }
	        });
	        // Keep the focus on this control when esc key is pressed on the grid
	        grid.addEventListener("keydown", function (event) {
	            if (event.key === "Escape" || event.key === "Esc") {
	                event.stopPropagation();
	                pitchButton.focus();
	                expandGrid(false);
	            }
	        });
	        // Dismiss the grid when esc key is pressed on the reset button and the tooltip is not visible
	        pitchButton.addEventListener("keydown", function (event) {
	            if ((event.key === "Escape" || event.key === "Esc") &&
	                (container === null || container === void 0 ? void 0 : container.classList.contains("in-use")) &&
	                (tooltip === null || tooltip === void 0 ? void 0 : tooltip.style.display) === "none") {
	                event.stopPropagation();
	                expandGrid(false);
	            }
	        });
	        // If the control's position will require inverting the element order
	        // add them in the opposite order to preserve tabindex.
	        if (options && PitchControl.INVERT_ORDER_POSITIONS.includes(options.position)) {
	            container.appendChild(grid);
	            container.appendChild(pitchButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, container);
	        }
	        else {
	            container.appendChild(pitchButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, container);
	            container.appendChild(grid);
	        }
	        this.map = map;
	        this.container = container;
	        this.pitchButton = pitchButton;
	        map.events.add('pitch', this.pitchChanged);
	        this.updatePitchButtonsState();
	        return container;
	    };
	    PitchControl.prototype.onRemove = function () {
	        if (this.container) {
	            this.container.remove();
	            this.container = null;
	            this.pitchButton = null;
	            this.pitchIncrementButton = null;
	            this.pitchDecrementButton = null;
	        }
	        if (this.map) {
	            this.map.events.remove('pitch', this.pitchChanged);
	            this.map = null;
	        }
	    };
	    PitchControl.prototype.constructPitchGrid = function (map, options) {
	        var grid = document.createElement("div");
	        grid.classList.add("sub-container");
	        grid.classList.add("hidden-accessible-element");
	        grid.setAttribute("aria-hidden", "true");
	        this.pitchIncrementButton = this.constructPitchIncrementButton(map);
	        this.pitchDecrementButton = this.constructPitchDecrementButton(map);
	        var tooltipIncrement = buildAccessibleTooltip("Increase Pitch");
	        var tooltipDecrease = buildAccessibleTooltip("Decrease Pitch");
	        if (options && PitchControl.INVERT_ORDER_POSITIONS.includes(options.position)) {
	            grid.appendChild(this.pitchDecrementButton);
	            grid.appendChild(tooltipDecrease);
	            positionTooltip(tooltipDecrease, this.pitchDecrementButton);
	            grid.appendChild(this.pitchIncrementButton);
	            grid.appendChild(tooltipIncrement);
	            positionTooltip(tooltipIncrement, this.pitchIncrementButton);
	        }
	        else {
	            grid.appendChild(this.pitchIncrementButton);
	            grid.appendChild(tooltipIncrement);
	            positionTooltip(tooltipIncrement, this.pitchIncrementButton);
	            grid.appendChild(this.pitchDecrementButton);
	            grid.appendChild(tooltipDecrease);
	            positionTooltip(tooltipDecrease, this.pitchDecrementButton);
	        }
	        return grid;
	    };
	    PitchControl.prototype.constructPitchButton = function (map) {
	        var _this = this;
	        var pitchButton = document.createElement("button");
	        pitchButton.classList.add("azure-maps-control-button");
	        pitchButton.classList.add("pitch");
	        pitchButton.setAttribute("aria-label", "Reset to Default Pitch");
	        pitchButton.setAttribute("alt", "Reset to Default Pitch");
	        pitchButton.setAttribute("type", "button");
	        pitchButton.addEventListener("click", function () {
	            // If the click is happening just after the control became active assume it's a touch event from Edge.
	            if (event.timeStamp - _this.lastActiveTime > ControlBase.activateClickDelay) {
	                map.setCamera({
	                    pitch: PitchControl.DEFAULT_PITCH
	                }, true);
	            }
	        });
	        return pitchButton;
	    };
	    PitchControl.prototype.constructPitchDecrementButton = function (map) {
	        var _this = this;
	        var pitchDecrementButton = document.createElement("button");
	        pitchDecrementButton.classList.add("azure-maps-control-button");
	        pitchDecrementButton.classList.add("pitch-down");
	        pitchDecrementButton.setAttribute("aria-label", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("alt", "Decrease Pitch");
	        pitchDecrementButton.setAttribute("type", "button");
	        pitchDecrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch - (_this.options.inverted ? -1 : 1) * _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchDecrementButton;
	    };
	    PitchControl.prototype.constructPitchIncrementButton = function (map) {
	        var _this = this;
	        var pitchIncrementButton = document.createElement("button");
	        pitchIncrementButton.classList.add("azure-maps-control-button");
	        pitchIncrementButton.classList.add("pitch-up");
	        pitchIncrementButton.setAttribute("aria-label", "Increase Pitch");
	        pitchIncrementButton.setAttribute("alt", "Increase Pitch");
	        pitchIncrementButton.setAttribute("type", "button");
	        pitchIncrementButton.addEventListener("click", function () {
	            map.setCamera({
	                pitch: map.getCamera().pitch + (_this.options.inverted ? -1 : 1) * _this.options.pitchDegreesDelta,
	                duration: PitchControl.PITCH_DURATION_MS,
	                type: "ease"
	            }, true);
	        });
	        return pitchIncrementButton;
	    };
	    PitchControl.PITCH_DURATION_MS = 100;
	    PitchControl.DEFAULT_PITCH = 0;
	    PitchControl.INVERT_ORDER_POSITIONS = [exports.ControlPosition.BottomRight, exports.ControlPosition.TopRight];
	    return PitchControl;
	}(ControlBase));

	var __extends$1c = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control to display a scale bar on the map.
	 */
	var ScaleControl = /** @class */ (function (_super) {
	    __extends$1c(ScaleControl, _super);
	    /**
	     * A control to displays a scale bar relative to the pixel resolution at the center of the map.
	     * @param options Options for defining how the control is rendered and functions.
	     */
	    function ScaleControl(options) {
	        var _this = _super.call(this) || this;
	        _this.map = null;
	        _this.control = new maplibregl.ScaleControl({
	            maxWidth: options === null || options === void 0 ? void 0 : options.maxWidth,
	            unit: options === null || options === void 0 ? void 0 : options.unit
	        });
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    ScaleControl.prototype.onAdd = function (map, options) {
	        var _a, _b, _c;
	        this.map = map;
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.addControl(this.control);
	        var container = this.buildContainer(map, exports.ControlStyle.auto, "Scale Bar");
	        container.appendChild((_c = this.control) === null || _c === void 0 ? void 0 : _c._container);
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    ScaleControl.prototype.onRemove = function () {
	        var _a, _b;
	        _super.prototype.onRemove.call(this);
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.removeControl(this.control);
	        this.map = null;
	    };
	    /**
	     * Set the scale's unit of the distance
	     * @param unit - Unit of the distance (`"imperial"`, `"metric"` or `"nautical"`).
	     */
	    ScaleControl.prototype.setUnit = function (unit) {
	        var _a;
	        (_a = this.control) === null || _a === void 0 ? void 0 : _a.setUnit(unit);
	    };
	    return ScaleControl;
	}(ControlBase));

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */

	function listCacheClear$1() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear$1;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */

	function eq$5(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq$5;

	var eq$4 = eq_1;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf$4(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq$4(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf$4;

	var assocIndexOf$3 = _assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$3(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete$1;

	var assocIndexOf$2 = _assocIndexOf;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet$1(key) {
	  var data = this.__data__,
	      index = assocIndexOf$2(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet$1;

	var assocIndexOf$1 = _assocIndexOf;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas$1(key) {
	  return assocIndexOf$1(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas$1;

	var assocIndexOf = _assocIndexOf;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet$1(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet$1;

	var listCacheClear = _listCacheClear,
	    listCacheDelete = _listCacheDelete,
	    listCacheGet = _listCacheGet,
	    listCacheHas = _listCacheHas,
	    listCacheSet = _listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache$4(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache$4.prototype.clear = listCacheClear;
	ListCache$4.prototype['delete'] = listCacheDelete;
	ListCache$4.prototype.get = listCacheGet;
	ListCache$4.prototype.has = listCacheHas;
	ListCache$4.prototype.set = listCacheSet;

	var _ListCache = ListCache$4;

	var ListCache$3 = _ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear$1() {
	  this.__data__ = new ListCache$3;
	  this.size = 0;
	}

	var _stackClear = stackClear$1;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function stackDelete$1(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete$1;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */

	function stackGet$1(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet$1;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function stackHas$1(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas$1;

	/** Detect free variable `global` from Node.js. */

	var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal$1;

	var freeGlobal = _freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root$8 = freeGlobal || freeSelf || Function('return this')();

	var _root = root$8;

	var root$7 = _root;

	/** Built-in value references. */
	var Symbol$5 = root$7.Symbol;

	var _Symbol = Symbol$5;

	var Symbol$4 = _Symbol;

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$f.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$f.toString;

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag$1(value) {
	  var isOwn = hasOwnProperty$c.call(value, symToStringTag$1),
	      tag = value[symToStringTag$1];

	  try {
	    value[symToStringTag$1] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString$1.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag$1] = tag;
	    } else {
	      delete value[symToStringTag$1];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag$1;

	/** Used for built-in method references. */

	var objectProto$e = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto$e.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString.call(value);
	}

	var _objectToString = objectToString$1;

	var Symbol$3 = _Symbol,
	    getRawTag = _getRawTag,
	    objectToString = _objectToString;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag$5(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	var _baseGetTag = baseGetTag$5;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */

	function isObject$8(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject$8;

	var baseGetTag$4 = _baseGetTag,
	    isObject$7 = isObject_1;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction$3(value) {
	  if (!isObject$7(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag$4(value);
	  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction$3;

	var root$6 = _root;

	/** Used to detect overreaching core-js shims. */
	var coreJsData$1 = root$6['__core-js_shared__'];

	var _coreJsData = coreJsData$1;

	var coreJsData = _coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked$1(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked$1;

	/** Used for built-in method references. */

	var funcProto$2 = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource$2(func) {
	  if (func != null) {
	    try {
	      return funcToString$2.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource$2;

	var isFunction$2 = isFunction_1,
	    isMasked = _isMasked,
	    isObject$6 = isObject_1,
	    toSource$1 = _toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$d = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$d.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative$1(value) {
	  if (!isObject$6(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource$1(value));
	}

	var _baseIsNative = baseIsNative$1;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */

	function getValue$1(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue$1;

	var baseIsNative = _baseIsNative,
	    getValue = _getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative$7(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative$7;

	var getNative$6 = _getNative,
	    root$5 = _root;

	/* Built-in method references that are verified to be native. */
	var Map$5 = getNative$6(root$5, 'Map');

	var _Map = Map$5;

	var getNative$5 = _getNative;

	/* Built-in method references that are verified to be native. */
	var nativeCreate$4 = getNative$5(Object, 'create');

	var _nativeCreate = nativeCreate$4;

	var nativeCreate$3 = _nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear$1() {
	  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear$1;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */

	function hashDelete$1(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete$1;

	var nativeCreate$2 = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$c.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet$1(key) {
	  var data = this.__data__;
	  if (nativeCreate$2) {
	    var result = data[key];
	    return result === HASH_UNDEFINED$2 ? undefined : result;
	  }
	  return hasOwnProperty$a.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet$1;

	var nativeCreate$1 = _nativeCreate;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas$1(key) {
	  var data = this.__data__;
	  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$9.call(data, key);
	}

	var _hashHas = hashHas$1;

	var nativeCreate = _nativeCreate;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet$1(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet$1;

	var hashClear = _hashClear,
	    hashDelete = _hashDelete,
	    hashGet = _hashGet,
	    hashHas = _hashHas,
	    hashSet = _hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash$1(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash$1.prototype.clear = hashClear;
	Hash$1.prototype['delete'] = hashDelete;
	Hash$1.prototype.get = hashGet;
	Hash$1.prototype.has = hashHas;
	Hash$1.prototype.set = hashSet;

	var _Hash = Hash$1;

	var Hash = _Hash,
	    ListCache$2 = _ListCache,
	    Map$4 = _Map;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear$1() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map$4 || ListCache$2),
	    'string': new Hash
	  };
	}

	var _mapCacheClear = mapCacheClear$1;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */

	function isKeyable$1(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable$1;

	var isKeyable = _isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData$4(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData$4;

	var getMapData$3 = _getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete$1(key) {
	  var result = getMapData$3(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete$1;

	var getMapData$2 = _getMapData;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet$1(key) {
	  return getMapData$2(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet$1;

	var getMapData$1 = _getMapData;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas$1(key) {
	  return getMapData$1(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas$1;

	var getMapData = _getMapData;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet$1(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet$1;

	var mapCacheClear = _mapCacheClear,
	    mapCacheDelete = _mapCacheDelete,
	    mapCacheGet = _mapCacheGet,
	    mapCacheHas = _mapCacheHas,
	    mapCacheSet = _mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache$2(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache$2.prototype.clear = mapCacheClear;
	MapCache$2.prototype['delete'] = mapCacheDelete;
	MapCache$2.prototype.get = mapCacheGet;
	MapCache$2.prototype.has = mapCacheHas;
	MapCache$2.prototype.set = mapCacheSet;

	var _MapCache = MapCache$2;

	var ListCache$1 = _ListCache,
	    Map$3 = _Map,
	    MapCache$1 = _MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet$1(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache$1) {
	    var pairs = data.__data__;
	    if (!Map$3 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache$1(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet$1;

	var ListCache = _ListCache,
	    stackClear = _stackClear,
	    stackDelete = _stackDelete,
	    stackGet = _stackGet,
	    stackHas = _stackHas,
	    stackSet = _stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack$3(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack$3.prototype.clear = stackClear;
	Stack$3.prototype['delete'] = stackDelete;
	Stack$3.prototype.get = stackGet;
	Stack$3.prototype.has = stackHas;
	Stack$3.prototype.set = stackSet;

	var _Stack = Stack$3;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */

	function arrayEach$1(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var _arrayEach = arrayEach$1;

	var getNative$4 = _getNative;

	var defineProperty$2 = (function() {
	  try {
	    var func = getNative$4(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty = defineProperty$2;

	var defineProperty$1 = _defineProperty;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue$3(object, key, value) {
	  if (key == '__proto__' && defineProperty$1) {
	    defineProperty$1(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue$3;

	var baseAssignValue$2 = _baseAssignValue,
	    eq$3 = eq_1;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue$2(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$8.call(object, key) && eq$3(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue$2(object, key, value);
	  }
	}

	var _assignValue = assignValue$2;

	var assignValue$1 = _assignValue,
	    baseAssignValue$1 = _baseAssignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject$5(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue$1(object, key, newValue);
	    } else {
	      assignValue$1(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject$5;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */

	function baseTimes$1(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes$1;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */

	function isObjectLike$9(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike$9;

	var baseGetTag$3 = _baseGetTag,
	    isObjectLike$8 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments$1(value) {
	  return isObjectLike$8(value) && baseGetTag$3(value) == argsTag$3;
	}

	var _baseIsArguments = baseIsArguments$1;

	var baseIsArguments = _baseIsArguments,
	    isObjectLike$7 = isObjectLike_1;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments$2 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike$7(value) && hasOwnProperty$7.call(value, 'callee') &&
	    !propertyIsEnumerable$1.call(value, 'callee');
	};

	var isArguments_1 = isArguments$2;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */

	var isArray$5 = Array.isArray;

	var isArray_1 = isArray$5;

	var isBuffer$4 = {exports: {}};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */

	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	isBuffer$4.exports;

	(function (module, exports) {
		var root = _root,
		    stubFalse = stubFalse_1;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer$4, isBuffer$4.exports));

	var isBufferExports = isBuffer$4.exports;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex$2(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER$1 : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex$2;

	/** Used as references for various `Number` constants. */

	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength$2(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	var isLength_1 = isLength$2;

	var baseGetTag$2 = _baseGetTag,
	    isLength$1 = isLength_1,
	    isObjectLike$6 = isObjectLike_1;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag$5 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    objectTag$4 = '[object Object]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$3 = '[object String]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] =
	typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] =
	typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] =
	typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] =
	typedArrayTags[uint32Tag$2] = true;
	typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] =
	typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] =
	typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] =
	typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] =
	typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] =
	typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] =
	typedArrayTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray$1(value) {
	  return isObjectLike$6(value) &&
	    isLength$1(value.length) && !!typedArrayTags[baseGetTag$2(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray$1;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */

	function baseUnary$3(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary$3;

	var _nodeUtil = {exports: {}};

	_nodeUtil.exports;

	(function (module, exports) {
		var freeGlobal = _freeGlobal;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));

	var _nodeUtilExports = _nodeUtil.exports;

	var baseIsTypedArray = _baseIsTypedArray,
	    baseUnary$2 = _baseUnary,
	    nodeUtil$2 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray$3 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;

	var isTypedArray_1 = isTypedArray$3;

	var baseTimes = _baseTimes,
	    isArguments$1 = isArguments_1,
	    isArray$4 = isArray_1,
	    isBuffer$3 = isBufferExports,
	    isIndex$1 = _isIndex,
	    isTypedArray$2 = isTypedArray_1;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys$2(value, inherited) {
	  var isArr = isArray$4(value),
	      isArg = !isArr && isArguments$1(value),
	      isBuff = !isArr && !isArg && isBuffer$3(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray$2(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex$1(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys$2;

	/** Used for built-in method references. */

	var objectProto$7 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype$3(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$7;

	  return value === proto;
	}

	var _isPrototype = isPrototype$3;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */

	function overArg$2(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg$2;

	var overArg$1 = _overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys$1 = overArg$1(Object.keys, Object);

	var _nativeKeys = nativeKeys$1;

	var isPrototype$2 = _isPrototype,
	    nativeKeys = _nativeKeys;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys$1(object) {
	  if (!isPrototype$2(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$5.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys$1;

	var isFunction$1 = isFunction_1,
	    isLength = isLength_1;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike$4(value) {
	  return value != null && isLength(value.length) && !isFunction$1(value);
	}

	var isArrayLike_1 = isArrayLike$4;

	var arrayLikeKeys$1 = _arrayLikeKeys,
	    baseKeys = _baseKeys,
	    isArrayLike$3 = isArrayLike_1;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$3(object) {
	  return isArrayLike$3(object) ? arrayLikeKeys$1(object) : baseKeys(object);
	}

	var keys_1 = keys$3;

	var copyObject$4 = _copyObject,
	    keys$2 = keys_1;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign$1(object, source) {
	  return object && copyObject$4(source, keys$2(source), object);
	}

	var _baseAssign = baseAssign$1;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */

	function nativeKeysIn$1(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn$1;

	var isObject$5 = isObject_1,
	    isPrototype$1 = _isPrototype,
	    nativeKeysIn = _nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn$1(object) {
	  if (!isObject$5(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype$1(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$4.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn$1;

	var arrayLikeKeys = _arrayLikeKeys,
	    baseKeysIn = _baseKeysIn,
	    isArrayLike$2 = isArrayLike_1;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$5(object) {
	  return isArrayLike$2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	var keysIn_1 = keysIn$5;

	var copyObject$3 = _copyObject,
	    keysIn$4 = keysIn_1;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn$1(object, source) {
	  return object && copyObject$3(source, keysIn$4(source), object);
	}

	var _baseAssignIn = baseAssignIn$1;

	var _cloneBuffer = {exports: {}};

	_cloneBuffer.exports;

	(function (module, exports) {
		var root = _root;

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var length = buffer.length,
		      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		  buffer.copy(result);
		  return result;
		}

		module.exports = cloneBuffer; 
	} (_cloneBuffer, _cloneBuffer.exports));

	var _cloneBufferExports = _cloneBuffer.exports;

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */

	function copyArray$2(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray$2;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */

	function arrayFilter$1(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter$1;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */

	function stubArray$2() {
	  return [];
	}

	var stubArray_1 = stubArray$2;

	var arrayFilter = _arrayFilter,
	    stubArray$1 = stubArray_1;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols$3;

	var copyObject$2 = _copyObject,
	    getSymbols$2 = _getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols$1(source, object) {
	  return copyObject$2(source, getSymbols$2(source), object);
	}

	var _copySymbols = copySymbols$1;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */

	function arrayPush$2(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush$2;

	var overArg = _overArg;

	/** Built-in value references. */
	var getPrototype$3 = overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype$3;

	var arrayPush$1 = _arrayPush,
	    getPrototype$2 = _getPrototype,
	    getSymbols$1 = _getSymbols,
	    stubArray = stubArray_1;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush$1(result, getSymbols$1(object));
	    object = getPrototype$2(object);
	  }
	  return result;
	};

	var _getSymbolsIn = getSymbolsIn$2;

	var copyObject$1 = _copyObject,
	    getSymbolsIn$1 = _getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn$1(source, object) {
	  return copyObject$1(source, getSymbolsIn$1(source), object);
	}

	var _copySymbolsIn = copySymbolsIn$1;

	var arrayPush = _arrayPush,
	    isArray$3 = isArray_1;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray$3(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys$2;

	var baseGetAllKeys$1 = _baseGetAllKeys,
	    getSymbols = _getSymbols,
	    keys$1 = keys_1;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys$2(object) {
	  return baseGetAllKeys$1(object, keys$1, getSymbols);
	}

	var _getAllKeys = getAllKeys$2;

	var baseGetAllKeys = _baseGetAllKeys,
	    getSymbolsIn = _getSymbolsIn,
	    keysIn$3 = keysIn_1;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn$1(object) {
	  return baseGetAllKeys(object, keysIn$3, getSymbolsIn);
	}

	var _getAllKeysIn = getAllKeysIn$1;

	var getNative$3 = _getNative,
	    root$4 = _root;

	/* Built-in method references that are verified to be native. */
	var DataView$1 = getNative$3(root$4, 'DataView');

	var _DataView = DataView$1;

	var getNative$2 = _getNative,
	    root$3 = _root;

	/* Built-in method references that are verified to be native. */
	var Promise$2 = getNative$2(root$3, 'Promise');

	var _Promise = Promise$2;

	var getNative$1 = _getNative,
	    root$2 = _root;

	/* Built-in method references that are verified to be native. */
	var Set$2 = getNative$1(root$2, 'Set');

	var _Set = Set$2;

	var getNative = _getNative,
	    root$1 = _root;

	/* Built-in method references that are verified to be native. */
	var WeakMap$1 = getNative(root$1, 'WeakMap');

	var _WeakMap = WeakMap$1;

	var DataView = _DataView,
	    Map$2 = _Map,
	    Promise$1 = _Promise,
	    Set$1 = _Set,
	    WeakMap = _WeakMap,
	    baseGetTag$1 = _baseGetTag,
	    toSource = _toSource;

	/** `Object#toString` result references. */
	var mapTag$4 = '[object Map]',
	    objectTag$3 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$4 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$3 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map$2),
	    promiseCtorString = toSource(Promise$1),
	    setCtorString = toSource(Set$1),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag$4 = baseGetTag$1;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$3) ||
	    (Map$2 && getTag$4(new Map$2) != mapTag$4) ||
	    (Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag) ||
	    (Set$1 && getTag$4(new Set$1) != setTag$4) ||
	    (WeakMap && getTag$4(new WeakMap) != weakMapTag$1)) {
	  getTag$4 = function(value) {
	    var result = baseGetTag$1(value),
	        Ctor = result == objectTag$3 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$3;
	        case mapCtorString: return mapTag$4;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$4;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag$4;

	/** Used for built-in method references. */

	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray$1(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$3.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	var _initCloneArray = initCloneArray$1;

	var root = _root;

	/** Built-in value references. */
	var Uint8Array$3 = root.Uint8Array;

	var _Uint8Array = Uint8Array$3;

	var Uint8Array$2 = _Uint8Array;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer$3(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer$3;

	var cloneArrayBuffer$2 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView$1(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	var _cloneDataView = cloneDataView$1;

	/** Used to match `RegExp` flags from their coerced string values. */

	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp$1(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	var _cloneRegExp = cloneRegExp$1;

	var Symbol$2 = _Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
	    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol$1(symbol) {
	  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
	}

	var _cloneSymbol = cloneSymbol$1;

	var cloneArrayBuffer$1 = _cloneArrayBuffer;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray$2(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer$1(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray$2;

	var cloneArrayBuffer = _cloneArrayBuffer,
	    cloneDataView = _cloneDataView,
	    cloneRegExp = _cloneRegExp,
	    cloneSymbol = _cloneSymbol,
	    cloneTypedArray$1 = _cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    mapTag$3 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$3 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$2 = '[object Symbol]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag$1(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$2:
	      return cloneArrayBuffer(object);

	    case boolTag$2:
	    case dateTag$2:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return cloneTypedArray$1(object, isDeep);

	    case mapTag$3:
	      return new Ctor;

	    case numberTag$2:
	    case stringTag$2:
	      return new Ctor(object);

	    case regexpTag$2:
	      return cloneRegExp(object);

	    case setTag$3:
	      return new Ctor;

	    case symbolTag$2:
	      return cloneSymbol(object);
	  }
	}

	var _initCloneByTag = initCloneByTag$1;

	var isObject$4 = isObject_1;

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate$1 = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject$4(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate$1;

	var baseCreate = _baseCreate,
	    getPrototype$1 = _getPrototype,
	    isPrototype = _isPrototype;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject$2(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype$1(object))
	    : {};
	}

	var _initCloneObject = initCloneObject$2;

	var getTag$3 = _getTag,
	    isObjectLike$5 = isObjectLike_1;

	/** `Object#toString` result references. */
	var mapTag$2 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap$1(value) {
	  return isObjectLike$5(value) && getTag$3(value) == mapTag$2;
	}

	var _baseIsMap = baseIsMap$1;

	var baseIsMap = _baseIsMap,
	    baseUnary$1 = _baseUnary,
	    nodeUtil$1 = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;

	var isMap_1 = isMap$1;

	var getTag$2 = _getTag,
	    isObjectLike$4 = isObjectLike_1;

	/** `Object#toString` result references. */
	var setTag$2 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet$1(value) {
	  return isObjectLike$4(value) && getTag$2(value) == setTag$2;
	}

	var _baseIsSet = baseIsSet$1;

	var baseIsSet = _baseIsSet,
	    baseUnary = _baseUnary,
	    nodeUtil = _nodeUtilExports;

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	var isSet_1 = isSet$1;

	var Stack$2 = _Stack,
	    arrayEach = _arrayEach,
	    assignValue = _assignValue,
	    baseAssign = _baseAssign,
	    baseAssignIn = _baseAssignIn,
	    cloneBuffer$1 = _cloneBufferExports,
	    copyArray$1 = _copyArray,
	    copySymbols = _copySymbols,
	    copySymbolsIn = _copySymbolsIn,
	    getAllKeys$1 = _getAllKeys,
	    getAllKeysIn = _getAllKeysIn,
	    getTag$1 = _getTag,
	    initCloneArray = _initCloneArray,
	    initCloneByTag = _initCloneByTag,
	    initCloneObject$1 = _initCloneObject,
	    isArray$2 = isArray_1,
	    isBuffer$2 = isBufferExports,
	    isMap = isMap_1,
	    isObject$3 = isObject_1,
	    isSet = isSet_1,
	    keys = keys_1,
	    keysIn$2 = keysIn_1;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$2 = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG$2 = 4;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag$1 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$1 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag$1 = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$1 = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] =
	cloneableTags[boolTag$1] = cloneableTags[dateTag$1] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag$1] =
	cloneableTags[numberTag$1] = cloneableTags[objectTag$2] =
	cloneableTags[regexpTag$1] = cloneableTags[setTag$1] =
	cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone$2(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG$2,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG$2;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject$3(value)) {
	    return value;
	  }
	  var isArr = isArray$2(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray$1(value, result);
	    }
	  } else {
	    var tag = getTag$1(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer$2(value)) {
	      return cloneBuffer$1(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$1 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject$1(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack$2);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone$2(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys$1)
	    : (isFlat ? keysIn$2 : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone$2(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	var _baseClone = baseClone$2;

	var baseClone$1 = _baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone$1(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
	}

	var cloneDeep_1 = cloneDeep;

	var cloneDeep$1 = /*@__PURE__*/getDefaultExportFromCjs(cloneDeep_1);

	var baseAssignValue = _baseAssignValue,
	    eq$2 = eq_1;

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue$2(object, key, value) {
	  if ((value !== undefined && !eq$2(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	var _assignMergeValue = assignMergeValue$2;

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */

	function createBaseFor$1(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	var _createBaseFor = createBaseFor$1;

	var createBaseFor = _createBaseFor;

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor$1 = createBaseFor();

	var _baseFor = baseFor$1;

	var isArrayLike$1 = isArrayLike_1,
	    isObjectLike$3 = isObjectLike_1;

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject$1(value) {
	  return isObjectLike$3(value) && isArrayLike$1(value);
	}

	var isArrayLikeObject_1 = isArrayLikeObject$1;

	var baseGetTag = _baseGetTag,
	    getPrototype = _getPrototype,
	    isObjectLike$2 = isObjectLike_1;

	/** `Object#toString` result references. */
	var objectTag$1 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject$2(value) {
	  if (!isObjectLike$2(value) || baseGetTag(value) != objectTag$1) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	var isPlainObject_1 = isPlainObject$2;

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */

	function safeGet$2(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	var _safeGet = safeGet$2;

	var copyObject = _copyObject,
	    keysIn$1 = keysIn_1;

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject$1(value) {
	  return copyObject(value, keysIn$1(value));
	}

	var toPlainObject_1 = toPlainObject$1;

	var assignMergeValue$1 = _assignMergeValue,
	    cloneBuffer = _cloneBufferExports,
	    cloneTypedArray = _cloneTypedArray,
	    copyArray = _copyArray,
	    initCloneObject = _initCloneObject,
	    isArguments = isArguments_1,
	    isArray$1 = isArray_1,
	    isArrayLikeObject = isArrayLikeObject_1,
	    isBuffer$1 = isBufferExports,
	    isFunction = isFunction_1,
	    isObject$2 = isObject_1,
	    isPlainObject$1 = isPlainObject_1,
	    isTypedArray$1 = isTypedArray_1,
	    safeGet$1 = _safeGet,
	    toPlainObject = toPlainObject_1;

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet$1(object, key),
	      srcValue = safeGet$1(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue$1(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray$1(srcValue),
	        isBuff = !isArr && isBuffer$1(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray$1(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject$2(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue$1(object, key, newValue);
	}

	var _baseMergeDeep = baseMergeDeep$1;

	var Stack$1 = _Stack,
	    assignMergeValue = _assignMergeValue,
	    baseFor = _baseFor,
	    baseMergeDeep = _baseMergeDeep,
	    isObject$1 = isObject_1,
	    keysIn = keysIn_1,
	    safeGet = _safeGet;

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge$1(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    stack || (stack = new Stack$1);
	    if (isObject$1(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	var _baseMerge = baseMerge$1;

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */

	function identity$2(value) {
	  return value;
	}

	var identity_1 = identity$2;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */

	function apply$1(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	var _apply = apply$1;

	var apply = _apply;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest$1(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	var _overRest = overRest$1;

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */

	function constant$1(value) {
	  return function() {
	    return value;
	  };
	}

	var constant_1 = constant$1;

	var constant = constant_1,
	    defineProperty = _defineProperty,
	    identity$1 = identity_1;

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	var _baseSetToString = baseSetToString$1;

	/** Used to detect hot functions by number of calls within a span of milliseconds. */

	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut$1(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	var _shortOut = shortOut$1;

	var baseSetToString = _baseSetToString,
	    shortOut = _shortOut;

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString$1 = shortOut(baseSetToString);

	var _setToString = setToString$1;

	var identity = identity_1,
	    overRest = _overRest,
	    setToString = _setToString;

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest$1(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	var _baseRest = baseRest$1;

	var eq$1 = eq_1,
	    isArrayLike = isArrayLike_1,
	    isIndex = _isIndex,
	    isObject = isObject_1;

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall$1(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq$1(object[index], value);
	  }
	  return false;
	}

	var _isIterateeCall = isIterateeCall$1;

	var baseRest = _baseRest,
	    isIterateeCall = _isIterateeCall;

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner$1(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	var _createAssigner = createAssigner$1;

	var baseMerge = _baseMerge,
	    createAssigner = _createAssigner;

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	var merge_1 = merge;

	var merge$1 = /*@__PURE__*/getDefaultExportFromCjs(merge_1);

	var __extends$1b = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a StyleControl object.
	 */
	var StyleControlOptions = /** @class */ (function (_super) {
	    __extends$1b(StyleControlOptions, _super);
	    function StyleControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The layout to display the styles in.<br />
	         * `"icons"`: A row of clickable icons for each style.<br />
	         * `"list"`: A scrollable list with the icons and names for each style.<br />
	         * Default `"icons"`
	         * @default "icons"
	         */
	        _this.layout = "icons";
	        /**
	         * The map styles to show in the control.
	         * Style names are case sensitive.
	         * If an included style isn't supported by the map it will be ignored.
	         * Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article.
	         * If "all" is specified, all map styles will be shown.
	         * Default `["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]`
	         * @default ["road", "grayscale_light", "grayscale_dark", "night", "road_shaded_relief"]
	         */
	        _this.mapStyles = [
	            "road",
	            "grayscale_light",
	            "grayscale_dark",
	            "night",
	            "road_shaded_relief",
	        ];
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Whether to let style control automatically set the style, once user select a map style.
	         * If set to `false`, then clicking on style will not set the set the style automatically.
	         * Default `true`
	         */
	        _this.autoSelectionMode = true;
	        return _this;
	    }
	    return StyleControlOptions;
	}(Options));

	var __extends$1a = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter$3 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$3 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$b = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * A control for changing the style of the map.
	 */
	var StyleControl = /** @class */ (function (_super) {
	    __extends$1a(StyleControl, _super);
	    /**
	     * Constructs a StyleControl.
	     * @param options The options for the control.
	     */
	    function StyleControl(options) {
	        var _this = _super.call(this) || this;
	        _this.styleOpsGrid = null;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        _this.styleButtons = new Dictionary();
	        _this.styleIcons = new Dictionary();
	        // we need to rely on this to avoid potentially redundant thumbnail requests and .blob calls
	        _this.thumbnailCache = {
	            assumedConfiguration: undefined,
	            response: new Dictionary(),
	            blob: new Dictionary()
	        };
	        /**
	         * Callback handler for the style changing.
	         */
	        _this.onStyleChange = function () {
	            if (_this.options.autoSelectionMode) {
	                var newStyle = _this.map.getStyle().style;
	                _this.setSelectedStyle(newStyle);
	            }
	        };
	        _this.onMapConfigurationChange = function (definitions) {
	            if (!_this.styleOpsGrid) {
	                return;
	            }
	            // do not recreate the styleOpsGrid if it is initialized and configuration object reference has not changed
	            if (_this.styleOpsGrid.children.length > 0 && _this.thumbnailCache.assumedConfiguration === definitions) {
	                return;
	            }
	            _this.thumbnailCache.assumedConfiguration = definitions;
	            Array.from(_this.styleOpsGrid.children).forEach(function (element) { return element.remove(); });
	            _this.styleButtons.clear();
	            _this.populateOpsGridFromDefinitions(definitions);
	        };
	        _this.mapToFriendlyStyleName = function (name, mapConfiguration) {
	            var style = mapConfiguration.configurations.find(function (style) { return style.name === name; });
	            return (style === null || style === void 0 ? void 0 : style.displayName) || name;
	        };
	        _this.options = new StyleControlOptions().merge(cloneDeep$1(options));
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    StyleControl.prototype.onAdd = function (map, options) {
	        var _this = this;
	        this.map = map;
	        var container = this.buildContainer(map, this.options.style, "Map Style Control");
	        var styleOpsGrid = this.buildStyleOpsGrid();
	        this.styleOpsGrid = styleOpsGrid;
	        var currStyleButton = this.buildCurrStyleBtn();
	        var tooltip = buildAccessibleTooltip("Select Style");
	        var expandGrid = function (expanded) {
	            if (expanded) {
	                container.classList.add(StyleControl.Css.inUse);
	                styleOpsGrid.setAttribute("aria-hidden", "false");
	                styleOpsGrid.classList.remove("hidden-accessible-element");
	            }
	            else {
	                container.classList.remove(StyleControl.Css.inUse);
	                styleOpsGrid.setAttribute("aria-hidden", "true");
	                styleOpsGrid.classList.add("hidden-accessible-element");
	            }
	        };
	        styleOpsGrid.classList.add(options ? options.position || 'top-right' : 'top-right');
	        container.addEventListener("mouseover", function () {
	            _this.hasMouse = true;
	            expandGrid(true);
	        });
	        container.addEventListener("focusin", function () {
	            _this.hasFocus = true;
	            expandGrid(true);
	        });
	        container.addEventListener("mouseleave", function () {
	            _this.hasMouse = false;
	            if (!_this.hasFocus) {
	                expandGrid(false);
	            }
	        });
	        container.addEventListener("focusout", function (event) {
	            if (event.target === currStyleButton) {
	                // on focusout from reveal button -> reset the tabIndex on the styleOpsGrid elements that could have been set to -1 on esc key press
	                Array.from(styleOpsGrid.children).forEach(function (e) { return e.removeAttribute('tabIndex'); });
	            }
	            if (!(event.relatedTarget instanceof Node && container.contains(event.relatedTarget))) {
	                _this.hasFocus = false;
	                if (!_this.hasMouse) {
	                    expandGrid(false);
	                }
	            }
	        });
	        // explictly hijack esc key behavior: we should not interrupt normal tab-navigation flow
	        // but focus out via esc from to the parent container should instead bring focus to the reveal button
	        styleOpsGrid.addEventListener('keydown', function (event) {
	            if (event.keyCode === 27) {
	                event.stopPropagation();
	                currStyleButton.focus();
	                Array.from(styleOpsGrid.children).forEach(function (e) { return e.setAttribute('tabIndex', "-1"); });
	                if (container.classList.contains(StyleControl.Css.inUse)) {
	                    expandGrid(false);
	                }
	            }
	        });
	        currStyleButton.addEventListener("click", function (event) {
	            if (container.classList.contains(StyleControl.Css.inUse)) {
	                expandGrid(false);
	            }
	            else {
	                expandGrid(true);
	                // clicking on a reveal button should move the focus to the first styleOpsGrid button
	                if (styleOpsGrid.firstElementChild) {
	                    styleOpsGrid.firstElementChild.focus();
	                }
	            }
	        });
	        if (options && StyleControl.InvertOrderPositions.includes(options.position)) {
	            container.appendChild(styleOpsGrid);
	            container.appendChild(currStyleButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, currStyleButton);
	        }
	        else {
	            container.appendChild(currStyleButton);
	            container.appendChild(tooltip);
	            positionTooltip(tooltip, currStyleButton);
	            container.appendChild(styleOpsGrid);
	        }
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    StyleControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        this.styleOpsGrid = null;
	        this.styleButtons.clear();
	        this.thumbnailCache.response.clear();
	        this.thumbnailCache.blob.clear();
	        this.thumbnailCache.assumedConfiguration = undefined;
	        this.map.events.remove("stylechanged", this.onStyleChange);
	        this.map.events.remove("mapconfigurationchanged", this.onMapConfigurationChange);
	    };
	    /**
	     * Set the style that need to be displayed as currently selected.
	     * Style will automatically get selected if `StyleControlOptions.autoSelectionMode` is `true`
	     * @param styleName - Style name that need to be disabled as currently selected
	     */
	    StyleControl.prototype.setSelectedStyle = function (styleName) {
	        var _this = this;
	        if (this.styleIcons.has(styleName)) {
	            var image_1 = this.currStyleImage;
	            var newSrc = this.styleIcons.get(styleName);
	            if (image_1.src !== newSrc) {
	                image_1.src = newSrc;
	            }
	            Object.entries(this.styleButtons).forEach(function (_a) {
	                var _b = __read$b(_a, 2), buttonStyleName = _b[0], button = _b[1];
	                return button.setAttribute('aria-current', buttonStyleName === styleName ? 'true' : 'false');
	            });
	            this.map.styles.definitions().then(function (mapConfiguration) {
	                var newAlt = _this.mapToFriendlyStyleName(styleName, mapConfiguration);
	                if (image_1.alt !== newAlt) {
	                    image_1.alt = newAlt;
	                }
	                if (image_1.parentElement.lastChild instanceof Text) {
	                    image_1.parentElement.lastChild.textContent = newAlt;
	                }
	            });
	        }
	    };
	    /**
	     * Set style in a disabled state
	     * @param styleName Style to be disabled
	     */
	    StyleControl.prototype.disableStyle = function (styleName) {
	        var styleButton = this.styleButtons[styleName];
	        if (styleButton) {
	            styleButton.setAttribute("disabled", "true");
	        }
	    };
	    /**
	     * Enabled style that was previously disabled
	     * @param styleName Style to be disabled
	     */
	    StyleControl.prototype.enableStyle = function (styleName) {
	        var styleButton = this.styleButtons[styleName];
	        if (styleButton) {
	            styleButton.removeAttribute("disabled");
	        }
	    };
	    StyleControl.prototype.buildSelectStyleBtn = function (name, mapConfiguration, fetchIconPromise) {
	        var _this = this;
	        var styleOptionButton = document.createElement("button");
	        var friendlyName = this.mapToFriendlyStyleName(name, mapConfiguration);
	        styleOptionButton.setAttribute("aria-label", friendlyName);
	        styleOptionButton.setAttribute("type", "button");
	        var styleIconImage = new Image();
	        fetchIconPromise
	            .then(function (response) {
	            if (_this.thumbnailCache.blob.has(response.url)) {
	                return _this.thumbnailCache.blob.get(response.url);
	            }
	            else {
	                // we need the response.clone() to allow reading over body multiple times since response objects are cached 
	                // and can be reused across multiple invocations
	                var blobPromise = response.clone().blob();
	                _this.thumbnailCache.blob.set(response.url, blobPromise);
	                return blobPromise;
	            }
	        })
	            .then(function (blob) {
	            var iconUrl = URL.createObjectURL(blob);
	            styleIconImage.src = iconUrl;
	            if (name === _this.map.getStyle().style) {
	                _this.currStyleImage.src = iconUrl;
	                _this.currStyleImage.alt = friendlyName;
	                if (_this.currStyleImage.parentElement.lastChild.nodeType == Node.TEXT_NODE) {
	                    _this.currStyleImage.parentElement.lastChild.textContent = friendlyName;
	                }
	                else {
	                    _this.currStyleImage.parentElement.appendChild(document.createTextNode(friendlyName));
	                }
	            }
	            _this.styleIcons.set(name, iconUrl);
	        });
	        styleIconImage.setAttribute("aria-hidden", "true");
	        styleOptionButton.appendChild(styleIconImage);
	        if (this.options.layout === "icons") {
	            styleOptionButton.classList.add(StyleControl.Css.button);
	        }
	        else {
	            styleOptionButton.classList.add(StyleControl.Css.listButton);
	            styleOptionButton.classList.add(StyleControl.Css.expanded);
	            styleOptionButton.appendChild(document.createTextNode(friendlyName));
	        }
	        styleOptionButton.addEventListener("click", function () {
	            _this.hasMouse = false;
	            _this.hasFocus = false;
	            var styleButton = _this.styleButtons[name];
	            if (styleButton && !styleButton.hasAttribute("disabled")) {
	                _this._invokeEvent("styleselected", name);
	                if (_this.options.autoSelectionMode) {
	                    _this.map.setStyle({ style: name });
	                }
	                Object.entries(_this.styleButtons).forEach(function (_a) {
	                    var _b = __read$b(_a, 2), styleName = _b[0], button = _b[1];
	                    return button.setAttribute('aria-current', styleName === name ? 'true' : 'false');
	                });
	            }
	        });
	        var iconDiv = document.createElement('div');
	        iconDiv.classList.add('selected-icon');
	        styleOptionButton.appendChild(iconDiv);
	        return styleOptionButton;
	    };
	    StyleControl.prototype.buildCurrStyleBtn = function () {
	        var selectCurrButton = document.createElement("button");
	        if (this.options.layout == 'icons') {
	            selectCurrButton.classList.add(StyleControl.Css.button);
	        }
	        else {
	            selectCurrButton.classList.add(StyleControl.Css.listButton);
	        }
	        selectCurrButton.classList.add(StyleControl.Css.currentStyle);
	        selectCurrButton.setAttribute("aria-label", "Select Style");
	        selectCurrButton.setAttribute("tabindex", "-1");
	        this.currStyleImage = new Image();
	        selectCurrButton.appendChild(this.currStyleImage);
	        var selectCurrButtonIcon = document.createElement("div");
	        selectCurrButtonIcon.classList.add("icon");
	        selectCurrButton.appendChild(selectCurrButtonIcon);
	        return selectCurrButton;
	    };
	    StyleControl.prototype.buildStyleOpsGrid = function () {
	        var _this = this;
	        var styleOpsGrid = document.createElement("div");
	        styleOpsGrid.classList.add(StyleControl.Css.styleOptions);
	        if (this.options.layout === 'icons') {
	            styleOpsGrid.classList.add(this.options.layout);
	        }
	        else {
	            styleOpsGrid.classList.add(StyleControl.Css.dropdown);
	        }
	        styleOpsGrid.setAttribute("aria-label", "Style Options");
	        styleOpsGrid.classList.add("hidden-accessible-element");
	        styleOpsGrid.setAttribute("aria-hidden", "true");
	        // Once the map's style definition is initialized create a map between style names and icons.
	        // If a style is one of those to be shown by the style picker also create it's element.
	        this.map.styles.definitions().then(function (definitions) { return __awaiter$3(_this, void 0, void 0, function () {
	            return __generator$3(this, function (_a) {
	                this.onMapConfigurationChange(definitions);
	                this.map.events.add("stylechanged", this.onStyleChange);
	                return [2 /*return*/];
	            });
	        }); });
	        this.map.events.add("mapconfigurationchanged", this.onMapConfigurationChange);
	        return styleOpsGrid;
	    };
	    StyleControl.prototype.populateOpsGridFromDefinitions = function (definitions) {
	        var _this = this;
	        if (!this.styleOpsGrid) {
	            return;
	        }
	        var styles = definitions.configurations;
	        if (Array.isArray(this.options.mapStyles)) {
	            styles = styles.filter(function (style) { return _this.options.mapStyles.includes(style.name.split("_indoor")[0]); });
	        }
	        styles.forEach(function (style) {
	            // Create fetch thumbnail request
	            var requestParams = {
	                url: style.thumbnail
	            };
	            style.thumbnail && _this.map.styles._transformStyleRequest(style.thumbnail, requestParams);
	            // Apply the users specified transform after ours
	            var mapServiceOptions = _this.map.getServiceOptions();
	            if (mapServiceOptions.transformRequest) {
	                merge$1(requestParams, mapServiceOptions.transformRequest(requestParams.url, "Thumbnail"));
	            }
	            var fetchThumbnailPromise;
	            if (_this.thumbnailCache.response.has(requestParams.url)) {
	                fetchThumbnailPromise = Promise.resolve(_this.thumbnailCache.response.get(requestParams.url));
	            }
	            else {
	                fetchThumbnailPromise = fetch(requestParams.url, { headers: requestParams.headers });
	                _this.thumbnailCache.response.set(requestParams.url, fetchThumbnailPromise);
	            }
	            // Add button for each style
	            var styleOptionButton = _this.buildSelectStyleBtn(style.name, definitions, fetchThumbnailPromise);
	            _this.styleOpsGrid.appendChild(styleOptionButton);
	            _this.styleButtons[style.name] = styleOptionButton;
	            if (_this.options.layout === "icons") {
	                var tooltip = buildAccessibleTooltip(_this.mapToFriendlyStyleName(style.name, definitions));
	                _this.styleOpsGrid.appendChild(tooltip);
	                positionTooltip(tooltip, styleOptionButton);
	            }
	        });
	        var targetStyleName = this.map.getStyle().style;
	        Object.entries(this.styleButtons).forEach(function (_a) {
	            var _b = __read$b(_a, 2), styleName = _b[0], button = _b[1];
	            return button.setAttribute('aria-current', styleName === targetStyleName ? 'true' : 'false');
	        });
	    };
	    StyleControl.InvertOrderPositions = [exports.ControlPosition.TopRight, exports.ControlPosition.BottomRight];
	    StyleControl.Css = {
	        button: "azure-maps-control-button",
	        listButton: "azure-maps-control-list-button",
	        expanded: 'expanded',
	        currentStyle: "curr-style",
	        inUse: "in-use",
	        styleOptions: "style-options",
	        dropdown: "azure-maps-control-dropdown"
	    };
	    return StyleControl;
	}(ControlBase));

	var __extends$19 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for setting traffic on the map.
	 */
	var TrafficOptions = /** @class */ (function (_super) {
	    __extends$19(TrafficOptions, _super);
	    function TrafficOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of traffic flow to display:<br />
	         * `"none"` is to display no traffic flow data<br />
	         * `"relative"` is the speed of the road relative to free-flow<br />
	         * @deprecated `"absolute"` is the absolute speed of the road<br />
	         * @deprecated `"relative-delay"` displays relative speed only where they differ from free-flow;
	         * false to stop displaying the traffic flow.<br />
	         * default `"none"`
	         * @default "none"
	         */
	        _this.flow = "none";
	        /**
	         * Whether to display incidents on the map.
	         * default `false`
	         * @default false
	         */
	        _this.incidents = false;
	        return _this;
	    }
	    return TrafficOptions;
	}(Options));

	var __extends$18 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a TrafficControl object.
	 */
	var TrafficControlOptions = /** @class */ (function (_super) {
	    __extends$18(TrafficControlOptions, _super);
	    function TrafficControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the control is in the active state (displaying traffic).
	         * Default: false
	         * @default false
	         */
	        _this.isActive = false;
	        /**
	         * The style of the control. Can be; light, dark, auto, or any CSS3 color. When set to auto, the style will change based on the map style.
	         * Default `light'.
	         * @default light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return TrafficControlOptions;
	}(TrafficOptions));

	var __extends$17 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control that toggles traffic data on the map.
	 */
	var TrafficControl = /** @class */ (function (_super) {
	    __extends$17(TrafficControl, _super);
	    /**
	     * Constructs a TrafficControl
	     * @param options The options for the control.
	     */
	    function TrafficControl(options) {
	        var _this = this;
	        var _a, _b;
	        _this = _super.call(this) || this;
	        _this.hasMouse = false;
	        _this.hasFocus = false;
	        // desired map traffic state when control is enabled 
	        _this.options = new TrafficOptions().merge({
	            flow: 'relative',
	            incidents: true
	        });
	        _this.style = exports.ControlStyle.light;
	        _this.container = null;
	        _this.trafficButton = null;
	        _this.map = null;
	        if (options) {
	            _this.initIsActive = (_a = options.isActive) !== null && _a !== void 0 ? _a : false;
	            _this.options.flow = options.flow || 'relative';
	            _this.options.incidents = (_b = options.incidents) !== null && _b !== void 0 ? _b : true;
	            _this.style = options.style || exports.ControlStyle.light;
	        }
	        return _this;
	    }
	    Object.defineProperty(TrafficControl.prototype, "isActive", {
	        /**
	         * Current control state (is traffic information displayed?)
	         */
	        get: function () {
	            if (!this.map) {
	                return false;
	            }
	            var trafficState = this.map.getTraffic();
	            return trafficState.flow !== "none" || trafficState.incidents;
	        },
	        /**
	         * Sets the control state
	         */
	        set: function (newValue) {
	            if (!this.map) {
	                return;
	            }
	            this.map.setTraffic({
	                flow: newValue ? this.options.flow : 'none',
	                incidents: newValue ? this.options.incidents : false
	            });
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    TrafficControl.prototype.onAdd = function (map) {
	        this.map = map;
	        map.getTraffic();
	        // bring map traffic state in sync with desired if initIsActive have been set
	        if (this.initIsActive !== undefined) {
	            this.isActive = this.initIsActive;
	        }
	        this.container = this.buildContainer(map, this.style, "Traffic Control");
	        this.container.style.flexDirection = "column";
	        var trafficButton = this.constructTrafficButton(map);
	        this.container.appendChild(trafficButton);
	        var tooltip = buildAccessibleTooltip("Toggle Traffic Display");
	        this.container.appendChild(tooltip);
	        positionTooltip(tooltip, trafficButton);
	        return this.container;
	    };
	    TrafficControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        this.map = null;
	    };
	    /**
	     * Get the TrafficControlOptions
	     */
	    TrafficControl.prototype.getOptions = function () {
	        return new TrafficControlOptions().merge({
	            isActive: this.isActive,
	            flow: this.options.flow,
	            incidents: this.options.incidents,
	            style: this.style
	        });
	    };
	    /**
	     * Updates the button state according to current traffic state
	     * This is invoked on init in constructTrafficButton and on each Map.setTraffic()
	     */
	    TrafficControl.prototype.updateButtonState = function () {
	        if (this.trafficButton) {
	            if (this.isActive) {
	                this.container.classList.add("in-use");
	                this.trafficButton.setAttribute("aria-description", "Traffic is displayed");
	            }
	            else {
	                this.container.classList.remove("in-use");
	                this.trafficButton.removeAttribute("aria-description");
	            }
	            this.trafficButton.setAttribute("aria-pressed", this.isActive ? "true" : "false");
	        }
	    };
	    TrafficControl.prototype.constructTrafficButton = function (map) {
	        var _this = this;
	        var trafficButton = document.createElement("button");
	        trafficButton.classList.add("azure-maps-control-button");
	        trafficButton.classList.add("traffic");
	        trafficButton.setAttribute("aria-label", "Toggle Traffic Display");
	        trafficButton.setAttribute("alt", "Toggle Traffic Display");
	        trafficButton.setAttribute("type", "button");
	        this.trafficButton = trafficButton;
	        this.updateButtonState();
	        // toggle button
	        trafficButton.addEventListener("click", function () {
	            _this.isActive = !_this.isActive;
	        });
	        return trafficButton;
	    };
	    return TrafficControl;
	}(ControlBase));

	var __extends$16 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$j = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A control that display traffic legend on the map.
	 */
	var TrafficLegendControl = /** @class */ (function (_super) {
	    __extends$16(TrafficLegendControl, _super);
	    /**
	     * Construct a traffic legend control
	     */
	    function TrafficLegendControl() {
	        var _this = _super.call(this) || this;
	        _this.table = ["Fast",
	            ["green", "yellow", "red", "dark-red"],
	            "Slow"];
	        _this.map = null;
	        _this.syncHiddenState = null;
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    TrafficLegendControl.prototype.onAdd = function (map) {
	        this.map = map;
	        var container = this.buildContainer(map, exports.ControlStyle.auto, "Traffic Legend");
	        var TrafficLegendDiv = this.buildTrafficLegendDiv(map);
	        container.setAttribute("role", "definition");
	        container.appendChild(TrafficLegendDiv);
	        return container;
	    };
	    TrafficLegendControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        if (this.syncHiddenState) {
	            this.map.events.remove('styledata', this.syncHiddenState);
	            this.syncHiddenState = null;
	        }
	        this.map = null;
	    };
	    TrafficLegendControl.prototype.buildTrafficLegendDiv = function (map) {
	        var e_1, _a, e_2, _b;
	        var trafficLegend = document.createElement("div");
	        trafficLegend.classList.add("traffic-legend", "hidden");
	        trafficLegend.setAttribute("alt", "Traffic Legend");
	        var trafficLegendTable = document.createElement("table");
	        // legend table title
	        var tr1 = document.createElement("tr");
	        var td = document.createElement("td");
	        td.setAttribute("alt", "Traffic");
	        td.appendChild(document.createTextNode("Traffic"));
	        var tooltip = buildAccessibleTooltip("Traffic");
	        td.classList.add("traffic-legend-title");
	        td.colSpan = 6;
	        tr1.appendChild(td);
	        tr1.appendChild(tooltip);
	        positionTooltip(tooltip, td);
	        trafficLegendTable.appendChild(tr1);
	        // legend table contents
	        var tr2 = document.createElement("tr");
	        try {
	            for (var _c = __values$j(this.table), _d = _c.next(); !_d.done; _d = _c.next()) {
	                var col = _d.value;
	                var data = document.createElement("td");
	                if (col === "Fast" || col === "Slow") {
	                    data.setAttribute("alt", col);
	                    data.appendChild(document.createTextNode(col));
	                    data.classList.add("traffic-legend-text");
	                }
	                else {
	                    data.classList.add("traffic-legend-colors");
	                    data.setAttribute("aria-label", "Traffic Legend");
	                    data.setAttribute("role", "img");
	                    try {
	                        for (var col_1 = (e_2 = void 0, __values$j(col)), col_1_1 = col_1.next(); !col_1_1.done; col_1_1 = col_1.next()) {
	                            var color = col_1_1.value;
	                            var div = document.createElement("div");
	                            div.classList.add(color);
	                            data.appendChild(div);
	                        }
	                    }
	                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
	                    finally {
	                        try {
	                            if (col_1_1 && !col_1_1.done && (_b = col_1.return)) _b.call(col_1);
	                        }
	                        finally { if (e_2) throw e_2.error; }
	                    }
	                }
	                tr2.appendChild(data);
	                var tooltip_1 = buildAccessibleTooltip(col instanceof Array ? "Traffic Legend" : col);
	                tr2.appendChild(tooltip_1);
	                positionTooltip(tooltip_1, data);
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        trafficLegendTable.appendChild(tr2);
	        trafficLegend.appendChild(trafficLegendTable);
	        this.syncHiddenState = function (eventData) {
	            if (eventData.dataType === "style") {
	                var trafficOptions = map.getTraffic();
	                if (trafficOptions.flow && trafficOptions.flow !== "none") {
	                    trafficLegend.classList.remove("hidden");
	                }
	                else {
	                    trafficLegend.classList.add("hidden");
	                }
	            }
	        };
	        // display legend when the traffic flow is shown, hide it otherwise
	        this.syncHiddenState({ dataType: 'style' });
	        map.events.add("styledata", this.syncHiddenState);
	        return trafficLegend;
	    };
	    return TrafficLegendControl;
	}(ControlBase));

	/** Used to stand-in for `undefined` hash values. */

	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd$1(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	var _setCacheAdd = setCacheAdd$1;

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */

	function setCacheHas$1(value) {
	  return this.__data__.has(value);
	}

	var _setCacheHas = setCacheHas$1;

	var MapCache = _MapCache,
	    setCacheAdd = _setCacheAdd,
	    setCacheHas = _setCacheHas;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache$1(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
	SetCache$1.prototype.has = setCacheHas;

	var _SetCache = SetCache$1;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */

	function arraySome$1(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	var _arraySome = arraySome$1;

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */

	function cacheHas$1(cache, key) {
	  return cache.has(key);
	}

	var _cacheHas = cacheHas$1;

	var SetCache = _SetCache,
	    arraySome = _arraySome,
	    cacheHas = _cacheHas;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	var _equalArrays = equalArrays$2;

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */

	function mapToArray$1(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	var _mapToArray = mapToArray$1;

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */

	function setToArray$1(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	var _setToArray = setToArray$1;

	var Symbol$1 = _Symbol,
	    Uint8Array$1 = _Uint8Array,
	    eq = eq_1,
	    equalArrays$1 = _equalArrays,
	    mapToArray = _mapToArray,
	    setToArray = _setToArray;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	var _equalByTag = equalByTag$1;

	var getAllKeys = _getAllKeys;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	var _equalObjects = equalObjects$1;

	var Stack = _Stack,
	    equalArrays = _equalArrays,
	    equalByTag = _equalByTag,
	    equalObjects = _equalObjects,
	    getTag = _getTag,
	    isArray = isArray_1,
	    isBuffer = isBufferExports,
	    isTypedArray = isTypedArray_1;

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	var _baseIsEqualDeep = baseIsEqualDeep$1;

	var baseIsEqualDeep = _baseIsEqualDeep,
	    isObjectLike$1 = isObjectLike_1;

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual$1(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike$1(value) && !isObjectLike$1(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
	}

	var _baseIsEqual = baseIsEqual$1;

	var baseIsEqual = _baseIsEqual;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	var isEqual_1 = isEqual;

	var isEqual$1 = /*@__PURE__*/getDefaultExportFromCjs(isEqual_1);

	/**
	 * A GeoJSON Feature object - a JSON object representing a spatially bounded entity. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.2}.
	 */
	var Feature = /** @class */ (function () {
	    /**
	     * Constructs a Feature.
	     * @param geometry The geometry of the feature.
	     * @param properties The properties of the feature.
	     * @param id The id of the feature.
	     * @param bbox The bounding box of the feature.
	     */
	    function Feature(geometry, properties, id, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "Feature".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Feature";
	        this.type = Feature.TYPE;
	        this.properties = properties || {};
	        this.id = id;
	        this.geometry = geometry;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Feature class to be used in runtime comparisons.
	     */
	    Feature.TYPE = "Feature";
	    return Feature;
	}());

	var __extends$15 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represent a pixel coordinate or offset. Extends an array of [x, y].
	 */
	var Pixel = /** @class */ (function (_super) {
	    __extends$15(Pixel, _super);
	    /**
	     * Constructs a Pixel object and initializes it with the specified x and y coordinates.
	     * @param x The horizontal pixel offset.
	     * @param y The vertical pixel offset.
	     */
	    function Pixel(x, y) {
	        return _super.call(this, x, y) || this;
	    }
	    /**
	     * Generates a Pixel object from an object that contains coordinate information.
	     * The object is scanned for x and y properties using a case insensitive test.
	     * @param data The object to extract coordinate information from.
	     * @returns A Pixel object that represents the provided data information.
	     */
	    Pixel.fromData = function (data) {
	        var x = NaN;
	        var y = NaN;
	        var xNames = new Set(["y"]);
	        var yNames = new Set(["x"]);
	        // Do a case insensitive search through the object properties.
	        Object.keys(data).forEach(function (key) {
	            var smallKey = key.toLowerCase();
	            if (isNaN(x) && xNames.has(smallKey) && typeof data[key] === "number") {
	                x = data[key];
	            }
	            else if (isNaN(y) && yNames.has(smallKey) && typeof data[key] === "number") {
	                y = data[key];
	            }
	        });
	        // If an x and y value were found return the Pixel constructed from them.
	        if (!isNaN(x) && !isNaN(y)) {
	            return new Pixel(x, y);
	        }
	        return null;
	    };
	    /**
	     * Return the x coordinate of the specified pixel.
	     * @param pixel The pixel to get the x coordinate of.
	     */
	    Pixel.getX = function (pixel) {
	        if (pixel.length > 0) {
	            return pixel[0];
	        }
	        return NaN;
	    };
	    /**
	     * Return the y coordinate of the specified pixel.
	     * @param pixel The pixel to get the y coordinate of.
	     */
	    Pixel.getY = function (pixel) {
	        if (pixel.length > 1) {
	            return pixel[1];
	        }
	        return NaN;
	    };
	    /**
	     * Calculates a destination pixel given an origin pixel,​
	     * a heading relative to the y-axis (0 = north) with clockwise-rotation,​
	     * and a distance in pixel units.​
	     * @param origin The starting pixel.​
	     * @param heading The heading at which to move away from the origin pixel.​
	     * @param distance The distance to move from the origin pixel.​
	     */
	    Pixel.getDestination = function (origin, heading, distance) {
	        return new Pixel(Pixel.getX(origin) + distance * Math.cos((heading + 270) * Math.PI / 180), Pixel.getY(origin) + distance * Math.sin((heading + 270) * Math.PI / 180));
	    };
	    /**
	     * Calculates the distance between two pixels.
	     * Returned value is in screen pixel units.
	     * @param p1 The first pixel.
	     * @param p2 The second pixel.
	     */
	    Pixel.getDistance = function (p1, p2) {
	        var dx = Pixel.getX(p1) - Pixel.getX(p2);
	        var dy = Pixel.getY(p1) - Pixel.getY(p2);
	        return Math.sqrt(dx * dx + dy * dy);
	    };
	    /**​
	     * Calculates the heading between two pixels.​ The heading value is relative to the y-axis (0 = north) with clockwise-rotation.
	     * @param origin The pixel the heading will point away from.​
	     * @param destination The pixel the heading will point toward.​
	     */
	    Pixel.getHeading = function (origin, destination) {
	        var dx = Pixel.getX(destination) - Pixel.getX(origin);
	        var dy = Pixel.getY(origin) - Pixel.getY(destination);
	        return ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * 180 / Math.PI % 360;
	    };
	    return Pixel;
	}(Array));

	/**
	 * A GeoJSON Point object - a JSON object that represents a geographic position. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.2}.
	 */
	var Point = /** @class */ (function () {
	    /**
	     * Constructs a Point.
	     * @param coordinates The position defining the point.
	     */
	    function Point(coordinates) {
	        /**
	         * A GeoJSON type descriptor with value "Point".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Point";
	        this.type = Point.TYPE;
	        this.coordinates = coordinates;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Point class to be used in runtime comparisons.
	     */
	    Point.TYPE = "Point";
	    return Point;
	}());

	var __read$a = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __values$i = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	//////////////////////
	/// Constants
	//////////////////////
	/**
	 * Earth Radius Semi Major Axis in meters
	 */
	var EARTH_RADIUS_SEMI_MAJOR_AXIS = 6378137;
	/**
	 * A constant for Math.PI/180. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var PI_BY_180 = Math.PI / 180;
	/**
	 * A constant for 180 / Math.PI. Using this constant is upto 3 times faster than always doing the calculation.
	 */
	var INV_PI_BY_180 = 180 / Math.PI;
	/**
	 * Cached array of powers of 10. This will be faster than call Math.pow.
	 */
	var POWERS_OF_10 = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
	/**
	 * Maximum latitude as defined in WebMercator
	 */
	var WEBMERCATOR_MAXLAT = 85.0511;
	//////////////////////
	/// Private Functions
	//////////////////////
	/**
	 * Converts an angle that is in degrees to radians. Angle * (PI / 180).
	 * @param angle An angle in degrees.
	 * @returns An angle in radians.
	 */
	function _toRadians(angle) {
	    return angle * PI_BY_180;
	}
	/**
	 * Converts an angle that is in radians to degrees. Angle * (180 / PI).
	 * @param angle An angle in radians.
	 * @returns An angle in degrees.
	 */
	function _toDegrees(angle) {
	    return angle * INV_PI_BY_180;
	}
	/**
	 * Clips a number to the specified minimum and maximum values.
	 * @param val The number to clip.
	 * @param minValue Minimum allowable value.
	 * @param maxValue Maximum allowable value.
	 * @returns The clipped value.
	 */
	function _clip(val, minValue, maxValue) {
	    return Math.min(Math.max(val, minValue), maxValue);
	}
	/**
	 * Calculates geodetic distance between two Position objects using Haversine formula in meters.
	 * @param origin Position to calculate distance from.
	 * @param destination Position to calculate distance to.
	 * @returns A distance in meters between the two positions.
	 */
	function _haversineDistance(origin, destination) {
	    // https://en.wikipedia.org/wiki/Haversine_formula
	    var dLat = _toRadians(destination[1] - origin[1]);
	    var dLon = _toRadians(destination[0] - origin[0]);
	    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(_toRadians(origin[1])) * Math.cos(_toRadians(destination[1])) * Math.pow(Math.sin(dLon / 2), 2);
	    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    return Math.round(EARTH_RADIUS_SEMI_MAJOR_AXIS * c * 100) / 100; // Round to 1cm precision.
	}
	/**
	 * Normalizes a distance unit string. Defaults to meters.
	 * @param units The distance units to normalize.
	 * @returns A normalized distance unit string.
	 */
	function _normalizeDistanceUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feet":
	            case "foot":
	            case "ft":
	                return DistanceUnits.feet;
	            case "kilometers":
	            case "kilometer":
	            case "kilometres":
	            case "kilometre":
	            case "km":
	            case "kms":
	                return DistanceUnits.kilometers;
	            case "miles":
	            case "mile":
	            case "mi":
	                return DistanceUnits.miles;
	            case "nauticalmiles":
	            case "nauticalmile":
	            case "nms":
	            case "nm":
	                return DistanceUnits.nauticalMiles;
	            case "yards":
	            case "yard":
	            case "yds":
	            case "yrd":
	            case "yrds":
	                return DistanceUnits.yards;
	            case "meters":
	            case "metres":
	            case "m":
	            default:
	                return DistanceUnits.meters;
	        }
	    }
	    return DistanceUnits.meters;
	}
	/**
	 * Normailzes a acceleration unit string. Defaults to metersPerSecondSquared.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param units The acceleration units to normalize.
	 * @returns A normailzed acceleration unit string.
	 */
	function _normalizeAccelerationUnit(units) {
	    // Convert to metersPerSecondSquared
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milespersecondsquared": // mi/s^2
	            case "milepersecondsquared":
	            case "mi/s^2":
	            case "mi/s2":
	                return AccelerationUnits.milesPerSecondSquared;
	            case "kilometerspersecondsquared": // km/s^2
	            case "kilometrespersecondsquared":
	            case "kilometerpersecondsquared":
	            case "kilometrepersecondsquared":
	            case "km/s^2":
	            case "km/s2":
	                return AccelerationUnits.kilometersPerSecondSquared;
	            case "knotspersecond": // knts/s
	            case "knotpersecond":
	            case "knts/s":
	            case "kn/s":
	            case "kt/s":
	                return AccelerationUnits.knotsPerSecond;
	            case "standardgravity": // g
	            case "g":
	                return AccelerationUnits.standardGravity;
	            case "feetpersecondsquared": // ft/s^2
	            case "footpersecondsquared":
	            case "ft/s^2":
	            case "ft/s2":
	                return AccelerationUnits.feetPerSecondSquared;
	            case "yardspersecondsquared": // yds/s^2
	            case "yardpersecondsquared":
	            case "yds/s^2":
	            case "yds/s2":
	            case "yd/s^2":
	            case "yd/s2":
	                return AccelerationUnits.yardsPerSecondSquared;
	            case "milesperhoursecond": // mi/h/s
	            case "mileperhoursecond":
	            case "milesperhourseconds":
	            case "mileperhourseconds":
	            case "mi/h/s":
	                return AccelerationUnits.milesPerHourSecond;
	            case "kilometersperhoursecond": // km/h/s
	            case "kilometrespersoursecond":
	            case "kilometerperhoursecond":
	            case "kilometrepersoursecond":
	            case "kilometersperhourssecond":
	            case "kilometrespersourssecond":
	            case "kilometerperhourssecond":
	            case "kilometrepersourssecond":
	            case "kmhs":
	            case "km/h/s":
	                return AccelerationUnits.kilometersPerHourSecond;
	            case "meterspersecondsquared": // m/s^2
	            case "metrespersecondsquared":
	            case "meterpersecondsquared":
	            case "metrepersecondsquared":
	            case "m/s^2":
	            case "m/s2":
	            default:
	                return AccelerationUnits.metersPerSecondSquared;
	        }
	    }
	    return AccelerationUnits.metersPerSecondSquared;
	}
	/**
	 * Normailzes an area unit string. Defaults to squareMeters.
	 * @param units The area units to normalize.
	 * @returns A normailzed area unit string.
	 */
	function _normalizeAreaUnits(units) {
	    if (units) {
	        switch (units) {
	            case "acres":
	            case "ac":
	                return AreaUnits.acres;
	            case "hectares":
	            case "ha":
	                return AreaUnits.hectares;
	            case "squareFeet":
	            case "ft^2":
	            case "ft2":
	                return AreaUnits.squareFeet;
	            case "squareYards":
	            case "squareYard":
	            case "yds^2":
	            case "yds2":
	            case "yd^2":
	            case "yd2":
	                return AreaUnits.squareYards;
	            case "squareKilometers":
	            case "squareKilometres":
	            case "squareKilometer":
	            case "squareKilometre":
	            case "km^2":
	            case "km2":
	                return AreaUnits.squareKilometers;
	            case "squareMiles":
	            case "squareMile":
	            case "mi^2":
	            case "mi2":
	                return AreaUnits.squareMiles;
	            case "squareMeters":
	            case "squareMetres":
	            case "squareMeter":
	            case "squareMetre":
	            case "m^2":
	            case "m2":
	            default:
	                return AreaUnits.squareMeters;
	        }
	    }
	    return AreaUnits.squareMeters;
	}
	/**
	 * Normailzes a speed unit string. Defaults to metersPerSecond.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param units The speed units to normalize.
	 * @returns A normailzed speed unit string.
	 */
	function _normalizeSpeedUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "feetpersecond":
	            case "footsecond":
	            case "ftps":
	            case "ft/s":
	                return SpeedUnits.feetPerSecond;
	            case "milesperhour":
	            case "mileperhour":
	            case "mph":
	            case "mi/hr":
	            case "mi/h":
	                return SpeedUnits.milesPerHour;
	            case "knots":
	            case "knot":
	            case "knts":
	            case "knt":
	            case "kn":
	            case "kt":
	                return SpeedUnits.knots;
	            case "mach":
	            case "m":
	                return SpeedUnits.mach;
	            case "kilometersperhour":
	            case "kilometresperhour":
	            case "kmperhour":
	            case "kmph":
	            case "km/hr":
	            case "km/h":
	                return SpeedUnits.kilometersPerHour;
	            case "meterspersecond":
	            case "metrespersecond":
	            case "mps":
	            case "ms":
	            case "m/s":
	            default:
	                return SpeedUnits.metersPerSecond;
	        }
	    }
	    return SpeedUnits.metersPerSecond;
	}
	/**
	 * Normailzes a time unit string. Defaults to seconds.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param units The time units to normalize.
	 * @returns A normailzed time unit string.
	 */
	function _normalizeTimeUnit(units) {
	    if (units) {
	        switch (units.toLowerCase()) {
	            case "milliseconds":
	            case "ms":
	                return TimeUnits.ms;
	            case "minutes":
	            case "minute":
	            case "mins":
	            case "min":
	                return TimeUnits.minutes;
	            case "hours":
	            case "hour":
	            case "hr":
	            case "h":
	                return TimeUnits.hours;
	            case "days":
	            case "day":
	            case "d":
	                return TimeUnits.days;
	            case "seconds":
	            case "second":
	            case "secs":
	            case "sec":
	            case "s":
	            default:
	                return TimeUnits.seconds;
	        }
	    }
	    return TimeUnits.seconds;
	}
	/**
	 * Calculates the area of a polygon in square meters.
	 * @param coordinates The coordinates of the polygon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @returns The area of a polygon in square meters.
	 */
	function _calculatePolygonArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates && coordinates.length > 0) {
	        // Calculate the area of the outer/exterior ring of the polygon.
	        area = Math.abs(_calculatePolygonRingArea(coordinates[0]));
	        // Subtract the area of the holes of the polygon.
	        for (var i = 1, len = coordinates.length; i < len; i++) {
	            area -= Math.abs(_calculatePolygonRingArea(coordinates[i]));
	        }
	    }
	    return area;
	}
	/**
	 * Calculates the area of a polygon ring  in square meters.
	 * The area value will be positive if the coordinates in the ring are ordered clockwise,
	 * and negative if ordered counter-clockwise.
	 * @param coordinates The coordinates of the polygon ring.
	 * @returns The area of the ring in square meters.
	 */
	function _calculatePolygonRingArea(coordinates) {
	    // Based on https://trs-new.jpl.nasa.gov/handle/2014/40409
	    var area = 0;
	    if (coordinates.length >= 3) {
	        var p1 = void 0;
	        var p2 = void 0;
	        var p3 = void 0;
	        for (var i = 0, len = coordinates.length; i < len; i++) {
	            // Create triangles from the coordinates.
	            if (i === len - 2) { // i = N-2
	                p1 = len - 2;
	                p2 = len - 1;
	                p3 = 0;
	            }
	            else if (i === len - 1) { // i = N-1
	                p1 = len - 1;
	                p2 = 0;
	                p3 = 1;
	            }
	            else { // i = 0 to N-3
	                p1 = i;
	                p2 = i + 1;
	                p3 = i + 2;
	            }
	            area += (_toRadians(coordinates[p3][0]) - _toRadians(coordinates[p1][0])) * Math.sin(_toRadians(coordinates[p2][1]));
	        }
	        area = area * EARTH_RADIUS_SEMI_MAJOR_AXIS * EARTH_RADIUS_SEMI_MAJOR_AXIS / 2;
	    }
	    return area;
	}
	/**
	 * 2D cross product of OA and OB vectors, i.e. z-component of their 3D cross product.
	 * Returns a positive value, if OAB makes a counter-clockwise turn,
	 * negative for clockwise turn, and zero if the points are collinear.
	 * @param a Position A
	 * @param b Position B
	 * @param o Position O
	 * @returns The 2D cross product of OA and OB vectors.
	 */
	function _cross(a, b, o) {
	    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
	}
	/**
	 * Takes an array of positions that form a path and calculates the closest point on the path to a specified position.
	 * @param pos The position to find the closest point to.
	 * @param px The pixel value of the position at zoom level 22.
	 * @param path An array of positions that form a path.
	 * @returns The closest point on the path to the specified position.
	 */
	function _closestPointOnPath(pos, px, path) {
	    // Need atleast two points
	    if (path.length >= 2) {
	        var minDis = Infinity;
	        var d = void 0;
	        var closest = null;
	        // Convert path to pixels.
	        var pixels = mercatorPositionsToPixels(path, 22);
	        var cPx = void 0;
	        for (var i = 0, len = pixels.length - 1; i < len; i++) {
	            cPx = _closestPixelOnLineSegment(px, pixels[i], pixels[i + 1]);
	            d = Pixel.getDistance(px, cPx);
	            if (d < minDis) {
	                minDis = d;
	                closest = cPx;
	            }
	        }
	        if (closest) {
	            var cPos = mercatorPixelsToPositions([closest], 22)[0];
	            return new Feature(new Point(cPos), {
	                distance: getDistanceTo(pos, cPos)
	            });
	        }
	    }
	    else if (path.length === 1) {
	        return new Feature(new Point(path[0]), {
	            distance: getDistanceTo(pos, path[0])
	        });
	    }
	    return null;
	}
	/**
	 * Calculates the closest pixel on a line segment from a given point in 2D space.
	 * @param px The pixel near the line that we are working with.
	 * @param sPx Start pixel of the line segment.
	 * @param ePx End pixel of the line segment.
	 * @returns The closest pixel on the line segement to the specified pixel.
	 */
	function _closestPixelOnLineSegment(px, sPx, ePx) {
	    // If start and end points of line are equal, then that is the closest point.
	    if (sPx[0] === ePx[0] && sPx[1] === ePx[1]) {
	        return sPx;
	    }
	    var APx = px[0] - sPx[0];
	    var APy = px[1] - sPx[1];
	    var ABx = ePx[0] - sPx[0];
	    var ABy = ePx[1] - sPx[1];
	    var magAB2 = ABx * ABx + ABy * ABy;
	    var ABdotAP = ABx * APx + ABy * APy;
	    var t = ABdotAP / magAB2;
	    if (t < 0) {
	        return sPx;
	    }
	    else if (t > 1) {
	        return ePx;
	    }
	    else {
	        return [sPx[0] + ABx * t, sPx[1] + ABy * t];
	    }
	}
	//////////////////////
	/// Internal Functions
	//////////////////////
	/**
	 * Round a number to the specified number of decimal places.
	 * @param val The value to round.
	 * @param decimals The number of decimals.
	 * @returns A number rounded to the specified number of decimal places.
	 * @internal
	 */
	function _precision(val, decimals) {
	    if (!isNaN(val) && typeof decimals === "number" && decimals >= 0) {
	        var power = void 0;
	        if (decimals < POWERS_OF_10.length) {
	            power = POWERS_OF_10[decimals];
	        }
	        else {
	            power = Math.pow(10, decimals);
	        }
	        val = Math.round(val * power) / power;
	    }
	    return val;
	}
	//////////////////////
	/// Public Enums
	//////////////////////
	/**
	 * Units of measurement for areas.
	 */
	var AreaUnits;
	(function (AreaUnits) {
	    /**
	     * Represents areas in square meters (m^2).
	     * Literal value `""`
	     */
	    AreaUnits["squareMeters"] = "squareMeters";
	    /**
	     * Represents areas in acres (ac).
	     * Literal value `"acres"`
	     */
	    AreaUnits["acres"] = "acres";
	    /**
	     * Represents areas in hectares (ha).
	     * Literal value `"hectares"`
	     */
	    AreaUnits["hectares"] = "hectares";
	    /**
	     * Represents areas in feet (ft^2).
	     * Literal value `"squareFeet"`
	     */
	    AreaUnits["squareFeet"] = "squareFeet";
	    /**
	     * Represents areas in square kilometers (km^2).
	     * Literal value `"squareKilometers"`
	     */
	    AreaUnits["squareKilometers"] = "squareKilometers";
	    /**
	     * Represents areas in miles (mi^2).
	     * Literal value `"squareMiles"`
	     */
	    AreaUnits["squareMiles"] = "squareMiles";
	    /**
	     * Represents areas in yards (yds^2).
	     * Literal value `"squareYards"`
	     */
	    AreaUnits["squareYards"] = "squareYards";
	})(AreaUnits || (AreaUnits = {}));
	/**
	 * Units of measurement for distances.
	 */
	var DistanceUnits;
	(function (DistanceUnits) {
	    /**
	     * Represents a distance in meters (m).
	     * Literal value `"meters"`
	     */
	    DistanceUnits["meters"] = "meters";
	    /**
	     * Represents a distance in kilometers (km).
	     * Literal value `"kilometers"`
	     */
	    DistanceUnits["kilometers"] = "kilometers";
	    /**
	     * Represents a distance in feet (ft).
	     * Literal value `"feet"`
	     */
	    DistanceUnits["feet"] = "feet";
	    /**
	     * Represents a distance in miles (mi).
	     * Literal value `"miles"`
	     */
	    DistanceUnits["miles"] = "miles";
	    /**
	     * Represents a distance in nautical miles.
	     * Literal value `"nauticalMiles"`
	     */
	    DistanceUnits["nauticalMiles"] = "nauticalMiles";
	    /**
	     * Represents a distance in yards (yds).
	     * Literal value `"yards"`
	     */
	    DistanceUnits["yards"] = "yards";
	})(DistanceUnits || (DistanceUnits = {}));
	/**
	 * Units of measurement for time.
	 */
	var TimeUnits;
	(function (TimeUnits) {
	    /**
	     * Represents a time in seconds (s).
	     * Literal value `"seconds"`
	     */
	    TimeUnits["seconds"] = "seconds";
	    /**
	     * Represents a time in hours (hr).
	     * Literal value `"hours"`
	     */
	    TimeUnits["hours"] = "hours";
	    /**
	     * Represents a time in milliseconds (ms).
	     * Literal value `"ms"`
	     */
	    TimeUnits["ms"] = "ms";
	    /**
	     * Represents a time in minutes (min).
	     * Literal value `"minutes"`
	     */
	    TimeUnits["minutes"] = "minutes";
	    /**
	     * Represents a time in days (d).
	     * Literal value `"days"`
	     */
	    TimeUnits["days"] = "days";
	})(TimeUnits || (TimeUnits = {}));
	/**
	 * Units of measurement for speed.
	 */
	var SpeedUnits;
	(function (SpeedUnits) {
	    /**
	     * Represents a speed in meters per second (m/s).
	     * Literal value `"metersPerSecond"`
	     */
	    SpeedUnits["metersPerSecond"] = "metersPerSecond";
	    /**
	     * Represents a speed in kilometers per hour (km/h).
	     * Literal value `"kilometersPerHour"`
	     */
	    SpeedUnits["kilometersPerHour"] = "kilometersPerHour";
	    /**
	     * Represents a speed in feet per second (ft/s).
	     * Literal value `"feetPerSecond"`
	     */
	    SpeedUnits["feetPerSecond"] = "feetPerSecond";
	    /**
	     * Represents a speed in miles per hour (mph).
	     * Literal value `"milesPerHour"`
	     */
	    SpeedUnits["milesPerHour"] = "milesPerHour";
	    /**
	     * Represents a speed in knots (knts).
	     * Literal value `"knots"`
	     */
	    SpeedUnits["knots"] = "knots";
	    /**
	     * Represents a speed in mach.
	     * Literal value `"mach"`
	     */
	    SpeedUnits["mach"] = "mach";
	})(SpeedUnits || (SpeedUnits = {}));
	/**
	 * Units of measurement for acceleration.
	 */
	var AccelerationUnits;
	(function (AccelerationUnits) {
	    /**
	     * Represents an acceleration in miles per second squared (mi/s^2).
	     * Literal value `"milesPerSecondSquared"`
	     */
	    AccelerationUnits["milesPerSecondSquared"] = "milesPerSecondSquared";
	    /**
	     * Represents an acceleration in kilometers per second squared (km/s^2).
	     * Literal value `"kilometersPerSecondSquared"`
	     */
	    AccelerationUnits["kilometersPerSecondSquared"] = "kilometersPerSecondSquared";
	    /**
	     * Represents an acceleration in knots per second (knts/s).
	     * Literal value `"knotsPerSecond"`
	     */
	    AccelerationUnits["knotsPerSecond"] = "knotsPerSecond";
	    /**
	     * Represents an acceleration in standard gravity units (g).
	     * Literal value `"standardGravity"`
	     */
	    AccelerationUnits["standardGravity"] = "standardGravity";
	    /**
	     * Represents an acceleration in feet per second squared (ft/s^2).
	     * Literal value `"feetPerSecondSquared"`
	     */
	    AccelerationUnits["feetPerSecondSquared"] = "feetPerSecondSquared";
	    /**
	     * Represents an acceleration in yards per second squared (yds/s^2).
	     * Literal value `"yardsPerSecondSquared"`
	     */
	    AccelerationUnits["yardsPerSecondSquared"] = "yardsPerSecondSquared";
	    /**
	     * Represents an acceleration in miles per hour second (mi/h/s).
	     * Literal value `"milesPerHourSecond"`
	     */
	    AccelerationUnits["milesPerHourSecond"] = "milesPerHourSecond";
	    /**
	     * Represents an acceleration in kilometers per hours second (km/h/s).
	     * Literal value `"kilometersPerHourSecond"`
	     */
	    AccelerationUnits["kilometersPerHourSecond"] = "kilometersPerHourSecond";
	    /**
	     * Represents an acceleration in meters per second squared (m/s^2).
	     * Literal value `"metersPerSecondSquared"`
	     */
	    AccelerationUnits["metersPerSecondSquared"] = "metersPerSecondSquared";
	})(AccelerationUnits || (AccelerationUnits = {}));
	//////////////////////
	/// Public Methods
	//////////////////////
	/**
	 * Takes a BoundingBox and converts it to a polygon.
	 * @param bounds The BoundingBox to convert to a Polygon.
	 * @returns A polygon representation of the BoundingBox.
	 */
	function boundingBoxToPolygon(bounds) {
	    var w = normalizeLongitude(BoundingBox.getWest(bounds));
	    var e = normalizeLongitude(BoundingBox.getEast(bounds));
	    var n = normalizeLatitude(BoundingBox.getNorth(bounds));
	    var s = normalizeLatitude(BoundingBox.getSouth(bounds));
	    var center = BoundingBox.getCenter(bounds);
	    var pos = [
	        [w, n],
	        [w, s],
	        [center[0], s],
	        [e, s],
	        [e, n],
	        [center[0], n],
	        [w, n]
	    ];
	    return new Polygon([pos]);
	}
	/**
	 * Converts a distance from one distance units to another. Supported units: miles, nauticalMiles, yards, meters, kilometers, feet
	 * @param distance A number that represents a distance to convert.
	 * @param fromUnits The distance units the original distance is in.
	 * @param toUnits The desired distance units to convert to.
	 * @param decimals Specifies the number of decimal places to round the result to. If undefined, no rounding will occur.
	 * @returns A distance in the new units.
	 */
	function convertDistance(distance, fromUnits, toUnits, decimals) {
	    // Convert the distance to kilometers
	    switch (_normalizeDistanceUnit(fromUnits)) {
	        case DistanceUnits.meters:
	            distance /= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance /= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance /= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance /= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance /= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    // Convert from kilometers to output distance unit
	    switch (_normalizeDistanceUnit(toUnits)) {
	        case DistanceUnits.meters:
	            distance *= 1000;
	            break;
	        case DistanceUnits.feet:
	            distance *= 3280.8399;
	            break;
	        case DistanceUnits.miles:
	            distance *= 0.62137119;
	            break;
	        case DistanceUnits.yards:
	            distance *= 1093.6133;
	            break;
	        case DistanceUnits.nauticalMiles:
	            distance *= 0.5399568;
	            break;
	        case DistanceUnits.kilometers:
	            break;
	    }
	    if (typeof decimals === "number" && decimals >= 0) {
	        var power = Math.pow(10, decimals);
	        distance = Math.round(distance * power) / power;
	    }
	    return distance;
	}
	/**
	 * Calculates an array of positions that form a cardinal spline between the specified array of positions.
	 * @param positions The array of positions to calculate the spline through.
	 * @param tension A number that indicates the tightness of the curve. Can be any number, although a value between 0 and 1 is usually used. Default: 0.5
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @param close A boolean indicating if the spline should be a closed ring or not. Default: false
	 * @returns An array of positions that form a cardinal spline between the specified array of positions.
	 */
	function getCardinalSpline(positions, tension, nodeSize, close) {
	    // Resources:
	    // http://www.cubic.org/docs/hermite.htm
	    // http://codeplea.com/introduction-to-splines
	    // https://msdn.microsoft.com/en-us/library/windows/desktop/ms536358(v=vs.85).aspx
	    var locs;
	    if (!positions || positions.length <= 2) {
	        return locs;
	    }
	    if (typeof tension !== "number") {
	        tension = 0.5;
	    }
	    if (typeof nodeSize !== "number" || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    // Get the number of locations the spline passs through.
	    var len = positions.length;
	    // Create a copy of the array of locations so that we don't alter the original array.
	    locs = positions.slice(0);
	    // Add additional locations to array so that tangents can be calculated for end points.
	    if (close) {
	        // If the location array forms a closed ring, remove the last location.
	        if (Position.areEqual(locs[0], locs[len - 1])) {
	            locs.pop();
	            len--;
	        }
	        // Insert the last coordinate as the first point.
	        locs.unshift(positions[len - 1]);
	        // Add the first two points to the end of the array.
	        locs.push(positions[0]);
	        locs.push(positions[1]);
	        // Increase index so that spline wraps back around to starting location.
	        len++;
	    }
	    else {
	        // In this case the spline is not closed, so tanget of end points will be 0.
	        // Buffer the end-points so that tanget calculations can be performed.
	        locs.unshift(positions[0]);
	        locs.push(positions[len - 1]);
	    }
	    // Precalculate the hermite basis function steps along the spline.
	    var hermiteSteps = [];
	    // Force the first step between two locations to be the first location.
	    hermiteSteps.push([1, 0, 0, 0]);
	    var step;
	    var step2;
	    var step3;
	    // Calculate the steps along the spline between two locations.
	    for (var i = 1; i < nodeSize - 1; i++) {
	        step = i / nodeSize; // Scale step to go from 0 to 1.
	        step2 = step * step; // s^2
	        step3 = step * step2; // s^3
	        hermiteSteps.push([
	            2 * step3 - 3 * step2 + 1,
	            -2 * step3 + 3 * step2,
	            step3 - 2 * step2 + step,
	            step3 - step2
	        ]); // Calculate hermite basis function 4.
	    }
	    // Force the last step between two locations to be the last location.
	    hermiteSteps.push([0, 1, 0, 0]);
	    var splineLocs = [];
	    var hermiteStep;
	    // Tangents
	    var t1x;
	    var t1y;
	    var t2x;
	    var t2y;
	    var lat;
	    var lon;
	    // Loop through and calculate the spline path between each location pair.
	    for (var i = 1; i < len; i++) {
	        t1x = tension * (locs[i + 1][0] - locs[i - 1][0]);
	        t1y = tension * (locs[i + 1][1] - locs[i - 1][1]);
	        t2x = tension * (locs[i + 2][0] - locs[i][0]);
	        t2y = tension * (locs[i + 2][1] - locs[i][1]);
	        for (step = 0; step < nodeSize; step++) {
	            hermiteStep = hermiteSteps[step];
	            lon = hermiteStep[0] * locs[i][0] + hermiteStep[1] * locs[i + 1][0] + hermiteStep[2] * t1x + hermiteStep[3] * t2x;
	            lat = hermiteStep[0] * locs[i][1] + hermiteStep[1] * locs[i + 1][1] + hermiteStep[2] * t1y + hermiteStep[3] * t2y;
	            lat = _clip(lat, -85, 85);
	            splineLocs.push([lon, lat]);
	        }
	    }
	    return splineLocs;
	}
	/**
	 * Calculates a destination position based on a starting position, a heading, a distance, and a distance unit type.
	 * @param origin Position that the destination is relative to.
	 * @param heading A heading angle between 0 - 360 degrees. 0 - North, 90 - East, 180 - South, 270 - West.
	 * @param distance Distance that destination is away.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position that is the specified distance away from the origin.
	 */
	function getDestination(origin, heading, distance, units) {
	    units = units || "meters";
	    origin = getPosition(origin);
	    var radius = getEarthRadius(units);
	    // convert latitude, longitude and heading into radians
	    var latRad = _toRadians(origin[1]);
	    var lonRad = _toRadians(origin[0]);
	    var headingRad = _toRadians(heading);
	    var centralAngle = distance / radius;
	    var desLatRad = Math.asin(Math.sin(latRad) * Math.cos(centralAngle) + Math.cos(latRad) * Math.sin(centralAngle) * Math.cos(headingRad));
	    var desLonRad = lonRad + Math.atan2(Math.sin(headingRad) * Math.sin(centralAngle) * Math.cos(latRad), Math.cos(centralAngle) - Math.sin(latRad) * Math.sin(desLatRad));
	    var lat = _clip(normalizeLatitude(_toDegrees(desLatRad)), -85, 85);
	    var lon = normalizeLongitude(_toDegrees(desLonRad));
	    return [lon, lat];
	}
	/**
	 * Calculate the distance between two position objects on the surface of the earth using the Haversine formula.
	 * @param origin First position to calculate distance between.
	 * @param destination Second position to calculate distance between.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns The shortest distance between two positions in the specified units.
	 */
	function getDistanceTo(origin, destination, units) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var d = _haversineDistance(origin, destination);
	    if (units === "meters") {
	        return d;
	    }
	    return convertDistance(d, "meters", units || "meters");
	}
	/**
	 * Retrieves the radius of the earth in a specific distance unit for WGS84.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns A number that represents the radius of the earth in a specific distance unit.
	 */
	function getEarthRadius(units) {
	    var normalUnit = _normalizeDistanceUnit(units);
	    return convertDistance(EARTH_RADIUS_SEMI_MAJOR_AXIS, DistanceUnits.meters, normalUnit);
	}
	/**
	 * constructs raw geodesic path that doesn't handle antimeridian crossing
	 */
	function _constructGeodesic(position, nextPosition, nodeSize) {
	    var geodesic = [];
	    // Convert positions from degrees to Radians
	    var lat1 = _toRadians(position[1]);
	    var lon1 = _toRadians(position[0]);
	    var lat2 = _toRadians(nextPosition[1]);
	    var lon2 = _toRadians(nextPosition[0]);
	    // Calculate the total extent of the route
	    var d = 2 * Math.asin(Math.sqrt(Math.pow((Math.sin((lat1 - lat2) / 2)), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow((Math.sin((lon1 - lon2) / 2)), 2)));
	    // Calculate positions at fixed intervals along the route
	    for (var k = 0; k <= nodeSize; k++) {
	        var f = (k / nodeSize);
	        var A = Math.sin((1 - f) * d) / Math.sin(d);
	        var B = Math.sin(f * d) / Math.sin(d);
	        // Obtain 3D Cartesian coordinates of each point
	        var x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
	        var y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
	        var z = A * Math.sin(lat1) + B * Math.sin(lat2);
	        // Convert these to latitude/longitude
	        var lat = Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
	        var lon = Math.atan2(y, x);
	        lat = _clip(_toDegrees(lat), -85, 85);
	        lon = _toDegrees(lon);
	        // Add this to the array
	        geodesic.push([lon, lat]);
	    }
	    return geodesic;
	}
	/**
	 * Denormalizes path on antimeridian, this makes lines with coordinates on the opposite side of the antimeridian to always cross it. Note that the path crossing antimeridian will contain longitude outside of -180 to 180 range.
	 * See getPathSplitByAntimeridian when this is not desired.
	 * @param path Array of position objects or linestring to denormalize
	 * @returns A denormalized array of position objects, path crossing antimeridian will contain longitude outside of -180 to 180 range.
	 */
	function getPathDenormalizedAtAntimerian(path) {
	    var coords = Array.isArray(path) ? path : path.coordinates;
	    return coords.reduce(function (targetPath, coord) {
	        var last = targetPath.length > 0 ? targetPath[targetPath.length - 1] : null;
	        // denormalize longitude on antimeridian crossing
	        if (last && Math.abs(coord[0] - last[0]) > 180.0) {
	            var denormLon = last[0] < 0 ? coord[0] - 360.0 : coord[0] + 360.0;
	            targetPath.push([denormLon, coord[1]]);
	        }
	        else {
	            targetPath.push(coord);
	        }
	        return targetPath;
	    }, []);
	}
	/**
	 * Split path on antimeridian into multiple paths.
	 * See getPathDenormalizedAtAntimerian when this is not desired.
	 * @param path Array of position objects or linestring to split
	 * @returns A path split into multiple paths by antimeridian.
	 */
	function getPathSplitByAntimeridian(path) {
	    var coords = Array.isArray(path) ? path : path.coordinates;
	    var currentNonCrossing = [];
	    var outputPaths = [];
	    for (var k = 0; k < coords.length; k++) {
	        currentNonCrossing.push(coords[k]);
	        if (k + 1 >= coords.length) {
	            continue;
	        }
	        var _a = __read$a(coords[k], 2), lon1 = _a[0], lat1 = _a[1];
	        var _b = __read$a(coords[k + 1], 2), lon2 = _b[0], lat2 = _b[1];
	        // split the line by antimeridian
	        // and break geodesic into two line segments
	        if (Math.abs(lon2 - lon1) > 180.0) {
	            var denormLon2 = lon1 > 0 ? lon2 + 360.0 : lon2 - 360.0;
	            var antiLon = lon1 > 0 ? 180.0 : -180.0;
	            var abs = Math.abs(denormLon2 - lon1);
	            var antiAbs = Math.abs(antiLon - lon1);
	            var f = antiAbs / abs;
	            var dLat = (lat2 - lat1) * f;
	            var antiLat = lat1 + dLat;
	            currentNonCrossing.push([antiLon, antiLat]);
	            outputPaths.push(currentNonCrossing);
	            currentNonCrossing = [[-antiLon, antiLat]];
	        }
	    }
	    outputPaths.push(currentNonCrossing);
	    return outputPaths;
	}
	/**
	 * Takes an array of positions objects and fills in the space between them with accurately positioned positions to form an approximated Geodesic path.
	 * @param path Array of position objects that form a path to fill in.
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @returns An array of position objects that form a geodesic paths, geodesic path crossing antimeridian will contain longitude outside of -180 to 180 range. See getGeodesicPaths() when this is undesired.
	 */
	function getGeodesicPath(path, nodeSize) {
	    if (!nodeSize || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    var len = locs.length - 1;
	    var geodesic = [];
	    for (var i = 0; i < len; i++) {
	        // Convert positions from degrees to Radians
	        geodesic = geodesic.concat(_constructGeodesic(locs[i], locs[i + 1], nodeSize));
	    }
	    return getPathDenormalizedAtAntimerian(geodesic);
	}
	/**
	 * Takes an array of positions objects and fills in the space between them with accurately positioned positions to form an approximated Geodesic path broken by antimeridian into multiple sub-paths.
	 * @param path Array of position objects that form a path to fill in.
	 * @param nodeSize Number of nodes to insert between each position. Default: 15
	 * @returns An array of paths that form geodesic paths, Comparing to getGeodesicPath, sub-paths will always contain longitude in -180 to 180 range
	 */
	function getGeodesicPaths(path, nodeSize) {
	    if (!nodeSize || nodeSize <= 0) {
	        nodeSize = 15;
	    }
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    var len = locs.length - 1;
	    var currentNonCrossing = [];
	    var outputLocs = [];
	    for (var i = 0; i < len; i++) {
	        var geodesic = _constructGeodesic(locs[i], locs[i + 1], nodeSize);
	        for (var k = 0; k < geodesic.length; k++) {
	            currentNonCrossing.push(geodesic[k]);
	            if (k + 1 >= geodesic.length) {
	                continue;
	            }
	            var _a = __read$a(geodesic[k], 2), lon1 = _a[0], lat1 = _a[1];
	            var _b = __read$a(geodesic[k + 1], 2), lon2 = _b[0], lat2 = _b[1];
	            // split the line by antimeridian
	            // and break geodesic into two line segments
	            if (Math.abs(lon2 - lon1) > 180.0) {
	                var denormLon2 = lon1 > 0 ? lon2 + 360.0 : lon2 - 360.0;
	                var antiLon = lon1 > 0 ? 180.0 : -180.0;
	                var abs = Math.abs(denormLon2 - lon1);
	                var antiAbs = Math.abs(antiLon - lon1);
	                var f = antiAbs / abs;
	                var dLat = (lat2 - lat1) * f;
	                var antiLat = lat1 + dLat;
	                currentNonCrossing.push([antiLon, antiLat]);
	                outputLocs.push(currentNonCrossing);
	                currentNonCrossing = [[-antiLon, antiLat]];
	            }
	        }
	    }
	    outputLocs.push(currentNonCrossing);
	    return outputLocs;
	}
	/**
	 * Calculates the heading from one position object to another.
	 * @param origin Point of origin.
	 * @param destination Destination to calculate relative heading to.
	 * @returns A heading in degrees between 0 and 360. 0 degrees points due North.
	 */
	function getHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    if (origin && origin.length >= 2 && destination && destination.length >= 2) {
	        var radianLat1 = _toRadians(origin[1]);
	        var radianLat2 = _toRadians(destination[1]);
	        var dLon = _toRadians(destination[0] - origin[0]);
	        var dy = Math.sin(dLon) * Math.cos(radianLat2);
	        var dx = Math.cos(radianLat1) * Math.sin(radianLat2) - Math.sin(radianLat1) * Math.cos(radianLat2) * Math.cos(dLon);
	        return (_toDegrees(Math.atan2(dy, dx)) + 360) % 360;
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance between all position objects in an array.
	 * @param path The array of position objects that make up the path to calculate the length of.
	 * @param units Unit of distance measurement. Default: meters
	 * @returns The distance between all positions in between all position objects in an array on the surface of a earth in the specified units.
	 */
	function getLengthOfPath(path, units) {
	    var totalLength = 0;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    for (var i = 0, len = locs.length - 1; i < len; i++) {
	        totalLength += _haversineDistance(locs[i], locs[i + 1]);
	    }
	    return convertDistance(totalLength, "meters", units || "meters");
	}
	/**
	 * Calculates the position object on a path that is a specified distance away from the start of the path. If the specified distance is longer
	 * than the length of the path, the last position of the path will be returned.
	 * @param path A polyline or array of position coordinates that form a path.
	 * @param distance The distance along the path (from the start) to calculate the position for.
	 * @param units Unit of distance measurement. Default is meters.
	 * @returns A position object that is the specified distance away from the start of the path when following the path.
	 */
	function getPositionAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                return getDestination(locs[i - 1], heading, distance - travelled, units);
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return locs[len - 1];
	        }
	        return locs[0];
	    }
	    return null;
	}
	/**
	 * constructs raw regular polygon path that doesn't handle antimeridian crossing
	 */
	function _constructRegularPolygonPath(origin, radius, numberOfPositions, units, offset) {
	    units = units || "meters";
	    offset = (offset) ? offset : 0;
	    origin = getPosition(origin);
	    var points = [];
	    var centralAngle = 360 / numberOfPositions;
	    for (var i = 0; i <= numberOfPositions; i++) {
	        points.push(getDestination(origin, (i * centralAngle + offset) % 360, radius, units));
	    }
	    return points;
	}
	/**
	 * Calculates an array of position objects that are an equal distance away from a central point to create a regular polygon.
	 * @param origin Center of the regular polygon.
	 * @param radius Radius of the regular polygon.
	 * @param numberOfPositions Number of positions the polygon should have.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param offset An offset to rotate the polygon. When 0 the first position will align with North.
	 * @returns An array of position objects that form a regular polygon. Path crossing antimeridian will contain longitude outside of -180 to 180 range. See getRegularPolygonPaths() when this is undesired.
	 */
	function getRegularPolygonPath(origin, radius, numberOfPositions, units, offset) {
	    return getPathDenormalizedAtAntimerian(_constructRegularPolygonPath(origin, radius, numberOfPositions, units, offset));
	}
	/**
	 * Calculates an array of position objects that are an equal distance away from a central point to create a regular polygon broken by antimeridian into multiple sub-paths.
	 * @param origin Center of the regular polygon.
	 * @param radius Radius of the regular polygon.
	 * @param numberOfPositions Number of positions the polygon should have.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param offset An offset to rotate the polygon. When 0 the first position will align with North.
	 * @returns An array of paths that form a regular polygon. Comparing to getRegularPolygonPath, sub-paths will always contain longitude in -180 to 180 range
	 */
	function getRegularPolygonPaths(origin, radius, numberOfPositions, units, offset) {
	    return getPathSplitByAntimeridian(_constructRegularPolygonPath(origin, radius, numberOfPositions, units, offset));
	}
	/**
	 * Calculates a position object that is a fractional distance between two position objects.
	 * @param origin First position to calculate mid-point between.
	 * @param destination Second position to calculate mid-point between.
	 * @param fraction The fractional parameter to calculate a mid-point for. Default 0.5.
	 * @returns A position that lies a fraction of the distance between two position objects, relative to the first position object.
	 */
	function interpolate(origin, destination, fraction) {
	    fraction = (typeof fraction === "undefined") ? 0.5 : fraction;
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var arcLength = getDistanceTo(origin, destination, "kilometers");
	    var brng = getHeading(origin, destination);
	    return getDestination(origin, brng, arcLength * fraction, "kilometers");
	}
	/**
	 * Normalizes a latitude value between -90 and 90 degrees.
	 * @param lat The latitude value to normalize.
	 */
	function normalizeLatitude(lat) {
	    if (lat > 90) {
	        lat = (lat + 90) % 360;
	        return lat > 180 ? 90 - (lat - 180) : lat - 90;
	    }
	    else if (lat < -90) {
	        lat = (lat - 90) % 360;
	        return lat < -180 ? -90 - (lat + 180) : lat + 90;
	    }
	    else {
	        return lat;
	    }
	}
	/**
	 * Normalizes a longitude value between -180 and 180 degrees.
	 * @param lng The longitude value to normalize.
	 */
	function normalizeLongitude(lng) {
	    if (lng > 180) {
	        return ((lng + 180) % 360) - 180;
	    }
	    else if (lng < -180) {
	        return ((lng - 180) % 360) + 180;
	    }
	    else {
	        return lng;
	    }
	}
	/**
	 * Takes an array of positions and rotates them around a given position for the specified angle of rotation.
	 * @param positions An array of positions to be rotated.
	 * @param origin The position to rotate the positions around.
	 * @param angle The amount to rotate the array of positions in degrees clockwise.
	 */
	function rotatePositions(positions, origin, angle) {
	    if (angle === 0) {
	        // When the rotation is 0 the results can sometimes be odd if the coordinates are on the meridians.
	        return Object.assign({}, positions);
	    }
	    origin = getPosition(origin);
	    var rotatedPositions = [];
	    var distance;
	    var heading;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        distance = getDistanceTo(origin, positions[i]);
	        heading = getHeading(origin, positions[i]);
	        rotatedPositions.push(getDestination(origin, heading + angle, distance));
	    }
	    return rotatedPositions;
	}
	/**
	 * Calculates the pixel accurate heading from one position to another based on the Mercator map projection. This heading is visually accurate.
	 * @param origin
	 * @param destination
	 */
	function getPixelHeading(origin, destination) {
	    origin = getPosition(origin);
	    destination = getPosition(destination);
	    var _a = __read$a(mercatorPositionsToPixels([origin, destination], 21), 2), p1 = _a[0], p2 = _a[1];
	    var dx = (p2[0] - p1[0]);
	    var dy = (p1[1] - p2[1]);
	    var alpha = ((5 / 2 * Math.PI) - Math.atan2(dy, dx)) * INV_PI_BY_180 % 360;
	    return alpha;
	}
	/**
	 * Converts an array of global Mercator pixel coordinates into an array of geospatial positions at a specified zoom level.
	 * Global pixel coordinates are relative to the top left corner of the map [-180, 90].
	 * @param pixels Array of pixel coordinates.
	 * @param zoom Zoom level.
	 * @returns An array of positions.
	 */
	function mercatorPixelsToPositions(pixels, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var positions = [];
	    var x;
	    var y;
	    for (var i = 0, len = pixels.length; i < len; i++) {
	        x = (pixels[i][0] / mapSize) - 0.5;
	        y = 0.5 - (pixels[i][1] / mapSize);
	        positions.push([
	            360 * x,
	            90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI
	        ]);
	    }
	    return positions;
	}
	/**
	 * Converts an array of positions into an array of global Mercator pixel coordinates at a specified zoom level.
	 * @param positions Array of positions.
	 * @param zoom Zoom level.
	 * @returns Array of global Mercator pixels.
	 */
	function mercatorPositionsToPixels(positions, zoom) {
	    // 512 is our tile size in pixels.
	    var mapSize = 512 * Math.pow(2, zoom);
	    var pixels = [];
	    var x;
	    var y;
	    var sinLatitude;
	    for (var i = 0, len = positions.length; i < len; i++) {
	        sinLatitude = Math.sin(positions[i][1] * Math.PI / 180);
	        x = (positions[i][0] + 180) / 360;
	        y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
	        pixels.push([
	            Math.round(x * mapSize),
	            Math.round(y * mapSize)
	        ]);
	    }
	    return pixels;
	}
	/**
	 * Converts an acceleration value from one unit to another.
	 * Supported units:
	 *    milesPerSecondSquared, kilometersPerSecondSquared, metersPerSecondSquared, feetPerSecondSquared
	 *    yardsPerSecondSquared, kilometersPerHoursSecond, milesPerHourSecond, knotsPerSecond, standardGravity
	 * @param acceleration The acceleration value to convert.
	 * @param fromUnits The acceleration units the value is in.
	 * @param toUnits The acceleration units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration value convertered from one unit to another.
	 */
	function convertAcceleration(acceleration, fromUnits, toUnits, decimals) {
	    // Convert the speed to meters per second squared and then convert to the toUnits.
	    switch (_normalizeAccelerationUnit(fromUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration /= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration /= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration /= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration /= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration /= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration /= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration /= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration /= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	    }
	    // metersPerSecondSquared to toUnit.
	    switch (_normalizeAccelerationUnit(toUnits)) {
	        case AccelerationUnits.kilometersPerHourSecond:
	            acceleration *= 3.6;
	            break;
	        case AccelerationUnits.milesPerHourSecond:
	            acceleration *= 2.236936292054;
	            break;
	        case AccelerationUnits.knotsPerSecond:
	            acceleration *= 1.943844492441;
	            break;
	        case AccelerationUnits.standardGravity:
	            acceleration *= 0.1019716212978;
	            break;
	        case AccelerationUnits.kilometersPerSecondSquared:
	            acceleration *= 0.001;
	            break;
	        case AccelerationUnits.milesPerSecondSquared:
	            acceleration *= 0.000621371192;
	            break;
	        case AccelerationUnits.feetPerSecondSquared:
	            acceleration *= 3.280839895012;
	            break;
	        case AccelerationUnits.yardsPerSecondSquared:
	            acceleration *= 1.093613298338;
	            break;
	        case AccelerationUnits.metersPerSecondSquared:
	    }
	    return _precision(acceleration, decimals);
	}
	/**
	 * Converts an area value from one unit to another.
	 * Supported units: squareMeters, acres, hectares, squareFeet, squareYards, squareMiles, squareKilometers
	 * @param area The area value to convert.
	 * @param fromUnits The area units the value is in.
	 * @param toUnits The area units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An area value convertered from one unit to another.
	 */
	function convertArea(area, fromUnits, toUnits, decimals) {
	    switch (_normalizeAreaUnits(fromUnits)) {
	        case AreaUnits.acres:
	            area *= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area *= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area *= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area *= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area *= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area *= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	    }
	    switch (_normalizeAreaUnits(toUnits)) {
	        case AreaUnits.acres:
	            area /= 4046.8564224;
	            break;
	        case AreaUnits.hectares:
	            area /= 10000;
	            break;
	        case AreaUnits.squareFeet:
	            area /= 0.09290304;
	            break;
	        case AreaUnits.squareKilometers:
	            area /= 1000000;
	            break;
	        case AreaUnits.squareMiles:
	            area /= 2590000;
	            break;
	        case AreaUnits.squareYards:
	            area /= 0.83612736;
	            break;
	        case AreaUnits.squareMeters:
	    }
	    return _precision(area, decimals);
	}
	/**
	 * Converts a speed value from one unit to another.
	 * Supported units:
	 *    kilometersPerHour, milesPerHour, metersPerSecond, feetPerSecond, knots, mach
	 * @param speed The speed value to convert.
	 * @param fromUnits The speed units to convert from.
	 * @param toUnits The speed units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A speed value convertered from one unit to another.
	 */
	function convertSpeed(speed, fromUnits, toUnits, decimals) {
	    // Convert the speed to kilometers per hour and then convert to the toUnits.
	    switch (_normalizeSpeedUnit(fromUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed *= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed *= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed *= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed *= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed *= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	    }
	    // KMPH to toUnit.
	    switch (_normalizeSpeedUnit(toUnits)) {
	        case SpeedUnits.feetPerSecond:
	            speed /= 1.09728;
	            break;
	        case SpeedUnits.milesPerHour:
	            speed /= 1.6093;
	            break;
	        case SpeedUnits.knots:
	            speed /= 1.852;
	            break;
	        case SpeedUnits.metersPerSecond:
	            speed /= 3.6;
	            break;
	        case SpeedUnits.mach:
	            speed /= 1234.8;
	            break;
	        case SpeedUnits.kilometersPerHour:
	    }
	    return _precision(speed, decimals);
	}
	/**
	 * Converts a timespan value from one unit to another.
	 * Supported units:
	 *    ms (milliseconds), hours, minutes, seconds
	 * @param timespan The time value to convert.
	 * @param fromUnits The time units to convert from.
	 * @param toUnits The time units to convert to.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns A time value convertered from one unit to another.
	 */
	function convertTimespan(timespan, fromUnits, toUnits, decimals) {
	    // Convert the time to seconds as base units.
	    switch (_normalizeTimeUnit(fromUnits)) {
	        case TimeUnits.ms:
	            timespan /= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan *= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan *= 60;
	            break;
	        case TimeUnits.days:
	            timespan *= 86400;
	            break;
	        case TimeUnits.seconds:
	    }
	    // seconds to toUnit.
	    switch (_normalizeTimeUnit(toUnits)) {
	        case TimeUnits.ms:
	            timespan *= 1000;
	            break;
	        case TimeUnits.hours:
	            timespan /= 3600;
	            break;
	        case TimeUnits.minutes:
	            timespan /= 60;
	            break;
	        case TimeUnits.days:
	            timespan /= 86400;
	            break;
	        case TimeUnits.seconds:
	    }
	    return _precision(timespan, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, travel distance and timespan. Formula: a = 2*(d - v*t)/t^2
	 * @param initialSpeed The initial speed.
	 * @param distance The distance that has been travelled.
	 * @param timespan The timespan that was travelled.
	 * @param distanceUnits The units of the distance information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param speedUnits The units of the speed information. If not specified m/s are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, travel distance and timespan.
	 */
	function getAcceleration(initialSpeed, distance, timespan, speedUnits, distanceUnits, timeUnits, accelerationUnits, decimals) {
	    var d = convertDistance(distance, distanceUnits, DistanceUnits.meters);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    var v = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    return convertAcceleration(2 * (d - v * t) / (t * t), AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration based on an initial speed, final speed and timespan. Formula: a = 2* (v2 - v1)/t
	 * @param initialSpeed The initial speed.
	 * @param finalSpeed The final speed.
	 * @param timespan The timespan that was travelled.
	 * @param speedUnits The units of the speed information. If not specified meters are used.
	 * @param timeUnits The units of the timespan information. If not specified seconds are used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration based on an initial speed, final speed and timespan.
	 */
	function getAccelerationFromSpeeds(initialSpeed, finalSpeed, timespan, speedUnits, timeUnits, accelerationUnits, decimals) {
	    var v1 = convertSpeed(initialSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var v2 = convertSpeed(finalSpeed, speedUnits, SpeedUnits.metersPerSecond);
	    var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    return convertAcceleration((v2 - v1) / t, AccelerationUnits.metersPerSecondSquared, accelerationUnits, decimals);
	}
	/**
	 * Calculates an acceleration between two point features that have a timestamp property and optionally a speed property.
	 * if speeds are provided, ignore distance between points as the path may not have been straight and calculate: a = (v2 - v1)/(t2 - t1)
	 * if speeds not provided or only provided on first point, calculate straight line distance between points and calculate: a = 2*(d - v*t)/t^2
	 * @param origin The initial point in which the acceleration is calculated from.
	 * @param destination The final point in which the acceleration is calculated from.
	 * @param timestampProperty The name of the property on the features that contains the timestamp information.
	 * @param speedProperty The name of the property on the features that contains a speed information.
	 * @param speedUnits The units of the speed information. If not specified m/s is used.
	 * @param accelerationUnits The units to return the acceleration value in. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns An acceleration between two point features that have a timestamp property and optionally a speed property. Returns NaN if unable to parse timestamp.
	 */
	function getAccelerationFromFeatures(origin, destination, timestampProperty, speedProperty, speedUnits, accelerationUnits, decimals) {
	    if (typeof timestampProperty === "string" && origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            var v = 0;
	            if (speedProperty && typeof speedProperty === "string") {
	                var v1 = origin.properties[speedProperty];
	                var v2 = destination.properties[speedProperty];
	                if (typeof v1 === "number") {
	                    v = v1;
	                    if (typeof v2 === "number") {
	                        return getAccelerationFromSpeeds(v1, v2, timespan, speedUnits, TimeUnits.seconds, accelerationUnits, decimals);
	                    }
	                }
	            }
	            var d = getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return getAcceleration(v, d, timespan, speedUnits, DistanceUnits.meters, TimeUnits.seconds, accelerationUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the approximate area of a geometry in the specified units
	 * @param coordinates The coordinates of the polyon ring.
	 * The first ring is the outer/exterior ring and all other rings are the interior ring.
	 * @param areaUnits Unit of area measurement. Default is squareMeters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The area of a geometry in the specified units.
	 */
	function getArea(data, areaUnits, decimals) {
	    // https://github.com/Turfjs/turf/blob/master/packages/turf-area/index.ts#L68-L75
	    if (data) {
	        var area = 0;
	        data = data instanceof Shape ? data.toJson() : data;
	        switch (data.type) {
	            case "Feature":
	                var f = data;
	                if (f.geometry) {
	                    return getArea(f.geometry, areaUnits, decimals);
	                }
	                break;
	            case "Polygon":
	                var p = data;
	                if (p.coordinates) {
	                    area = _calculatePolygonArea(p.coordinates);
	                }
	                break;
	            case "MultiPolygon":
	                var mp = data;
	                if (mp.coordinates) {
	                    for (var i = 0, len = mp.coordinates.length; i < len; i++) {
	                        area += _calculatePolygonArea(mp.coordinates[i]);
	                    }
	                }
	                break;
	        }
	        return convertArea(area, AreaUnits.squareMeters, areaUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two points based on the provided amount of time.
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param time The time take to travel between the start and end points.
	 * @param timeUnits The units of the time value. If not specified seconds are used.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The average speed of travel between two points based on the provided amount of time.
	 */
	function getSpeed(origin, destination, timespan, timeUnits, speedUnits, decimals) {
	    var org = getPosition(origin);
	    var dest = getPosition(destination);
	    if (org && dest) {
	        // Convert the time value to seconds.
	        var t = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	        // Calculate the distance`between the points in meters.
	        var d = getDistanceTo(org, dest, DistanceUnits.meters);
	        // Calculate the speed and convert it into the requested units.
	        return convertSpeed(d / t, SpeedUnits.metersPerSecond, speedUnits, decimals);
	    }
	    return 0;
	}
	/**
	 * Calculates the average speed of travel between two point features that have a property containing a timestamp.
	 * The timestamp can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param origin The initial point in which the speed is calculated from.
	 * @param destination The final point in which the speed is calculated from.
	 * @param timestampProperty The name of the property on the features which has the timestamp information.
	 * @param speedUnits The units to return the speed value in. If not specified m/s are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The speed in the specified units or NaN if valid timestamps are not found.
	 */
	function getSpeedFromFeatures(origin, destination, timestampProperty, speedUnits, decimals) {
	    if (typeof timestampProperty === "string" &&
	        origin.type === "Feature" && origin.geometry.type === "Point" &&
	        destination.type === "Feature" && destination.geometry.type === "Point") {
	        var timespan = getTimespan(origin.properties[timestampProperty], destination.properties[timestampProperty], TimeUnits.seconds);
	        // Ensure that the start and end point features have the specified timeStamp
	        if (!isNaN(timespan)) {
	            // Calculate the distance`between the points in meters.
	            var d = getDistanceTo(origin.geometry.coordinates, destination.geometry.coordinates, DistanceUnits.meters);
	            return convertSpeed(d / timespan, SpeedUnits.metersPerSecond, speedUnits, decimals);
	        }
	    }
	    return NaN;
	}
	/**
	 * Calculates the timespan between two dates or timestamps.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param startTime The start date or time.
	 * @param endTime The end date or time.
	 * @param units The units to return the time value in. If not specified seconds are used.
	 * @returns A timespan between two dates or timestamps. Returns NaN if unable to parse timestamps.
	 */
	function getTimespan(startTime, endTime, units, decimals) {
	    var st = parseTimestamp(startTime);
	    var et = parseTimestamp(endTime);
	    // Ensure that the start and end point features have the specified timeStamp
	    if (st != null && et != null) {
	        // Calculate timespan between the time stamps in seconds.
	        return convertTimespan(et.getTime() - st.getTime(), TimeUnits.ms, units, decimals);
	    }
	    return NaN;
	}
	/**
	 * Calculates the distance traveled for a specified timespan, speed and optionally an acceleration.
	 * Formula: d = v*t + 0.5*a*t^2
	 * @param distanceUnits The distance units in which to return the distance in.
	 * @param timespan The timespan to calculate the distance for.
	 * @param speed The initial or constant speed.
	 * @param acceleration Optional. An acceleration which increases the speed over time.
	 * @param timeUnits The units of the timespan. If not specified seconds are used.
	 * @param speedUnits The units of the speed value. If not specified m/s are used.
	 * @param accelerationUnits Optional. The units of the acceleration value. If not specified m/s^2 are used.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns The distance traveled for a specified timespan, speed and optionally an acceleration.
	 */
	function getTravelDistance(distanceUnits, timespan, speed, acceleration, timeUnits, speedUnits, accelerationUnits, decimals) {
	    // Convert timespan to seconds.
	    timespan = convertTimespan(timespan, timeUnits, TimeUnits.seconds);
	    // Convert speed to meters per second.
	    speed = convertSpeed(speed, speedUnits, SpeedUnits.metersPerSecond);
	    var distance = speed * timespan;
	    if (typeof acceleration === "number") {
	        // Convert acceleration to meters per second squared.
	        distance += 0.5 * convertAcceleration(acceleration, accelerationUnits, AccelerationUnits.metersPerSecondSquared) * timespan * timespan;
	    }
	    return convertDistance(distance, DistanceUnits.meters, distanceUnits, decimals);
	}
	/**
	 * Parses a timestamp into a JavaScript Date object.
	 * Timestamps can be;
	 *  - A JavaScript Date object
	 *  - A number which represents the number of milliseconds since Jan 1st, 1970.
	 *  - A string which uses one of the following formats:
	 *      - ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	 *      - RFC282 / IETF date syntax (section 3.3)
	 *      - OData Date string (i.e. "/Date(1235764800000)/")
	 * @param timestamp The timestamp value to parse.
	 * @returns A Date object that represents the timestamp or null if the timestamp could not be parsed.
	 */
	function parseTimestamp(timestamp) {
	    if (Object.prototype.toString.call(timestamp) === "[object Date]") {
	        return timestamp;
	    }
	    if (typeof timestamp === "string") {
	        // ISO8601 date format (i.e. 2012-04-23T18:25:43.511Z)
	        // RFC282 / IETF date syntax (section 3.3)
	        var d = Date.parse(timestamp);
	        if (!isNaN(d)) {
	            return new Date(d);
	        }
	        // OData Date format "/Date(1235764800000)/"
	        if (timestamp.indexOf("Date(") >= 0) {
	            timestamp = timestamp.replace("/Date(", "").replace(")/", "");
	            var ms = 0; // number of milliseconds since midnight Jan 1, 1970
	            if (timestamp.indexOf("+") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("+")), 10);
	            }
	            else if (timestamp.indexOf("-") > 0) {
	                ms = parseInt(timestamp.substr(0, timestamp.indexOf("-")), 10);
	            }
	            else {
	                ms = parseInt(timestamp, 10);
	            }
	            return new Date(ms);
	        }
	    }
	    else if (typeof timestamp === "number") {
	        // Assume the number is the number of milliseconds from Jan 1st, 1970.
	        return new Date(timestamp);
	    }
	    return null;
	}
	/**
	 * Calculates a Convex Hull from an array of positions, geometries or features.
	 * @param data The array of positions, geometries or features to calculate a convex hull for.
	 * @returns A Convex Hull from an array of positions, geometries or features.
	 */
	function getConvexHull(data) {
	    var e_1, _a;
	    // Uses a Monotone chain algorithm for convex hulls:
	    // https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	    var positions = getPositions(data).map(function (pos) {
	        return [normalizeLongitude(pos[0]), normalizeLatitude(pos[1])];
	    });
	    positions.sort(function (a, b) {
	        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
	    });
	    var lower = [];
	    try {
	        for (var positions_1 = __values$i(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
	            var position = positions_1_1.value;
	            while (lower.length >= 2 && _cross(lower[lower.length - 2], lower[lower.length - 1], position) <= 0) {
	                lower.pop();
	            }
	            lower.push(position);
	        }
	    }
	    catch (e_1_1) { e_1 = { error: e_1_1 }; }
	    finally {
	        try {
	            if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);
	        }
	        finally { if (e_1) throw e_1.error; }
	    }
	    var upper = [];
	    for (var i = positions.length - 1; i >= 0; i--) {
	        while (upper.length >= 2 && _cross(upper[upper.length - 2], upper[upper.length - 1], positions[i]) <= 0) {
	            upper.pop();
	        }
	        upper.push(positions[i]);
	    }
	    return new Polygon([lower.concat(upper)]);
	}
	/**
	 * Retrieves an array of all positions in the provided geometry, feature or array of geometries/features.
	 * @param data The geometries or features to retrieve the positions from.
	 * @returns An array of all positions in the provided geometry, feature or array of geometries/features.
	 */
	function getPositions(data) {
	    var loc = [];
	    var loc2d = null;
	    var loc3d = null;
	    if (Array.isArray(data) && data.length > 0) {
	        if (Array.isArray(data[0]) && typeof data[0][0] === "number") {
	            loc = data;
	        }
	        else {
	            var len = data.length;
	            for (var i = 0; i < len; i++) {
	                loc = loc.concat(getPositions(data[i]));
	            }
	        }
	    }
	    else if (data["type"]) {
	        switch (data["type"]) {
	            case "Point":
	                loc = [data.coordinates];
	                break;
	            case "LineString":
	                loc = data.coordinates;
	                break;
	            case "Polygon":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPoint":
	                loc = data.coordinates;
	                break;
	            case "MultiLineString":
	                loc2d = data.coordinates;
	                break;
	            case "MultiPolygon":
	                loc3d = data.coordinates;
	                break;
	            case "Feature":
	                var f = data;
	                if (Shape._isCircle(f)) {
	                    loc = Shape._getCirclePositions(f);
	                }
	                else {
	                    loc = getPositions(f.geometry);
	                }
	                break;
	            case "FeatureCollection":
	                loc = getPositions(data.features);
	                break;
	            case "GeometryCollection":
	                loc = getPositions(data.geometries);
	                break;
	        }
	    }
	    else if (data instanceof Shape) {
	        return getPositions(data.toJson());
	    }
	    if (loc2d) {
	        var len = loc2d.length;
	        for (var i = 0; i < len; i++) {
	            loc = loc.concat(loc2d[i]);
	        }
	    }
	    else if (loc3d) {
	        var outerLen = loc3d.length;
	        for (var i = 0; i < outerLen; i++) {
	            var innerLen = loc3d[i].length;
	            for (var j = 0; j < innerLen; j++) {
	                loc = loc.concat(loc3d[i][j]);
	            }
	        }
	    }
	    return loc;
	}
	/**
	 * Gets the position of an object that is a position, point, point feature, or circle. If it is a circle, its center coordinate will be returned.
	 * @param data The data object to extract the position from.
	 * @returns The position of an object that is a position, point, or point feature. Returns null if invalid data passed in.
	 */
	function getPosition(data) {
	    if (Array.isArray(data) && typeof data[0] === "number") {
	        return data;
	    }
	    else if (data["type"]) {
	        if (data["type"] === "Point") {
	            return data.coordinates;
	        }
	        else if (data["type"] === "Feature" && data["geometry"]["type"] === "Point") {
	            return data.geometry.coordinates;
	        }
	    }
	    else if (data instanceof Shape && data.getType() === "Point") {
	        return data.getCoordinates();
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced positions along a path.
	 * @param path The path to get the positions from.
	 * @param numPositions The number of positions to get.
	 * @returns An array of evenly spaced positions along a path.
	 */
	function getPositionsAlongPath(path, numPositions) {
	    if (numPositions < 2) {
	        return [];
	    }
	    var positions = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the positions. There is one less gap than there are positions.
	    var dx = len / (numPositions - 1);
	    for (var i = 0; i < numPositions; i++) {
	        var p = getPositionAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            positions.push(p);
	        }
	    }
	    return positions;
	}
	/**
	 * Gets a point with heading a specified distance along a path.
	 * @param path The path to get the point from.
	 * @param distance The distance along the path to get the point at.
	 * @param units The distance units.
	 * @returns A point with heading a specified distance along a path.
	 */
	function getPointWithHeadingAlongPath(path, distance, units) {
	    units = units || "meters";
	    var travelled = 0;
	    var dx;
	    var locs;
	    if (Array.isArray(path)) {
	        locs = path;
	    }
	    else if (path.type && path.type === "LineString") {
	        locs = path.coordinates;
	    }
	    if (locs.length >= 2) {
	        var len = locs.length;
	        for (var i = 1; i < len; i++) {
	            dx = getDistanceTo(locs[i - 1], locs[i], units);
	            if (travelled + dx >= distance) {
	                // Overshot
	                var heading = getHeading(locs[i - 1], locs[i]);
	                var p = getDestination(locs[i - 1], heading, distance - travelled, units);
	                return new Feature(new Point(p), {
	                    heading: heading
	                });
	            }
	            travelled += dx;
	        }
	        if (distance >= travelled) {
	            return new Feature(new Point(locs[len - 1]), {
	                heading: getHeading(locs[len - 2], locs[len - 1])
	            });
	        }
	        return new Feature(new Point(locs[0]), {
	            heading: getHeading(locs[0], locs[1])
	        });
	    }
	    return null;
	}
	/**
	 * Gets an array of evenly spaced points with headings along a path.
	 * @param path The path to get the positions from.
	 * @param numPoints The number of points to get.
	 * @returns An array of evenly spaced points with headings along a path.
	 */
	function getPointsWithHeadingsAlongPath(path, numPoints) {
	    if (numPoints <= 0) {
	        return [];
	    }
	    var points = [];
	    var len = getLengthOfPath(path, DistanceUnits.meters);
	    // Calculate the gaps between the points. There is one less gap than there are points.
	    var dx = len / (numPoints - 1);
	    for (var i = 0; i < numPoints; i++) {
	        var p = getPointWithHeadingAlongPath(path, dx * i, DistanceUnits.meters);
	        if (p != null) {
	            points.push(p);
	        }
	    }
	    return points;
	}
	/**
	 * Calculates the closest point on the edge of a geometry to a specified point or position.
	 * The returned point feature will have a `distance` property that specifies the distance between the two points in the specified units.
	 * If the geometry is a Point, that points position will be used for the result.
	 * If the geometry is a MultiPoint, the distances to the individual positions will be used.
	 * If the geometry is a Polygon or MultiPolygon, the point closest to any edge will be returned regardless of if the point intersects the geometry or not.
	 * @param pt The point or position to find the closest point on the edge of the geometry.
	 * @param geom The geometry to find the closest point on.
	 * @param units Unit of distance measurement. Default is meters.
	 * @param decimals The number of decimal places to round the result to.
	 * @returns
	 */
	function getClosestPointOnGeometry(pt, geom, units, decimals) {
	    // Does not support geometries that cross the antimerdian.
	    var pos = getPosition(pt);
	    var px = mercatorPositionsToPixels([pos], 22)[0];
	    var result = null;
	    var paths;
	    var minDis = Infinity;
	    geom = geom instanceof Shape ? geom.toJson() : geom;
	    switch (geom.type) {
	        case "Feature":
	            return getClosestPointOnGeometry(pt, geom.geometry, units);
	        case "Point":
	            paths = [[geom.coordinates]];
	            break;
	        case "MultiPoint":
	            var d = void 0;
	            var mp = geom.coordinates;
	            for (var i = 0, len = mp.length; i < len; i++) {
	                d = getDistanceTo(pos, mp[i]);
	                if (d < minDis) {
	                    minDis = d;
	                    result = new Feature(new Point(mp[i]), {
	                        distance: d
	                    });
	                }
	            }
	            break;
	        case "LineString":
	            paths = [geom.coordinates];
	            break;
	        case "Polygon":
	        case "MultiLineString":
	            paths = geom.coordinates;
	            break;
	        case "MultiPolygon":
	            var mPaths = geom.coordinates;
	            if (mPaths.length > 0) {
	                paths = mPaths[0];
	                for (var i = 1, len = mPaths.length; i < len; i++) {
	                    paths = paths.concat(mPaths[i]);
	                }
	            }
	            break;
	    }
	    if (paths) {
	        var temp = void 0;
	        for (var i = 0, len = paths.length; i < len; i++) {
	            temp = _closestPointOnPath(pos, px, paths[i]);
	            if (temp && temp.properties.distance < minDis) {
	                minDis = temp.properties.distance;
	                result = temp;
	            }
	        }
	    }
	    if (result) {
	        result.properties.distance = convertDistance(result.properties.distance, "meters", units, decimals);
	    }
	    return result;
	}

	var __extends$14 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A GeoJSON Position object - an array that specifies the longitude and latitude of a location. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.1}.
	 */
	var Position = /** @class */ (function (_super) {
	    __extends$14(Position, _super);
	    /**
	     * Constructs a Position.
	     * @param longitude The position's longitude.
	     * @param latitude The position's latitude.
	     * @param elevation The position's elevation.
	     */
	    function Position(longitude, latitude, elevation) {
	        var _this = this;
	        if (elevation) {
	            _this = _super.call(this, longitude, latitude, elevation) || this;
	        }
	        else {
	            _this = _super.call(this, longitude, latitude) || this;
	        }
	        return _this;
	    }
	    /**
	     * Clones a position.
	     * @param position The position to clone.
	     */
	    Position.fromPosition = function (position) {
	        if (position.length === 2) {
	            return new Position(position[0], position[1]);
	        }
	        else if (position.length > 2) {
	            return new Position(position[0], position[1], position[2]);
	        }
	        return null;
	    };
	    /**
	     * Compares the longitude and latitude values of two positions to see if they are equal at an accuracy of 6 decimal places.
	     * @param pos1 First position to compare.
	     * @param pos2 Second position to compare.
	     * @param precision The number of decimal places to compare to. Default: 6.
	     * @returns A boolean indicating if two positions to see if they are equal at an accuracy of the specified precision or 6 decimal places.
	     */
	    Position.areEqual = function (pos1, pos2, precision) {
	        if (typeof (precision) === "undefined") {
	            precision = 6;
	        }
	        if (pos1 && pos1.length >= 2 && pos2 && pos2.length >= 2) {
	            var offset = Math.pow(10, precision);
	            var lat1 = normalizeLatitude(pos1[1]);
	            var lat2 = normalizeLatitude(pos2[1]);
	            var lon1 = normalizeLongitude(pos1[0]);
	            var lon2 = normalizeLongitude(pos2[0]);
	            var latDiff = Math.round((lat1 - lat2) * offset) / offset;
	            if (latDiff !== 0) {
	                return false;
	            }
	            // A diff of 360 is also allowed because -180 and 180 are the same longitude
	            var lonDiff = Math.round((lon1 - lon2) * offset) / offset;
	            if (lonDiff !== 0 && lonDiff !== 360) {
	                return false;
	            }
	            return true;
	        }
	        return false;
	    };
	    Position.fromLatLng = function (y, x, z) {
	        var position = [];
	        if (typeof y === "number") {
	            if (typeof x === "number") {
	                position.push(x);
	            }
	            position.push(y);
	            if (typeof z === "number") {
	                position.push(z);
	            }
	        }
	        else if (Array.isArray(y)) {
	            // Assume array is in the form [lat, lng] or [lat, lng, elv]
	            if (y.length >= 2 && typeof y[0] === "number" && typeof y[1] === "number") {
	                if (y.length >= 3 && typeof y[2] === "number") {
	                    position.push(y[1], y[0], y[2]);
	                }
	                else {
	                    position.push(y[1], y[0]);
	                }
	            }
	        }
	        else if (typeof y === "object") {
	            // Consider pulling these out into static variable so that we don't constantly create instances of these.
	            var latNames_1 = ["lat", "latitude", "y"];
	            var lngNames_1 = ["lng", "longitude", "lon", "x"];
	            var elvNames_1 = ["elv", "elevation", "alt", "altitude", "z"];
	            var lat_1 = NaN;
	            var lng_1 = NaN;
	            var elv_1 = NaN;
	            // Do a case insensitive search through the object properties.
	            Object.keys(y).forEach(function (key, idx, arr) {
	                var smallKey = key.toLowerCase();
	                if (isNaN(lat_1) && latNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lat_1 = y[key];
	                }
	                else if (isNaN(lng_1) && lngNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    lng_1 = y[key];
	                }
	                else if (isNaN(elv_1) && elvNames_1.indexOf(smallKey) >= 0 && typeof y[key] === "number") {
	                    elv_1 = y[key];
	                }
	            });
	            if (!isNaN(lat_1) && !isNaN(lng_1)) {
	                position.push(lng_1, lat_1);
	                if (!isNaN(elv_1)) {
	                    position.push(elv_1);
	                }
	            }
	        }
	        if (position.length >= 2) {
	            return position;
	        }
	        return null;
	    };
	    /**
	     * Converts an array of objects that contain coordinate information into an array of Positions. Objects that can't be converted are discarded.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns An array of Position objects that contain all the provided coordinate information.
	     */
	    Position.fromLatLngs = function (latLngs) {
	        var positions = [];
	        if (Array.isArray(latLngs)) {
	            for (var i = 0, len = latLngs.length; i < len; i++) {
	                var p = Position.fromLatLng(latLngs[i]);
	                // skip undetermined positions.
	                if (p) {
	                    positions.push(p);
	                }
	            }
	        }
	        return positions;
	    };
	    /**
	     * Returns the number of dimensions in the specified coordinates.
	     * Does not include the extra dimension form the Position type.
	     * @param coords The coordinates to get the dimension count for.
	     * @private
	     */
	    Position._getDimensions = function (coords) {
	        var count = 0;
	        while (Array.isArray(coords)) {
	            coords = coords[0];
	            count++;
	        }
	        // If the inner most array has a number for it's first
	        // element it is a position and the count must be reduced by 1.
	        if (typeof coords === "number") {
	            count--;
	        }
	        return count;
	    };
	    return Position;
	}(Array));

	/**
	 * A GeoJSON Polygon object - a JSON object that represents a geographic polygon. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.6}.
	 */
	var Polygon = /** @class */ (function () {
	    /**
	     * Constructs a Polygon.
	     * @param coordinates The array of linear ring coordinate arrays defining the polygon.
	     * @param bbox The bounding box of the polygon.
	     */
	    function Polygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "Polygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "Polygon";
	        this.type = Polygon.TYPE;
	        // check if it has only one ring
	        if (Position._getDimensions(coordinates) === 1) {
	            this.coordinates = [coordinates];
	        }
	        else {
	            this.coordinates = coordinates;
	        }
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the Polygon class to be used in runtime comparisons.
	     */
	    Polygon.TYPE = "Polygon";
	    return Polygon;
	}());

	var __extends$13 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$h = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A helper class that wraps a Geometry or Feature and makes it easy to update and maintain.
	 */
	var Shape = /** @class */ (function (_super) {
	    __extends$13(Shape, _super);
	    function Shape(data, id, properties) {
	        var _this = _super.call(this) || this;
	        var geometry;
	        if (data.type === "Feature") {
	            var feature = data;
	            geometry = cloneDeep$1(feature.geometry);
	            properties = feature.properties ? cloneDeep$1(feature.properties) : {};
	            id = feature.id == null || feature.id === "" ? uuid() : feature.id;
	        }
	        else {
	            geometry = cloneDeep$1(data);
	            id = id == null || id === "" ? uuid() : id;
	            properties = properties ? cloneDeep$1(properties) : {};
	        }
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = id;
	        // Always create a new feature to guarantee the data matches our definition of a Feature.
	        _this.data = new Feature(geometry, properties, id);
	        _this._handleCircle();
	        return _this;
	    }
	    /**
	     * Adds or updates an existing property value in the shape.
	     * @param key
	     * @param value
	     */
	    Shape.prototype.addProperty = function (key, value) {
	        // Only add the property if it is a new value.
	        if (!isEqual$1(this.data.properties[key], value)) {
	            this.data.properties[key] = cloneDeep$1(value);
	            if (key === "subType" || key === "radius") {
	                this._handleCircle();
	            }
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Gets the bounding box of the shape
	     */
	    Shape.prototype.getBounds = function () {
	        var e_1, _a, e_2, _b;
	        var positions = this.getCoordinates();
	        var bbox;
	        var geoType = this.getType();
	        if (geoType === "Point") {
	            if (this.circlePolygon) { // If a circle from the extended GeoJSON spec.
	                var pos = this.circlePolygon.geometry.coordinates;
	                bbox = BoundingBox.fromPositions(pos[0]);
	            }
	            else {
	                var pos = positions;
	                bbox = new BoundingBox(pos, pos);
	            }
	        }
	        else if (geoType === "MultiPoint" || geoType === "LineString") {
	            var pos = positions;
	            bbox = BoundingBox.fromPositions(pos);
	        }
	        else if (geoType === "Polygon") {
	            var pos = positions;
	            // only need to check the exterior ring of Polygon
	            bbox = BoundingBox.fromPositions(pos[0]);
	        }
	        else if (geoType === "MultiLineString") {
	            var pos = positions;
	            try {
	                for (var pos_1 = __values$h(pos), pos_1_1 = pos_1.next(); !pos_1_1.done; pos_1_1 = pos_1.next()) {
	                    var p = pos_1_1.value;
	                    bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p));
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (pos_1_1 && !pos_1_1.done && (_a = pos_1.return)) _a.call(pos_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else if (geoType === "MultiPolygon") {
	            var pos = positions;
	            try {
	                for (var pos_2 = __values$h(pos), pos_2_1 = pos_2.next(); !pos_2_1.done; pos_2_1 = pos_2.next()) {
	                    var p1 = pos_2_1.value;
	                    // only need to check the exterior ring of Polygon
	                    bbox = BoundingBox.merge(bbox, BoundingBox.fromPositions(p1[0]));
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (pos_2_1 && !pos_2_1.done && (_b = pos_2.return)) _b.call(pos_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        return bbox;
	    };
	    /**
	     * Gets the coordinates of the shape.
	     */
	    Shape.prototype.getCoordinates = function () {
	        return cloneDeep$1(this.data.geometry.coordinates);
	    };
	    /**
	     * If the shape is a circle, this gets its coordinates. Otherwise returns null.
	     */
	    Shape.prototype.getCircleCoordinates = function () {
	        if (this.circlePolygon) {
	            return cloneDeep$1(this.circlePolygon.geometry.coordinates[0]);
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * Gets the id of the shape.
	     */
	    Shape.prototype.getId = function () {
	        return this.data.id;
	    };
	    /**
	     * Gets the properties of the shape.
	     */
	    Shape.prototype.getProperties = function () {
	        return cloneDeep$1(this.data.properties);
	    };
	    /**
	     * Returns a string indicating the type of geometry this shape contains.
	     */
	    Shape.prototype.getType = function () {
	        return this.data.geometry.type;
	    };
	    /**
	     * Indicates if the contained shape is a Circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isCircle = function () {
	        return Shape._isCircle(this.data);
	    };
	    /**
	     * Indicates if the contained shape is a Rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     */
	    Shape.prototype.isRectangle = function () {
	        return Shape._isRectangle(this.data);
	    };
	    /**
	     * Updates the coordinates of the shape
	     * @param coords Point: Position, LineString: Position[], Polygon: Position[][],
	     * MultiPoint: Position[], MultiLineString: Position[][], MultiPolygon: Position[][]
	     */
	    Shape.prototype.setCoordinates = function (coords) {
	        // If a Position[] is supplied for a polygon wrap it in an array.
	        var newCoords;
	        if (this.getType() === "Polygon" &&
	            Position._getDimensions(coords) === 1) {
	            newCoords = [coords];
	        }
	        else {
	            newCoords = coords;
	        }
	        // Only update the coordinates if they've actually changed.
	        if (!isEqual$1(this.data.geometry.coordinates, newCoords)) {
	            this.data.geometry.coordinates = cloneDeep$1(newCoords);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Sets the properties on the shape. Overwrites all existing properties.
	     * @param properties
	     */
	    Shape.prototype.setProperties = function (properties) {
	        // Assign the feature's id to another property to workaround the Mapbox bug
	        // that prevents non-numerical ids from being returned by some functions.
	        // TODO Remove once this issue if fixed. https://github.com/mapbox/mapbox-gl-js/issues/2716
	        properties[Shape._shapeIdPropName] = this.data.id;
	        // Only update the properties if they've actually changed.
	        if (!isEqual$1(this.data.properties, properties)) {
	            this.data.properties = cloneDeep$1(properties);
	            this._handleCircle();
	            if (this.dataSource) {
	                this.dataSource._updateSource();
	            }
	            this._invokeEvent("shapechanged", this);
	        }
	    };
	    /**
	     * Returns a GeoJSON feature that represents the shape.
	     */
	    Shape.prototype.toJson = function () {
	        return JSON.parse(JSON.stringify(this.data));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape.prototype._toJson = function () {
	        return this.circlePolygon || this.data;
	    };
	    /**
	     * @internal
	     */
	    Shape.prototype._setDataSource = function (dataSource) {
	        if (dataSource === undefined || dataSource == null) {
	            delete this.dataSource;
	        }
	        else {
	            this.dataSource = dataSource;
	        }
	    };
	    /**
	     * Check if the shape's wrapped feature is a circle form the extended GeoJSON spec.
	     * If so it will calculate a polygon feature that approximates the specified circle.
	     * @private
	     */
	    Shape.prototype._handleCircle = function () {
	        if (this.isCircle()) {
	            var coords = Shape._getCirclePositions(this.data);
	            this.circlePolygon = new Feature(new Polygon([coords]), this.data.properties, this.data.id);
	            // Set the subType to "Circle" to make sure the case is correct.
	            this.data.properties.subType = "Circle";
	        }
	        else {
	            delete this.circlePolygon;
	        }
	    };
	    /**
	     * Indicates if the specified feature is a circle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isCircle = function (data) {
	        return data && data.geometry &&
	            data.geometry.type === "Point" &&
	            data.geometry.coordinates && data.properties &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "circle" &&
	            typeof data.properties.radius === "number";
	    };
	    /**
	     * Indicates if the specified feature is a rectangle, defined by the extended GeoJSON specification supported by Azure Maps.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    Shape._isRectangle = function (data) {
	        if (data.geometry.type === "Polygon" &&
	            data.geometry.coordinates &&
	            typeof data.properties.subType === "string" &&
	            data.properties.subType.toLowerCase() === "rectangle") {
	            // If type is Polygon we can assume the coordinates are a Position[][].
	            var coords = data.geometry.coordinates;
	            if (coords.length === 1) {
	                var ring = coords[0];
	                if (ring.length === 5) {
	                    return ring[0][0] === ring[4][0] &&
	                        ring[0][1] === ring[4][1];
	                }
	                else if (ring.length === 4) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    /**
	     * Calculates to positions that should be used to approximate the specified circle feature.
	     * @internal
	     */
	    Shape._getCirclePositions = function (data) {
	        return getRegularPolygonPath(data.geometry.coordinates, data.properties.radius, 72, "meters");
	    };
	    /**
	     * Represents the feature property name that the shape's id will be assigned to.
	     * This is a workaround for the Mapbox bug preventing non-numerical ids from being returned by some functions.
	     * TODO Remove once this issue if fixed.
	     * {@link https://github.com/mapbox/mapbox-gl-js/issues/2716}
	     * @internal
	     */
	    // tslint:disable-next-line: variable-name
	    Shape._shapeIdPropName = "_azureMapsShapeId";
	    return Shape;
	}(EventEmitter));

	var __extends$12 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$g = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A GeoJSON BoundingBox object - an array that defines a shape whose edges follow lines of constant longitude,
	 * latitude, and elevation. All axes of the most southwesterly point are followed by all axes of the more northeasterly
	 * point. The axes order of the BoundingBox follows the axes order of geometries. The full description is detailed in
	 * [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-5}.
	 */
	var BoundingBox = /** @class */ (function (_super) {
	    __extends$12(BoundingBox, _super);
	    function BoundingBox(southwestPositionOrPositions, northeastPosition) {
	        var _this = this;
	        if (southwestPositionOrPositions && northeastPosition) {
	            var southwestPosition = southwestPositionOrPositions;
	            if (southwestPosition[2] && northeastPosition[2]) {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], southwestPosition[2] || 0, northeastPosition[0], northeastPosition[1], northeastPosition[2] || 0) || this;
	            }
	            else {
	                _this = _super.call(this, southwestPosition[0], southwestPosition[1], northeastPosition[0], northeastPosition[1]) || this;
	            }
	        }
	        else if (southwestPositionOrPositions) {
	            var positions = southwestPositionOrPositions;
	            if (positions) {
	                if (positions.length === 4) {
	                    // [west, south, east, north]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3]) || this;
	                }
	                else if (positions.length >= 6) {
	                    // [west, south, elevation1, east, north, elevation2]
	                    _this = _super.call(this, positions[0], positions[1], positions[2], positions[3], positions[4], positions[5]) || this;
	                }
	            }
	        }
	        return _this;
	    }
	    /**
	     * Clones a bounding box.
	     * @param boundingBox The bounding box to clone.
	     */
	    BoundingBox.fromBoundingBox = function (boundingBox) {
	        var west = BoundingBox.getWest(boundingBox);
	        var south = BoundingBox.getSouth(boundingBox);
	        var east = BoundingBox.getEast(boundingBox);
	        var north = BoundingBox.getNorth(boundingBox);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified dimensions.
	     * @param center The center position of the bounding box.
	     * @param width The width of the bounding box.
	     * @param height The height of the bounding box.
	     */
	    BoundingBox.fromDimensions = function (center, width, height) {
	        var lon = center[0];
	        var lat = center[1];
	        var north = Math.min(Math.max(lat + height / 2, -85.5), 85.5);
	        var south = Math.min(Math.max(lat - height / 2, -85.5), 85.5);
	        var east = normalizeLongitude(lon + width / 2);
	        var west = normalizeLongitude(lon - width / 2);
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Constructs a BoundingBox from the specified edges.
	     * @param west The west edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param north The north edge of the bounding box.
	     */
	    BoundingBox.fromEdges = function (west, south, east, north) {
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Determines if a position is within a bounding box.
	     * @param bounds The bounding box to see if the position is in.
	     * @param position The position to see if it is in the bounding box.
	     * @returns True if the position is within the bounding box.
	     */
	    BoundingBox.containsPosition = function (bounds, position) {
	        // Allow a small difference to account for arithmetic accuracy errors.
	        // This is important for points on the edge of the bounding box which is the case when using BoundingBox.fromLocations
	        var accuracyAllowance = 0.00000001;
	        // Use the distance between the position and center of the bounding box to determine if they intersect.
	        var center = BoundingBox.getCenter(bounds);
	        var diffLatitude = Math.abs(center[1] - position[1]);
	        var diffLongitude = Math.abs(center[0] - position[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height = BoundingBox.getHeight(bounds);
	        var width = BoundingBox.getWidth(bounds);
	        return (diffLatitude <= (height / 2) + accuracyAllowance) && (diffLongitude <= (width / 2) + accuracyAllowance);
	    };
	    /**
	     * Determines if a bounding box is within another bounding box
	     * @param outer The outer bounding box
	     * @param inner The inner bounding box (the one that should be contained within outer)
	     * @returns True if the inner bounding box is fully container in outer
	     */
	    BoundingBox.containsBoundingBox = function (outer, inner) {
	        var outerValid = outer && outer.length === 4;
	        var innerValid = inner && inner.length === 4;
	        if (!outerValid || !innerValid) {
	            return false;
	        }
	        return BoundingBox.getWest(outer) < BoundingBox.getWest(inner) && BoundingBox.getWest(inner) < BoundingBox.getEast(outer) &&
	            BoundingBox.getWest(outer) < BoundingBox.getEast(inner) && BoundingBox.getEast(inner) < BoundingBox.getEast(outer) &&
	            BoundingBox.getSouth(outer) < BoundingBox.getSouth(inner) && BoundingBox.getSouth(inner) < BoundingBox.getNorth(outer) &&
	            BoundingBox.getSouth(outer) < BoundingBox.getNorth(inner) && BoundingBox.getNorth(inner) < BoundingBox.getNorth(outer);
	    };
	    /**
	     * Returns a boolean indicating if the bounding box crosses the antimeridian or not.
	     * @param bounds The bounding box to check.
	     * @returns A boolean indicating if the bounding box crosses the antimeridian or not.
	     */
	    BoundingBox.crossesAntimeridian = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        return (east - west) < 0
	            || BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(bounds)
	            || BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(bounds);
	    };
	    /**
	     * Calculates the center of a bounding box.
	     * @param bounds A bounding box to calculate the center of.
	     * @returns A position that represents the center of the bounding box.
	     */
	    BoundingBox.getCenter = function (bounds) {
	        // [west, south, east, north]
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        if (west > east) {
	            east += 360.0;
	        }
	        var centerLongitude = normalizeLongitude((west + east) / 2.0);
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var centerLatitude = normalizeLatitude((south + north) / 2.0);
	        return [centerLongitude, centerLatitude];
	    };
	    /**
	     * Gets the height of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The height of the bounding box in degrees.
	     */
	    BoundingBox.getHeight = function (bounds) {
	        var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	        var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	        var height = north - south;
	        return isNaN(height) ? 0 : height;
	    };
	    /**
	     * Gets the width of a bounding box in degrees.
	     * @param bounds The bounding box to check.
	     * @returns The width of the bounding box in degrees.
	     */
	    BoundingBox.getWidth = function (bounds) {
	        var east = normalizeLongitude(BoundingBox.getEast(bounds));
	        var west = normalizeLongitude(BoundingBox.getWest(bounds));
	        var width = east - west;
	        // Check to see if bounds crosses antimeridian
	        return isNaN(width) ? 0 : width < 0 ? width += 360 : width;
	    };
	    /**
	     * Returns the south west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south west position of the bounding box.
	     */
	    BoundingBox.getSouthWest = function (bounds) {
	        var south = this.getSouth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(south) || isNaN(west)) ? null : [west, south];
	    };
	    /**
	     * Returns the north east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north east position of the bounding box.
	     */
	    BoundingBox.getNorthEast = function (bounds) {
	        var north = this.getNorth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(north) || isNaN(east)) ? null : [east, north];
	    };
	    /**
	     * Returns the north west position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north west position of the bounding box.
	     */
	    BoundingBox.getNorthWest = function (bounds) {
	        var north = this.getNorth(bounds);
	        var west = this.getWest(bounds);
	        return (isNaN(north) || isNaN(west)) ? null : [west, north];
	    };
	    /**
	     * Returns the south east position of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south east position of the bounding box.
	     */
	    BoundingBox.getSouthEast = function (bounds) {
	        var south = this.getSouth(bounds);
	        var east = this.getEast(bounds);
	        return (isNaN(south) || isNaN(east)) ? null : [east, south];
	    };
	    /**
	     * Returns the south position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The south position value of the bounding box.
	     */
	    BoundingBox.getSouth = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[1]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the west position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The west position value of the bounding box.
	     */
	    BoundingBox.getWest = function (bounds) {
	        if (bounds && bounds.length >= 4) {
	            return Number(bounds[0]);
	        }
	        return NaN;
	    };
	    /**
	     * Returns the north position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The north position value of the bounding box.
	     */
	    BoundingBox.getNorth = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[3]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[4]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Returns the east position value of the bounding box.
	     * @param bounds The bounding box to get the position from.
	     * @returns The east position value of the bounding box.
	     */
	    BoundingBox.getEast = function (bounds) {
	        if (bounds) {
	            if (bounds.length === 4) {
	                return Number(bounds[2]);
	            }
	            else if (bounds.length === 6) {
	                return Number(bounds[3]);
	            }
	        }
	        return NaN;
	    };
	    /**
	     * Determines is two bounding boxes intersect.
	     * @param bounds1 The first bounding box to compare with.
	     * @param bounds2 The second bounding box to compare with.
	     * @returns true if the provided bounding boxes intersect.
	     */
	    BoundingBox.intersect = function (bounds1, bounds2) {
	        var center1 = BoundingBox.getCenter(bounds1);
	        var center2 = BoundingBox.getCenter(bounds2);
	        // Use the distance between the 2 centers to determine if they intersect.
	        var diffLatitude = Math.abs(center1[1] - center2[1]);
	        var diffLongitude = Math.abs(center1[0] - center2[0]);
	        if (diffLongitude > 180.0) {
	            // We want the shortest distance between the 2 points.
	            diffLongitude = 360 - diffLongitude;
	        }
	        var height1 = BoundingBox.getHeight(bounds1);
	        var width1 = BoundingBox.getWidth(bounds1);
	        var height2 = BoundingBox.getHeight(bounds2);
	        var width2 = BoundingBox.getWidth(bounds2);
	        return (diffLatitude <= (height1 / 2 + height2 / 2) && diffLongitude <= (width1 / 2 + width2 / 2));
	    };
	    /**
	     * Merges two bounding boxes together.
	     * @param bounds1 The first bounding box to merge with.
	     * @param bounds2 The second bounding box to merge with.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.merge = function (bounds1, bounds2) {
	        var bb1Valid = bounds1 && bounds1.length === 4;
	        var bb2Valid = bounds2 && bounds2.length === 4;
	        if (bb1Valid && !bb2Valid) {
	            return bounds1;
	        }
	        else if (bb2Valid && !bb1Valid) {
	            return bounds2;
	        }
	        else if (!bb1Valid && !bb2Valid) {
	            return null;
	        }
	        var north = Math.max(normalizeLatitude(BoundingBox.getNorth(bounds1)), normalizeLatitude(BoundingBox.getNorth(bounds2)));
	        var south = Math.min(normalizeLatitude(BoundingBox.getSouth(bounds1)), normalizeLatitude(BoundingBox.getSouth(bounds2)));
	        // Find out the longitude spans of the two bounding boxes.
	        var boundingBoxes = [bounds1, bounds2];
	        var longIntervals = [];
	        var i = 0;
	        for (i = 0; i < boundingBoxes.length; i++) {
	            var b = boundingBoxes[i];
	            var w = normalizeLongitude(BoundingBox.getWest(b));
	            var e = normalizeLongitude(BoundingBox.getEast(b));
	            if (BoundingBox.crossesAntimeridian(b)) {
	                longIntervals.push([w, 180]);
	                longIntervals.push([-180, e]);
	            }
	            else {
	                longIntervals.push([w, e]);
	            }
	        }
	        // sort and merge (overlaped intervals) these intervals
	        // after the sort and merge we should have a list of intervals that don't overlap with each other.
	        longIntervals.sort(function (a, b) { return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]; });
	        var mergedIntervals = [];
	        var currentInterval = longIntervals[0];
	        i = 1;
	        while (i < longIntervals.length) {
	            var nextInterval = longIntervals[i];
	            if (currentInterval[1] >= nextInterval[0]) {
	                currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);
	            }
	            else {
	                mergedIntervals.push(currentInterval);
	                currentInterval = nextInterval;
	            }
	            i++;
	        }
	        mergedIntervals.push(currentInterval);
	        // find out the biggest gap between these intervals. suppose this gap is [A, B], then A will be the east bound and B will be the west bound of the merged rectangle.
	        var length = mergedIntervals.length;
	        var maxGapSpan = mergedIntervals[0][0] + 360 - mergedIntervals[length - 1][1];
	        var maxGap = [mergedIntervals[length - 1][1], mergedIntervals[0][0]];
	        for (i = 1; i < length; i++) {
	            var thisGapSpan = mergedIntervals[i][0] - mergedIntervals[i - 1][1];
	            if (thisGapSpan > maxGapSpan) {
	                maxGapSpan = thisGapSpan;
	                maxGap = [mergedIntervals[i - 1][1], mergedIntervals[i][0]];
	            }
	        }
	        // now we have all the edges of the rectangle
	        return new BoundingBox([maxGap[1], south], [maxGap[0], north]);
	    };
	    /**
	     * Creates a BoundingBox that contains all provided Position objects.
	     * @param positions An array of locations to use to generate the bounding box.
	     * @returns A bounding box that contains all given positions.
	     */
	    BoundingBox.fromPositions = function (positions) {
	        var north = NaN;
	        var south = NaN;
	        var west = NaN;
	        var east = NaN;
	        var position;
	        var i = positions.length;
	        var longitudes = new Array(i);
	        var longCount = 0;
	        while (i--) {
	            position = positions[i];
	            if (position && position.length >= 2) {
	                var normalizedPosition1 = normalizeLatitude(position[1]);
	                north = isNaN(north) ? normalizedPosition1 : Math.max(north, normalizedPosition1);
	                south = isNaN(south) ? normalizedPosition1 : Math.min(south, normalizedPosition1);
	                longitudes[longCount++] = normalizeLongitude(position[0]);
	            }
	        }
	        if (longCount) {
	            // Find largest gap between longitudes
	            longitudes.length = longCount;
	            longitudes.sort(function (a, b) { return a - b; });
	            var maxGap = (longitudes[0] + 360) - longitudes[longCount - 1];
	            var maxGapIndex = 0;
	            for (i = 1; i < longCount; i++) {
	                var gap = longitudes[i] - longitudes[i - 1];
	                if (gap > maxGap) {
	                    maxGap = gap;
	                    maxGapIndex = i;
	                }
	            }
	            west = longitudes[maxGapIndex];
	            east = longitudes[(maxGapIndex || longCount) - 1];
	        }
	        if (isNaN(west) || isNaN(south) || isNaN(east) || isNaN(north)) {
	            return null;
	        }
	        return new BoundingBox([west, south, east, north]);
	    };
	    /**
	     * Creates a BoundingBox from any array of objects that contain coordinate information.
	     * Each object is either an array in the format; [lat, lng] or [lat, lng, elv], or an object with the any combination of the following properties:
	     * Longitude: lng, longitude, lon, x
	     * Latitude: lat, latitude, y
	     * Elevation: elv, elevation, alt, altitude, z
	     * @param latLngs The objects that contain coordinate information.
	     * @returns A BoundingBox that contains all the provided coordinate information.
	     */
	    BoundingBox.fromLatLngs = function (latLngs) {
	        return BoundingBox.fromPositions(Position.fromLatLngs(latLngs));
	    };
	    /**
	     * Calculates the bounding box of a FeatureCollection, Feature, Geometry, Shape or array of these objects.
	     * @param data The FeatureCollection, Feature, Geometry, Shape or array of these objects to calculate the bounding box for.
	     * @returns A bounding box in the format [minLon, minLat, maxLon, maxLat].
	     */
	    BoundingBox.fromData = function (data) {
	        var e_1, _a;
	        var tempBounds;
	        var bounds = null;
	        if (Array.isArray(data) && data.length > 0) {
	            try {
	                for (var data_1 = __values$g(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
	                    var datum = data_1_1.value;
	                    tempBounds = BoundingBox.fromData(datum);
	                    if (tempBounds != null) {
	                        if (bounds === null) {
	                            bounds = tempBounds;
	                        }
	                        else {
	                            bounds = BoundingBox.merge(bounds, tempBounds);
	                        }
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return bounds;
	        }
	        else if (data instanceof Shape) {
	            return data.getBounds();
	        }
	        else if (data && data["type"]) {
	            // Data is a GeoJson object.
	            var geoJsonObj = data;
	            // Check to see if the GeoJSON object has a bbox, property, and if it does, use that.
	            if (geoJsonObj["bbox"] && geoJsonObj["bbox"].length === 4) {
	                return geoJsonObj["bbox"];
	            }
	            else {
	                switch (geoJsonObj.type) {
	                    case "FeatureCollection":
	                        // features: Array<Feature<Geometry>>
	                        return BoundingBox.fromData(geoJsonObj.features);
	                    case "Feature":
	                        // geometry: G
	                        if (Shape._isCircle(geoJsonObj)) {
	                            return BoundingBox.fromPositions(Shape._getCirclePositions(geoJsonObj));
	                        }
	                        else {
	                            return BoundingBox.fromData(geoJsonObj.geometry);
	                        }
	                    case "GeometryCollection":
	                        // geometries: Geometry[]
	                        return BoundingBox.fromData(geoJsonObj.geometries);
	                    case "Point":
	                        // coordinates: Position
	                        var p = geoJsonObj.coordinates;
	                        if (p && p.length >= 2) {
	                            return [p[0], p[1], p[0], p[1]];
	                        }
	                        break;
	                    case "LineString":
	                    case "MultiPoint":
	                        // coordinates: Position[]
	                        return BoundingBox.fromPositions(geoJsonObj.coordinates);
	                    case "Polygon":
	                    case "MultiLineString":
	                        // coordinates: Position[][]
	                        var ml = geoJsonObj.coordinates;
	                        if (ml && ml.length > 0) {
	                            for (var i = 0, len = ml.length; i < len; i++) {
	                                tempBounds = BoundingBox.fromPositions(ml[i]);
	                                if (tempBounds != null) {
	                                    if (bounds === null) {
	                                        bounds = tempBounds;
	                                    }
	                                    else {
	                                        bounds = BoundingBox.merge(bounds, tempBounds);
	                                    }
	                                }
	                            }
	                            if (bounds != null) {
	                                return bounds;
	                            }
	                        }
	                        break;
	                    case "MultiPolygon":
	                        // coordinates: Position[][][]
	                        var mp = geoJsonObj.coordinates;
	                        if (mp && mp.length > 0) {
	                            for (var i = 0, len = mp.length; i < len; i++) {
	                                for (var j = 0, cnt = mp[i].length; j < cnt; j++) {
	                                    tempBounds = BoundingBox.fromPositions(mp[i][j]);
	                                    if (tempBounds != null) {
	                                        if (bounds === null) {
	                                            bounds = tempBounds;
	                                        }
	                                        else {
	                                            bounds = BoundingBox.merge(bounds, tempBounds);
	                                        }
	                                    }
	                                }
	                            }
	                            return bounds;
	                        }
	                        break;
	                }
	            }
	        }
	        return null;
	    };
	    /**
	     * Splits a BoundingBox that crosses the Antimeridian into two BoundingBox's. One entirely west of the Antimerdian and another entirely east of the Antimerdian.
	     * @param bounds
	     */
	    BoundingBox.splitOnAntimeridian = function (bounds) {
	        var bboxes = [];
	        //Test the case when the bounding box is wider than a single globe.
	        if (BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe(bounds)) {
	            return [[-180, bounds[1], bounds[2], 180, bounds[4], bounds[5]]];
	        }
	        else if (BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe(bounds)) {
	            return [[-180, bounds[1], 180, bounds[3]]];
	        }
	        else if (BoundingBox.crossesAntimeridian(bounds)) {
	            //Case when map less than full globe width, but crosses anti-meridian.
	            var bbox1 = void 0;
	            var bbox2 = void 0;
	            var west = normalizeLongitude(BoundingBox.getWest(bounds));
	            var east = normalizeLongitude(BoundingBox.getEast(bounds));
	            var north = normalizeLatitude(BoundingBox.getNorth(bounds));
	            var south = normalizeLatitude(BoundingBox.getSouth(bounds));
	            // has elevations
	            if (bounds.length >= 6) {
	                bbox1 = [west, south, bounds[2], 180, north, bounds[5]];
	                bbox2 = [-180, south, bounds[2], east, north, bounds[5]];
	            }
	            else {
	                bbox1 = [west, south, 180, north];
	                bbox2 = [-180, south, east, north];
	            }
	            bboxes.push(bbox1, bbox2);
	        }
	        else {
	            bboxes.push(bounds);
	        }
	        return bboxes;
	    };
	    BoundingBox.isBoundingBoxWithSixOrMoreElementsLargerThanGlobe = function (bounds) {
	        return bounds.length >= 6 && bounds[3] - bounds[0] > 360;
	    };
	    BoundingBox.isBoundingBoxWithLessThanSixElementsLargerThanGlobe = function (bounds) {
	        return bounds.length < 6 && bounds[2] - bounds[0] > 360;
	    };
	    return BoundingBox;
	}(Array));

	/**
	 * A GeoJSON FeatureCollection object - a JSON object that contains a collection of GeoJSON features. The full
	 * description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.3}.
	 */
	var FeatureCollection = /** @class */ (function () {
	    /**
	     * Constructs a FeatureCollection.
	     * @param features The collection of features that make up the feature collection.
	     * @param bbox The bounding box of the feature collection.
	     */
	    function FeatureCollection(features, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "FeatureCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "FeatureCollection";
	        this.type = FeatureCollection.TYPE;
	        this.features = features;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the FeatureCollection class to be used in runtime comparisons.
	     */
	    FeatureCollection.TYPE = "FeatureCollection";
	    return FeatureCollection;
	}());

	/**
	 * A GeoJSON GeometryCollection object - a JSON object that contains a collection of a GeoJSON Geometry objects. The
	 * full description is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.8}.
	 */
	var GeometryCollection = /** @class */ (function () {
	    /**
	     * Constructs a GeometryCollection.
	     * @param geometries The collection of geometries that make up the geometry collection.
	     */
	    function GeometryCollection(geometries) {
	        /**
	         * A GeoJSON type descriptor with value "GeometryCollection".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "GeometryCollection";
	        this.type = GeometryCollection.TYPE;
	        this.geometries = geometries;
	    }
	    /**
	     * A static GeoJSON type descriptor for the GeometryCollection class to be used in runtime comparisons.
	     */
	    GeometryCollection.TYPE = "GeometryCollection";
	    return GeometryCollection;
	}());

	/**
	 * A GeoJSON LineString object - a JSON object that represents a geographic curve. The full description is detailed
	 * in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.4}.
	 */
	var LineString = /** @class */ (function () {
	    /**
	     * Constructs a LineString.
	     * @param coordinates The ordered list of positions defining the linestring.
	     * @param bbox The bounding box of the linestring.
	     */
	    function LineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "LineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "LineString";
	        this.type = LineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the LineString class to be used in runtime comparisons.
	     */
	    LineString.TYPE = "LineString";
	    return LineString;
	}());

	/**
	 * A GeoJSON MultiLineString object - a JSON object that represents multiple geographic curves. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.5}.
	 */
	var MultiLineString = /** @class */ (function () {
	    /**
	     * Constructs a MultiLineString.
	     * @param coordinates The array of LineString coordinate arrays defining the multilinestring.
	     * @param bbox The bounding box of the multilinestring.
	     */
	    function MultiLineString(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliLineString".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiLineString";
	        this.type = MultiLineString.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiLineString class to be used in runtime comparisons.
	     */
	    MultiLineString.TYPE = "MultiLineString";
	    return MultiLineString;
	}());

	/**
	 * A GeoJSON MultiPoint object - a JSON object that represents multiple geographic positions. The full description
	 * is detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.3}.
	 */
	var MultiPoint = /** @class */ (function () {
	    /**
	     * Constructs a MultiPoint.
	     * @param coordinates The array of multiple positions defining the multipoint.
	     * @param bbox The bounding box of the multipoint.
	     */
	    function MultiPoint(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPoint".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPoint";
	        this.type = MultiPoint.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPoint class to be used in runtime comparisons.
	     */
	    MultiPoint.TYPE = "MultiPoint";
	    return MultiPoint;
	}());

	/**
	 * A GeoJSON MultiPolygon object - a JSON object that represents multiple geographic polygons. The full description is
	 * detailed in [RFC 7946]{@link https://tools.ietf.org/html/rfc7946#section-3.1.7}.
	 */
	var MultiPolygon = /** @class */ (function () {
	    /**
	     * Constructs a MultiPolygon.
	     * @param coordinates The array of polygon coordinate arrays defining the multipolygon.
	     * @param bbox The bounding box of the multipolygon.
	     */
	    function MultiPolygon(coordinates, bbox) {
	        /**
	         * A GeoJSON type descriptor with value "MutliPolygon".
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        this.type = "MultiPolygon";
	        this.type = MultiPolygon.TYPE;
	        this.coordinates = coordinates;
	        this.bbox = bbox;
	    }
	    /**
	     * A static GeoJSON type descriptor for the MultiPolygon class to be used in runtime comparisons.
	     */
	    MultiPolygon.TYPE = "MultiPolygon";
	    return MultiPolygon;
	}());

	var __extends$11 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	//Based on: https://github.com/mapbox/mapbox-gl-js/blob/main/src/geo/mercator_coordinate.js
	/**
	 * A `MercatorPoint` object represents a projected three dimensional position.
	 *
	 * `MercatorPoint` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:
	 * - the size of 1 unit is the width of the projected world instead of the "mercator meter"
	 * - the origin of the coordinate space is at the north-west corner instead of the middle.
	 *
	 * For example, `MercatorPoint(0, 0, 0)` is the north-west corner of the mercator world and
	 * `MercatorPoint(1, 1, 0)` is the south-east corner. If you are familiar with
	 * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think
	 * of the coordinate space as the `0/0/0` tile with an extent of `1`.
	 *
	 * The `z` dimension of `MercatorPoint` is conformal. A cube in the mercator coordinate space would be rendered as a cube.
	 */
	var MercatorPoint = /** @class */ (function (_super) {
	    __extends$11(MercatorPoint, _super);
	    /**
	     * Constructs a MercatorPoint.
	     * @param x A points x position in mercator units.
	     * @param y A points y position in mercator units.
	     * @param z A points z position in mercator units.
	     */
	    function MercatorPoint(x, y, z) {
	        return _super.call(this, x, y, z ? z : 0) || this;
	    }
	    /***********************************
	     * Public static functions
	     ***********************************/
	    /**
	     * Converts a position into a mercator point.
	     * @param position Position to convert.
	     * @returns A mercator point.
	     */
	    MercatorPoint.fromPosition = function (position) {
	        if (position.length >= 2) {
	            return new MercatorPoint((180 + position[0]) / 360, MercatorPoint._latToMercatorY(position[1]), position.length >= 3 ? MercatorPoint._altitudeToMercatorZ(position[2], position[1]) : 0);
	        }
	        return [0, 0, 0];
	    };
	    /**
	     * Converts an array of positions into an array of mercator points.
	     * @param positions Array of positions to convert.
	     * @returns An array of  mercator points.
	     */
	    MercatorPoint.fromPositions = function (positions) {
	        var mercators = [];
	        for (var i = 0, len = positions.length; i < len; i++) {
	            mercators.push(this.fromPosition(positions[i]));
	        }
	        return mercators;
	    };
	    /**
	     * Converts an array of positions into a Float32Array of mercator xyz values.
	     * @param positions Array of positions to convert.
	     * @returns A Float32Array of mercator xyz values.
	     */
	    MercatorPoint.toFloat32Array = function (positions) {
	        var arr = new Float32Array(positions.length * 3);
	        for (var i = 0, len = positions.length; i < len; i++) {
	            var idx = i * 3;
	            var p = positions[i];
	            //x
	            arr[idx] = (180 + p[0]) / 360;
	            //y
	            arr[idx + 1] = MercatorPoint._latToMercatorY(p[1]);
	            //z
	            arr[idx + 2] = p.length >= 3 ? MercatorPoint._altitudeToMercatorZ(p[2], p[1]) : 0;
	        }
	        return arr;
	    };
	    /**
	     * Converts a mercator point into a map position.
	     * @param mercator Mercator point to convert.
	     * @returns A map position.
	     */
	    MercatorPoint.toPosition = function (mercator) {
	        if (mercator.length >= 2) {
	            var lat = (360 / Math.PI) * Math.atan(Math.exp(((180 - mercator[1] * 360) * Math.PI) / 180)) - 90;
	            return new Position(mercator[0] * 360 - 180, lat, mercator.length >= 3 ? MercatorPoint._mercatorZToAltitude(mercator[2], mercator[1]) : 0);
	        }
	        return [0, 0, 0];
	    };
	    /**
	     * Converts an array of mercator points into an array of map positions.
	     * @param mercators Mercator points to convert.
	     * @returns An array of map positions.
	     */
	    MercatorPoint.toPositions = function (mercators) {
	        var positions = [];
	        for (var i = 0, len = mercators.length; i < len; i++) {
	            positions.push(this.toPosition(mercators[i]));
	        }
	        return positions;
	    };
	    /**
	     * Determine the Mercator scale factor for a given latitude, see
	     * https://en.wikipedia.org/wiki/Mercator_projection#Scale_factor
	     *
	     * At the equator the scale factor will be 1, which increases at higher latitudes.
	     *
	     * @param latitude Latitude
	     * @returns The mercator scale factor.
	     */
	    MercatorPoint.mercatorScale = function (latitude) {
	        return 1 / Math.cos((latitude * Math.PI) / 180);
	    };
	    /**
	     * Returns the distance of 1 meter in `MercatorPoint` units at this latitude.
	     *
	     * For coordinates in real world units using meters, this naturally provides the scale
	     * to transform into `MercatorPoint`s.
	     *
	     * @returns {number} Distance of 1 meter in `MercatorPoint` units.
	     */
	    MercatorPoint.meterInMercatorUnits = function (latitude) {
	        // 1 meter / circumference at equator in meters * Mercator projection scale factor at this latitude
	        return ((1 / MercatorPoint.earthCircumference) *
	            MercatorPoint.mercatorScale(MercatorPoint._latToMercatorY(latitude)));
	    };
	    /***********************************
	     * Private static functions
	     ***********************************/
	    /*
	     * The circumference at a line of latitude in meters.
	     */
	    MercatorPoint._circumferenceAtLatitude = function (latitude) {
	        return MercatorPoint.earthCircumference * Math.cos((latitude * Math.PI) / 180);
	    };
	    MercatorPoint._altitudeToMercatorZ = function (altitude, latitude) {
	        return altitude / MercatorPoint._circumferenceAtLatitude(latitude);
	    };
	    MercatorPoint._mercatorZToAltitude = function (zoom, y) {
	        return zoom * MercatorPoint._circumferenceAtLatitude(MercatorPoint._latToMercatorY(y));
	    };
	    MercatorPoint._latToMercatorY = function (y) {
	        return (180 - (180 / Math.PI) * Math.log(Math.tan(Math.PI / 4 + (y * Math.PI) / 360))) / 360;
	    };
	    /*
	     * The average circumference of the world in meters.
	     */
	    MercatorPoint.earthCircumference = 2 * Math.PI * getEarthRadius(); // meters
	    return MercatorPoint;
	}(Array));

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoundingBox: BoundingBox,
		Feature: Feature,
		FeatureCollection: FeatureCollection,
		GeometryCollection: GeometryCollection,
		LineString: LineString,
		MercatorPoint: MercatorPoint,
		MultiLineString: MultiLineString,
		MultiPoint: MultiPoint,
		MultiPolygon: MultiPolygon,
		Point: Point,
		Polygon: Polygon,
		Position: Position
	});

	function getAddedSquaresAP(dx, dy) {
	    return dx * dx + dy * dy;
	}
	function getSqDistAP(p1, p2) {
	    return getAddedSquaresAP(p1[0] - p2[0], p1[1] - p2[1]);
	}
	function getSqSegDistAP(p, p1, p2) {
	    var x = p1[0], y = p1[1], dx = p2[0] - x, dy = p2[1] - y;
	    if (dx !== 0 || dy !== 0) {
	        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / getAddedSquaresAP(dx, dy);
	        if (t > 1) {
	            x = p2[0];
	            y = p2[1];
	        }
	        else if (t > 0) {
	            x += dx * t;
	            y += dy * t;
	        }
	    }
	    return getAddedSquaresAP(p[0] - x, p[1] - y);
	}
	function simplifyRadialDistAP(points, sqTolerance) {
	    var prevPoint = points[0], point;
	    var newPoints = [prevPoint];
	    for (var i = 1, len = points.length; i < len; i++) {
	        point = points[i];
	        if (getSqDistAP(point, prevPoint) > sqTolerance) {
	            newPoints.push(point);
	            prevPoint = point;
	        }
	    }
	    if (prevPoint !== point) {
	        newPoints.push(point);
	    }
	    return newPoints;
	}
	function simplifyDPStepAP(points, first, last, sqTolerance, simplified) {
	    var maxSqDist = sqTolerance, index;
	    for (var i = first + 1; i < last; i++) {
	        var sqDist = getSqSegDistAP(points[i], points[first], points[last]);
	        if (sqDist > maxSqDist) {
	            index = i;
	            maxSqDist = sqDist;
	        }
	    }
	    if (maxSqDist > sqTolerance) {
	        if (index - first > 1) {
	            simplifyDPStepAP(points, first, index, sqTolerance, simplified);
	        }
	        simplified.push(points[index]);
	        if (last - index > 1) {
	            simplifyDPStepAP(points, index, last, sqTolerance, simplified);
	        }
	    }
	}
	function simplifyDouglasPeuckerAP(points, sqTolerance) {
	    var last = points.length - 1;
	    var simplified = [points[0]];
	    simplifyDPStepAP(points, 0, last, sqTolerance, simplified);
	    simplified.push(points[last]);
	    return simplified;
	}
	function SimplifyAP(points, tolerance, highestQuality) {
	    if (tolerance === void 0) { tolerance = 1; }
	    if (highestQuality === void 0) { highestQuality = false; }
	    if (points.length <= 2) {
	        return points;
	    }
	    var sqTolerance = tolerance * tolerance;
	    points = highestQuality ? points : simplifyRadialDistAP(points, sqTolerance);
	    points = simplifyDouglasPeuckerAP(points, sqTolerance);
	    return points;
	}
	var SimplifyAP_1 = SimplifyAP;

	/**
	 * Perform a Douglas-Peucker simplification on an array of positions or pixels.
	 * @param points The position or pixel points to simplify.
	 * @param tolerance A tolerance to use in the simplification.
	 * @returns A new array of the simplified set of points.
	 */
	function simplify(points, tolerance) {
	    //Perform a Douglas-Peucker simplification of the pixels.
	    return SimplifyAP_1(points, tolerance, true);
	}

	var __values$f = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * An Affine Transform class generated from a set of reference points.
	 */
	var AffineTransform = /** @class */ (function () {
	    /**
	     * An Affine Transform class generated from a set of reference points.
	     * @param source A set of reference points from the source reference system to transform from.
	     * @param target A set of reference points from the target reference system to transform to.
	     */
	    function AffineTransform(source, target) {
	        this.M = AffineTransform._calculateAffineTransform(source, target);
	        this.inverseM = AffineTransform._calculateAffineTransform(target, source);
	    }
	    /**
	     * Converts an array of points from the source reference system to the target reference system.
	     * @param sourcePoints An array of points from the source reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the target reference system.
	     */
	    AffineTransform.prototype.toTarget = function (sourcePoints, decimals) {
	        if (typeof sourcePoints !== undefined) {
	            return this.transformArray(sourcePoints, this.M, decimals);
	        }
	        throw new Error("Invalid sourcePoints specified.");
	    };
	    /**
	     * Converts an array of points from the target reference system to the source reference system.
	     * @param targetPoints An array of points from the target reference system to transform.
	     * @param decimals Number of decimal places to round the results off to.
	     * @returns An array of points that have been transformed to the source reference system.
	     */
	    AffineTransform.prototype.toSource = function (targetPoints, decimals) {
	        if (typeof targetPoints !== undefined) {
	            return this.transformArray(targetPoints, this.inverseM, decimals);
	        }
	        throw new Error("Invalid targetPoints specified.");
	    };
	    /**
	     * Applies a transform matrix over a set of points and optionally rounds off the values to a specified number of decimals.
	     * @param points The array of points to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transformArray = function (points, transformMatrix, decimals) {
	        var e_1, _a;
	        if (points && Array.isArray(points) && Array.isArray(points[0])) {
	            var pos = [];
	            try {
	                for (var points_1 = __values$f(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
	                    var subPoints = points_1_1.value;
	                    pos.push(this.transform(subPoints, transformMatrix, decimals));
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	            return pos;
	        }
	        return null;
	    };
	    /**
	     * Applies a transform matrix on a point and optionally rounds off the values to a specified number of decimals.
	     * @param point The point to transform.
	     * @param transformMatrix The transform matrix to apply.
	     * @param decimals The number of decimals to round each calculated point value off to.
	     * @returns An array of points that have been transformed.
	     */
	    AffineTransform.prototype.transform = function (point, transformMatrix, decimals) {
	        var x = point[0] * transformMatrix[0][3] + point[1] * transformMatrix[1][3] + transformMatrix[2][3];
	        var y = point[0] * transformMatrix[0][4] + point[1] * transformMatrix[1][4] + transformMatrix[2][4];
	        return typeof decimals === "number" && decimals >= 0 ?
	            [_precision(x, decimals), _precision(y, decimals)] :
	            [_precision(x, 6), _precision(y, 6)];
	    };
	    /**
	     * Takes in a set of source and target points can calculates an approximate Affine Transform matrix that best fits the data.
	     * Modified version of this code: https://github.com/commenthol/affinefit
	     * @param sourcePoints A set of source points to transform from.
	     * @param targetPoints A set of target points to transform to.
	     * @returns An Affine Tranform matrix.
	     */
	    AffineTransform._calculateAffineTransform = function (sourcePoints, targetPoints) {
	        if (sourcePoints.length !== targetPoints.length || sourcePoints.length < 1) {
	            throw new Error("Error: source and target arrays must have the same length.");
	        }
	        // Use the smallest dimension of the input.
	        var dim = Math.min(sourcePoints[0].length, targetPoints[0].length);
	        var dimPlusOne = dim + 1;
	        if (sourcePoints.length < dim) {
	            throw new Error("Erorr: At least " + dim + " reference points required.");
	        }
	        // Create an empty (dim + 1) x (dim) matrix and fill it.
	        var c = [];
	        var transformMatrix = [];
	        for (var i = 0; i < dimPlusOne; i++) {
	            transformMatrix[i] = [];
	            for (var j = 0; j < dimPlusOne; j++) {
	                if (j < dim) {
	                    c[j] = 0;
	                }
	                transformMatrix[i][j] = 0;
	                for (var k = 0; k < sourcePoints.length; k++) {
	                    if (j < dim) {
	                        if (i < dim) {
	                            c[j] += sourcePoints[k][i] * targetPoints[k][j];
	                        }
	                        else {
	                            c[j] += targetPoints[k][j];
	                        }
	                    }
	                    if (i >= dim && j >= dim) {
	                        transformMatrix[i][j] += 1;
	                    }
	                    else if (i >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][j];
	                    }
	                    else if (j >= dim) {
	                        transformMatrix[i][j] += sourcePoints[k][i];
	                    }
	                    else {
	                        transformMatrix[i][j] += sourcePoints[k][i] * sourcePoints[k][j];
	                    }
	                }
	            }
	            transformMatrix[i] = transformMatrix[i].concat(c);
	        }
	        if (!this._gaussJordanElimination(transformMatrix)) {
	            throw new Error("Error: Singular matrix. Points are likely coplanar.");
	        }
	        return transformMatrix;
	    };
	    /**
	     * Puts a given matrix (2D array) into the Reduced Row Echelon Form.
	     * Returns True if successful, False if the transformMatrix is singular.
	     * Code from: https://github.com/commenthol/affinefit
	     * Modification:
	     * 1. Updated epsilon from 1e-10 to 1e-12 to reduce the possibility of valid matrix detected as singular
	     *    (can happen when points to convert are too close to each other on high LODs)
	     */
	    AffineTransform._gaussJordanElimination = function (transformMatrix) {
	        var eps = 1e-12; // 1.0 / Math.pow(10, 12)
	        var dimPlusOne = transformMatrix.length;
	        var w = 2 * dimPlusOne - 1;
	        var tempNum;
	        var tempArray;
	        for (var j = 0; j < dimPlusOne; j++) {
	            var maxrow = j;
	            for (var i = j + 1; i < dimPlusOne; i++) {
	                // Find max pivot.
	                if (Math.abs(transformMatrix[i][j]) > Math.abs(transformMatrix[maxrow][j])) {
	                    maxrow = i;
	                }
	            }
	            tempArray = transformMatrix[maxrow];
	            transformMatrix[maxrow] = transformMatrix[j];
	            transformMatrix[j] = tempArray;
	            if (Math.abs(transformMatrix[j][j]) <= eps) {
	                // Is Singular?
	                return false;
	            }
	            for (var _j = j + 1; _j < dimPlusOne; _j++) {
	                // Eliminate column y.
	                tempNum = transformMatrix[_j][j] / transformMatrix[j][j];
	                for (var _i = j; _i < w; _i++) {
	                    transformMatrix[_j][_i] -= transformMatrix[j][_i] * tempNum;
	                }
	            }
	        }
	        for (var j = dimPlusOne - 1; j > -1; j--) {
	            // Backsubstitute.
	            tempNum = transformMatrix[j][j];
	            for (var i = 0; i < j; i++) {
	                for (var _x = w - 1; _x > j - 1; _x--) {
	                    transformMatrix[i][_x] -= transformMatrix[j][_x] * transformMatrix[i][j] / tempNum;
	                }
	            }
	            transformMatrix[j][j] /= tempNum;
	            for (var _x2 = dimPlusOne; _x2 < w; _x2++) {
	                // Normalize row y.
	                transformMatrix[j][_x2] /= tempNum;
	            }
	        }
	        return true;
	    };
	    return AffineTransform;
	}());

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get AccelerationUnits () { return AccelerationUnits; },
		AffineTransform: AffineTransform,
		get AreaUnits () { return AreaUnits; },
		get DistanceUnits () { return DistanceUnits; },
		get SpeedUnits () { return SpeedUnits; },
		get TimeUnits () { return TimeUnits; },
		WEBMERCATOR_MAXLAT: WEBMERCATOR_MAXLAT,
		_precision: _precision,
		boundingBoxToPolygon: boundingBoxToPolygon,
		convertAcceleration: convertAcceleration,
		convertArea: convertArea,
		convertDistance: convertDistance,
		convertSpeed: convertSpeed,
		convertTimespan: convertTimespan,
		getAcceleration: getAcceleration,
		getAccelerationFromFeatures: getAccelerationFromFeatures,
		getAccelerationFromSpeeds: getAccelerationFromSpeeds,
		getArea: getArea,
		getCardinalSpline: getCardinalSpline,
		getClosestPointOnGeometry: getClosestPointOnGeometry,
		getConvexHull: getConvexHull,
		getDestination: getDestination,
		getDistanceTo: getDistanceTo,
		getEarthRadius: getEarthRadius,
		getGeodesicPath: getGeodesicPath,
		getGeodesicPaths: getGeodesicPaths,
		getHeading: getHeading,
		getLengthOfPath: getLengthOfPath,
		getPathDenormalizedAtAntimerian: getPathDenormalizedAtAntimerian,
		getPathSplitByAntimeridian: getPathSplitByAntimeridian,
		getPixelHeading: getPixelHeading,
		getPointWithHeadingAlongPath: getPointWithHeadingAlongPath,
		getPointsWithHeadingsAlongPath: getPointsWithHeadingsAlongPath,
		getPosition: getPosition,
		getPositionAlongPath: getPositionAlongPath,
		getPositions: getPositions,
		getPositionsAlongPath: getPositionsAlongPath,
		getRegularPolygonPath: getRegularPolygonPath,
		getRegularPolygonPaths: getRegularPolygonPaths,
		getSpeed: getSpeed,
		getSpeedFromFeatures: getSpeedFromFeatures,
		getTimespan: getTimespan,
		getTravelDistance: getTravelDistance,
		interpolate: interpolate,
		mercatorPixelsToPositions: mercatorPixelsToPositions,
		mercatorPositionsToPixels: mercatorPositionsToPixels,
		normalizeLatitude: normalizeLatitude,
		normalizeLongitude: normalizeLongitude,
		parseTimestamp: parseTimestamp,
		rotatePositions: rotatePositions,
		simplify: simplify
	});

	var __extends$10 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a ZoomControl object.
	 */
	var ZoomControlOptions = /** @class */ (function (_super) {
	    __extends$10(ZoomControlOptions, _super);
	    function ZoomControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The extent to which the map will zoom with each click of the control.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoomDelta = 1;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`.
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        return _this;
	    }
	    return ZoomControlOptions;
	}(Options));

	var __extends$$ = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control for changing the zoom of the map.
	 */
	var ZoomControl = /** @class */ (function (_super) {
	    __extends$$(ZoomControl, _super);
	    /**
	     * Constructs a ZoomControl.
	     * @param options The options for the control.
	     */
	    function ZoomControl(options) {
	        var _this = _super.call(this) || this;
	        _this.container = null;
	        _this.zoomInButton = null;
	        _this.zoomOutButton = null;
	        _this.zoomChanged = function (event) { return _this.updateZoomButtonsState(); };
	        _this.minZoomChanged = function (zoom) { return _this.updateZoomButtonsState(); };
	        _this.maxZoomChanged = function (zoom) { return _this.updateZoomButtonsState(); };
	        _this.options = new ZoomControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    ZoomControl.prototype.onAdd = function (map) {
	        this.container = this.buildContainer(map, this.options.style, "Zoom Control");
	        this.container.style.flexDirection = "column";
	        this.zoomInButton = this.constructZoomInButton(map);
	        this.zoomOutButton = this.constructZoomOutButton(map);
	        var tooltipZoomIn = buildAccessibleTooltip("Zoom In");
	        var tooltipZoomOut = buildAccessibleTooltip("Zoom Out");
	        this.container.appendChild(this.zoomInButton);
	        this.container.appendChild(tooltipZoomIn);
	        this.container.appendChild(this.zoomOutButton);
	        this.container.appendChild(tooltipZoomOut);
	        positionTooltip(tooltipZoomIn, this.zoomInButton);
	        positionTooltip(tooltipZoomOut, this.zoomOutButton);
	        map.events.add('zoom', this.zoomChanged);
	        map.events.add('minzoomchanged', this.minZoomChanged);
	        map.events.add('maxzoomchanged', this.maxZoomChanged);
	        this.map = map;
	        return this.container;
	    };
	    ZoomControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        if (this.map) {
	            this.map.events.remove('zoom', this.zoomChanged);
	            this.map.events.remove('minzoomchanged', this.minZoomChanged);
	            this.map.events.remove('maxzoomchanged', this.maxZoomChanged);
	            this.map = null;
	        }
	        if (this.container) {
	            this.container.remove();
	            this.container = null;
	            this.zoomInButton = null;
	            this.zoomOutButton = null;
	        }
	    };
	    ZoomControl.prototype.updateZoomButtonsState = function () {
	        var zoomInDisabled = this.map.getCamera().zoom >= this.map._getMap().getMaxZoom();
	        // small values need special handling, since depending on the height of the map view
	        // the actual zoom we can zoom out to can be above or below 0 when the entire map fits the height into the view
	        // use web mercator bounds to check if entire latitude range is visible
	        var reachedLatitudeBoundaries = BoundingBox.getSouth(this.map.getCamera().bounds) <= -WEBMERCATOR_MAXLAT
	            && BoundingBox.getNorth(this.map.getCamera().bounds) >= WEBMERCATOR_MAXLAT;
	        var zoomOutDisabled = this.map.getCamera().zoom <= this.map._getMap().getMinZoom() || reachedLatitudeBoundaries;
	        if (this.zoomInButton && this.zoomInButton.disabled != zoomInDisabled) {
	            this.zoomInButton.disabled = zoomInDisabled;
	            this.zoomInButton.setAttribute("aria-label", zoomInDisabled ? "Zoom In disabled" : "Zoom In");
	        }
	        if (this.zoomOutButton && this.zoomOutButton.disabled != zoomOutDisabled) {
	            this.zoomOutButton.disabled = zoomOutDisabled;
	            this.zoomOutButton.setAttribute("aria-label", zoomInDisabled ? "Zoom Out disabled" : "Zoom Out");
	        }
	    };
	    ZoomControl.prototype.constructZoomInButton = function (map) {
	        var _this = this;
	        var zoomInButton = document.createElement("button");
	        zoomInButton.classList.add("azure-maps-control-button");
	        zoomInButton.classList.add("zoom-in");
	        zoomInButton.setAttribute("aria-label", "Zoom In");
	        zoomInButton.setAttribute("alt", "Zoom In");
	        zoomInButton.setAttribute("type", "button");
	        zoomInButton.addEventListener("click", function () {
	            var _a;
	            map.setCamera({
	                maxBounds: (_a = map._getMap().getMaxBounds()) === null || _a === void 0 ? void 0 : _a.toArray().flat(),
	                zoom: map.getCamera().zoom + _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomInButton;
	    };
	    ZoomControl.prototype.constructZoomOutButton = function (map) {
	        var _this = this;
	        var zoomOutButton = document.createElement("button");
	        zoomOutButton.classList.add("azure-maps-control-button");
	        zoomOutButton.classList.add("zoom-out");
	        zoomOutButton.setAttribute("aria-label", "Zoom Out");
	        zoomOutButton.setAttribute("alt", "Zoom Out");
	        zoomOutButton.setAttribute("type", "button");
	        zoomOutButton.addEventListener("click", function () {
	            var _a;
	            map.setCamera({
	                maxBounds: (_a = map._getMap().getMaxBounds()) === null || _a === void 0 ? void 0 : _a.toArray().flat(),
	                zoom: map.getCamera().zoom - _this.options.zoomDelta,
	                duration: ZoomControl.ZOOM_DURATION_MS,
	                type: "ease",
	            }, true);
	        });
	        return zoomOutButton;
	    };
	    ZoomControl.ZOOM_DURATION_MS = 200;
	    return ZoomControl;
	}(ControlBase));

	var __extends$_ = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a FullscreenControl object.
	 */
	var FullscreenControlOptions = /** @class */ (function (_super) {
	    __extends$_(FullscreenControlOptions, _super);
	    function FullscreenControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The style of the control.
	         * Default `ControlStyle.light`
	         * @default ControlStyle.light
	         */
	        _this.style = exports.ControlStyle.light;
	        /**
	         * Indicates if the control should be hidden if the browser does not support fullscreen mode.
	         * Default `false`
	         * @default false
	         */
	        _this.hideIfUnsupported = false;
	        /**
	         * The HTML element which should be made full screen.
	         * If not specified, the map container element will be used.
	         */
	        _this.container = undefined;
	        return _this;
	    }
	    return FullscreenControlOptions;
	}(Options));

	var __extends$Z = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control to make the map or a specified element fullscreen.
	 */
	var FullscreenControl = /** @class */ (function (_super) {
	    __extends$Z(FullscreenControl, _super);
	    /**
	     * A control to make the map or a specified element fullscreen.
	     * @param options Options for defining how the control is rendered and the container to be made fullscreen.
	     */
	    function FullscreenControl(options) {
	        var _this = _super.call(this) || this;
	        _this.map = null;
	        _this.isFullscreenState = false;
	        _this.options = new FullscreenControlOptions().merge(options);
	        _this.control = new maplibregl.FullscreenControl({
	            container: _this.options.container,
	        });
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    FullscreenControl.prototype.onAdd = function (map) {
	        var _this = this;
	        var _a, _b;
	        this.map = map;
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.addControl(this.control);
	        var container = this.buildContainer(map, this.options.style, "Fullscreen Control");
	        var fullscreenButton = this.control._fullscreenButton;
	        if (fullscreenButton) {
	            var icon_1 = fullscreenButton.querySelector("span");
	            if (icon_1) {
	                var tooltip_1 = buildAccessibleTooltip("Enter Fullscreen");
	                container.appendChild(fullscreenButton);
	                // Add classes for styling.
	                fullscreenButton.classList.add("azure-maps-control-button", "fullscreen");
	                icon_1.classList.add("fullscreen-icon", "fullscreen-end");
	                // Add the tooltip and prevent the default one set by Maplibre.
	                fullscreenButton.removeAttribute("title"); // A title attribute will be converted to a tooltip by the browser.
	                container.appendChild(tooltip_1);
	                positionTooltip(tooltip_1, fullscreenButton);
	                // Update the icon and the tooltip based on the fullscreen state.
	                this.control.on("fullscreenstart", function () {
	                    // Remove the title attribute added automatically whenever fullscreen event is fired
	                    fullscreenButton.removeAttribute("title");
	                    icon_1.classList.remove("fullscreen-end");
	                    icon_1.classList.add("fullscreen-start");
	                    tooltip_1.innerText = "Exit Fullscreen";
	                    _this.isFullscreenState = true;
	                });
	                this.control.on("fullscreenend", function () {
	                    fullscreenButton.removeAttribute("title");
	                    icon_1.classList.remove("fullscreen-start");
	                    icon_1.classList.add("fullscreen-end");
	                    tooltip_1.innerText = "Enter Fullscreen";
	                    _this.isFullscreenState = false;
	                });
	            }
	        }
	        // Invisiblize the control if the browser does not support fullscreen mode.
	        if (this.options.hideIfUnsupported && !FullscreenControl.isSupported()) {
	            container.style.display = "none";
	        }
	        return container;
	    };
	    /**
	     * Method that is called when the control is removed from the map. Should perform any necessary cleanup for the
	     * control.
	     */
	    FullscreenControl.prototype.onRemove = function () {
	        var _a, _b;
	        _super.prototype.onRemove.call(this);
	        (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a._getMap()) === null || _b === void 0 ? void 0 : _b.removeControl(this.control);
	        this.map = null;
	    };
	    /**
	     * Gets the current fullscreen state of the map.
	     * @returns A boolean indicating if the map is in fullscreen mode.
	     */
	    FullscreenControl.prototype.isFullscreen = function () {
	        return this.isFullscreenState;
	    };
	    /**
	     * Checks to see if the browser supports going into fullscreen mode.
	     * @returns A boolean indicating if the browser supports fullscreen mode.
	     */
	    FullscreenControl.isSupported = function () {
	        var d = document;
	        return d['fullscreenEnabled'] ||
	            d['msFullscreenEnabled'] ||
	            d['mozFullScreenEnabled'] ||
	            d['webkitFullscreenEnabled'];
	    };
	    return FullscreenControl;
	}(ControlBase));

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		CompassControl: CompassControl,
		ControlBase: ControlBase,
		FullscreenControl: FullscreenControl,
		PitchControl: PitchControl,
		ScaleControl: ScaleControl,
		StyleControl: StyleControl,
		TrafficControl: TrafficControl,
		TrafficLegendControl: TrafficLegendControl,
		ZoomControl: ZoomControl
	});

	var baseClone = _baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.cloneWith` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.cloneWith
	 * @example
	 *
	 * function customizer(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * }
	 *
	 * var el = _.cloneDeepWith(document.body, customizer);
	 *
	 * console.log(el === document.body);
	 * // => false
	 * console.log(el.nodeName);
	 * // => 'BODY'
	 * console.log(el.childNodes.length);
	 * // => 20
	 */
	function cloneDeepWith(value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	}

	var cloneDeepWith_1 = cloneDeepWith;

	var cloneDeepWith$1 = /*@__PURE__*/getDefaultExportFromCjs(cloneDeepWith_1);

	/**
	 * A hidden HTML element that is used to provide accessibility to shapes such as bubble.
	 */
	var AccessibleIndicator = /** @class */ (function () {
	    /**
	     * Constructs an AccessibleIndicator object by initializing a hidden `div` element.
	     * @internal
	     */
	    function AccessibleIndicator(options) {
	        var _this = this;
	        /**
	         * Attaches the indicator to the HTML document in a hidden style.
	         * @param map The map.
	         */
	        this.attach = function (map) {
	            // If attaching to a different map, remove popup on current map
	            if (_this.map !== map) {
	                // If map was defined the indicator was attached to another map.
	                if (_this.map) {
	                    _this.detachFromCurrentMap();
	                }
	                _this.map = map;
	                _this.map.indicators._getCollectionDiv().appendChild(_this.element);
	                _this.map.indicators.add(_this);
	            }
	        };
	        /**
	         * Removes the indicator from the map and the HTML document.
	        */
	        this.remove = function () {
	            _this.detachFromCurrentMap();
	            _this.element.remove();
	        };
	        /**
	         * Get the DOM element of the indicator.
	         * @returns The DOM element of the indicator.
	         */
	        this.getElement = function () {
	            return _this.element;
	        };
	        this.detachFromCurrentMap = function () {
	            if (_this.map) {
	                _this.map.indicators.remove(_this);
	                delete _this.map;
	            }
	        };
	        this.element = document.createElement("div");
	        // Set tabindex to 0 to make the element focusable.
	        this.element.setAttribute("tabindex", "0");
	        // Set the role to option, and it's container to listbox so the reader will read the listbox as a list.
	        // For example, NVDA will read "data point, {posinset} of {setsize}" when the indicator is focused.
	        this.element.setAttribute("role", "option");
	        if (options === null || options === void 0 ? void 0 : options.setSize)
	            this.element.setAttribute("aria-setsize", options.setSize.toString());
	        if (options === null || options === void 0 ? void 0 : options.positionInSet)
	            this.element.setAttribute("aria-posinset", options.positionInSet.toString());
	        this.element.setAttribute("aria-label", "data point");
	        this.element.classList.add(AccessibleIndicator.Css.hidden);
	    }
	    // CSS class names.
	    AccessibleIndicator.Css = {
	        hidden: "hidden-accessible-element"
	    };
	    return AccessibleIndicator;
	}());

	var __extends$Y = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `DataSourceOptions`.
	 * @module Object Definitions
	 */
	var DataSourceOptions = /** @class */ (function (_super) {
	    __extends$Y(DataSourceOptions, _super);
	    function DataSourceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /*
	         * The size of the buffer around each tile.
	         * A buffer value of 0 will provide better performance but will be more likely to generate artifacts when rendering.
	         * Larger buffers will produce left artifacts but will result in slower performance.
	         */
	        _this.buffer = 128;
	        /**
	         * Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels).
	         * default `18`
	         * @default 18
	         */
	        _this.maxZoom = 18;
	        /**
	         * A boolean indicating if Point features in the source should be clustered or not.
	         * If set to true, points will be clustered together into groups by radius.
	         * default `false`
	         * @default false
	         */
	        _this.cluster = false;
	        /**
	         * The radius of each cluster in pixels.
	         * default `50`
	         * @default 50
	         */
	        _this.clusterRadius = 50;
	        /**
	         * The maximum zoom level in which to cluster points.
	         * Defaults to one zoom less than `maxZoom` so that last zoom features are not clustered.
	         */
	        _this.clusterMaxZoom = undefined;
	        /**
	         * Defines custom properties that are calculated using expressions against all the points within each cluster and added to the properties of each cluster point.
	         */
	        _this.clusterProperties = undefined;
	        /**
	         * Specifies whether to calculate line distance metrics.
	         * This is required for line layers that specify `lineGradient` values.
	         * default `false`
	         * @default false
	         */
	        _this.lineMetrics = false;
	        /**
	         * The Douglas-Peucker simplification tolerance that is applied to the data when rendering (higher means simpler geometries and faster performance).
	         * default `0.375`
	         * @default 0.375
	         */
	        _this.tolerance = 0.375;
	        /**
	         * Minimum number of points necessary to form a cluster if clustering is enabled.
	         * @default 2
	         */
	        _this.clusterMinPoints = 2;
	        /**
	         * Whether to generate ids for the geojson features. When enabled, the feature.id property will be auto assigned based on its index in the features array, over-writing any previous values.
	         */
	        _this.generateId = false;
	        /**
	         * A specified property name to be used as a feature ID (for feature state).
	         * This can either be a property name or an object in the form `{<sourceLayer>: <propertyName>}`.
	         */
	        _this.promoteId = undefined;
	        /**
	         * An expression for filtering features prior to processing them for rendering.
	         */
	        _this.filter = undefined;
	        return _this;
	    }
	    return DataSourceOptions;
	}(Options));

	var __extends$X = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A base abstract class in which all other source objects extend.
	 * A source must be added to a layer before it is visible on the map.
	 */
	var Source = /** @class */ (function (_super) {
	    __extends$X(Source, _super);
	    function Source(id) {
	        var _this = _super.call(this) || this;
	        _this.id = id || uuid();
	        return _this;
	    }
	    /**
	     * Gets the id of the data source
	     */
	    Source.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Get reference to Mapbox Map
	     * @internal
	     */
	    Source.prototype._setMap = function (map, shouldInvokeEvent) {
	        if (shouldInvokeEvent === void 0) { shouldInvokeEvent = true; }
	        if (map == null || map === undefined) {
	            var temp = this.map;
	            delete this.map;
	            if (shouldInvokeEvent) {
	                this._invokeEvent("sourceremoved", this);
	                if (temp) {
	                    temp.events.invoke("sourceremoved", this);
	                }
	            }
	        }
	        else {
	            this.map = map;
	            if (shouldInvokeEvent) {
	                this._invokeEvent("sourceadded", this);
	                this.map.events.invoke("sourceadded", this);
	            }
	        }
	    };
	    return Source;
	}(EventEmitter));

	var __extends$W = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$e = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * The DataSource class may be used with the SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, and HeatMapLayer.
	 */
	var DataSource = /** @class */ (function (_super) {
	    __extends$W(DataSource, _super);
	    /**
	     * A data source class that makes it easy to manage shapes data that will be displayed on the map.
	     * A data source must be added to a layer before it is visible on the map.
	     * The `DataSource` class may be used with the `SymbolLayer`, `LineLayer`, `PolygonLayer`, `BubbleLayer`, and `HeatMapLayer`.
	     * @param id a unique id that the user assigns to the data source. If this is not specified, then the data source will automatically be assigned an id.
	     * @param options the options for the data source.
	     */
	    function DataSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.requestId = undefined;
	        _this.options = new DataSourceOptions().merge(cloneDeep$1(options));
	        _this.shapes = [];
	        _this.shapesMap = new Dictionary();
	        return _this;
	    }
	    /**
	     * Adds shapes to the data source.
	     * GeoJSON objects will be wrapped within a Shape class to make them easier to manage.
	     * Optionally specify an index to insert the feature between other shapes/features in the layers.
	     * @param data
	     * @param index
	     */
	    DataSource.prototype.add = function (data, index) {
	        this._addNoUpdate(data, index);
	        this._updateSource();
	    };
	    /**
	     * Removes all data in the data source.
	     */
	    DataSource.prototype.clear = function () {
	        this._clearNoUpdate();
	        this._updateSource();
	    };
	    /**
	     * Cleans up any resources this object is consuming.
	     */
	    DataSource.prototype.dispose = function () {
	        this.options = null;
	        this.shapes = null;
	        this.shapesMap = null;
	        this.map = null;
	    };
	    /*
	     * (P3) Gets the bounding box the encloses all data in the data source.
	     * public getBounds() {}
	     */
	    /**
	     * Calculates a zoom level at which the cluster will start expanding or break apart.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterExpansionZoom = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterExpansionZoom(clusterId)
	                    .then(function (zoom) {
	                    if (typeof zoom === "number") {
	                        resolve(zoom);
	                    }
	                })
	                    .catch(function (error) {
	                    if (error) {
	                        reject(error);
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves the children of the given cluster on the next zoom level. This may be a combination of shapes and sub-clusters.
	     * The sub-clusters will be features with properties matching ClusteredProperties.
	     * @param clusterId
	     */
	    DataSource.prototype.getClusterChildren = function (clusterId) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterChildren(clusterId)
	                    .then(function (features) {
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                    }
	                })
	                    .catch(function (error) {
	                    if (error) {
	                        reject(error);
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Retrieves shapes that are within the cluster.
	     * @param clusterId
	     * @param limit The maximum number of features to return. Set to Infinity to return all shapes.
	     * @param offset The number of shapes to skip. Allows you to page through the shapes in the cluster.
	     */
	    DataSource.prototype.getClusterLeaves = function (clusterId, limit, offset) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            if (!_this.map) {
	                reject("The DataSource hasn't been added to a map.");
	                return;
	            }
	            var mbSource = _this.map._getMap().getSource(_this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.getClusterLeaves(clusterId, limit, offset)
	                    .then(function (features) {
	                    if (features) {
	                        resolve(_this.map.sources._mapFeaturesToShapes(features, false, _this));
	                    }
	                })
	                    .catch(function (error) {
	                    if (error) {
	                        reject(error);
	                        return;
	                    }
	                });
	            }
	        });
	    };
	    /**
	     * Gets the options used by the data source.
	     */
	    DataSource.prototype.getOptions = function () {
	        return cloneDeep$1(this.options);
	    };
	    /**
	     * Returns all shapes that are in the DataSource.
	     */
	    DataSource.prototype.getShapes = function () {
	        return Array.from(this.shapes);
	    };
	    /**
	     * Downloads a GeoJSON document and imports its data into the data source.
	     * The GeoJSON document must be on the same domain or accessible using CORS.
	     * @param url
	     */
	    DataSource.prototype.importDataFromUrl = function (url) {
	        var _this = this;
	        return fetch(url, {
	            method: "GET",
	            mode: "cors"
	        }).then(function (response) {
	            if (response.ok) {
	                return response.json();
	            }
	            else {
	                throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText));
	            }
	        }).then(function (geoJson) {
	            _this.add(geoJson);
	        });
	    };
	    /**
	     * Retrieves a shape with the specified id.
	     * If no shape with the specified id is contained in the data source, null will be return.
	     * @param id The id of the shape to return.
	     */
	    DataSource.prototype.getShapeById = function (id) {
	        return this.shapes[this.shapesMap.get(id)] || null;
	    };
	    /**
	     * Removes one or more shapes from the data source.
	     * If a string is passed in, it is assumed to be an id.
	     * If a number is passed in, removes the shape at that index.
	     * @param shape The shape(s), shape id(s), or feature(s) to be removed
	     */
	    DataSource.prototype.remove = function (shape) {
	        var e_1, _a;
	        var shapes = Array.isArray(shape) ? shape : [shape];
	        try {
	            for (var shapes_1 = __values$e(shapes), shapes_1_1 = shapes_1.next(); !shapes_1_1.done; shapes_1_1 = shapes_1.next()) {
	                var s = shapes_1_1.value;
	                if (typeof s === "number") {
	                    this._removeByIndex(s);
	                }
	                else {
	                    this._removeById(s);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (shapes_1_1 && !shapes_1_1.done && (_a = shapes_1.return)) _a.call(shapes_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        this._updateSource();
	    };
	    /**
	     * Removes one or more shapes from the datasource based on its id.
	     * @param shape shape id
	     */
	    DataSource.prototype.removeById = function (id) {
	        var e_2, _a;
	        var ids = Array.isArray(id) ? id : [id];
	        try {
	            for (var ids_1 = __values$e(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
	                var i = ids_1_1.value;
	                this._removeById(i);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        this._updateSource();
	    };
	    /**
	     * Sets the data source options.
	     * The data source will retain its current values for any option not specified in the supplied options.
	     * @param options the DataSourceOptions to be set
	     */
	    DataSource.prototype.setOptions = function (options) {
	        var newOptions = new DataSourceOptions().merge(this.options, cloneDeep$1(options));
	        // Only rebuild the map's style if a options has actually changed.
	        if (!isEqual$1(this.options, newOptions)) {
	            this._invokeEvent("datasourceupdated", this);
	            // Update the options before rebuilding.
	            this.options = newOptions;
	            if (this.map) {
	                this.map._rebuildStyle();
	            }
	        }
	    };
	    /**
	     * Overwrites all shapes in the data source with the new array of shapes.
	     * @param shape the new shapes to update
	     */
	    DataSource.prototype.setShapes = function (shape) {
	        this._clearNoUpdate();
	        this.add(shape);
	    };
	    /**
	     * Returns a GeoJSON FeatureCollection which contains all the shape data that is in the data source.
	     */
	    DataSource.prototype.toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape.toJson(); }));
	    };
	    /**
	     * Just like the toJson() function but will return a polygon feature
	     * for any circles as defined by the extended GeoJSON spec.
	     * [Extended Spec]{@link https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson}
	     * @internal
	     */
	    DataSource.prototype._toJson = function () {
	        return new FeatureCollection(this.shapes.map(function (shape) { return shape._toJson(); }));
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._buildSource = function () {
	        var geoJsonSource = {
	            type: "geojson",
	            data: this._toJson(),
	            maxzoom: this.options.maxZoom,
	            cluster: this.options.cluster,
	            clusterRadius: this.options.clusterRadius,
	            tolerance: this.options.tolerance,
	            lineMetrics: this.options.lineMetrics,
	            clusterProperties: this.options.clusterProperties,
	            buffer: this.options.buffer,
	            clusterMinPoints: this.options.clusterMinPoints,
	            generateId: this.options.generateId,
	            promoteId: this.options.promoteId,
	            filter: this.options.filter
	        };
	        if (typeof this.options.clusterMaxZoom === "number") {
	            geoJsonSource.clusterMaxZoom = this.options.clusterMaxZoom;
	        }
	        return geoJsonSource;
	    };
	    DataSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this._buildSource();
	        var otherSource = other._buildSource();
	        return source.type === otherSource.type &&
	            // no data comparison since it is costly and not needed. If geojson data is different, but other source properties are same, we treat it as an update.
	            //source.data === otherSource.data &&
	            source.maxzoom === otherSource.maxzoom &&
	            source.cluster === otherSource.cluster &&
	            source.clusterRadius === otherSource.clusterRadius &&
	            source.tolerance === otherSource.tolerance &&
	            source.lineMetrics === otherSource.lineMetrics &&
	            JSON.stringify(source.clusterProperties) === JSON.stringify(otherSource.clusterProperties) &&
	            source.buffer === otherSource.buffer &&
	            source.clusterMinPoints === otherSource.clusterMinPoints &&
	            source.generateId === otherSource.generateId &&
	            source.promoteId === otherSource.promoteId &&
	            source.filter === otherSource.filter;
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._addNoUpdate = function (data, index) {
	        var newShapes;
	        if (data instanceof Shape) {
	            this._addToSources(data, index);
	            newShapes = [data];
	        }
	        else if (Array.isArray(data)) {
	            newShapes = data.map(function (ele) { return ele instanceof Shape ? ele : new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "FeatureCollection") {
	            newShapes = data.features.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else if (data.type === "GeometryCollection") {
	            newShapes = data.geometries.map(function (ele) { return new Shape(ele); });
	            this._addToSources(newShapes, index);
	        }
	        else {
	            // Either a Feature or Geometry.
	            // The Shape constructor can handle either.
	            var shape = new Shape(data);
	            this._addToSources(shape, index);
	            newShapes = [shape];
	        }
	        // Invoke the dataadded event once all the new features have been wrapped with shapes.
	        this._invokeEvent("dataadded", newShapes);
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._clearNoUpdate = function () {
	        var oldShapes = this.shapes;
	        this.shapes = [];
	        this.shapesMap = new Dictionary();
	        // If any shapes were removed fire the dataremoved event.
	        if (oldShapes && oldShapes.length > 0) {
	            this._invokeEvent("dataremoved", oldShapes);
	        }
	    };
	    /**
	     * @internal
	     */
	    DataSource.prototype._updateSource = function () {
	        var _this = this;
	        // throttling logic that makes DataSource waits a small amount of time before rerendering the map, so the browser won't get frozen
	        // when there is too much data
	        if (this.requestId !== undefined) {
	            return;
	        }
	        else {
	            this.requestId = requestAnimationFrame(function () {
	                _this._updateMboxSource();
	                _this.requestId = undefined;
	            });
	        }
	    };
	    DataSource.prototype._addToSources = function (data, index) {
	        var e_3, _a, e_4, _b;
	        data = Array.isArray(data) ? data : [data];
	        if (typeof index !== "number") {
	            try {
	                for (var data_1 = __values$e(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
	                    var d = data_1_1.value;
	                    this.shapes.push(d);
	                    this.shapesMap.set(d.getId(), this.shapes.length - 1);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	        }
	        else {
	            for (var i = data.length - 1; i >= 0; i--) {
	                this.shapes.splice(index, 0, data[i]);
	                this._updateShapesMap(index);
	            }
	        }
	        try {
	            for (var data_2 = __values$e(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
	                var d = data_2_1.value;
	                d._setDataSource(this);
	            }
	        }
	        catch (e_4_1) { e_4 = { error: e_4_1 }; }
	        finally {
	            try {
	                if (data_2_1 && !data_2_1.done && (_b = data_2.return)) _b.call(data_2);
	            }
	            finally { if (e_4) throw e_4.error; }
	        }
	    };
	    DataSource.prototype._removeById = function (shape) {
	        var oldShape;
	        var i = shape instanceof Shape ? shape.getId() : typeof shape === "string" || typeof shape === "number" ? shape : shape.id;
	        oldShape = this.shapes[this.shapesMap.get(i)];
	        if (oldShape) {
	            oldShape._setDataSource(null);
	            this.shapes.splice(this.shapesMap.get(i), 1);
	            this._updateShapesMap(this.shapesMap.get(i));
	            this.shapesMap.delete(i);
	            // Invoke the dataremoved event with the single shape removed.
	            this._invokeEvent("dataremoved", [oldShape]);
	        }
	    };
	    DataSource.prototype._removeByIndex = function (i) {
	        var oldShape;
	        if (i >= this.shapes.length) {
	            throw new Error("The specified remove index '".concat(i, "' ") +
	                "is greater than the maximum possible index '".concat(this.shapes.length - 1, "'"));
	        }
	        oldShape = this.shapes[i];
	        this.shapesMap.delete(oldShape.getId());
	        oldShape._setDataSource(null);
	        this.shapes.splice(i, 1);
	        this._updateShapesMap(i);
	        // Invoke the dataremoved event with the single shape removed.
	        this._invokeEvent("dataremoved", [oldShape]);
	    };
	    DataSource.prototype._updateShapesMap = function (index) {
	        for (var i = index; i < this.shapes.length; i++) {
	            this.shapesMap.set(this.shapes[i].getId(), i);
	        }
	    };
	    DataSource.prototype._updateMboxSource = function () {
	        if (this.map && this.map._getMap()) {
	            var mbSource = this.map._getMap().getSource(this.getId());
	            // Double check a source was found and that it is a GeoJSON source.
	            if (mbSource && mbSource.type === "geojson") {
	                mbSource.setData(this._toJson());
	            }
	        }
	    };
	    return DataSource;
	}(Source));

	var __extends$V = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A data source for managing shape data that will be displayed on the map.
	 * A data source must be added to a layer before it is visible on the map.
	 * Options for a `VectorTileSource`.
	 * @module Object Definitions
	 */
	var VectorTileSourceOptions = /** @class */ (function (_super) {
	    __extends$V(VectorTileSourceOptions, _super);
	    function VectorTileSourceOptions() {
	        /*
	         * TODO:
	         * (P4) An attribute to display to the user when this data source is visible.
	         *
	         * public attribute?: string;
	         */
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         */
	        _this.bounds = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * default `0`
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * default `22`
	         * @default 22
	         */
	        _this.maxZoom = 22;
	        /**
	         * Specifies is the tile systems y coordinate uses the OSGeo Tile Map Services which reverses the Y coordinate axis.
	         * default `false`
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of one or more tile source URLs. Supported URL parameters:
	         *  <ul>
	         *      <li>`{x}` - X position of tile. Tile URL usually also needs {y} and {z}.</li>
	         *      <li>`{y}` - Y position of tile. Tile URL usually also needs {x} and {z}.</li>
	         *      <li>`{z}` - Zoom level of tile. Tile URL usually also needs {x} and {y}.</li>
	         *      <li>`{quadkey}` - Tile quadkey id based on the Bing Maps tile system naming convention.</li>
	         *      <li>`{bbox-epsg-3857}` - A bounding box string with the format "{west},{south},{east},{north}" with coordinates in the EPSG 3857 Spatial Reference System also commonly known as WGS84 Web Mercator. This is useful when working with WMS imagery services.</li>
	         *  <ul>
	         */
	        _this.tiles = undefined;
	        /**
	         * A URL to a TileJSON resource.
	         * Supported protocols are `http:` and `https:`.
	         */
	        _this.url = undefined;
	        return _this;
	    }
	    return VectorTileSourceOptions;
	}(Options));

	var __extends$U = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A vector tile source describes how to access a vector tile layer.
	 * Vector tile sources can be used with; SymbolLayer, LineLayer, PolygonLayer, BubbleLayer, HeatmapLayer and VectorTileLayer.
	 */
	var VectorTileSource = /** @class */ (function (_super) {
	    __extends$U(VectorTileSource, _super);
	    function VectorTileSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new VectorTileSourceOptions().merge(cloneDeep$1(options));
	        return _this;
	    }
	    /**
	     * Gets the options of the VectorTileSource.
	     */
	    VectorTileSource.prototype.getOptions = function () {
	        return cloneDeep$1(this.options);
	    };
	    /**
	     * Returns all GeoJSON features that are in the VectorTileSource and which satisfy the specified filter expression.
	     * @param sourceLayer Required if the source is a VectorTileSource. Specifies the layer within the VectorTileSource to query.
	     * @param filter A filter that will limit the query.
	     */
	    VectorTileSource.prototype.getShape = function (sourceLayer, filter) {
	        return this.map._getMap().querySourceFeatures(this.getId(), { sourceLayer: sourceLayer, filter: filter });
	    };
	    /**
	     * @internal
	     */
	    VectorTileSource.prototype._buildSource = function () {
	        var vectorSource = {
	            type: "vector",
	        };
	        if (this.options.bounds) {
	            vectorSource.bounds = this.options.bounds;
	        }
	        if (this.options.tiles) {
	            vectorSource.tiles = this.options.tiles;
	            vectorSource.minzoom = this.options.minZoom;
	            vectorSource.maxzoom = this.options.maxZoom;
	        }
	        else if (this.options.url) {
	            vectorSource.url = this.options.url;
	        }
	        if (this.options.isTMS) {
	            vectorSource.scheme = "tms";
	        }
	        return vectorSource;
	    };
	    /**
	     * @internal
	     */
	    VectorTileSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this._buildSource();
	        var otherSource = other._buildSource();
	        return source.type === otherSource.type &&
	            source.url === otherSource.url &&
	            ((source.tiles === undefined && otherSource.tiles === undefined) ||
	                (source.tiles && otherSource.tiles && source.tiles.length === otherSource.tiles.length && source.tiles.every(function (value, idx) { return value === otherSource.tiles[idx]; }))) &&
	            source.minzoom === otherSource.minzoom &&
	            source.maxzoom === otherSource.maxzoom &&
	            source.bounds === otherSource.bounds &&
	            source.attribution === otherSource.attribution &&
	            source.promoteId === otherSource.promoteId &&
	            source.scheme === otherSource.scheme;
	    };
	    return VectorTileSource;
	}(Source));

	var __extends$T = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent the canvas source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var CanvasSource = /** @class */ (function (_super) {
	    __extends$T(CanvasSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef Canvas source specification.
	     * @param options Unused for now
	     */
	    function CanvasSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    CanvasSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type
	            && source.canvas === otherSource.canvas
	            && JSON.stringify(source.coordinates) === JSON.stringify(otherSource.coordinates)
	            && source.animate === otherSource.animate;
	    };
	    /**
	     * @internal
	     */
	    CanvasSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return CanvasSource;
	}(Source));

	var __extends$S = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent an unkown source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var UnknownSource = /** @class */ (function (_super) {
	    __extends$S(UnknownSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef source specification.
	     * @param options Unused for now
	     */
	    function UnknownSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    UnknownSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type;
	    };
	    /**
	     * @internal
	     */
	    UnknownSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return UnknownSource;
	}(Source));

	var __extends$R = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent the image source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var ImageSource = /** @class */ (function (_super) {
	    __extends$R(ImageSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef Image source specification.
	     * @param options Unused for now
	     */
	    function ImageSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    ImageSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type
	            && JSON.stringify(source.coordinates) === JSON.stringify(otherSource.coordinates)
	            && source.url === otherSource.url;
	    };
	    /**
	     * @internal
	     */
	    ImageSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return ImageSource;
	}(Source));

	var __extends$Q = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Used to represent the video source wrapper.
	 * This is not meant to be exposed publicly yet
	 * @private
	 */
	var VideoSource = /** @class */ (function (_super) {
	    __extends$Q(VideoSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef Video source specification.
	     * @param options Unused for now
	     */
	    function VideoSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = sourceDef;
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    VideoSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        return source.type === otherSource.type
	            && JSON.stringify(source.coordinates) === JSON.stringify(otherSource.coordinates)
	            && source.urls === otherSource.urls;
	    };
	    /**
	     * @internal
	     */
	    VideoSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    return VideoSource;
	}(Source));

	var __extends$P = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var RasterTileSourceOptions = /** @class */ (function (_super) {
	    __extends$P(RasterTileSourceOptions, _super);
	    function RasterTileSourceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * raster tile pixel size.
	         * default `512`
	         * @default 512
	         */
	        _this.tileSize = 512;
	        return _this;
	    }
	    return RasterTileSourceOptions;
	}(VectorTileSourceOptions));

	var __extends$O = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var ElevationTileSourceOptions = /** @class */ (function (_super) {
	    __extends$O(ElevationTileSourceOptions, _super);
	    function ElevationTileSourceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * DEM tiles encoding format. Supported: `mapbox` or `terrarium`.<br />
	         * `"terrarium": Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info.<br />
	         * `"mapbox": Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info.<br />
	         * default `mapbox`
	         * @default mapbox
	         */
	        _this.encoding = undefined;
	        return _this;
	    }
	    return ElevationTileSourceOptions;
	}(RasterTileSourceOptions));

	var __extends$N = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$a = (window && window.__assign) || function () {
	    __assign$a = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$a.apply(this, arguments);
	};
	/**
	 * Publicly exposed ElevationTileSource.
	 */
	var ElevationTileSource = /** @class */ (function (_super) {
	    __extends$N(ElevationTileSource, _super);
	    function ElevationTileSource(id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new ElevationTileSourceOptions().merge(cloneDeep$1(options));
	        return _this;
	    }
	    /**
	     * Gets the options of the ElevationTileSource.
	     */
	    ElevationTileSource.prototype.getOptions = function () {
	        return cloneDeep$1(this.options);
	    };
	    ElevationTileSource.prototype._buildSource = function () {
	        var t = __assign$a({ type: "raster-dem", bounds: this.options.bounds, minzoom: this.options.minZoom, maxzoom: this.options.maxZoom, tileSize: this.options.tileSize, encoding: this.options.encoding }, (!this.options.tiles ? { url: this.options.url } : { tiles: this.options.tiles }));
	        return t;
	    };
	    ElevationTileSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var otherOptions = other.getOptions();
	        return this.options.url === otherOptions.url &&
	            this.options.tiles === otherOptions.tiles &&
	            this.options.bounds === otherOptions.bounds &&
	            this.options.minZoom === otherOptions.minZoom &&
	            this.options.maxZoom === otherOptions.maxZoom &&
	            this.options.tileSize === otherOptions.tileSize &&
	            this.options.encoding === otherOptions.encoding;
	    };
	    return ElevationTileSource;
	}(Source));

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		CanvasSource: CanvasSource,
		DataSource: DataSource,
		ElevationTileSource: ElevationTileSource,
		ImageSource: ImageSource,
		Source: Source,
		UnknownSource: UnknownSource,
		VectorTileSource: VectorTileSource,
		VideoSource: VideoSource
	});

	var __extends$M = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Abstract class for other layer classes to extend.
	 */
	var Layer = /** @class */ (function (_super) {
	    __extends$M(Layer, _super);
	    function Layer(id) {
	        var _this = 
	        // Assign an random id using a UUID if none was specified.
	        _super.call(this) || this;
	        _this.id = id || uuid();
	        return _this;
	    }
	    /**
	     * Gets the id of the layer
	     */
	    Layer.prototype.getId = function () {
	        return this.id;
	    };
	    /**
	     * Gets the map that the layer is currently added to, or null.
	     */
	    Layer.prototype.getMap = function () {
	        return this.map || null;
	    };
	    /**
	     * Initialization method for the layer which is called when added to the map.
	     * @param map The map the layer has been added to.
	     */
	    Layer.prototype.onAdd = function (map) {
	        this.map = map;
	        this._invokeEvent("layeradded", this);
	        this.map.events.invoke("layeradded", this);
	    };
	    /**
	     * Method that is called when the layer is removed from the map.
	     * Should perform any necessary cleanup for the layer.
	     */
	    Layer.prototype.onRemove = function () {
	        var temp = this.map;
	        delete this.map;
	        this._invokeEvent("layerremoved", this);
	        if (temp) {
	            temp.events.invoke("layerremoved", this);
	        }
	    };
	    /**
	     * Returns if an event is one specified by Mapbox.
	     * False means we have defined that event.
	     * @internal
	     */
	    Layer._isMBoxEvent = function (eventType) {
	        return !this.LayerEvents.hasOwnProperty(eventType);
	    };
	    /**
	     * Updates the base layout and paint properties.
	     * Covers the follow properties: minZoom, maxZoom, filter, and visible.
	     * @param newOptions The new base layer options.
	     * @internal
	     */
	    Layer.prototype._updateBaseProperties = function (newOptions, oldOptions) {
	        this._updateFilter(newOptions.filter, oldOptions.filter);
	        this._updateZoomRange(newOptions.minZoom, oldOptions.minZoom, newOptions.maxZoom, oldOptions.maxZoom);
	        this._updateLayoutProperty("visibility", newOptions.visible, oldOptions.visible, newOptions.visible ? "visible" : "none");
	    };
	    /**
	     * Updates the filter for the layer in the maps its attached to.
	     * @param newFilter The new filter.
	     * @param oldFilter The old filter.
	     * Will be checked against newFilter to determine if an update is necessary.
	     * @param subFilter Optional filter to substitute for newFilter if updating is necessary.
	     * Useful when the option value doesn't exactly match the paint property.
	     * @internal
	     */
	    Layer.prototype._updateFilter = function (newFilter, oldFilter) {
	        if (!(isEqual$1(newFilter, oldFilter))) {
	            this.map._getMap().setFilter(this.id, newFilter);
	        }
	    };
	    Layer.prototype._updatePaintProperty = function (name, newValue, oldValue, subValue) {
	        // Only update if attached to a map and the values are changed.
	        if (!(isEqual$1(newValue, oldValue))) {
	            this.map._getMap().setPaintProperty(this.id, name, subValue || newValue);
	        }
	    };
	    Layer.prototype._updateLayoutProperty = function (name, newValue, oldValue, subValue) {
	        if (!(isEqual$1(newValue, oldValue))) {
	            this.map._getMap().setLayoutProperty(this.id, name, subValue || newValue);
	        }
	    };
	    /**
	     * Sets the zoom range for the layer in the attached map.
	     * @param minZoom The new minimum zoom value.
	     * @param maxZoom The new maximum zoom value.
	     * @internal
	     */
	    Layer.prototype._updateZoomRange = function (newMin, oldMin, newMax, oldMax) {
	        if ((newMin !== oldMin) || (oldMax !== newMax)) {
	            this.map._getMap().setLayerZoomRange(this.id, newMin, newMax);
	        }
	    };
	    // This object is accessible at runtime (unlike interfaces)
	    // and can be used to determine which events are ours vs Mapbox's.
	    Layer.LayerEvents = {
	        layeradded: undefined,
	        layerremoved: undefined,
	        focusin: undefined,
	        focusout: undefined,
	    };
	    return Layer;
	}(EventEmitter));

	var __extends$L = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A base class which all other layer options inherit from.
	 */
	var LayerOptions$1 = /** @class */ (function (_super) {
	    __extends$L(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * An expression specifying conditions on source features.
	         * Only features that match the filter are displayed.
	         */
	        _this.filter = undefined;
	        /**
	         * An integer specifying the minimum zoom level to render the layer at.
	         * This value is inclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level to render the layer at.
	         * This value is exclusive, i.e. the layer will be visible at `maxZoom > zoom >= minZoom`.
	         * Default `24`.
	         * @default 24
	         */
	        _this.maxZoom = 24;
	        /**
	         * Specifies if the layer is visible or not.
	         * Default `true`.
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    LayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	        else {
	            return undefined;
	        }
	    };
	    return LayerOptions;
	}(Options));

	var __extends$K = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Point objects in a BubbleLayer.
	 */
	var BubbleLayerOptions = /** @class */ (function (_super) {
	    __extends$K(BubbleLayerOptions, _super);
	    function BubbleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the circle symbol with.
	         * Default `"#1A73AA"`.
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * The amount to blur the circles.
	         * A value of 1 blurs the circles such that only the center point if at full opacity.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The color of the circles' outlines.
	         * Default `"#FFFFFF"`.
	         * @default "#FFFFFF"
	         */
	        _this.strokeColor = "#FFFFFF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the circles' outlines will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The width of the circles' outlines in pixels.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        /**
	         * Specifies the orientation of circle when map is pitched.<br />
	         * `"map"`: The circle is aligned to the plane of the map.<br />
	         * `"viewport"`: The circle is aligned to the plane of the viewport.<br />
	         * Default: `"viewport"`
	         * @default "viewport"
	         */
	        _this.pitchAlignment = "viewport";
	        /**
	         * The radius of the circle symbols in pixels.
	         * Must be greater than or equal to 0.
	         * Default `8`.
	         * @default 8
	         */
	        _this.radius = 8;
	        /**
	         * @internal
	         * Specifies whether to create focusable indicators for the bubbles.
	         * The default highlighting style is provided if the source is DataSource with Shape:
	         * ```ts
	         * const datasource = new DataSource('bubble-source');
	         * datasource.setShapes([new Shape(new Point([-122.335, 47.62]))]);
	         * this.map.sources.add(datasource);
	         * const layer = new BubbleLayer(datasource, 'bubble', {
	         *  radius: 10,
	         *  color: 'cyan',
	         *  createIndicators: true,
	         * });
	         * ```
	         *
	         * For other sources, you can provide the accessibilityIdKey option to specify the property name of the feature to use as the accessibility id.
	         * ```ts
	         * const vtSource = new VectorTileSource("indoorTiles", { tiles,  // provide your tile urls });
	         * this.map.sources.add(vtSource);
	         * const layer = new BubbleLayer(vtSource, 'bubble', {
	         *  createIndicators: true,
	         *  accessibilityIdKey: '{add your ID here}'
	         * });
	         * ```
	         *
	         * If you want to customize the highlighting style, you can use the focusin/focusout events to change the style of the bubble.
	         * ```ts
	         * this.map.events.add('focusin', 'bubble', (e) => { handle the style highlight });
	         * ```
	         *
	         * Note: We treat this as an internal option for now because we hadn't fully decided the default styling for the indicators.
	         * Once we decide, we will make this a public option or remove it.
	         */
	        _this.createIndicators = false;
	        /**
	         * @internal
	         */
	        _this.accessibilityIdKey = undefined;
	        return _this;
	    }
	    return BubbleLayerOptions;
	}(LayerOptions$1));

	var __extends$J = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __awaiter$2 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$2 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$9 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$7 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * Renders Point objects as scalable circles (bubbles).
	 */
	var BubbleLayer = /** @class */ (function (_super) {
	    __extends$J(BubbleLayer, _super);
	    /**
	     * Constructs a new BubbleLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the bubble layer.
	     */
	    function BubbleLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.accessibleIndicator = [];
	        /** @internal */
	        _this._setAccessibleIndicator = function () { return __awaiter$2(_this, void 0, void 0, function () {
	            var renderedShapes, accessibilityIdKey, createIndicator, insertHiddenBefore, insertHiddenInFront, attach;
	            var _this = this;
	            return __generator$2(this, function (_a) {
	                this.accessibleIndicator.forEach(function (indicator) { return indicator.remove(); });
	                this.accessibleIndicator = [];
	                renderedShapes = this.map.layers.getRenderedShapes(this.map.getCamera().bounds, this);
	                accessibilityIdKey = this.options.accessibilityIdKey || (this._getDataSource() ? Shape._shapeIdPropName : undefined);
	                createIndicator = function (renderedShapes, idx) {
	                    var curRenderedShape = renderedShapes[idx];
	                    var bubbleFeature = curRenderedShape instanceof Shape ? curRenderedShape.toJson() : curRenderedShape;
	                    var indicator = new AccessibleIndicator({ positionInSet: idx + 1, setSize: renderedShapes.length });
	                    var element = indicator.getElement();
	                    var _a = __read$9(_this.map.positionsToPixels([_this.getFirstCoordinate(bubbleFeature.geometry.coordinates)]), 1), pixel = _a[0];
	                    element.addEventListener('focusin', function (event) {
	                        _this.accessibleIndicator.filter(function (i) { return i !== indicator; }).forEach(function (indicator) { return indicator.remove(); });
	                        // insert previous and next popups
	                        if (idx - 1 >= 0) {
	                            insertHiddenBefore(indicator, createIndicator(renderedShapes, idx - 1));
	                        }
	                        if (idx + 1 < renderedShapes.length) {
	                            attach(createIndicator(renderedShapes, idx + 1));
	                        }
	                        // if we are on boundaries: add the first / last indicator 
	                        // to maintain indicators on full page navigation cycle
	                        if (idx >= 2 && idx == renderedShapes.length - 1) {
	                            insertHiddenInFront(createIndicator(renderedShapes, 0));
	                        }
	                        if (idx == 0 && renderedShapes.length >= 2) {
	                            attach(createIndicator(renderedShapes, renderedShapes.length - 1));
	                        }
	                        if (accessibilityIdKey !== undefined) {
	                            _this.map._getMap().setPaintProperty(_this.id, 'circle-stroke-color', ['case', ['==', ['get', accessibilityIdKey], bubbleFeature.properties[accessibilityIdKey]], '#000000', _this.options.strokeColor]);
	                        }
	                        var focusEvent = {
	                            target: element,
	                            type: 'focusin',
	                            map: _this.map,
	                            shape: curRenderedShape,
	                            originalEvent: event,
	                            pixel: pixel
	                        };
	                        _this._invokeEvent('focusin', focusEvent);
	                    });
	                    element.addEventListener('focusout', function (event) {
	                        if (accessibilityIdKey !== undefined) {
	                            _this.map._getMap().setPaintProperty(_this.id, 'circle-stroke-color', ['case', ['==', ['get', accessibilityIdKey], bubbleFeature.properties[accessibilityIdKey]], _this.options.strokeColor, _this.options.strokeColor]);
	                        }
	                        var focusEvent = {
	                            target: element,
	                            type: 'focusout',
	                            map: _this.map,
	                            shape: curRenderedShape,
	                            originalEvent: event,
	                            pixel: pixel
	                        };
	                        _this._invokeEvent('focusout', focusEvent);
	                    });
	                    _this.accessibleIndicator.push(indicator);
	                    return indicator;
	                };
	                insertHiddenBefore = function (base, toInsert) {
	                    toInsert.attach(_this.map);
	                    var elementToSwapIn = toInsert.getElement();
	                    var baseElement = base.getElement();
	                    baseElement.parentElement.insertBefore(elementToSwapIn, baseElement);
	                };
	                insertHiddenInFront = function (toInsert) {
	                    toInsert.attach(_this.map);
	                    var elementToSwapIn = toInsert.getElement();
	                    var parent = elementToSwapIn.parentElement;
	                    parent.insertBefore(elementToSwapIn, parent.firstElementChild);
	                };
	                attach = function (popup) {
	                    popup.attach(_this.map);
	                };
	                if (renderedShapes.length > 0) {
	                    attach(createIndicator(renderedShapes, 0));
	                }
	                if (renderedShapes.length > 1) {
	                    attach(createIndicator(renderedShapes, renderedShapes.length - 1));
	                }
	                return [2 /*return*/];
	            });
	        }); };
	        _this.options = new BubbleLayerOptions().merge(cloneDeepWith$1(options, BubbleLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the bubble layer.
	     */
	    BubbleLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, BubbleLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    BubbleLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the bubble layer.
	     * @param newOptions The new options of the bubble layer.
	     */
	    BubbleLayer.prototype.setOptions = function (options) {
	        var newOptions = new BubbleLayerOptions().merge(this.options, cloneDeepWith$1(options, BubbleLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("circle-blur", newOptions.blur, this.options.blur);
	            this._updatePaintProperty("circle-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("circle-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("circle-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("circle-stroke-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("circle-stroke-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("circle-stroke-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("circle-pitch-alignment", newOptions.pitchAlignment, this.options.pitchAlignment);
	        }
	        this.options = newOptions;
	    };
	    BubbleLayer.prototype.onAdd = function (map) {
	        var _this = this;
	        _super.prototype.onAdd.call(this, map);
	        if (this.options.createIndicators) {
	            // Wait for map idle for the first time to ensure `layer.getRenderedShapes` return correct shapes.
	            map.events.addOnce('idle', this._setAccessibleIndicator);
	            // The rendered shapes may be changed when map is moved. Update the indicators when map is moved.
	            map.events.add('moveend', this._setAccessibleIndicator);
	            var dataSource = this._getDataSource();
	            if (dataSource) {
	                // The rendered shapes may be changed when data is added. Update the indicators when data is added.
	                map.events.add('dataadded', dataSource, function () {
	                    // Wait for map idle to ensure `layer.getRenderedShapes` return correct shapes.
	                    map.events.addOnce('idle', _this._setAccessibleIndicator);
	                });
	            }
	            else {
	                var sourceId_1 = typeof this.options.source === 'string' ? this.options.source : this.options.source.getId();
	                map.events.add('sourcedata', function (mapDataEvent) {
	                    var _a;
	                    // There's chances that mapDataEvent.isSourceLoaded doesn't update correctly when using flyTo, thus we check by using map.isSourceLoaded.
	                    if (((_a = mapDataEvent.source) === null || _a === void 0 ? void 0 : _a.getId()) === sourceId_1 && map._getMap().isSourceLoaded(sourceId_1)) {
	                        // Source event will be fired multiple times, and we are only interested when the source is loaded.
	                        // Thus design a cache key that only changed when camera & style properties are changed.
	                        var curCacheKey = _this._getSourceDataEventCacheKey();
	                        if (curCacheKey !== _this.sourceDataEventCacheKey) {
	                            _this._setAccessibleIndicator();
	                            _this.sourceDataEventCacheKey = curCacheKey;
	                        }
	                    }
	                });
	            }
	        }
	    };
	    BubbleLayer.prototype.onRemove = function () {
	        if (this.options.createIndicators) {
	            this.map.events.remove('idle', this._setAccessibleIndicator);
	            this.map.events.remove('moveend', this._setAccessibleIndicator);
	            var dataSource = this._getDataSource();
	            if (dataSource) {
	                this.map.events.remove('dataadded', dataSource, this._setAccessibleIndicator);
	            }
	            else {
	                this.map.events.remove('sourcedata', this._setAccessibleIndicator);
	            }
	        }
	        _super.prototype.onRemove.call(this);
	    };
	    BubbleLayer.prototype._getSourceDataEventCacheKey = function () {
	        if (!this.map) {
	            return undefined;
	        }
	        var mapConfiguration = this.map.getServiceOptions().mapConfiguration;
	        return __spreadArray$7(__spreadArray$7([], __read$9(this.map.getCamera().bounds), false), [
	            this.map.getCamera().zoom,
	            this.map.getCamera().pitch,
	            this.map.getStyle().style,
	            mapConfiguration instanceof Object ? mapConfiguration.id : mapConfiguration
	        ], false).join(',');
	    };
	    BubbleLayer.prototype._getDataSource = function () {
	        var source = typeof this.options.source === 'string' ? this.map.sources.getById(this.options.source) : this.options.source;
	        if (source instanceof DataSource) {
	            return source;
	        }
	        return undefined;
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "circle",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "circle-color": this.options.color,
	                "circle-blur": this.options.blur,
	                "circle-opacity": this.options.opacity,
	                "circle-stroke-color": this.options.strokeColor,
	                "circle-stroke-opacity": this.options.strokeOpacity,
	                "circle-stroke-width": this.options.strokeWidth,
	                "circle-pitch-alignment": this.options.pitchAlignment,
	                "circle-radius": this.options.radius
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    BubbleLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    /**
	     * The coordinates can be nested, so we need to get the first coordinate.
	     * @param coordinates The property from the Geometry. Can be Position, Position[], Position[][], etc.
	     * @returns
	     */
	    BubbleLayer.prototype.getFirstCoordinate = function (coordinates) {
	        if (!Array.isArray(coordinates[0])) {
	            return coordinates;
	        }
	        return this.getFirstCoordinate(coordinates[0]);
	    };
	    return BubbleLayer;
	}(Layer));

	var __extends$I = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Point objects in a HeatMapLayer.
	 */
	var HeatMapLayerOptions = /** @class */ (function (_super) {
	    __extends$I(HeatMapLayerOptions, _super);
	    function HeatMapLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies the color gradient used to colorize the pixels in the heatmap.
	         * This is defined using an expression that uses `["heatmap-density"]` as input.
	         * Default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         * @default `["interpolate",["linear"],["heatmap-density"],0,"rgba(0,0, 255,0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"]`
	         */
	        _this.color = ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0,0, 255,0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"];
	        /**
	         * Similar to `heatmap-weight` but specifies the global heatmap intensity.
	         * The higher this value is, the more ‘weight’ each point will contribute to the appearance.
	         * Default `1`
	         * @default 1
	         */
	        _this.intensity = 1;
	        /**
	         * The opacity at which the heatmap layer will be rendered defined as a number between 0 and 1.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * The radius in pixels used to render a data point on the heatmap.
	         * The radius must be a number greater or equal to 1.
	         * Default `30`.
	         * @default 30
	         */
	        _this.radius = 30;
	        /**
	         * Specifies how much an individual data point contributes to the heatmap.
	         * Must be a number greater than 0. A value of 5 would be equivalent to having 5 points of weight 1 in the same spot.
	         * This is useful when clustering points to allow heatmap rendering or large datasets.
	         * Default `1`
	         * @default 1
	         */
	        _this.weight = 1;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HeatMapLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	        else {
	            return undefined;
	        }
	    };
	    return HeatMapLayerOptions;
	}(LayerOptions$1));

	var __extends$H = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represent the density of data using different colors (HeatMap).
	 */
	var HeatMapLayer = /** @class */ (function (_super) {
	    __extends$H(HeatMapLayer, _super);
	    /**
	     * Constructs a new HeatMapLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the heat map layer.
	     */
	    function HeatMapLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new HeatMapLayerOptions().merge(cloneDeepWith$1(options, HeatMapLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the heat map layer.
	     */
	    HeatMapLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, HeatMapLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    HeatMapLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the heat map layer.
	     * @param newOptions The new options of the heat map layer.
	     */
	    HeatMapLayer.prototype.setOptions = function (options) {
	        var newOptions = new HeatMapLayerOptions().merge(this.options, cloneDeepWith$1(options, HeatMapLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("heatmap-color", newOptions.color, this.options.color);
	            this._updatePaintProperty("heatmap-intensity", newOptions.intensity, this.options.intensity);
	            this._updatePaintProperty("heatmap-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("heatmap-radius", newOptions.radius, this.options.radius);
	            this._updatePaintProperty("heatmap-weight", newOptions.weight, this.options.weight);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "heatmap",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "heatmap-color": this.options.color,
	                "heatmap-intensity": this.options.intensity,
	                "heatmap-opacity": this.options.opacity,
	                "heatmap-radius": this.options.radius,
	                "heatmap-weight": this.options.weight,
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    HeatMapLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return HeatMapLayer;
	}(Layer));

	var __extends$G = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering canvas, image, raster tile, and video layers
	 */
	var MediaLayerOptions = /** @class */ (function (_super) {
	    __extends$G(MediaLayerOptions, _super);
	    function MediaLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A number between -1 and 1 that increases or decreases the contrast of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.contrast = 0;
	        /**
	         * The duration in milliseconds of a fade transition when a new tile is added.
	         * Must be greater or equal to 0.
	         * Default `300`.
	         * @default 300
	         */
	        _this.fadeDuration = 300;
	        /**
	         * Rotates hues around the color wheel.
	         * A number in degrees.
	         * Default `0`.
	         * @default 0
	         */
	        _this.hueRotation = 0;
	        /**
	         * A number between 0 and 1 that increases or decreases the maximum brightness of the overlay.
	         * Default `1`.
	         * @default 1
	         */
	        _this.maxBrightness = 1;
	        /**
	         * A number between 0 and 1 that increases or decreases the minimum brightness of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minBrightness = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the overlay will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        /**
	         * A number between -1 and 1 that increases or decreases the saturation of the overlay.
	         * Default `0`.
	         * @default 0
	         */
	        _this.saturation = 0;
	        return _this;
	    }
	    return MediaLayerOptions;
	}(LayerOptions$1));

	var __extends$F = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Point objects in a ImageLayer.
	 */
	var ImageLayerOptions = /** @class */ (function (_super) {
	    __extends$F(ImageLayerOptions, _super);
	    function ImageLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * URL to an image to overlay. Images hosted on other domains must have CORs enabled.
	         */
	        _this.url = undefined;
	        /**
	         * An array of positions for the corners of the image listed in clockwise order: [top left, top right, bottom right, bottom left].
	         */
	        _this.coordinates = undefined;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Source objects to pass through without cloning.
	     * Source objects are designed to be modifiable so a reference to the actual Source is fine for users to have.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ImageLayerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Source) {
	            return value;
	        }
	        else {
	            return undefined;
	        }
	    };
	    return ImageLayerOptions;
	}(MediaLayerOptions));

	var __extends$E = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Abstract class for other layer classes which have to build sources.
	 * @internal
	 */
	var SourceBuildingLayer = /** @class */ (function (_super) {
	    __extends$E(SourceBuildingLayer, _super);
	    function SourceBuildingLayer() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    /**
	     * @internal
	     */
	    SourceBuildingLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        ids.add(this._getSourceId());
	        return ids;
	    };
	    SourceBuildingLayer.prototype.onAdd = function (map) {
	        _super.prototype.onAdd.call(this, map);
	    };
	    return SourceBuildingLayer;
	}(Layer));

	var __extends$D = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Overlays an image on the map with each corner anchored to a coordinate on the map. Also known as a ground or image overlay.
	 */
	var ImageLayer = /** @class */ (function (_super) {
	    __extends$D(ImageLayer, _super);
	    /**
	     * Constructs a new ImageLayer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the image layer.
	     */
	    function ImageLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        _this.isLoading = false;
	        _this.options = new ImageLayerOptions().merge(cloneDeepWith$1(options, ImageLayerOptions._cloneCustomizer));
	        _this.img = new Image();
	        _this.reloadImage();
	        return _this;
	    }
	    /**
	     * Gets the options of the image layer.
	     */
	    ImageLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, ImageLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the image layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    ImageLayer.prototype.setOptions = function (options) {
	        var newOptions = new ImageLayerOptions().merge(this.options, cloneDeepWith$1(options, ImageLayerOptions._cloneCustomizer));
	        var reloadImageTransform = (typeof options.url === "string" && options.url !== this.getOptions().url);
	        var coordChanged = (typeof options.coordinates !== "undefined" && options.coordinates !== this.getOptions().coordinates);
	        if (this.map) {
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	            // TODO: the mapbox typing file doesn't support maplibregl.ImageSource.updateImage()
	            // update "as any" to "as maplibregl.ImageSource" after the typing file is updated
	            var source = this.map._getMap().getSource(this._getSourceId());
	            if (source) {
	                source.updateImage(newOptions);
	            }
	        }
	        this.options = newOptions;
	        // Modified to update transform if image url or coordinates change
	        if (reloadImageTransform) {
	            this.reloadImage();
	        }
	        else if (coordChanged) {
	            this.updateTransform();
	        }
	    };
	    /**
	     * Calculates the approximate positions that align with the provided pixels from the source image.
	     * @param pixels the provided pixels from the source image used to calculate the positions
	     */
	    ImageLayer.prototype.getPositions = function (pixels) {
	        return this.transform.then(function (t) {
	            return t.toTarget(pixels);
	        });
	    };
	    /**
	     * Calculates the approximate pixels on the source image that align with the provided positions.
	     * @param positions the provided positions from the source image used to calculate the pixels
	     */
	    ImageLayer.prototype.getPixels = function (positions) {
	        return this.transform.then(function (t) {
	            return t.toSource(positions);
	        });
	    };
	    /**
	     * Calculates the approximate corner coordinates for an image based on the image width, height and by calculating an affine transform from a set of source pixels in the image and a set of target positions that are related.
	     * The same number of source and target values must be provided as reference points. It is recommended to provide atleast 3 reference points.
	     * @param imgWidth image width
	     * @param imgHeight image height
	     * @param source a set of source pixels
	     * @param target target positions
	     */
	    ImageLayer.getCoordinatesFromRefPoints = function (imgWidth, imgHeight, source, target) {
	        var transform = new AffineTransform(source, target);
	        return transform.toTarget([
	            [0, 0],
	            [imgWidth, 0],
	            [imgWidth, imgHeight],
	            [0, imgHeight]
	        ]);
	    };
	    /**
	     * Calculates coordinates for a rotated image layer when provided with the bounding box edges and rotation value.
	     * Note: If your rotation value is from a KML Ground Overlay it will need to be converted to a clockwise rotation using the following formula: `rotation = 360 – KmlRotation`
	     * @param north The north edge of the bounding box.
	     * @param south The south edge of the bounding box.
	     * @param east The east edge of the bounding box.
	     * @param west The west edge of the bounding box.
	     * @param rotation Clockwise rotation in degrees
	     */
	    ImageLayer.getCoordinatesFromEdges = function (north, south, east, west, rotation) {
	        if (typeof rotation !== "number") {
	            rotation = 0;
	        }
	        // [minLon, minLat, maxLon, maxLat]
	        var bounds = [
	            Math.min(west, east),
	            south,
	            Math.max(west, east),
	            north
	        ];
	        // Calculate the center of the bounding box and use that as the rotation origin.
	        var origin = BoundingBox.getCenter(bounds);
	        // Calculate the corner coordinates of the bounding box.
	        var topLeft = BoundingBox.getNorthWest(bounds);
	        var topRight = BoundingBox.getNorthEast(bounds);
	        var bottomRight = BoundingBox.getSouthEast(bounds);
	        var bottomLeft = BoundingBox.getSouthWest(bounds);
	        // Calcuate to rotated corners of the bounding box.
	        return rotatePositions([
	            topLeft,
	            topRight,
	            bottomRight,
	            bottomLeft
	        ], origin, rotation);
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "raster",
	            source: this._getSourceId(),
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "raster-opacity": this.options.opacity,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-saturation": this.options.saturation,
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    ImageLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the imge source to include with the layer.
	     * @internal
	     */
	    ImageLayer.prototype._buildSource = function () {
	        return {
	            type: "image",
	            url: this.options.url,
	            coordinates: this.options.coordinates
	        };
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    ImageLayer.prototype._getSourceId = function () {
	        return "".concat(this.getId(), "-ImageSource");
	    };
	    ImageLayer.prototype.reloadImage = function () {
	        var _this = this;
	        if (this.options.url) {
	            this.transform = new Promise(function (resolve, reject) {
	                _this.img.onload = function () {
	                    var corners = [[0, 0], [_this.img.width, 0], [_this.img.width, _this.img.height], [0, _this.img.height]];
	                    resolve(new AffineTransform(corners, _this.options.coordinates));
	                    _this.isLoading = false;
	                };
	                _this.img.onerror = _this.img.onabort = function () {
	                    reject("Failed to load image");
	                };
	                _this.isLoading = true;
	                _this.img.src = _this.options.url;
	            });
	        }
	    };
	    ImageLayer.prototype.updateTransform = function () {
	        if (!this.isLoading) {
	            var corners = [[0, 0], [this.img.width, 0], [this.img.width, this.img.height], [0, this.img.height]];
	            this.transform = Promise.resolve(new AffineTransform(corners, this.options.coordinates));
	        }
	    };
	    ImageLayer.prototype._getSourceWrapper = function () {
	        var sourceId = this._getSourceId();
	        var source = this._buildSource();
	        return new ImageSource(sourceId, source);
	    };
	    return ImageLayer;
	}(SourceBuildingLayer));

	var __extends$C = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering SimpleLine, SimplePolygon, CirclePolygon,
	 * LineString, MultiLineString, Polygon, and MultiPolygon objects in a line layer.
	 */
	var LineLayerOptions = /** @class */ (function (_super) {
	    __extends$C(LineLayerOptions, _super);
	    function LineLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Specifies how the ends of the lines are rendered.<br />
	         * `"butt"`: A cap with a squared-off end which is drawn to the exact endpoint of the line.<br />
	         * `"round"`: A cap with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.<br />
	         * `"square"`: A cap with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the line width.<br />
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineCap = "round";
	        /**
	         * Specifies how the joints in the lines are rendered.<br />
	         * `"bevel"`: A join with a squared-off end which is drawn beyond the endpoint of the line
	         * at a distance of one-half of the lines width.<br />
	         * `"round"`: A join with a rounded end which is drawn beyond the endpoint of the line
	         * at a radius of one-half of the lines width and centered on the endpoint of the line.<br />
	         * `"miter"`: A join with a sharp, angled corner which is drawn with the outer sides
	         * beyond the endpoint of the path until they meet.<br />
	         * Default `"round"`.
	         * @default "round"
	         */
	        _this.lineJoin = "round";
	        /**
	         * The amount of blur to apply to the line in pixels.
	         * Default `0`.
	         * @default 0
	         */
	        _this.blur = 0;
	        /**
	         * Specifies the color of the line.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.strokeColor = "#1E90FF";
	        /**
	         * Specifies the lengths of the alternating dashes and gaps that form the dash pattern.
	         * Numbers must be equal or greater than 0. The lengths are scaled by the strokeWidth.
	         * To convert a dash length to pixels, multiply the length by the current stroke width.
	         */
	        _this.strokeDashArray = undefined;
	        /**
	         * Defines a gradient with which to color the lines.
	         * Requires the DataSource lineMetrics option to be set to true.
	         * Disabled if strokeDashArray is set.
	         */
	        _this.strokeGradient = undefined;
	        /**
	         * The line's offset.
	         * A positive value offsets the line to the right, relative to the direction of the line.
	         * A negative value offsets to the left.
	         * Default `0`.
	         * @default 0
	         */
	        _this.offset = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the line will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.strokeOpacity = 1;
	        /**
	         * The amount of offset in pixels to render the line relative to where it would render normally.
	         * Negative values indicate left and up.
	         * Default: `[0,0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.<br />
	         * `"map"`: Lines are translated relative to the map.<br />
	         * `"viewport"`: Lines are translated relative to the viewport<br />
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * The width of the line in pixels. Must be a value greater or equal to 0.
	         * Default `2`.
	         * @default 2
	         */
	        _this.strokeWidth = 2;
	        return _this;
	    }
	    return LineLayerOptions;
	}(LayerOptions$1));

	var __extends$B = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$9 = (window && window.__assign) || function () {
	    __assign$9 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$9.apply(this, arguments);
	};
	/**
	 * Renders line data on the map. Can be used with SimpleLine, SimplePolygon,
	 * CirclePolygon, LineString, MultiLineString, Polygon, and MultiPolygon objects.
	 */
	var LineLayer = /** @class */ (function (_super) {
	    __extends$B(LineLayer, _super);
	    /**
	     * Constructs a new LineLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the line layer.
	     */
	    function LineLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new LineLayerOptions().merge(cloneDeepWith$1(options, LineLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the line layer.
	     */
	    LineLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, LineLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    LineLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the line layer.
	     * @param options The new options of the line layer.
	     */
	    LineLayer.prototype.setOptions = function (options) {
	        var newOptions = new LineLayerOptions().merge(this.options, cloneDeepWith$1(options, LineLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("line-blur", newOptions.blur, this.options.blur);
	            this._updateLayoutProperty("line-cap", newOptions.lineCap, this.options.lineCap);
	            this._updateLayoutProperty("line-join", newOptions.lineJoin, this.options.lineJoin);
	            this._updatePaintProperty("line-offset", newOptions.offset, this.options.offset);
	            this._updatePaintProperty("line-color", newOptions.strokeColor, this.options.strokeColor);
	            this._updatePaintProperty("line-dasharray", newOptions.strokeDashArray, this.options.strokeDashArray);
	            this._updatePaintProperty("line-gradient", newOptions.strokeGradient, this.options.strokeGradient);
	            this._updatePaintProperty("line-opacity", newOptions.strokeOpacity, this.options.strokeOpacity);
	            this._updatePaintProperty("line-width", newOptions.strokeWidth, this.options.strokeWidth);
	            this._updatePaintProperty("line-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("line-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._buildLayers = function () {
	        var layer = __assign$9(__assign$9(__assign$9(__assign$9({ id: this.id, type: "line" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	                "line-cap": this.options.lineCap,
	                "line-join": this.options.lineJoin
	            }, paint: __assign$9(__assign$9(__assign$9({ "line-blur": this.options.blur, "line-color": this.options.strokeColor }, (this.options.strokeDashArray ? { "line-dasharray": this.options.strokeDashArray } : {})), (this.options.strokeGradient ? { "line-gradient": this.options.strokeGradient } : {})), { "line-offset": this.options.offset, "line-opacity": this.options.strokeOpacity, "line-translate": this.options.translate, "line-translate-anchor": this.options.translateAnchor, "line-width": this.options.strokeWidth }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    LineLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return LineLayer;
	}(Layer));

	var __extends$A = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering `Polygon` and `MultiPolygon` objects in a `PolygonExtrusionLayer`.
	 */
	var PolygonExtrusionLayerOptions = /** @class */ (function (_super) {
	    __extends$A(PolygonExtrusionLayerOptions, _super);
	    function PolygonExtrusionLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The height in meters to extrude the base of this layer.
	         * This height is relative to the ground.
	         * Must be greater or equal to 0 and less than or equal to `height`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.base = 0;
	        /**
	         * The color to fill the polygons with.
	         * Ignored if `fillPattern` is set.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * The height in meters to extrude this layer.
	         * This height is relative to the ground.
	         * Must be a number greater or equal to 0.
	         * Default `0`
	         * @default 0
	         */
	        _this.height = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.fillOpacity = 1;
	        /**
	         * Name of image in sprite to use for drawing image fills.
	         * For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        /**
	         * The polygons' pixel offset.
	         * Values are [x, y] where negatives indicate left and up, respectively.
	         * Default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.translate = new Pixel(0, 0);
	        /**
	         * Specifies the frame of reference for `translate`.<br />
	         * `"map"`: Polygons are translated relative to the map.<br />
	         * `"viewport"`: Polygons are translated relative to the viewport.<br />
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.translateAnchor = "map";
	        /**
	         * Specifies if the polygon should have a vertical gradient on the sides of the extrusion.
	         * Default: `true`
	         * @default true
	         */
	        _this.verticalGradient = true;
	        return _this;
	    }
	    return PolygonExtrusionLayerOptions;
	}(LayerOptions$1));

	var __extends$z = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$8 = (window && window.__assign) || function () {
	    __assign$8 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$8.apply(this, arguments);
	};
	/**
	 * Renders extruded filled `Polygon` and `MultiPolygon` objects on the map.
	 */
	var PolygonExtrusionLayer = /** @class */ (function (_super) {
	    __extends$z(PolygonExtrusionLayer, _super);
	    /**
	     * Constructs a new PolygonExtrusionLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon extrusion layer.
	     */
	    function PolygonExtrusionLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonExtrusionLayerOptions().merge(cloneDeepWith$1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, PolygonExtrusionLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonExtrusionLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonExtrusionLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonExtrusionLayerOptions().merge(this.options, cloneDeepWith$1(options, PolygonExtrusionLayerOptions._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-extrusion-base", newOptions.base, this.options.base);
	            this._updatePaintProperty("fill-extrusion-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-extrusion-height", newOptions.height, this.options.height);
	            this._updatePaintProperty("fill-extrusion-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-extrusion-pattern", newOptions.fillPattern, this.options.fillPattern);
	            this._updatePaintProperty("fill-extrusion-translate", newOptions.translate, this.options.translate);
	            this._updatePaintProperty("fill-extrusion-translate-anchor", newOptions.translateAnchor, this.options.translateAnchor);
	            this._updatePaintProperty("fill-extrusion-vertical-gradient", newOptions.verticalGradient, this.options.verticalGradient);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._buildLayers = function () {
	        var layer = __assign$8(__assign$8(__assign$8(__assign$8({ id: this.id, type: "fill-extrusion" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: {
	                visibility: this.options.visible ? "visible" : "none",
	            }, paint: __assign$8(__assign$8({ "fill-extrusion-base": this.options.base, "fill-extrusion-height": this.options.height, "fill-extrusion-opacity": this.options.fillOpacity }, (this.options.fillPattern ?
	                { "fill-extrusion-pattern": this.options.fillPattern } :
	                { "fill-extrusion-color": this.options.fillColor })), { "fill-extrusion-translate": this.options.translate, "fill-extrusion-translate-anchor": this.options.translateAnchor, "fill-extrusion-vertical-gradient": this.options.verticalGradient }) }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonExtrusionLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonExtrusionLayer;
	}(Layer));

	var __extends$y = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering Polygon and MultiPolygon objects in a PolygonLayer.
	 */
	var PolygonLayerOptions$1 = /** @class */ (function (_super) {
	    __extends$y(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * The color to fill the polygons with.
	         * Default `"#1E90FF"`.
	         * @default "#1E90FF"
	         */
	        _this.fillColor = "#1E90FF";
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the fill will be drawn.
	         * Default `0.5`.
	         * @default 0.5
	         */
	        _this.fillOpacity = 0.5;
	        /**
	         * Name of image in sprite to use for drawing image fills. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512).
	         */
	        _this.fillPattern = undefined;
	        /**
	         * Whether or not the fill should be antialiased.
	         * Default `true`.
	         * @default true
	         */
	        _this.fillAntialias = true;
	        return _this;
	    }
	    return PolygonLayerOptions;
	}(LayerOptions$1));

	var __extends$x = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Renders filled Polygon and MultiPolygon objects on the map.
	 */
	var PolygonLayer = /** @class */ (function (_super) {
	    __extends$x(PolygonLayer, _super);
	    /**
	     * Constructs a new PolygonLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function PolygonLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new PolygonLayerOptions$1().merge(cloneDeepWith$1(options, PolygonLayerOptions$1._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the polygon layer.
	     */
	    PolygonLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, PolygonLayerOptions$1._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    PolygonLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the polygon layer.
	     * When `fillPattern` is set, `fillColor` will be ignored.
	     * To set `fillColor`, make sure `fillPattern` is set to `undefined`.
	     * @param newOptions The new options of the polygon layer.
	     */
	    PolygonLayer.prototype.setOptions = function (options) {
	        var newOptions = new PolygonLayerOptions$1().merge(this.options, cloneDeepWith$1(options, PolygonLayerOptions$1._cloneCustomizer));
	        // Update layout and paint properties if they've changed.
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("fill-color", newOptions.fillColor, this.options.fillColor);
	            this._updatePaintProperty("fill-opacity", newOptions.fillOpacity, this.options.fillOpacity);
	            this._updatePaintProperty("fill-pattern", newOptions.fillPattern, this.options.fillPattern);
	            this._updatePaintProperty("fill-antialias", newOptions.fillAntialias, this.options.fillAntialias);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._buildLayers = function () {
	        var layer = {
	            id: this.id,
	            type: "fill",
	            source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source,
	            layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            },
	            paint: {
	                "fill-opacity": this.options.fillOpacity,
	                "fill-antialias": this.options.fillAntialias,
	            },
	            minzoom: this.options.minZoom,
	            maxzoom: this.options.maxZoom
	        };
	        // Set properties without defaults only if they are defined.
	        if (this.options.filter) {
	            layer["filter"] = this.options.filter;
	        }
	        if (this.options.sourceLayer) {
	            layer["source-layer"] = this.options.sourceLayer;
	        }
	        // The property fill-pattern should only be set if there is a value for fillPattern.
	        // The property fill-color should only be set if fill-pattern isn't.
	        if (this.options.fillPattern) {
	            layer.paint["fill-pattern"] = this.options.fillPattern;
	        }
	        else {
	            layer.paint["fill-color"] = this.options.fillColor;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    PolygonLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return PolygonLayer;
	}(Layer));

	var __extends$w = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used to customize the icons in a SymbolLayer
	 */
	var IconOptions = /** @class */ (function (_super) {
	    __extends$w(IconOptions, _super);
	    function IconOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the symbol icon can overlay other symbols on the map.
	         * If `true` the icon will be visible even if it collides with other previously drawn symbols.
	         * Tip: Set this to true if animating an symbol to ensure smooth rendering.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.<br />
	         * `"center"`: The center of the icon is placed closest to the anchor.<br />
	         * `"left"`: The left side of the icon is placed closest to the anchor.<br />
	         * `"right"`: The right side of the icon is placed closest to the anchor.<br />
	         * `"top"`: The top of the icon is placed closest to the anchor.<br />
	         * `"bottom"`: The bottom of the icon is placed closest to the anchor.<br />
	         * `"top-left"`: The top left corner of the icon is placed closest to the anchor.<br />
	         * `"top-right"`: The top right corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.<br />
	         * Default `"bottom"`.
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * Specifies if other symbols can overlap this symbol.
	         * If true, other symbols can be visible even if they collide with the icon.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * The name of the image in the map's image sprite to use for drawing the icon.
	         * Available built-in images are: `marker-black`, `marker-blue`, `marker-darkblue`,
	         * `marker-red`, `marker-yellow`, `pin-blue`, `pin-darkblue`, `pin-red`, `pin-round-blue`,
	         * `pin-round-darkblue`, `pin-round-red`.
	         * Default `"marker-blue"`.
	         * @default "marker-blue"
	         */
	        _this.image = "marker-blue";
	        /**
	         * Specifies an offset distance of the icon from its anchor in pixels.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Each component is multiplied by the value of size to obtain the final offset in pixels.
	         * When combined with rotation the offset will be as if the rotated direction was up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if a symbols icon can be hidden but its text displayed if it is overlapped with another symbol.
	         * If true, text will display without their corresponding icons
	         * when the icon collides with other symbols and the text does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Size of the additional area around the icon bounding box used for detecting symbol collisions.
	         * Default `2`.
	         * @default 2
	         */
	        _this.padding = 2;
	        /**
	         * Specifies the orientation of the icon when the map is pitched.<br />
	         * `"auto"`: Automatically matches the value of `rotationAlignment`.<br />
	         * `"map"`: The icon is aligned to the plane of the map.<br />
	         * `"viewport"`: The icon is aligned to the plane of the viewport<br />
	         * Default `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * The amount to rotate the icon clockwise in degrees
	         * Default `0`.
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the placement property of a SymbolLayerOptions
	         * this determines the rotation behavior of icons.<br />
	         * `"auto"`: When placement is "point" this is equivalent to "viewport".
	         * When placement is "line" this is equivalent to "map".<br />
	         * `"map"`: When placement is "point" aligns icons east-west.
	         * When placement is "line" aligns the icons' x-axes with the line.<br />
	         * `"viewport"`: Icons' x-axes will align with the x-axis of the viewport.<br />
	         * Default `"auto"`.
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * Scales the original size of the icon by the provided factor.
	         * Must be greater or equal to 0.
	         * Default `1`.
	         * @default 1
	         */
	        _this.size = 1;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the icon will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return IconOptions;
	}(Options));

	var __extends$v = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used to customize the text in a SymbolLayer
	 */
	var TextOptions = /** @class */ (function (_super) {
	    __extends$v(TextOptions, _super);
	    function TextOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies if the text will be visible if it collides with other symbols.
	         * If true, the text will be visible even if it collides with other previously drawn symbols.
	         * Default `false`.
	         * @default false
	         */
	        _this.allowOverlap = false;
	        /**
	         * Specifies which part of the icon is placed closest to the icons anchor position on the map.<br />
	         * `"center"`: The center of the icon is placed closest to the anchor.<br />
	         * `"left"`: The left side of the icon is placed closest to the anchor.<br />
	         * `"right"`: The right side of the icon is placed closest to the anchor.<br />
	         * `"top"`: The top of the icon is placed closest to the anchor.<br />
	         * `"bottom"`: The bottom of the icon is placed closest to the anchor.<br />
	         * `"top-left"`: The top left corner of the icon is placed closest to the anchor.<br />
	         * `"top-right"`: The top right corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.<br />
	         * Default `"center"`.
	         * @default "center"
	         */
	        _this.anchor = "center";
	        /**
	         * Specifies the name of a property on the features to use for a text label.
	         */
	        _this.textField = undefined;
	        /**
	         * The font stack to use for displaying text.
	         * Possible values: `"SegoeFrutigerHelveticaMYingHei-Bold"`, `"SegoeFrutigerHelveticaMYingHei-Medium"`,
	         * `"SegoeFrutigerHelveticaMYingHei-Regular"`, `"SegoeUi-Bold"`, `"SegoeUi-Light"`, `"SegoeUi-Regular"`,
	         * `"SegoeUi-SemiBold"`, `"SegoeUi-SemiLight"`, `"SegoeUi-SymbolRegular"`, `"StandardCondensedSegoeUi-Black"`,
	         * `"StandardCondensedSegoeUi-Bold"`, `"StandardCondensedSegoeUi-Light"`, `"StandardCondensedSegoeUi-Regular"`,
	         * `"StandardFont-Black"`, `"StandardFont-Bold"`, `"StandardFont-Light"`, `"StandardFont-Regular"`,
	         * `"StandardFontCondensed-Black"`, `"StandardFontCondensed-Bold"`, `"StandardFontCondensed-Light"`,
	         * `"StandardFontCondensed-Regular"`.
	         * Default `["StandardFont-Regular"]`.
	         * @default ["StandardFont-Regular"]
	         */
	        _this.font = ["StandardFont-Regular"];
	        /**
	         * Specifies if the other symbols are allowed to collide with the text.
	         * If true, other symbols can be visible even if they collide with the text.
	         * Default `false`.
	         * @default false
	         */
	        _this.ignorePlacement = false;
	        /**
	         * Text justification options.<br />
	         * `"auto"`: The text is aligned towards the anchor position.<br />
	         * `"left"`: The text is aligned to the left.<br />
	         * `"center"`: The text is centered.<br />
	         * `"right"`: The text is aligned to the right.<br />
	         * Default `"center"`.
	         * @default "center"
	         */
	        _this.justify = "center";
	        /**
	         * Specifies an offset distance of the icon from its anchor in ems.
	         * Positive values indicate right and down, while negative values indicate left and up.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * Specifies if the text can be hidden if it is overlapped by another symbol.
	         * If true, icons will display without their corresponding text
	         * when the text collides wit other symbols and the icon does not.
	         * Default `false`.
	         * @default false
	         */
	        _this.optional = false;
	        /**
	         * Size of the additional area around the text bounding box used for detecting
	         * symbol collisions.
	         * Default `2`.
	         * @default 2
	         */
	        _this.padding = 2;
	        /**
	         * Specifies the orientation of the text when the map is pitched.<br />
	         * `"auto"`: Automatically matches the value of `rotationAlignment`.<br />
	         * `"map"`: The text is aligned to the plane of the map.<br />
	         * `"viewport"`: The text is aligned to the plane of the viewport.<br />
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.pitchAlignment = "auto";
	        /**
	         * Radial offset of text, in the direction of the symbol's anchor. Useful in combination
	         * with `variableAnchor`, which defaults to using the two-dimensional `offset` if present.
	         * Default: `undefined`
	         * @default undefined
	         */
	        _this.radialOffset = undefined;
	        /**
	         * The amount to rotate the text clockwise in degrees.
	         * Default `0`
	         * @default 0
	         */
	        _this.rotation = 0;
	        /**
	         * In combination with the `placement` property of the `SymbolLayerOptions`,
	         * specifies the rotation behavior of the individual glyphs forming the text.<br />
	         * `"auto"`: When the `placement` is set to `"point"`, this is equivalent to `"map"`.
	         * When the `placement` is set to `"line"` this is equivalent to `"map"`.<br />
	         * `"map"`: When the `placement` is set to `"point"`, aligns text east-west.
	         * When the `placement` is set to `"line"`, aligns text x-axes with the line.<br />
	         * `"viewport"`: Produces glyphs whose x-axes are aligned with the x-axis of the viewport,
	         * regardless of the value of `placement`.<br />
	         * Default: `"auto"`
	         * @default "auto"
	         */
	        _this.rotationAlignment = "auto";
	        /**
	         * List of potential anchor locations, to increase the chance of placing high-priority
	         * labels on the map. The renderer will attempt to place the label at each location,
	         * in order, before moving onto the next label. Use `justify: "auto"` to choose text
	         * justification based on anchor position. To apply an offset use the `radialOffset` or
	         * two-dimensional `offset` options.<br />
	         * `"center"`: The center of the icon is placed closest to the anchor.<br />
	         * `"left"`: The left side of the icon is placed closest to the anchor.<br />
	         * `"right"`: The right side of the icon is placed closest to the anchor.<br />
	         * `"top"`: The top of the icon is placed closest to the anchor.<br />
	         * `"bottom"`: The bottom of the icon is placed closest to the anchor.<br />
	         * `"top-left"`: The top left corner of the icon is placed closest to the anchor.<br />
	         * `"top-right"`: The top right corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-left"`: The bottom left corner of the icon is placed closest to the anchor.<br />
	         * `"bottom-right"`: The bottom right corner of the icon is placed closest to the anchor.<br />
	         * Default: `undefined`
	         * @default undefined
	         */
	        _this.variableAnchor = undefined;
	        /**
	         * The size of the font in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `16`.
	         * @default 16
	         */
	        _this.size = 16;
	        /**
	         * The color of the text.
	         * Default `"#000000"`.
	         * @default "#000000"
	         */
	        _this.color = "#000000";
	        /**
	         * The halo's fadeout distance towards the outside in pixels.
	         * Must be a number greater or equal to 0.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloBlur = 0;
	        /**
	         * The color of the text's halo, which helps it stand out from backgrounds.
	         * Default `"rgba(0,0,0,0)"`.
	         * @default "rgba(0,0,0,0)"
	         */
	        _this.haloColor = "rgba(0,0,0,0)";
	        /**
	         * The distance of the halo to the font outline in pixels.
	         * Must be a number greater or equal to 0.
	         * The maximum text halo width is 1/4 of the font size.
	         * Default `0`.
	         * @default 0
	         */
	        _this.haloWidth = 0;
	        /**
	         * A number between 0 and 1 that indicates the opacity at which the text will be drawn.
	         * Default `1`.
	         * @default 1
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return TextOptions;
	}(Options));

	var __extends$u = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering geometries in a SymbolLayer.
	 */
	var SymbolLayerOptions = /** @class */ (function (_super) {
	    __extends$u(SymbolLayerOptions, _super);
	    function SymbolLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The id or instance of a data source which the layer will render.
	         */
	        _this.source = undefined;
	        /**
	         * Required when the source of the layer is a VectorTileSource.
	         * A vector source can have multiple layers within it, this identifies which one to render in this layer.
	         * Prohibited for all other types of sources.
	         */
	        _this.sourceLayer = undefined;
	        /**
	         * Options used to customize the icons of the symbols.
	         * @see IconOptions for defaults.
	         */
	        _this.iconOptions = new IconOptions();
	        /**
	         * Options used to customize the text of the symbols.
	         * @see TextOptions for defaults.
	         */
	        _this.textOptions = new TextOptions();
	        /**
	         * Specifies the label placement relative to its geometry.<br />
	         * `"point"`: The label is placed at the point where the geometry is located.<br />
	         * `"line"`: The label is placed along the line of the geometry.
	         * Can only be used on LineString and Polygon geometries.<br />
	         *  `"line-center"`: The label is placed at the center of the line of the geometry.
	         * Can only be used on `LineString` and `Polygon` geometries <br />
	         * Default `"point"`.
	         * @default "point"
	         */
	        _this.placement = "point";
	        /**
	         * Sorts features in ascending order based on this value. Features with
	         * lower sort keys are drawn and placed first.
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.sortKey = undefined;
	        /**
	         * Determines whether overlapping symbols in the same layer are rendered in the order
	         * that they appear in the data source, or by their y position relative to the viewport.
	         * To control the order and prioritization of symbols otherwise, use `sortKey`.<br />
	         * `"auto"`: Sorts symbols by `sortKey` if set. Otherwise behaves like `"viewport-y"`.<br />
	         * `"viewport-y"`: Sorts symbols by their y position if `allowOverlap` is `true` or
	         * if `ignorePlacement` is `false`.<br />
	         * `"source"`: Sorts symbols by `sortKey` if set. Otherwise, symbols are rendered in the
	         * same order as the source data.<br />
	         * Default `"auto"`
	         * @default "auto"
	         */
	        _this.zOrder = "auto";
	        /**
	         * Distance in pixels between two symbol anchors along a line. Must be greater or equal to 1.
	         * Default `250`.
	         * @default 250
	         */
	        _this.lineSpacing = 250;
	        return _this;
	    }
	    return SymbolLayerOptions;
	}(LayerOptions$1));

	var __extends$t = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$7 = (window && window.__assign) || function () {
	    __assign$7 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$7.apply(this, arguments);
	};
	/**
	 * Renders point based data as symbols on the map using text and/or icons.
	 * Symbols can also be created for line and polygon data as well.
	 */
	var SymbolLayer = /** @class */ (function (_super) {
	    __extends$t(SymbolLayer, _super);
	    /**
	     * Constructs a new SymbolLayer.
	     * @param source The id or instance of a data source which the layer will render.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the polygon layer.
	     */
	    function SymbolLayer(source, id, options) {
	        var _this = _super.call(this, id) || this;
	        _this.options = new SymbolLayerOptions().merge(cloneDeepWith$1(options, SymbolLayerOptions._cloneCustomizer));
	        _this.options.source = source || _this.options.source;
	        return _this;
	    }
	    /**
	     * Gets the options of the symbol layer.
	     */
	    SymbolLayer.prototype.getOptions = function () {
	        return cloneDeepWith$1(this.options, SymbolLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Gets the source provided when creating the layer.
	     */
	    SymbolLayer.prototype.getSource = function () {
	        return this.options.source;
	    };
	    /**
	     * Sets the options of the symbol layer.
	     * @param newOptions The new options of the polygon layer.
	     */
	    SymbolLayer.prototype.setOptions = function (options) {
	        var newOptions = new SymbolLayerOptions().merge(this.options, cloneDeepWith$1(options, SymbolLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the source or sourceLayer options are changed
	            // the layer must be re-added to the map entirely.
	            if (newOptions.source !== this.options.source ||
	                newOptions.sourceLayer !== this.options.sourceLayer) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            var thisOpts = this.options;
	            var newIconOpts = newOptions.iconOptions;
	            var thisIconOpts = thisOpts.iconOptions;
	            var newTextOpts = newOptions.textOptions;
	            var thisTextOpts = thisOpts.textOptions;
	            // Symbol options.
	            this._updateBaseProperties(newOptions, thisOpts);
	            this._updateLayoutProperty("symbol-spacing", newOptions.lineSpacing, thisOpts.lineSpacing);
	            this._updateLayoutProperty("symbol-placement", newOptions.placement, thisOpts.placement);
	            this._updateLayoutProperty("symbol-sort-key", newOptions.sortKey, thisOpts.sortKey);
	            // REVIEW: @types/maplibregl-js doesn't show "auto" for "symbol-z-order"
	            this._updateLayoutProperty("symbol-z-order", newOptions.zOrder, thisOpts.zOrder);
	            // Icon options.
	            this._updateLayoutProperty("icon-allow-overlap", newIconOpts.allowOverlap, thisIconOpts.allowOverlap);
	            this._updateLayoutProperty("icon-anchor", newIconOpts.anchor, thisIconOpts.anchor);
	            this._updateLayoutProperty("icon-ignore-placement", newIconOpts.ignorePlacement, thisIconOpts.ignorePlacement);
	            this._updateLayoutProperty("icon-image", newIconOpts.image, thisIconOpts.image);
	            this._updateLayoutProperty("icon-offset", newIconOpts.offset, thisIconOpts.offset);
	            this._updatePaintProperty("icon-opacity", newIconOpts.opacity, thisIconOpts.opacity);
	            this._updateLayoutProperty("icon-optional", newIconOpts.optional, thisIconOpts.optional);
	            this._updateLayoutProperty("icon-padding", newIconOpts.padding, thisIconOpts.padding);
	            this._updateLayoutProperty("icon-pitch-alignment", newIconOpts.pitchAlignment, thisIconOpts.pitchAlignment);
	            this._updateLayoutProperty("icon-rotate", newIconOpts.rotation, thisIconOpts.rotation);
	            this._updateLayoutProperty("icon-rotation-alignment", newIconOpts.rotationAlignment, thisIconOpts.rotationAlignment);
	            this._updateLayoutProperty("icon-size", newIconOpts.size, thisIconOpts.size);
	            // Text options.
	            this._updateLayoutProperty("text-allow-overlap", newTextOpts.allowOverlap, thisTextOpts.allowOverlap);
	            this._updateLayoutProperty("text-anchor", newTextOpts.anchor, thisTextOpts.anchor);
	            this._updatePaintProperty("text-color", newTextOpts.color, thisTextOpts.color);
	            this._updateLayoutProperty("text-font", newTextOpts.font, thisTextOpts.font);
	            this._updateLayoutProperty("text-ignore-placement", newTextOpts.ignorePlacement, thisTextOpts.ignorePlacement);
	            this._updateLayoutProperty("text-justify", newTextOpts.justify, thisTextOpts.justify);
	            this._updatePaintProperty("text-halo-blur", newTextOpts.haloBlur, thisTextOpts.haloBlur);
	            this._updatePaintProperty("text-halo-color", newTextOpts.haloColor, thisTextOpts.haloColor);
	            this._updatePaintProperty("text-halo-width", newTextOpts.haloWidth, thisTextOpts.haloWidth);
	            this._updateLayoutProperty("text-offset", newTextOpts.offset, thisTextOpts.offset);
	            this._updatePaintProperty("text-opacity", newTextOpts.opacity, thisTextOpts.opacity);
	            this._updateLayoutProperty("text-optional", newTextOpts.optional, thisTextOpts.optional);
	            this._updateLayoutProperty("text-padding", newTextOpts.padding, thisTextOpts.padding);
	            this._updateLayoutProperty("text-pitch-alignment", newTextOpts.pitchAlignment, thisTextOpts.pitchAlignment);
	            this._updateLayoutProperty("text-radial-offset", newTextOpts.radialOffset, thisTextOpts.radialOffset);
	            this._updateLayoutProperty("text-rotate", newTextOpts.rotation, thisTextOpts.rotation);
	            this._updateLayoutProperty("text-rotation-alignment", newTextOpts.rotationAlignment, thisTextOpts.rotationAlignment);
	            this._updateLayoutProperty("text-size", newTextOpts.size, thisTextOpts.size);
	            this._updateLayoutProperty("text-variable-anchor", newTextOpts.variableAnchor, thisTextOpts.variableAnchor);
	            this._updateLayoutProperty("text-field", newTextOpts.textField, thisTextOpts.textField);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._buildLayers = function () {
	        var layer = __assign$7(__assign$7(__assign$7(__assign$7({ id: this.id, type: "symbol" }, (this.options.sourceLayer && { "source-layer": this.options.sourceLayer })), { source: this.options.source instanceof Source ?
	                this.options.source.getId() :
	                this.options.source, layout: __assign$7(__assign$7({ visibility: this.options.visible ? "visible" : "none", "symbol-placement": this.options.placement, "symbol-spacing": this.options.lineSpacing, "symbol-z-order": this.options.zOrder, 
	                // Text options.
	                "text-allow-overlap": this.options.textOptions.allowOverlap, "text-anchor": this.options.textOptions.anchor }, (this.options.textOptions.textField && { "text-field": this.options.textOptions.textField })), { "text-font": this.options.textOptions.font, "text-ignore-placement": this.options.textOptions.ignorePlacement, "text-justify": this.options.textOptions.justify, "text-offset": this.options.textOptions.offset, "text-optional": this.options.textOptions.optional, "text-padding": this.options.textOptions.padding, "text-pitch-alignment": this.options.textOptions.pitchAlignment, "text-rotate": this.options.textOptions.rotation, "text-rotation-alignment": this.options.textOptions.rotationAlignment, "text-size": this.options.textOptions.size, 
	                // Icon options.
	                "icon-allow-overlap": this.options.iconOptions.allowOverlap, "icon-anchor": this.options.iconOptions.anchor, "icon-ignore-placement": this.options.iconOptions.ignorePlacement, "icon-image": this.options.iconOptions.image, "icon-offset": this.options.iconOptions.offset, "icon-optional": this.options.iconOptions.optional, "icon-padding": this.options.iconOptions.padding, "icon-pitch-alignment": this.options.iconOptions.pitchAlignment, "icon-rotate": this.options.iconOptions.rotation, "icon-rotation-alignment": this.options.iconOptions.rotationAlignment, "icon-size": this.options.iconOptions.size }), paint: {
	                // Text options.
	                "text-color": this.options.textOptions.color,
	                "text-halo-blur": this.options.textOptions.haloBlur,
	                "text-halo-color": this.options.textOptions.haloColor,
	                "text-halo-width": this.options.textOptions.haloWidth,
	                "text-opacity": this.options.textOptions.opacity,
	                // Icon options.
	                "icon-opacity": this.options.iconOptions.opacity,
	            } }), (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        // REVIEW: MapLibre throws style validation error if optional properties show up in style
	        // with null/undefined as value.
	        if (typeof this.options.sortKey !== "undefined") {
	            layer.layout["symbol-sort-key"] = this.options.sortKey;
	        }
	        if (typeof this.options.textOptions.radialOffset !== "undefined") {
	            layer.layout["text-radial-offset"] = this.options.textOptions.radialOffset;
	        }
	        if (typeof this.options.textOptions.variableAnchor !== "undefined") {
	            layer.layout["text-variable-anchor"] = this.options.textOptions.variableAnchor;
	        }
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    SymbolLayer.prototype._getSourceIds = function () {
	        var ids = new Set();
	        this.options.source instanceof Source ?
	            ids.add(this.options.source.getId()) :
	            ids.add(this.options.source);
	        return ids;
	    };
	    return SymbolLayer;
	}(Layer));

	var __extends$s = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$6 = (window && window.__assign) || function () {
	    __assign$6 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$6.apply(this, arguments);
	};
	/**
	 * Used to represent the fundamental map source.
	 * @private
	 */
	var FundamentalMapSource = /** @class */ (function (_super) {
	    __extends$s(FundamentalMapSource, _super);
	    /**
	     * Constructs a source from the contents of a layer resource file.
	     * @param id The source's id.
	     * @param sourceDef The sources entry of the resource file.
	     * @param options The query parameters to add to the urls listed in the resource file.
	     */
	    function FundamentalMapSource(id, sourceDef, options) {
	        var _this = _super.call(this, id) || this;
	        _this.source = _this._modifySource(sourceDef, options);
	        return _this;
	    }
	    /**
	     * @internal
	     */
	    FundamentalMapSource.prototype._buildSource = function () {
	        return this.source;
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapSource.prototype._isDeepEqual = function (other) {
	        if (this.constructor !== other.constructor) {
	            return false;
	        }
	        var source = this.source;
	        var otherSource = other.source;
	        var baseEqual = source.type === otherSource.type &&
	            source.url === otherSource.url
	            && ((source.tiles === undefined && otherSource.tiles === undefined) ||
	                (source.tiles && otherSource.tiles && source.tiles.length === otherSource.tiles.length && source.tiles.every(function (value, idx) { return value === otherSource.tiles[idx]; })))
	            && source.minzoom === otherSource.minzoom
	            && source.maxzoom === otherSource.maxzoom
	            && source.bounds === otherSource.bounds
	            && source['attribution'] === otherSource['attribution'];
	        var rasterEqual = source.type !== "raster" || (source.type === "raster"
	            && source.type === otherSource.type
	            && source.tileSize === otherSource.tileSize
	            && source.scheme === otherSource.scheme);
	        var rasterDemEqual = source.type !== "raster-dem" || (source.type === "raster-dem"
	            && source.type === otherSource.type
	            && source.tileSize === otherSource.tileSize
	            && source['encoding'] === otherSource['encoding']);
	        var vectorEqual = source.type !== "vector" || (source.type === "vector"
	            && source.type === otherSource.type
	            && source.promoteId === otherSource.promoteId
	            && source.scheme === otherSource.scheme);
	        return baseEqual && rasterEqual && rasterDemEqual && vectorEqual;
	    };
	    /**
	     * Updates the source info to convert the tiles to url strings.
	     * @param sourceDef The original source info.
	     * @param options The query parameters to add to the tile urls.
	     */
	    FundamentalMapSource.prototype._modifySource = function (sourceDef, options) {
	        if ((sourceDef.type === 'raster' || sourceDef.type === 'raster-dem' || sourceDef.type === 'vector') && sourceDef.tiles) {
	            var tileStrings = sourceDef.tiles.map(function (tile) {
	                if (typeof tile === "string") {
	                    return tile;
	                }
	                var tileUrl = new Url({
	                    domain: constants.domainPlaceHolder,
	                    path: tile.path,
	                    queryParams: __assign$6(__assign$6({}, options), tile.queryParams)
	                });
	                return tileUrl.toString();
	            });
	            sourceDef.tiles = tileStrings;
	        }
	        else if ((sourceDef.type === 'raster' || sourceDef.type === 'raster-dem' || sourceDef.type === 'vector') && sourceDef.url) {
	            sourceDef.url = (typeof sourceDef.url === "string") ?
	                sourceDef.url :
	                new Url({
	                    domain: constants.domainPlaceHolder,
	                    path: sourceDef.url.path,
	                    queryParams: __assign$6(__assign$6({}, options), sourceDef.url.queryParams)
	                }).toString();
	        }
	        else {
	            throw new Error("Source definition must define a TileJSON 'url' or a 'tiles' array.");
	        }
	        return sourceDef;
	    };
	    return FundamentalMapSource;
	}(Source));

	var __extends$r = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used when rendering raster tiled images in a TileLayer.
	 */
	var TileLayerOptions = /** @class */ (function (_super) {
	    __extends$r(TileLayerOptions, _super);
	    function TileLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * A bounding box that specifies where tiles are available.
	         * When specified, no tiles outside of the bounding box will be requested.
	         * Default `[-180, -85.0511, 180, 85.0511]`.
	         * @default [-180, -85.0511, 180, 85.0511]
	         */
	        _this.bounds = [-180, -85.0511, 180, 85.0511];
	        /**
	         * An integer specifying the minimum zoom level in which tiles are available from the tile source.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minSourceZoom = 0;
	        /**
	         * An integer specifying the maximum zoom level in which tiles are available from the tile source.
	         * Default `22`.
	         * @default 22
	         */
	        _this.maxSourceZoom = 22;
	        /**
	         * An integer value that specifies the width and height dimensions of the map tiles.
	         * For a seamless experience, the tile size must be a multiplier of 2.
	         * Default `512`.
	         * @default 512
	         */
	        _this.tileSize = 512;
	        /**
	         * Specifies if the tile systems coordinates uses the Tile Map Services specification,
	         * which reverses the Y coordinate axis.
	         * Default `false`.
	         * @default false
	         */
	        _this.isTMS = false;
	        /**
	         * An array of subdomain values to apply to the tile URL.
	         */
	        _this.subdomains = undefined;
	        /**
	         * A http/https URL to a TileJSON resource or a tile URL template that uses the following parameters:
	         * <p>{x}: X position of the tile. Usually also needs {y} and {z}.</p>
	         * <p>{y}: Y position of the tile. Usually also needs {x} and {z}.</p>
	         * <p>{z}: Zoom level of the tile. Usually also needs {x} and {y}.</p>
	         * <p>{quadkey}: Tile quadKey id based on the Bing Maps tile system naming convention.</p>
	         * <p>{bbox-epsg-3857}: A bounding box string with the format {west},{south},{east},{north}
	         * in the EPSG 4325 Spacial Reference System.</p>
	         * <p>{subdomain}: A placeholder where the subdomain values if specified will be added.</p>
	         */
	        _this.tileUrl = undefined;
	        return _this;
	    }
	    return TileLayerOptions;
	}(MediaLayerOptions));

	var __extends$q = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$5 = (window && window.__assign) || function () {
	    __assign$5 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$5.apply(this, arguments);
	};
	var __values$d = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * Renders raster tiled images on top of the map tiles.
	 */
	var TileLayer = /** @class */ (function (_super) {
	    __extends$q(TileLayer, _super);
	    /**
	     * Constructs a new TileLayer.
	     * @param options The options for the tile layer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     */
	    function TileLayer(options, id) {
	        var _this = _super.call(this, id) || this;
	        if (options) {
	            _this.setOptions(options);
	        }
	        return _this;
	    }
	    /**
	     * Gets the options of the tile layer.
	     */
	    TileLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, TileLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the tile layer.
	     * @param newOptions The new options of the tile layer.
	     */
	    TileLayer.prototype.setOptions = function (options) {
	        var newOptions = new TileLayerOptions().merge(this.options, cloneDeepWith$1(options, TileLayerOptions._cloneCustomizer));
	        if (this.map) {
	            // If the bounds, isTMS, max/minSourceZoom, subdomains, tileSize, or tileUrl
	            // options are changed the layer must be re-added to the map entirely.
	            if (!(isEqual$1(newOptions.bounds, this.options.bounds)) ||
	                newOptions.isTMS !== this.options.isTMS ||
	                newOptions.maxSourceZoom !== this.options.maxSourceZoom ||
	                newOptions.minSourceZoom !== this.options.minSourceZoom ||
	                !(isEqual$1(newOptions.subdomains, this.options.subdomains)) ||
	                newOptions.tileSize !== this.options.tileSize ||
	                newOptions.tileUrl !== this.options.tileUrl) {
	                // No update calls needed if the entire layer is being re-added.
	                this.options = newOptions;
	                this.map.layers.add(this);
	                return;
	            }
	            this._updateBaseProperties(newOptions, this.options);
	            this._updatePaintProperty("raster-contrast", newOptions.contrast, this.options.contrast);
	            this._updatePaintProperty("raster-fade-duration", newOptions.fadeDuration, this.options.fadeDuration);
	            this._updatePaintProperty("raster-hue-rotate", newOptions.hueRotation, this.options.hueRotation);
	            this._updatePaintProperty("raster-brightness-max", newOptions.maxBrightness, this.options.maxBrightness);
	            this._updatePaintProperty("raster-opacity", newOptions.opacity, this.options.opacity);
	            this._updatePaintProperty("raster-saturation", newOptions.saturation, this.options.saturation);
	        }
	        this.options = newOptions;
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._setOptionsNoUpdate = function (options) {
	        this.options = new TileLayerOptions().merge(this.options, cloneDeepWith$1(options, TileLayerOptions._cloneCustomizer));
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._buildLayers = function () {
	        var layer = __assign$5(__assign$5({ id: this.id, type: "raster", source: this._getSourceId(), layout: {
	                visibility: this.options.visible ? "visible" : "none"
	            }, paint: {
	                "raster-contrast": this.options.contrast,
	                "raster-fade-duration": this.options.fadeDuration,
	                "raster-hue-rotate": this.options.hueRotation,
	                "raster-brightness-max": this.options.maxBrightness,
	                "raster-brightness-min": this.options.minBrightness,
	                "raster-opacity": this.options.opacity,
	                "raster-saturation": this.options.saturation
	            } }, (this.options.filter && { filter: this.options.filter })), { minzoom: this.options.minZoom, maxzoom: this.options.maxZoom });
	        return [layer];
	    };
	    /**
	     * @internal
	     */
	    TileLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * Builds the raster source to include with the layer.
	     * @internal
	     */
	    TileLayer.prototype._buildSource = function () {
	        var e_1, _a;
	        var tiles;
	        if (this.options.tileUrl) {
	            // If the tileUrl include { assume it is a formatted string and use tiles property.
	            if (this.options.tileUrl.indexOf("{") !== -1) {
	                // If the tileUrl include the subdomain placeholder
	                // we must manually assign an array of urls to the tiles property
	                // because mapbox does not support the subdomain placeholder.
	                if (this.options.tileUrl.indexOf("{subdomain}") !== -1) {
	                    // Throw an error if no subdomains were specified
	                    if (this.options.subdomains && this.options.subdomains.length > 0) {
	                        var urls = [];
	                        try {
	                            for (var _b = __values$d(this.options.subdomains), _c = _b.next(); !_c.done; _c = _b.next()) {
	                                var subdomain = _c.value;
	                                urls.push(this.options.tileUrl.replace(/{subdomain}/g, subdomain));
	                            }
	                        }
	                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                        finally {
	                            try {
	                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                            }
	                            finally { if (e_1) throw e_1.error; }
	                        }
	                        tiles = urls;
	                    }
	                    else {
	                        throw new Error("The {subdomain} placeholder was included in the tileUrl but no subdomains were specified");
	                    }
	                }
	                else {
	                    // Else just provide a single url.
	                    tiles = [this.options.tileUrl];
	                }
	            }
	            else {
	                // Else assume it is just a TileJSON url and use the url property.
	                // For a TileJSON url only the url needs to be specified.
	                return {
	                    type: "raster",
	                    url: this.options.tileUrl
	                };
	            }
	        }
	        return __assign$5({ type: "raster", bounds: this.options.bounds, maxzoom: this.options.maxSourceZoom, minzoom: this.options.minSourceZoom, scheme: this.options.isTMS ? "tms" : "xyz", tileSize: this.options.tileSize }, (tiles && { tiles: tiles }));
	    };
	    /**
	     * Gets the id of the source to be paired with this layer.
	     * @internal
	     */
	    TileLayer.prototype._getSourceId = function () {
	        return "".concat(this.getId(), "-RasterSource");
	    };
	    TileLayer.prototype._getSourceWrapper = function () {
	        var sourceId = this._getSourceId();
	        var source = this._buildSource();
	        return new FundamentalMapSource(sourceId, {
	            name: sourceId,
	            tiles: source.tiles,
	            type: source.type,
	            url: source.url
	        });
	    };
	    return TileLayer;
	}(SourceBuildingLayer));

	var __extends$p = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options used to render graphics in a WebGLLayer.
	 */
	var WebGLLayerOptions = /** @class */ (function (_super) {
	    __extends$p(WebGLLayerOptions, _super);
	    function WebGLLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * An object that contains the rendering logic.
	         */
	        _this.renderer = undefined;
	        return _this;
	    }
	    return WebGLLayerOptions;
	}(LayerOptions$1));

	var __extends$o = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Enables custom rendering logic with access to the WebGL context of the map.
	 */
	var WebGLLayer = /** @class */ (function (_super) {
	    __extends$o(WebGLLayer, _super);
	    /**
	     * Constructs a new WebGLLayer.
	     * @param id The id of the layer. If not specified a random one will be generated.
	     * @param options The options of the WebGL layer.
	     */
	    function WebGLLayer(id, options) {
	        var _this = _super.call(this, id) || this;
	        /**
	         * Make sure the layer is available after a style change.
	         * @internal
	         */
	        _this._onStyleChange = function () {
	            var _a;
	            // Custom layers cannot be serialized and preserved by mapbox.
	            // Add this layer again if the layer was removed by mapbox after a style change.
	            if (!_this.map._getMap().getLayer(_this.id)) {
	                var map = _this.map;
	                var before = (_a = _this.map.layers._getUserLayers().find(function (l) { return l.layer.getId() == _this.id; })) === null || _a === void 0 ? void 0 : _a.before;
	                map.layers.remove(_this);
	                map.layers.add(_this, before);
	            }
	        };
	        _this.options = new WebGLLayerOptions().merge(cloneDeepWith$1(options, WebGLLayerOptions._cloneCustomizer));
	        _this.source = new DataSource();
	        return _this;
	    }
	    /**
	     * Gets the options of the WebGL layer.
	     */
	    WebGLLayer.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, WebGLLayerOptions._cloneCustomizer);
	    };
	    /**
	     * Sets the options of the WebGL layer.
	     * @param options The new options of the WebGL layer.
	     */
	    WebGLLayer.prototype.setOptions = function (options) {
	        var newOptions = new WebGLLayerOptions().merge(this.options, cloneDeepWith$1(options, WebGLLayerOptions._cloneCustomizer));
	        // Trigger a repaint of the map if the layer options have changed.
	        if (this.map) {
	            this.map.triggerRepaint();
	        }
	        this.options = newOptions;
	    };
	    WebGLLayer.prototype.onAdd = function (map) {
	        var _a, _b;
	        _super.prototype.onAdd.call(this, map);
	        // Make sure the layer is available after a style change.
	        this.map.events.add("stylechanged", this._onStyleChange);
	        // Notify the renderer this layer has been added to the map.
	        if (this.options.renderer && this.glContext) {
	            (_b = (_a = this.options.renderer).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, map, this.glContext);
	        }
	    };
	    WebGLLayer.prototype.onRemove = function () {
	        var _a, _b;
	        // Notify the renderer this layer has been removed from the map.
	        if (this.options.renderer && this.glContext) {
	            (_b = (_a = this.options.renderer).onRemove) === null || _b === void 0 ? void 0 : _b.call(_a, this.map, this.glContext);
	        }
	        // Cleanup
	        this.map.events.remove("stylechanged", this._onStyleChange);
	        this.glContext = null;
	        _super.prototype.onRemove.call(this);
	    };
	    /**
	     * @internal
	     */
	    WebGLLayer.prototype._buildLayers = function () {
	        var _this = this;
	        if (!this.options.renderer) {
	            throw new Error("Cannot build the WebGL layer because renderer was not set.");
	        }
	        return [
	            {
	                id: this.id,
	                type: "custom",
	                renderingMode: this.options.renderer.renderingMode,
	                onAdd: function (m, gl) {
	                    // Capture the GL context to reuse it later.
	                    // renderer.onAdd will be called in the onAdd callback of this layer.
	                    _this.glContext = gl;
	                },
	                onRemove: function (m, gl) {
	                    // renderer.onRemove will be called in the onRemove callback of this layer.
	                },
	                prerender: function (gl, matrix) {
	                    var _a, _b;
	                    if (_this._shouldRender()) {
	                        (_b = (_a = _this.options.renderer).prerender) === null || _b === void 0 ? void 0 : _b.call(_a, gl, matrix);
	                    }
	                },
	                render: function (gl, matrix) {
	                    if (_this._shouldRender()) {
	                        _this.options.renderer.render(gl, matrix);
	                    }
	                }
	            }
	        ];
	    };
	    /**
	     * @internal
	     */
	    WebGLLayer.prototype._getLayerIds = function () {
	        return [this.id];
	    };
	    /**
	     * @internal
	     */
	    WebGLLayer.prototype._getSourceIds = function () {
	        return new Set().add(this.source.getId());
	    };
	    /**
	     * Returns true if the next frame should be rendered
	     * @internal
	     */
	    WebGLLayer.prototype._shouldRender = function () {
	        if (this.map) {
	            var zoom = this.map.getCamera().zoom;
	            return this.options.visible && this.options.minZoom <= zoom && this.options.maxZoom > zoom;
	        }
	        return false;
	    };
	    return WebGLLayer;
	}(Layer));

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BubbleLayer: BubbleLayer,
		HeatMapLayer: HeatMapLayer,
		ImageLayer: ImageLayer,
		Layer: Layer,
		LineLayer: LineLayer,
		PolygonExtrusionLayer: PolygonExtrusionLayer,
		PolygonLayer: PolygonLayer,
		SymbolLayer: SymbolLayer,
		TileLayer: TileLayer,
		WebGLLayer: WebGLLayer
	});

	var Html = /** @class */ (function () {
	    function Html() {
	    }
	    /**
	     * Converts the specified content into a div element.
	     * @param content A string to make the innerHTML of the div element.
	     * If a HTMLElement is provided it is returned unmodified.
	     */
	    Html.convertHtmlString = function (content) {
	        if (typeof content === "string") {
	            var htmlEle = document.createElement("div");
	            htmlEle.innerHTML = content;
	            return htmlEle;
	        }
	        else {
	            return content;
	        }
	    };
	    /**
	     * Parses the html string and filters out DOM nodes according to provided filter
	     * @param content A string containing valid html.
	     * @param filter A filter condition to check if the DOM node is allowed
	     * @param groupingElement An element that will be used as a root element if the content is a flat list of nodes
	     * If plain text is provided, the string will be returned
	     */
	    Html.parseWithFilter = function (content, filter, transformer, groupingElement) {
	        var _this = this;
	        if (filter === void 0) { filter = function (_) { return true; }; }
	        if (transformer === void 0) { transformer = function (elem) { return elem; }; }
	        if (groupingElement === void 0) { groupingElement = function () { return document.createElement('div'); }; }
	        var elem;
	        if (typeof content === 'string') {
	            var body = (new DOMParser()).parseFromString(content, 'text/html').body;
	            if (body.children.length == 0) {
	                return transformer(body.innerHTML);
	            }
	            else if (body.children.length == 1 && body.childNodes.length == 1) {
	                elem = body.children[0];
	            }
	            else {
	                var container_1 = groupingElement();
	                Array.from(body.childNodes).map(function (node) { return container_1.append(node); });
	                elem = container_1;
	            }
	        }
	        else {
	            elem = content;
	        }
	        Array.from(elem.children).forEach(function (elem) { return _this.parseWithFilter(elem, filter, transformer); });
	        if (!filter(elem)) {
	            if (elem.parentNode) {
	                elem.parentNode.removeChild(elem);
	            }
	            return null;
	        }
	        else {
	            return transformer(elem);
	        }
	    };
	    return Html;
	}());

	var isObjectLike = isObjectLike_1,
	    isPlainObject = isPlainObject_1;

	/**
	 * Checks if `value` is likely a DOM element.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	 * @example
	 *
	 * _.isElement(document.body);
	 * // => true
	 *
	 * _.isElement('<body>');
	 * // => false
	 */
	function isElement(value) {
	  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	}

	var isElement_1 = isElement;

	var isElement$1 = /*@__PURE__*/getDefaultExportFromCjs(isElement_1);

	var __extends$n = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a popup.
	 */
	var PopupOptions = /** @class */ (function (_super) {
	    __extends$n(PopupOptions, _super);
	    function PopupOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the popup's location relative to its position on the map.
	         * Optional values: `"none"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * default `"none"`
	         * @default "none"
	         */
	        _this.anchor = "none";
	        /**
	         * Specifies if the popup can be dragged away from its position.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * Specifies if the close button should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.closeButton = true;
	        /**
	         * The content to display within the popup.
	         * default `span`
	         * @default span
	         */
	        _this.content = document.createElement("span");
	        /**
	         * Specifies the fill color of the popup.
	         * default `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.fillColor = "#FFFFFF";
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the anchor of the popup should be
	         * offset. Negative numbers can be used to offset the popup left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position on the map where the popup should be anchored.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * Specifies if the pointer should be displayed in the popup or not.
	         * default `true`
	         * @default true
	         */
	        _this.showPointer = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    PopupOptions._cloneCustomizer = function (value) {
	        if (isElement$1(value)) {
	            return value;
	        }
	    };
	    return PopupOptions;
	}(Options));

	var __extends$m = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __read$8 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	/**
	 * An information window anchored at a specified position on a map.
	 */
	var Popup = /** @class */ (function (_super) {
	    __extends$m(Popup, _super);
	    /**
	     * Constructs a Popup object and initializes it with the specified options.
	     * @param options The options for the popup.
	     */
	    function Popup(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Attaches the popup to the HTML document in a hidden state.
	         * @param map The map.
	         */
	        _this.attach = function (map) {
	            // If attaching to a different map, remove popup on current map
	            if (_this.map !== map) {
	                // If map was defined the popup was attached to another map.
	                if (_this.map) {
	                    _this.remove();
	                }
	                // Create the marker before attaching the popup and it to the map.
	                _this.map = map;
	                _this.marker = _this._createMarker(_this.options);
	                // Attach the wrapped mapbox marker to the map.
	                // When the marker is attached to the map it will attach the containerHtml to a default container.
	                // Move the containerHtml to the popup collection container after attaching the marker.
	                _this.marker.addTo(_this.map._getMap());
	                _this.map.popups._getCollectionDiv().appendChild(_this.containerDiv);
	                _this.map.popups.add(_this);
	            }
	        };
	        /**
	         * Opens the popup.
	         * @param map The map to open the popup on.
	         * Optional if already attached to a map.
	         */
	        _this.open = function (map) {
	            if (!map && !_this.map) {
	                throw new Error("Must specify a map to open on or attach to a map in advance");
	            }
	            _this.attach(map || _this.map);
	            _this.containerDiv.classList.remove(Popup.Css.hidden);
	            _this.map.events.add("move", _this._onMove);
	            _this._onMove();
	            _this._invokeEvent("open", { target: _this, type: "open" });
	        };
	        /**
	         * Closes the popup on the map. The popup remains attached to the HTML document.
	         */
	        _this.close = function () {
	            if (_this.map) {
	                _this.map.events.remove("move", _this._onMove);
	            }
	            _this.containerDiv.classList.add(Popup.Css.hidden);
	            _this._invokeEvent("close", { target: _this, type: "close" });
	        };
	        /**
	         * Closes the popup on the map and removes it from the HTML document.
	         */
	        _this.remove = function () {
	            if (_this.map) {
	                _this.marker.remove();
	                _this.containerDiv.classList.remove(_this.autoAnchor || _this.options.anchor);
	                _this.map.events.remove("move", _this._onMove);
	                _this.map.popups.remove(_this);
	                delete _this.map;
	                delete _this.marker;
	                delete _this.autoAnchor;
	            }
	        };
	        /**
	         * Returns true if the popup is currently open, otherwise false.
	         */
	        _this.isOpen = function () {
	            return _this.map && !_this.containerDiv.classList.contains(Popup.Css.hidden);
	        };
	        /**
	         * Callback for the move listener used for auto anchoring.
	         */
	        _this._onMove = function () {
	            var newAutoAnchor = _this._getAutoAnchor(_this.map, _this.options);
	            if (newAutoAnchor !== _this.autoAnchor) {
	                // When we replace the marker it adds a new move listeners.
	                // We want our listener to fire after the marker's, so we add it again.
	                // Adding the listener again means it will fire after all other previously listeners.
	                _this._replaceMarker(_this.map, _this.options, newAutoAnchor);
	                _this.map.events.add("move", _this._onMove);
	            }
	        };
	        /**
	         * Called by a mouse down or touch start event.
	         */
	        _this._onDown = function (event) {
	            var _a;
	            _this.map.popups._addDraggedPopup(_this);
	            var anchorPixel = (_a = __read$8(_this.map.positionsToPixels([_this.options.position]), 1), _a[0]);
	            if (event.type === "mousedown") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.clientX,
	                    anchorPixel[1] - event.clientY
	                ];
	            }
	            else if (event.type === "touchstart") {
	                event = event;
	                _this.dragOffset = [
	                    anchorPixel[0] - event.touches[0].clientX,
	                    anchorPixel[1] - event.touches[0].clientY
	                ];
	            }
	        };
	        /**
	         * Called by the container's dragstart event.
	         * Used to call preventDefault as a fix for Edge dragging issues.
	         */
	        _this._onDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new PopupOptions().merge(cloneDeepWith$1(options, PopupOptions._cloneCustomizer));
	        // Create full content container
	        _this.containerDiv = _this._createContainerDiv(_this.options);
	        // Create the container for the content specified in the options.
	        _this.contentDiv = _this._createContentDiv(_this.options);
	        _this.containerDiv.appendChild(_this.contentDiv);
	        // Create arrow tip if specified in the options.
	        if (_this.options.showPointer) {
	            _this.arrowDiv = _this._createArrowDiv();
	            _this.containerDiv.appendChild(_this.arrowDiv);
	        }
	        // Create close button if specified in the options.
	        if (_this.options.closeButton) {
	            _this.closeBtn = _this._createCloseButton();
	            _this.contentDiv.appendChild(_this.closeBtn);
	            var tooltip = buildAccessibleTooltip("close");
	            _this.contentDiv.appendChild(tooltip);
	            positionTooltip(tooltip, _this.closeBtn, true);
	        }
	        return _this;
	    }
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     * @deprecated Use setOptions(...) instead.
	     */
	    Popup.prototype.setPopupOptions = function (options) {
	        this.setOptions(options);
	    };
	    /**
	     * Sets the options for the popup.
	     * @param options The options for the popup.
	     */
	    Popup.prototype.setOptions = function (options) {
	        var newOptions = new PopupOptions().merge(this.options, cloneDeepWith$1(options, PopupOptions._cloneCustomizer));
	        if (newOptions.content !== this.options.content) {
	            // If the popup content is changed remove the old content and add the new stuff.
	            // Will also implicitly update draggability.
	            this.htmlContent.remove();
	            this.htmlContent = this._createHtmlContent(newOptions);
	            this.contentDiv.prepend(this.htmlContent);
	        }
	        else if (newOptions.draggable !== this.options.draggable) {
	            // If the content hasn't changed, check if draggable is changed.
	            this._setDraggable(this.htmlContent, newOptions.draggable);
	        }
	        // If a close button should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.closeButton && !this.closeBtn) {
	            this.closeBtn = this._createCloseButton();
	            this.contentDiv.appendChild(this.closeBtn);
	            var tooltip = buildAccessibleTooltip("close");
	            this.contentDiv.appendChild(tooltip);
	            positionTooltip(tooltip, this.closeBtn, true);
	        }
	        else if (!newOptions.closeButton && this.closeBtn) {
	            this.contentDiv.removeChild(this.closeBtn);
	            delete this.closeBtn;
	        }
	        // If a pointer should be shown but the close button hasn't
	        // been initialized or is missing from the container add it.
	        if (newOptions.showPointer && !this.arrowDiv) {
	            this.arrowDiv = this._createArrowDiv();
	            this.containerDiv.appendChild(this.arrowDiv);
	        }
	        else if (!newOptions.showPointer && this.arrowDiv) {
	            this.containerDiv.removeChild(this.arrowDiv);
	            delete this.arrowDiv;
	        }
	        // If the fill color is changed update the relavent elements.
	        if (newOptions.fillColor !== this.options.fillColor) {
	            this.containerDiv.style.borderColor = newOptions.fillColor;
	            this.contentDiv.style.backgroundColor = newOptions.fillColor;
	        }
	        if (this.marker) {
	            if (newOptions.anchor !== this.options.anchor) {
	                // If the anchor property has changed we need to build a new marker.
	                if (this.options.anchor === "none") {
	                    if (this.autoAnchor !== newOptions.anchor) {
	                        this._replaceMarker(this.map, newOptions);
	                    }
	                    this.map.events.remove("move", this._onMove);
	                    delete this.autoAnchor;
	                }
	                else {
	                    this._replaceMarker(this.map, newOptions);
	                    if (newOptions.anchor === "none") {
	                        this.map.events.add("move", this._onMove);
	                    }
	                }
	            }
	            else {
	                // Check if the position is changed.
	                if (!isEqual$1(newOptions.position, this.options.position)) {
	                    this.marker.setLngLat(newOptions.position);
	                }
	                // Check if the offset is changed.
	                if (!isEqual$1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                    this.marker.setOffset(newOptions.pixelOffset);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Returns the options for the popup.
	     * @deprecated Use getOptions() instead.
	     */
	    Popup.prototype.getPopupOptions = function () {
	        return this.getOptions();
	    };
	    /**
	     * Returns the options for the popup.
	     */
	    Popup.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, PopupOptions._cloneCustomizer);
	    };
	    /**
	     * Returns popup container element.
	     */
	    Popup.prototype.getPopupContainer = function () {
	        return this.containerDiv;
	    };
	    /**
	     * Drags the popup to the specified pixel.
	     * Accounts for the pixel offset when dragging started.
	     * @internal
	     */
	    Popup.prototype._dragToPixel = function (pixel) {
	        var _a;
	        // Wait until the popup has been dragged the first time to fire th dragstart event.
	        if (!this.dragging) {
	            this.dragging = true;
	            this.contentDiv.style.pointerEvents = "none";
	            this._invokeEvent("dragstart", { type: "dragstart", target: this });
	        }
	        var anchorPixel = [
	            pixel[0] + this.dragOffset[0],
	            pixel[1] + this.dragOffset[1]
	        ];
	        var anchorPos = (_a = __read$8(this.map.pixelsToPositions([anchorPixel]), 1), _a[0]);
	        this.options.position = anchorPos;
	        this.marker.setLngLat(this.options.position);
	        this._invokeEvent("drag", { type: "drag", target: this });
	    };
	    /**
	     * Called by a mouse up or touch end event.
	     * @internal
	     */
	    Popup.prototype._onUp = function () {
	        // Only fire the dragend event if the popup was actually dragged.
	        if (this.dragging) {
	            this.contentDiv.style.pointerEvents = "";
	            this._invokeEvent("dragend", { type: "dragend", target: this });
	            if (this.options.anchor === "none") {
	                // If automatically anchoring the popup check if the anchor should change after done dragging.
	                this._onMove();
	            }
	        }
	        // Clear the drag state tracking variables.
	        delete this.dragOffset;
	        delete this.dragging;
	    };
	    /**
	     * Creates the overall container div.
	     */
	    Popup.prototype._createContainerDiv = function (options) {
	        var _this = this;
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.container);
	        ele.classList.add(Popup.Css.hidden);
	        ele.style.borderColor = options.fillColor;
	        ele.setAttribute("role", "dialog");
	        ele.setAttribute("aria-label", "Map Information Window");
	        // Track if a key which can change the focus has been pressed.
	        var focusKeyDown = false;
	        ele.addEventListener("keydown", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = true;
	            }
	        });
	        // If the keyup event occurs before the focusout then don't close the popup.
	        ele.addEventListener("keyup", function (e) {
	            if (e.key === "Tab" || e.key === "Escape" || e.key === "Esc") {
	                focusKeyDown = false;
	            }
	        });
	        // If focus comes in without the popup being open go ahead and open it.
	        ele.addEventListener("focusin", function (e) {
	            if (_this.map && !_this.isOpen()) {
	                _this.open(_this.map);
	                // Focus on the element again because it may have been removed and added back to the DOM
	                if (e.target instanceof HTMLElement) {
	                    e.target.focus();
	                }
	            }
	        });
	        // If the focus is lost after a key was pressed close the popup.
	        ele.addEventListener("focusout", function (e) {
	            if (focusKeyDown && e.relatedTarget instanceof Node && !ele.contains(e.relatedTarget)) {
	                focusKeyDown = false;
	                if (_this.isOpen()) {
	                    _this.close();
	                }
	            }
	        });
	        return ele;
	    };
	    /**
	     * Creates the content container div.
	     */
	    Popup.prototype._createContentDiv = function (options) {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.content);
	        ele.style.backgroundColor = options.fillColor;
	        ele.setAttribute("tabindex", "0");
	        this.htmlContent = this._createHtmlContent(options);
	        ele.appendChild(this.htmlContent);
	        return ele;
	    };
	    /**
	     * Creates an arrow element.
	     */
	    Popup.prototype._createArrowDiv = function () {
	        var ele = document.createElement("div");
	        ele.classList.add(Popup.Css.arrow);
	        return ele;
	    };
	    /**
	     * Creates a close button.
	     */
	    Popup.prototype._createCloseButton = function () {
	        var ele = document.createElement("button");
	        ele.addEventListener("click", this.close);
	        ele.classList.add(Popup.Css.close);
	        ele.setAttribute("aria-label", "close");
	        ele.setAttribute("tabindex", "0");
	        ele.innerHTML = "&times;";
	        return ele;
	    };
	    /**
	     * Creates the user content element.
	     */
	    Popup.prototype._createHtmlContent = function (options) {
	        var ele = Html.convertHtmlString(options.content);
	        if (options.draggable) {
	            this._setDraggable(ele, options.draggable);
	        }
	        return ele;
	    };
	    /**
	     * Creates the marker which wraps the popup.
	     */
	    Popup.prototype._createMarker = function (options, autoAnchor) {
	        // If a marker already exists use it's LngLat value for the new marker's position
	        // This prevent the marker from jumping around if world copies are rendered.
	        var position = this.marker ?
	            this.marker.getLngLat() :
	            options.position;
	        // Create the mapbox marker that will hold the popup.
	        var marker;
	        if (options.anchor === "none") {
	            this.autoAnchor = autoAnchor || "bottom";
	            this.containerDiv.classList.add(this.autoAnchor);
	            marker = new maplibregl.Marker({
	                anchor: this.autoAnchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        else {
	            this.containerDiv.classList.add(options.anchor);
	            marker = new maplibregl.Marker({
	                anchor: options.anchor,
	                element: this.containerDiv,
	                offset: options.pixelOffset,
	            }).setLngLat(position);
	        }
	        return marker;
	    };
	    /**
	     * Calculates the auto anchor value for the current marker.
	     */
	    Popup.prototype._getAutoAnchor = function (map, options) {
	        var _a, _b;
	        var width = this.containerDiv.offsetWidth;
	        var height = this.containerDiv.offsetHeight;
	        var posX;
	        var posY;
	        if (this.marker) {
	            var pt = map._getMap().project(this.marker.getLngLat());
	            posX = pt.x;
	            posY = pt.y;
	        }
	        else {
	            var x = (_a = __read$8(map.positionsToPixels([options.position]), 1), _b = __read$8(_a[0], 2), _b[0]), y = _b[1];
	            posX = x;
	            posY = y;
	        }
	        var autoAnchor = [];
	        if (posY < height) {
	            autoAnchor.push("top");
	        }
	        else if (posY > map.getCanvas().offsetHeight - height) {
	            autoAnchor.push("bottom");
	        }
	        if (posX < width / 2) {
	            autoAnchor.push("left");
	        }
	        else if (posX > map.getCanvas().offsetWidth - width / 2) {
	            autoAnchor.push("right");
	        }
	        return autoAnchor.length > 0 ?
	            autoAnchor.join("-") :
	            "bottom";
	    };
	    /**
	     * Replaces the current marker with a new one using the specified options.
	     */
	    Popup.prototype._replaceMarker = function (map, options, autoAnchor) {
	        // Track the next sibling before the marker is removed.
	        var next = this.containerDiv.nextElementSibling;
	        this.marker.remove();
	        this.containerDiv.classList.remove(this.autoAnchor || this.options.anchor);
	        this.marker = this._createMarker(options, autoAnchor);
	        this.marker.addTo(map._getMap());
	        // If the popup was already to the DOM place it back in the original order
	        // This keeps the tab order consistent.
	        map.popups._getCollectionDiv().insertBefore(this.containerDiv, next || null);
	    };
	    /**
	     * Called to setup or remove draggability.
	     */
	    Popup.prototype._setDraggable = function (ele, draggable) {
	        if (draggable) {
	            ele.addEventListener("mousedown", this._onDown);
	            ele.addEventListener("touchstart", this._onDown);
	            ele.addEventListener("dragstart", this._onDragStart);
	        }
	        else {
	            ele.removeEventListener("mousedown", this._onDown);
	            ele.removeEventListener("touchstart", this._onDown);
	            ele.removeEventListener("dragstart", this._onDragStart);
	        }
	    };
	    // CSS class names.
	    Popup.Css = {
	        arrow: "popup-arrow",
	        close: "popup-close",
	        container: "popup-container",
	        content: "popup-content-container",
	        hidden: "hidden-accessible-element"
	    };
	    return Popup;
	}(EventEmitter));

	var __extends$l = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Options for rendering an HtmlMarker object
	 */
	var HtmlMarkerOptions = /** @class */ (function (_super) {
	    __extends$l(HtmlMarkerOptions, _super);
	    function HtmlMarkerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Indicates the marker's location relative to its position on the map.
	         * Optional values: `"center"`, `"top"`, `"bottom"`, `"left"`, `"right"`,
	         * `"top-left"`, `"top-right"`, `"bottom-left"`, `"bottom-right"`.
	         * Default `"bottom"`
	         * @default "bottom"
	         */
	        _this.anchor = "bottom";
	        /**
	         * A color value that replaces any {color} placeholder property that has been included in a string htmlContent.
	         * default `"#1A73AA"`
	         * @default "#1A73AA"
	         */
	        _this.color = "#1A73AA";
	        /**
	         * Indicates if the user can drag the position of the marker using the mouse or touch controls.
	         * default `false`
	         * @default false
	         */
	        _this.draggable = false;
	        /**
	         * The HTML content of the marker. Can be an HTMLElement or HTML string.
	         * Add {text} and {color} to HTML strings as placeholders to make it easy to update
	         * these values in your marker by using the setOptions function of the HtmlMarker class.
	         * This allows you to create a single HTML marker string that can be used as a template for multiple markers.
	         */
	        _this.htmlContent = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24.5 36.5\" id=\"marker_".concat(uuid(), "\" width=\"24.5\" height=\"36.5\" display=\"block\"><path d=\"M12.25.25a12.2543,12.2543,0,0,0-12,12.4937c0,6.4436,6.4879,12.1093,11.059,22.5641.5493,1.2563,1.3327,1.2563,1.882,0C17.7621,24.8529,24.25,19.1857,24.25,12.7437A12.2543,12.2543,0,0,0,12.25.25Z\"   fill=\"{color}\" stroke=\"{secondaryColor}\" stroke-width=\"0.5\"/><text style=\"font-family: Arial, Helvetica, sans-serif; font-size: 14px; fill: white;\" text-anchor=\"middle\" x=\"12\" y=\"18\">{text}</text></svg>");
	        /**
	         * An offset in pixels to move the popup relative to the markers center.
	         * Negatives indicate left and up.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.pixelOffset = new Pixel(0, 0);
	        /**
	         * The position of the marker.
	         * default `[0, 0]`
	         * @default [0, 0]
	         */
	        _this.position = new Position(0, 0);
	        /**
	         * A popup that is attached to the marker.
	         */
	        _this.popup = undefined;
	        /**
	         * A color value that replaces any {secondaryColor} placeholder property that has been included in a string htmlContent.
	         * default `"white"`
	         * @default "white"
	         */
	        _this.secondaryColor = "white";
	        /**
	         * A string of text that replaces any {text} placeholder property that has been included in a string htmlContent.
	         */
	        _this.text = undefined;
	        /**
	         * Specifies if the marker is visible or not.
	         * default `true`
	         * @default true
	         */
	        _this.visible = true;
	        return _this;
	    }
	    /**
	     * Customizer for _.cloneDeep calls, allows Popups and HTMLElements to pass through without cloning.
	     * @param value The value being cloned.
	     * @internal
	     */
	    HtmlMarkerOptions._cloneCustomizer = function (value) {
	        if (value instanceof Popup || isElement$1(value)) {
	            return value;
	        }
	    };
	    return HtmlMarkerOptions;
	}(Options));

	var __extends$k = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * This class wraps an HTML element that can be displayed on the map.
	 */
	var HtmlMarker = /** @class */ (function (_super) {
	    __extends$k(HtmlMarker, _super);
	    /**
	     * Constructs a new HtmlMarker.
	     * @param options The options for the HtmlMarker.
	     */
	    function HtmlMarker(options) {
	        var _this = _super.call(this) || this;
	        /**
	         * Called by the drag event of the mapbox marker.
	         * @private
	         */
	        _this._onDrag = function () {
	            var lngLat = _this.marker.getLngLat().wrap();
	            _this.options.position = new Position(lngLat.lng, lngLat.lat);
	            _this._invokeEvent("drag", { type: "drag", target: _this });
	        };
	        /**
	         * Called by the dragstart event of the mapbox marker.
	         * @private
	         */
	        _this._onDragStart = function () {
	            _this._invokeEvent("dragstart", { type: "dragstart", target: _this });
	        };
	        /**
	         * Called by the dragend event of the mapbox marker.
	         * @private
	         */
	        _this._onDragEnd = function () {
	            _this._invokeEvent("dragend", { type: "dragend", target: _this });
	        };
	        /**
	         * Called by the events of the marker's element.
	         * @private
	         */
	        _this._bubbleElementEvent = function (event) {
	            _this._invokeEvent(event.type, { type: event.type, target: _this });
	        };
	        /**
	         * Called by the element's dragstart event.
	         * Used to call preventDefault so Edge doesn't break dragging.
	         * @private
	         */
	        _this._onEleDragStart = function (event) {
	            event.preventDefault();
	        };
	        _this.options = new HtmlMarkerOptions().merge(cloneDeepWith$1(options, HtmlMarkerOptions._cloneCustomizer));
	        _this._buildMarker(_this.options);
	        return _this;
	    }
	    /**
	     * Gets the HTML marker options.
	     */
	    HtmlMarker.prototype.getOptions = function () {
	        // Copy the options so the user can't directly change options.
	        // They must use setOptions(...).
	        return cloneDeepWith$1(this.options, HtmlMarkerOptions._cloneCustomizer);
	    };
	    /**
	     * Returns the underlying `Marker`'s HTML element.
	     */
	    HtmlMarker.prototype.getElement = function () {
	        return this.marker.getElement();
	    };
	    /**
	     * Sets the options of the marker.
	     * @param options The options for the marker.
	     */
	    HtmlMarker.prototype.setOptions = function (options) {
	        var newOptions = new HtmlMarkerOptions().merge(this.options, cloneDeepWith$1(options, HtmlMarkerOptions._cloneCustomizer));
	        if (!isEqual$1(newOptions.htmlContent, this.options.htmlContent) ||
	            newOptions.anchor !== this.options.anchor) {
	            // If the htmlContent is new the old marker must be removed and a new one created.
	            this.marker.remove();
	            this._buildMarker(newOptions);
	            // If this marker is attached to a map the new mapbox marker should be added to it.
	            if (this.map) {
	                this.marker.addTo(this.map._getMap());
	                this._getCollectionContainer().appendChild(this.element);
	            }
	        }
	        else {
	            // Check for which options have been updated.
	            // Not necessary if a new marker was created as it will have all the new properties.
	            if (typeof newOptions.htmlContent === "string" &&
	                (newOptions.color !== this.options.color ||
	                    newOptions.text !== this.options.text ||
	                    newOptions.secondaryColor !== this.options.secondaryColor)) {
	                this.element.innerHTML = this._getSubbedHtmlString(newOptions) || "";
	            }
	            if (newOptions.draggable !== this.options.draggable) {
	                this._setDraggable(newOptions.draggable);
	                this.marker.setDraggable(newOptions.draggable);
	            }
	            if (!isEqual$1(newOptions.pixelOffset, this.options.pixelOffset)) {
	                this.marker.setOffset(newOptions.pixelOffset);
	            }
	            if (!isEqual$1(newOptions.position, this.options.position)) {
	                this.marker.setLngLat(newOptions.position);
	            }
	            if (newOptions.visible !== this.options.visible) {
	                if (newOptions.visible) {
	                    this.element.classList.remove(HtmlMarker.hiddenClass);
	                }
	                else {
	                    this.element.classList.add(HtmlMarker.hiddenClass);
	                }
	            }
	        }
	        this.options = newOptions;
	    };
	    /**
	     * Toggles the popup attached to the marker.
	     */
	    HtmlMarker.prototype.togglePopup = function () {
	        if (this.options.popup) {
	            if (this.options.popup.isOpen()) {
	                this.options.popup.close();
	            }
	            else if (this.map) {
	                // Set the popup position to match the marker's.
	                // Same as the mapbox behavior.
	                this.options.popup.setOptions({
	                    position: this.options.position,
	                });
	                this.options.popup.open(this.map);
	            }
	            else {
	                throw new Error("The marker must be added to a map before calling togglePopup().");
	            }
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._addToMap = function (map, position) {
	        // If already added to a different map remove it and add to the new one.
	        if (this.map && this.map !== map) {
	            this._removeFromMap();
	        }
	        if (position) {
	            this.options.position = cloneDeep$1(position);
	            this.marker.setLngLat(this.options.position);
	        }
	        // If the marker is being added to a map it already belongs to this isn't needed.
	        if (this.map !== map) {
	            this.map = map;
	            this.marker.addTo(map._getMap());
	            this._getCollectionContainer().appendChild(this.element);
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._removeFromMap = function () {
	        if (this.map) {
	            this.marker.remove();
	            delete this.map;
	        }
	    };
	    /**
	     * @internal
	     */
	    HtmlMarker.prototype._getId = function () {
	        if (this.element) {
	            if (typeof this.options.htmlContent === "string") {
	                return this.element.firstChild["id"];
	            }
	            else {
	                return this.element.id;
	            }
	        }
	        return undefined;
	    };
	    /**
	     * Builds the Mapbox marker that this HtmlMarker will wrap.
	     * @private
	     */
	    HtmlMarker.prototype._buildMarker = function (options) {
	        // Construct a mapbox marker that this class wraps.
	        // Must converts a HTML string to a HTMLElement (div with innerHTML == htmlContent).
	        // Must also handle the substitution of HTML string placeholders.
	        if (typeof options.htmlContent === "string") {
	            var subbedContent = this._getSubbedHtmlString(options) || "";
	            this.element = Html.convertHtmlString(subbedContent);
	        }
	        else {
	            this.element = options.htmlContent;
	        }
	        this.element.classList.add(HtmlMarker.containerClass);
	        // If draggability is enabled some attributes need updated.
	        if (options.draggable) {
	            this._setDraggable(true);
	        }
	        // If visible is false the marker should still exist on the DOM so it is accessible.
	        if (!options.visible) {
	            this.element.classList.add(HtmlMarker.hiddenClass);
	        }
	        this.marker = new maplibregl.Marker({
	            element: this.element,
	            offset: options.pixelOffset,
	            draggable: options.draggable,
	            anchor: options.anchor
	        }).setLngLat(options.position);
	        // Listen for marker specific events.
	        this.marker.on("drag", this._onDrag);
	        this.marker.on("dragstart", this._onDragStart);
	        this.marker.on("dragend", this._onDragEnd);
	        // Listen for HtmlElement specific events.
	        this.element.addEventListener("click", this._bubbleElementEvent);
	        this.element.addEventListener("dblclick", this._bubbleElementEvent);
	        this.element.addEventListener("contextmenu", this._bubbleElementEvent);
	        this.element.addEventListener("keydown", this._bubbleElementEvent);
	        this.element.addEventListener("keypress", this._bubbleElementEvent);
	        this.element.addEventListener("keyup", this._bubbleElementEvent);
	        this.element.addEventListener("mousedown", this._bubbleElementEvent);
	        this.element.addEventListener("mouseenter", this._bubbleElementEvent);
	        this.element.addEventListener("mouseleave", this._bubbleElementEvent);
	        this.element.addEventListener("mousemove", this._bubbleElementEvent);
	        this.element.addEventListener("mouseout", this._bubbleElementEvent);
	        this.element.addEventListener("mouseover", this._bubbleElementEvent);
	        this.element.addEventListener("mouseup", this._bubbleElementEvent);
	    };
	    /**
	     * Returns a HTML string with all place holders substituted for.
	     * @private
	     */
	    HtmlMarker.prototype._getSubbedHtmlString = function (options) {
	        if (typeof options.htmlContent === "string") {
	            return options.htmlContent
	                .replace(/{color}/ig, options.color || "")
	                .replace(/{secondaryColor}/ig, options.secondaryColor || "")
	                .replace(/{text}/ig, options.text || "");
	        }
	        else {
	            return null;
	        }
	    };
	    /**
	     * Returns the element that should contain all the markers.
	     * Creates it if it doesn't already exist.
	     * @private
	     */
	    HtmlMarker.prototype._getCollectionContainer = function () {
	        var collectionContainer = this.map.getCanvasContainer()
	            .querySelector(".".concat(HtmlMarker.collectionContainerClass));
	        if (!collectionContainer) {
	            collectionContainer = document.createElement("div");
	            collectionContainer.classList.add(HtmlMarker.collectionContainerClass);
	            this.map.getCanvasContainer().appendChild(collectionContainer);
	        }
	        return collectionContainer;
	    };
	    /**
	     * Called to set the element dragstart listener, needed for proper draggability on Edge.
	     */
	    HtmlMarker.prototype._setDraggable = function (draggable) {
	        if (draggable) {
	            this.element.addEventListener("dragstart", this._onEleDragStart);
	        }
	        else {
	            this.element.removeEventListener("dragstart", this._onEleDragStart);
	        }
	    };
	    HtmlMarker.collectionContainerClass = "marker-collection-container";
	    HtmlMarker.hiddenClass = "hidden-accessible-element";
	    HtmlMarker.containerClass = "marker-container";
	    return HtmlMarker;
	}(EventEmitter));

	var Media = /** @class */ (function () {
	    function Media() {
	    }
	    /**
	     * Returns the current high contrast mode based on media queries.
	     * Can return the following values:
	     * - `"light"`: High contrast using black text on white backgrounds
	     * - `"dark"`: High contrast using white text on black backgrounds
	     * - `"invert"`: Inverting colors, often used for high contrast
	     * - `null`: Not in high contrast mode
	     */
	    Media.getHighContrastMode = function () {
	        if (matchMedia("(-ms-high-contrast: white-on-black)").matches) {
	            return "dark";
	        }
	        else if (matchMedia("(-ms-high-contrast: black-on-white)").matches) {
	            return "light";
	        }
	        else if (matchMedia("(-ms-high-contrast: active)").matches) {
	            return "dark"; // Default to dark if we can't detect a specific style
	        }
	        else if (matchMedia("(inverted-colors: inverted)").matches) {
	            return "invert"; // Inverted colors is specific to macOS
	        }
	        // If nothing matches assume high contrast isn't in use
	        return null;
	    };
	    return Media;
	}());

	var __extends$j = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a CopyrightControl object.
	 */
	var CopyrightControlOptions = /** @class */ (function (_super) {
	    __extends$j(CopyrightControlOptions, _super);
	    function CopyrightControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The copyright plain text message to display. Will be appended to copyright content if provided
	         */
	        _this.copyrightMessage = undefined;
	        /**
	         * The copyright content element containing formatted copyright message
	         * this is the primary way of setting copyright by CopyrightDelegate
	         */
	        _this.copyrightContent = undefined;
	        /**
	         * Additional custom user attribution appended to the end as it is
	         */
	        _this.customAttribution = undefined;
	        /**
	         * If true will show a link to the map feedback page.
	         */
	        _this.showFeedbackLink = true;
	        /**
	         * If true will show the Microsoft logo.
	         */
	        _this.showLogo = true;
	        return _this;
	    }
	    return CopyrightControlOptions;
	}(Options));

	var __extends$i = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * @private
	 */
	var CopyrightControl = /** @class */ (function (_super) {
	    __extends$i(CopyrightControl, _super);
	    function CopyrightControl(options) {
	        var _this = _super.call(this) || this;
	        _this.textAttribution = function (options) {
	            return [_this.options.copyrightMessage, _this.options.customAttribution]
	                .filter(function (message) { return message; })
	                .join("");
	        };
	        // Append latitude, longitude and zoom level to feedback link.
	        _this.updateFeedbackLink = function () {
	            var _a;
	            if (_this.feedbackAnchor && _this.map) {
	                var center = (_a = _this.map.getCamera(), _a.center), zoom = _a.zoom;
	                _this.feedbackAnchor.href = "".concat(CopyrightControl.feedbackLink, "&cp=").concat(center[1], "~").concat(center[0], "&lvl=").concat(zoom + 1);
	            }
	        };
	        _this.options = new CopyrightControlOptions().merge(options);
	        return _this;
	    }
	    CopyrightControl.prototype.onAdd = function (map) {
	        this.map = map;
	        this.container = this.buildContainer(map, exports.ControlStyle.auto);
	        this.container.className = "map-copyright without-bg";
	        this.copyrightDiv = this.buildCopyrightDiv();
	        this.copyrightDiv.className = "azure-map-copyright";
	        this.container.appendChild(this.copyrightDiv);
	        if (this.options.showFeedbackLink) {
	            this.addRemoveFeedbackDiv(true);
	        }
	        return this.container;
	    };
	    CopyrightControl.prototype.onRemove = function () {
	        _super.prototype.onRemove.call(this);
	        delete this.container;
	    };
	    CopyrightControl.prototype.setOptions = function (options) {
	        var _this = this;
	        var newOptions = new CopyrightControlOptions().merge(this.options, options);
	        if (newOptions.copyrightMessage !== this.options.copyrightMessage
	            || newOptions.customAttribution !== this.options.customAttribution) {
	            this.copyrightDiv.innerText = this.textAttribution(newOptions);
	        }
	        if (newOptions.copyrightContent !== this.options.copyrightContent) {
	            if (this.options.copyrightContent) {
	                var prev = Array.from(this.copyrightDiv.children).find(function (elem) { return elem === _this.options.copyrightContent; });
	                this.copyrightDiv.removeChild(prev);
	            }
	            if (this.copyrightDiv.childNodes.length > 0) {
	                this.copyrightDiv.insertBefore(newOptions.copyrightContent, this.copyrightDiv.childNodes[0]);
	            }
	            else {
	                this.copyrightDiv.appendChild(newOptions.copyrightContent);
	            }
	            this.options.copyrightContent = newOptions.copyrightContent;
	        }
	        if (!newOptions.showFeedbackLink && this.feedbackAnchor) {
	            this.addRemoveFeedbackDiv(false);
	        }
	        else if (newOptions.showFeedbackLink && !this.feedbackAnchor) {
	            this.addRemoveFeedbackDiv(true);
	        }
	        this.options = newOptions;
	    };
	    CopyrightControl.prototype.getDefaultAttributions = function () {
	        var currentYear = new Date().getFullYear();
	        var copyright = ["\u00A9".concat(currentYear, " TomTom")];
	        if (!this.options.showLogo) {
	            copyright.push("\u00A9".concat(currentYear, " Microsoft"));
	        }
	        return copyright;
	    };
	    CopyrightControl.prototype.buildCopyrightDiv = function () {
	        var copyright = document.createElement("div");
	        copyright.innerText = this.textAttribution(this.options) || "";
	        return copyright;
	    };
	    CopyrightControl.prototype.buildFeedbackLink = function () {
	        var link = document.createElement("a");
	        link.setAttribute("alt", "Provide Map Data Feedback");
	        link.setAttribute("aria-label", "Provide Map Data Feedback");
	        link.innerText = "Feedback";
	        link.href = CopyrightControl.feedbackLink;
	        link.target = "_blank";
	        link.rel = "noopener";
	        link.className = "azure-map-feedback-text";
	        return link;
	    };
	    CopyrightControl.prototype.addRemoveFeedbackDiv = function (add) {
	        var _a, _b, _c, _d;
	        if (add) {
	            this.feedbackAnchor = this.buildFeedbackLink();
	            this.feedbackTooltip = buildAccessibleTooltip("Provide Map Data Feedback");
	            this.container.appendChild(this.feedbackAnchor);
	            this.container.appendChild(this.feedbackTooltip);
	            positionTooltip(this.feedbackTooltip, this.feedbackAnchor);
	            (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a.events) === null || _b === void 0 ? void 0 : _b.add("moveend", this.updateFeedbackLink);
	        }
	        else {
	            this.feedbackAnchor.remove();
	            this.feedbackTooltip.remove();
	            delete this.feedbackTooltip;
	            delete this.feedbackAnchor;
	            (_d = (_c = this.map) === null || _c === void 0 ? void 0 : _c.events) === null || _d === void 0 ? void 0 : _d.remove("moveend", this.updateFeedbackLink);
	        }
	    };
	    CopyrightControl.feedbackLink = "https://aka.ms/azuremaps-feedback?feedbackep=UrlAzureMapsWebSdk";
	    return CopyrightControl;
	}(ControlBase));

	var __extends$h = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a LogoControl object.
	 */
	var LogoControlOptions = /** @class */ (function (_super) {
	    __extends$h(LogoControlOptions, _super);
	    function LogoControlOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * If true will show the Microsoft logo.
	         */
	        _this.showLogo = true;
	        return _this;
	    }
	    return LogoControlOptions;
	}(Options));

	var __extends$g = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * A control that displays the logo on the map.
	 * @private
	 */
	var LogoControl = /** @class */ (function (_super) {
	    __extends$g(LogoControl, _super);
	    /**
	     * Construct a control
	     */
	    function LogoControl(options) {
	        var _this = _super.call(this) || this;
	        _this.map = null;
	        /**
	         * Set visibility of the control based on the container width.
	         */
	        _this._onResize = function () {
	            var _a, _b;
	            var width = ((_b = (_a = _this.map) === null || _a === void 0 ? void 0 : _a.getMapContainer()) === null || _b === void 0 ? void 0 : _b.clientWidth) || 0;
	            _this._setVisiblity(_this.options.showLogo && width >= LogoControl.CONTAINER_MIN_WIDTH);
	        };
	        _this.options = new LogoControlOptions().merge(options);
	        return _this;
	    }
	    /**
	     * Initialization method for the control which is called when added to the map.
	     * @param map The map that the control will be added to.
	     * @param options The ControlOptions for this control.
	     * @return An HTMLElement to be placed on the map for the control.
	     */
	    LogoControl.prototype.onAdd = function (map) {
	        var _a;
	        this.map = map;
	        this.container = this.buildContainer(map, exports.ControlStyle.auto);
	        this.container.className = "map-logo-control";
	        (_a = this.map) === null || _a === void 0 ? void 0 : _a.events.add("resize", this._onResize);
	        this._addRemoveLogo(this.options.showLogo);
	        return this.container;
	    };
	    LogoControl.prototype.onRemove = function () {
	        var _a;
	        _super.prototype.onRemove.call(this);
	        (_a = this.map) === null || _a === void 0 ? void 0 : _a.events.remove("resize", this._onResize);
	        this.map = null;
	        delete this.container;
	    };
	    LogoControl.prototype.setOptions = function (options) {
	        var newOptions = new LogoControlOptions().merge(this.options, options);
	        if (!newOptions.showLogo && this.logoAnchor) {
	            this._addRemoveLogo(false);
	        }
	        else if (newOptions.showLogo && !this.logoAnchor) {
	            this._addRemoveLogo(true);
	        }
	        this.options = newOptions;
	    };
	    LogoControl.prototype._addRemoveLogo = function (add) {
	        var _a, _b;
	        if (add) {
	            this.logoAnchor = document.createElement("a");
	            this.logoAnchor.className = "azure-map-logo";
	            this.logoAnchor.href = "https://aka.ms/azuremaps";
	            this.logoAnchor.setAttribute("aria-label", "Visit azure.microsoft.com");
	            this.logoAnchor.setAttribute("target", "_blank");
	            this.container.appendChild(this.logoAnchor);
	            this.logoTooltip = buildAccessibleTooltip("Visit azure.microsoft.com");
	            this.container.appendChild(this.logoTooltip);
	            positionTooltip(this.logoTooltip, this.logoAnchor);
	            this._setVisiblity(true);
	        }
	        else {
	            (_a = this.logoAnchor) === null || _a === void 0 ? void 0 : _a.remove();
	            (_b = this.logoTooltip) === null || _b === void 0 ? void 0 : _b.remove();
	            delete this.logoAnchor;
	            this._setVisiblity(false);
	        }
	    };
	    /**
	     * Set visibility of the control.
	     */
	    LogoControl.prototype._setVisiblity = function (visible) {
	        if (this.container) {
	            this.container.style.display = visible ? "flex" : "none";
	        }
	    };
	    LogoControl.CONTAINER_MIN_WIDTH = 480; // The minimum width of the container to show the logo, 5 copyright texts, and the feedback link.
	    return LogoControl;
	}(ControlBase));

	var __assign$4 = (window && window.__assign) || function () {
	    __assign$4 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$4.apply(this, arguments);
	};

	(window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	(window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	(window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	(window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};

	/**
	 * @private
	 */
	var AccessibleMapDelegate = /** @class */ (function () {
	    function AccessibleMapDelegate(map) {
	        var _this = this;
	        this.addToMap = function () {
	            if (_this.mapViewDesc != null) {
	                // AccessibleMapDelegate is already initialized and added to the map.
	                return;
	            }
	            _this.initializeMapLiveStateInfo();
	            _this.initializeMapStyleInfo();
	            _this.createMapKeyBindingInfo();
	            _this.map.getMapContainer().setAttribute("role", "application");
	            _this.map.getMapContainer().setAttribute("aria-label", "Map Application");
	            _this.map.getCanvasContainer().setAttribute("aria-live", "polite");
	            _this.map.getCanvasContainer().setAttribute("aria-describedby", "atlas-map-state atlas-map-style");
	            _this.map.getCanvas().setAttribute("aria-label", "Interactive Map");
	            _this.map.getCanvas().setAttribute("aria-describedby", "atlas-map-shortcuts");
	            _this.map.getCanvas().setAttribute("alt", "Interactive Map");
	        };
	        this.removeFromMap = function () {
	            if (_this.mapViewDesc != null) {
	                _this.mapViewDesc.dispose();
	            }
	            delete _this.mapViewDesc;
	            if (_this.atlasMapKeyBindings != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapKeyBindings);
	            }
	            delete _this.atlasMapKeyBindings;
	            if (_this.atlasMapLiveStateInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapLiveStateInfo);
	            }
	            delete _this.atlasMapLiveStateInfo;
	            if (_this.atlasMapStyleInfo != null) {
	                _this.map.getCanvasContainer().removeChild(_this.atlasMapStyleInfo);
	            }
	            delete _this.atlasMapStyleInfo;
	            _this.map.getMapContainer().removeAttribute("role");
	            _this.map.getMapContainer().removeAttribute("aria-label");
	            _this.map.getCanvasContainer().removeAttribute("aria-live");
	            _this.map.getCanvasContainer().removeAttribute("aria-describedby");
	            _this.map.getCanvas().removeAttribute("aria-label");
	            _this.map.getCanvas().removeAttribute("aria-describedby");
	            _this.map.getCanvas().removeAttribute("alt");
	            _this.map.events.remove("stylechanged", _this.updateMapStyle);
	        };
	        this.createMapKeyBindingInfo = function () {
	            _this.atlasMapKeyBindings = document.createElement("div");
	            _this.atlasMapKeyBindings.setAttribute("tabindex", "-1");
	            _this.atlasMapKeyBindings.setAttribute("aria-hidden", "true");
	            _this.atlasMapKeyBindings.id = "atlas-map-shortcuts";
	            _this.atlasMapKeyBindings.classList.add("hidden-accessible-element");
	            _this.atlasMapKeyBindings.innerHTML = [
	                "Map shortcuts:",
	                "Zoom out: hyphen.",
	                "Zoom in: plus.",
	                "Pan right 100 pixels: right arrow.",
	                "Pan left 100 pixels: left arrow.",
	                "Pan up 100 pixels: up arrow.",
	                "Pan down 100 pixels: down arrow.",
	                "Rotate 15 degrees clockwise: shift + right arrow.",
	                "Rotate 15 degrees counter clockwise: shift + left arrow.",
	                "Increase pitch 10 degrees: shift + up arrow.",
	                "Decrease pitch 10 degrees: shift + down arrow.",
	                // Interesting... i'm not sure that verbose map state was ever implemented 
	                // "Toggle verbose map state: control + alt + D.",
	                "Jump focus to the map: Escape."
	            ].join("\n");
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapKeyBindings);
	            var baseShortcutKeyCodes = [
	                // - (zoom out)
	                189,
	                // = (zoom in)
	                187,
	                // arrow up
	                38,
	                // arrow left
	                37,
	                // arrow right
	                39,
	                // arrow down
	                40
	            ];
	            // accessibility recommendation: After using any of the map shortcut keys, NVDA should not read all the shortcut keys again.
	            // // TODO: this should be this.map._getMap().getCanvas
	            var mapCanvas = _this.map._getMap()._canvas;
	            mapCanvas === null || mapCanvas === void 0 ? void 0 : mapCanvas.addEventListener('keyup', function (event) {
	                if (baseShortcutKeyCodes.find(function (code) { return event.keyCode === code; })) {
	                    _this.atlasMapKeyBindings.innerHTML = '';
	                }
	            });
	        };
	        this.initializeMapLiveStateInfo = function () {
	        };
	        this.initializeMapStyleInfo = function () {
	            _this.atlasMapStyleInfo = document.createElement("div");
	            _this.atlasMapStyleInfo.setAttribute("tabindex", "-1");
	            _this.atlasMapStyleInfo.setAttribute("aria-hidden", "true");
	            _this.atlasMapStyleInfo.id = "atlas-map-style";
	            _this.atlasMapStyleInfo.classList.add("hidden-accessible-element");
	            _this.map.events.add("stylechanged", _this.updateMapStyle);
	            _this.map.getCanvasContainer().appendChild(_this.atlasMapStyleInfo);
	        };
	        this.updateMapStyle = function () {
	            _this.atlasMapStyleInfo.innerHTML = "<p>Map style: ".concat(_this.map.getStyle().style, ".</p>");
	        };
	        this.updateMapState = function (desc) {
	            _this.atlasMapLiveStateInfo.innerHTML = desc;
	        };
	        this.map = map;
	    }
	    return AccessibleMapDelegate;
	}());

	/**
	 * @private
	 */
	var FlowServiceDelegate = /** @class */ (function () {
	    function FlowServiceDelegate(map) {
	        var _this = this;
	        this.listenerEnabled = false;
	        this.lastFlowMode = "none";
	        this.addToMap = function () {
	            // Check that the map is ready first.
	            if (!_this.map._isReady()) {
	                throw new Error("Traffic flow could not be added to the map because " +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before enabling traffic flow.");
	            }
	            // Enable the styledata listener.
	            // The flowPath may need to change if the style changes.
	            if (!_this.listenerEnabled) {
	                _this.map.events.add("styledata", _this.addToMap);
	                _this.listenerEnabled = true;
	            }
	            var trafficOptions = _this.map.getTraffic();
	            if (trafficOptions.flow !== "none") {
	                var trafficFlowComponent = _this.map.layers.getLayerById("traffic_".concat(trafficOptions.flow));
	                if (trafficFlowComponent) {
	                    _this.lastFlowMode = trafficOptions.flow;
	                    trafficFlowComponent._updateLayoutProperty("visibility", "visible", "none");
	                }
	            }
	        };
	        this.removeFromMap = function () {
	            _this.map.getTraffic();
	            if (_this.lastFlowMode != "none") {
	                var trafficFlowComponent = _this.map.layers.getLayerById("traffic_".concat(_this.lastFlowMode));
	                if (trafficFlowComponent) {
	                    trafficFlowComponent._updateLayoutProperty("visibility", "none", "visible");
	                }
	                _this.lastFlowMode = "none";
	            }
	            // Disable the styledata listener
	            if (_this.listenerEnabled) {
	                _this.map.events.remove("styledata", _this.addToMap);
	                _this.listenerEnabled = false;
	            }
	        };
	        this.map = map;
	    }
	    return FlowServiceDelegate;
	}());

	var __extends$f = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for enabling/disabling user interaction with the map.
	 */
	var UserInteractionOptions = /** @class */ (function (_super) {
	    __extends$f(UserInteractionOptions, _super);
	    function UserInteractionOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Whether the map is interactive or static. If false, all user interaction is disabled.  If true, only selected
	         * user interactions will enabled.
	         * default `true`
	         * @default true
	         */
	        _this.interactive = true;
	        /**
	         * Whether the map should zoom on scroll input.
	         * default `true`
	         * @default true
	         */
	        _this.scrollZoomInteraction = true;
	        /**
	         * Whether the Shift + left click and drag will draw a zoom box.
	         * default `true`
	         * @default true
	         */
	        _this.boxZoomInteraction = true;
	        /**
	         * Whether right click and drag will rotate and pitch the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragRotateInteraction = true;
	        /**
	         * Whether left click and drag will pan the map.
	         * default `true`
	         * @default true
	         */
	        _this.dragPanInteraction = true;
	        /**
	         * Whether the keyboard interactions are enabled.
	         * <style> .k-key { border: 1px solid grey; border-radius: 6px; background-color: #ccc; line-height: 14px;
	         * font-size: 14px; padding: 2px; } </style>
	         * <p><span class="k-key">Escape</span>: Jump focus to the map.</p>
	         * <p><span class="k-key">+/=</span>: Increase zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">+/=</span>: Increase the zoom level by 2.</p>
	         * <p><span class="k-key">-</span>: Decrease zoom level by 1.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">-</span>: Decrease zoom level by 2.</p>
	         * <p><span class="k-key">⇢</span>: Pan right 100 pixels.</p>
	         * <p><span class="k-key">⇠</span>: Pan left 100 pixels.</p>
	         * <p><span class="k-key">⇡</span>: Pan up 100 pixels.</p>
	         * <p><span class="k-key">⇣</span>: Pan down 100 pixels.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇢</span>: Rotate 15 degrees clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇠</span>: Rotate 15 degrees counter-clockwise.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇡</span>: Increase pitch by 10 degrees.</p>
	         * <p><span class="k-key">Shift</span> + <span class="k-key">⇣</span>: Decrease pitch by 10 degrees.</p>
	         * default `true`
	         * @default true
	         */
	        _this.keyboardInteraction = true;
	        /**
	         * Whether double left click will zoom the map inwards.
	         * default `true`
	         * @default true
	         */
	        _this.dblClickZoomInteraction = true;
	        /**
	         * Whether touch interactions are enabled for touch devices.
	         * default `true`
	         * @default true
	         */
	        _this.touchInteraction = true;
	        /**
	         * Whether touch rotation is enabled for touch devices. This option is not applied if touchInteraction is disabled.
	         * default `true`
	         * @default true
	         */
	        _this.touchRotate = true;
	        /**
	         * Sets the zoom rate of the mouse wheel
	         * default `1/450`
	         * @default 1/450
	         */
	        _this.wheelZoomRate = 1 / 450;
	        return _this;
	    }
	    return UserInteractionOptions;
	}(Options));

	/** A handler that adds a shortcut for jumping focus to the top map div. */
	var FocusShortcutHandler = /** @class */ (function () {
	    function FocusShortcutHandler(map) {
	        var _this = this;
	        /** A listener for the shortcut */
	        this._onKeyDown = function (event) {
	            if (event.keyCode === 27 /* Escape */) {
	                _this.map.getCanvas().focus();
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.enable = function () {
	        this.map.getMapContainer().addEventListener("keydown", this._onKeyDown);
	    };
	    /** Disables the mobile pitch gesture support. */
	    FocusShortcutHandler.prototype.disable = function () {
	        this.map.getMapContainer().removeEventListener("keydown", this._onKeyDown);
	    };
	    return FocusShortcutHandler;
	}());

	/** A handler that adds support for pinch and zoom gestures on devices without touch events. */
	var PinchZoomHandler = /** @class */ (function () {
	    function PinchZoomHandler(map) {
	        var _this = this;
	        this._onGestureStart = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.initZoom = _this.map.getCamera().zoom;
	            }
	        };
	        this._onGestureChange = function (e) {
	            if (!_this.hasTouch) {
	                e.preventDefault();
	                _this.map.setCamera({ zoom: _this.initZoom + e.scale - 1 });
	            }
	        };
	        this._onTouchStart = function (e) {
	            _this.hasTouch = true;
	        };
	        this._onTouchEnd = function (e) {
	            if (e.touches.length === 0) {
	                _this.hasTouch = false;
	            }
	        };
	        this.map = map;
	    }
	    /** Enables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.enable = function () {
	        this.map.getCanvasContainer().addEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().addEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().addEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().addEventListener("touchend", this._onTouchEnd);
	    };
	    /** Disables the mobile pitch gesture support. */
	    PinchZoomHandler.prototype.disable = function () {
	        this.map.getCanvasContainer().removeEventListener("gesturestart", this._onGestureStart);
	        this.map.getCanvasContainer().removeEventListener("gesturechange", this._onGestureChange);
	        this.map.getCanvasContainer().removeEventListener("touchstart", this._onTouchStart);
	        this.map.getCanvasContainer().removeEventListener("touchend", this._onTouchEnd);
	    };
	    return PinchZoomHandler;
	}());

	/**
	 * @private
	 */
	var UserInteractionDelegate = /** @class */ (function () {
	    function UserInteractionDelegate(map, options) {
	        this.added = false;
	        this.map = map;
	        this.focusShortcut = new FocusShortcutHandler(map);
	        this.pinchZoom = new PinchZoomHandler(map);
	        this.options = new UserInteractionOptions().merge(options);
	    }
	    UserInteractionDelegate.prototype.addToMap = function () {
	        if (!this.added) {
	            this.added = true;
	            this._setInteractions(this.options);
	        }
	    };
	    UserInteractionDelegate.prototype.removeFromMap = function () {
	        if (this.added) {
	            this.added = false;
	            this._setInteractions({ interactive: false });
	        }
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    UserInteractionDelegate.prototype.setOptions = function (options) {
	        this.options = new UserInteractionOptions().merge(this.options, options);
	        // Only need to actually update things if the delegate has already been added to the map
	        if (this.added) {
	            this._setInteractions(this.options);
	        }
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    UserInteractionDelegate.prototype.getOptions = function () {
	        return Object.assign({}, this.options);
	    };
	    /** Sets the interaction config based on the specified options. */
	    UserInteractionDelegate.prototype._setInteractions = function (options) {
	        if (!options.interactive) {
	            // Disable everything
	            this.map._getMap().boxZoom.disable();
	            this.map._getMap().doubleClickZoom.disable();
	            this.map._getMap().dragPan.disable();
	            this.map._getMap().dragRotate.disable();
	            this.map._getMap().keyboard.disable();
	            this.focusShortcut.disable();
	            this.map._getMap().scrollZoom.disable();
	            this.map._getMap().touchZoomRotate.disable();
	            this.pinchZoom.disable();
	        }
	        else {
	            // Box Zoom
	            if (options.boxZoomInteraction) {
	                this.map._getMap().boxZoom.enable();
	            }
	            else {
	                this.map._getMap().boxZoom.disable();
	            }
	            // Double Click Zoom
	            if (options.dblClickZoomInteraction) {
	                this.map._getMap().doubleClickZoom.enable();
	            }
	            else {
	                this.map._getMap().doubleClickZoom.disable();
	            }
	            // Drag Pan
	            if (options.dragPanInteraction) {
	                this.map._getMap().dragPan.enable();
	            }
	            else {
	                this.map._getMap().dragPan.disable();
	            }
	            // Drag Rotate
	            if (options.dragRotateInteraction) {
	                this.map._getMap().dragRotate.enable();
	            }
	            else {
	                this.map._getMap().dragRotate.disable();
	            }
	            // Keyboard
	            if (options.keyboardInteraction) {
	                this.map._getMap().keyboard.enable();
	                this.focusShortcut.enable();
	            }
	            else {
	                this.map._getMap().keyboard.disable();
	                this.focusShortcut.disable();
	            }
	            // Scroll Zoom
	            if (options.scrollZoomInteraction) {
	                this.map._getMap().scrollZoom.enable();
	                this.map._getMap().scrollZoom.setWheelZoomRate(options.wheelZoomRate);
	            }
	            else {
	                this.map._getMap().scrollZoom.disable();
	            }
	            // Touch
	            var touchZoomRotate = this.map._getMap().touchZoomRotate;
	            if (options.touchInteraction) {
	                touchZoomRotate.enable();
	                if (options.touchRotate) {
	                    touchZoomRotate.enableRotation();
	                }
	                else {
	                    touchZoomRotate.disableRotation();
	                }
	                this.pinchZoom.enable();
	            }
	            else {
	                touchZoomRotate.disable();
	                this.pinchZoom.enable();
	            }
	        }
	    };
	    return UserInteractionDelegate;
	}());

	var __values$c = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's controls.
	 * Exposed through the controls property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ControlManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function ControlManager(map) {
	        this.map = map;
	        // Add containers for map controls
	        this.controlContainer = document.createElement("div");
	        this.controlContainer.classList.add("atlas-control-container");
	        for (var controlPosition in exports.ControlPosition) {
	            if (exports.ControlPosition.hasOwnProperty(controlPosition)) {
	                var subcontrolContainer = document.createElement("div");
	                subcontrolContainer.classList.add(exports.ControlPosition[controlPosition]);
	                subcontrolContainer.classList.add("subcontrol-container");
	                this.controlContainer.appendChild(subcontrolContainer);
	            }
	        }
	        this.map.getMapContainer().appendChild(this.controlContainer);
	        this.controls = new Set();
	    }
	    /**
	     * Add a control(s) to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     */
	    ControlManager.prototype.add = function (control, options) {
	        var e_1, _a;
	        if (Array.isArray(control)) {
	            try {
	                for (var control_1 = __values$c(control), control_1_1 = control_1.next(); !control_1_1.done; control_1_1 = control_1.next()) {
	                    var c = control_1_1.value;
	                    this._add(c, options);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (control_1_1 && !control_1_1.done && (_a = control_1.return)) _a.call(control_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._add(control, options);
	        }
	    };
	    /**
	     * Gets an array of all controls on the map
	     */
	    ControlManager.prototype.getControls = function () {
	        return Array.from(this.controls);
	    };
	    /**
	     * Remove a control(s) from the map.
	     * @param control The control to remove.
	     */
	    ControlManager.prototype.remove = function (control) {
	        var e_2, _a;
	        if (Array.isArray(control)) {
	            try {
	                for (var control_2 = __values$c(control), control_2_1 = control_2.next(); !control_2_1.done; control_2_1 = control_2.next()) {
	                    var c = control_2_1.value;
	                    this._remove(c);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (control_2_1 && !control_2_1.done && (_a = control_2.return)) _a.call(control_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._remove(control);
	        }
	    };
	    /**
	     * Add a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._add = function (control, options) {
	        this.controls.add(control);
	        var controlOptions = new ControlOptions().merge(options);
	        var controlHtml = control.onAdd(this.map, options);
	        var subcontrolContainers = this.controlContainer.getElementsByClassName(controlOptions.position);
	        if (subcontrolContainers.length > 0) {
	            subcontrolContainers.item(0).appendChild(controlHtml);
	        }
	        else {
	            throw new Error("Control position ".concat(controlOptions.position, " does not exist."));
	        }
	    };
	    /**
	     * Remove a control from the map.
	     * @internal
	     */
	    ControlManager.prototype._remove = function (control) {
	        control.onRemove();
	        this.controls.delete(control);
	    };
	    return ControlManager;
	}());

	var __assign$3 = (window && window.__assign) || function () {
	    __assign$3 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3.apply(this, arguments);
	};
	/**
	 * @private
	 */
	var MapCallbackHandler = /** @class */ (function () {
	    function MapCallbackHandler(map) {
	        // Dictionary keys represent the following: layer name -> event type -> user callback => [modified callback, once].
	        this.callbacks = new Dictionary();
	        this.map = map;
	    }
	    MapCallbackHandler.prototype.addCallback = function (eventType, layer, callback, legacy, once) {
	        var _this = this;
	        var modifiedCallback;
	        // If using legacy callbacks provide a MapEventData object to the user's callback
	        // Legacy callbacks cannot be added as once handles, so we don't need any logic for the once case.
	        if (legacy) {
	            modifiedCallback = function (data) {
	                var position = (data.lngLat) ?
	                    new Position(data.lngLat.lng, data.lngLat.lat) :
	                    undefined;
	                var coordinate = (data.point) ?
	                    [data.point.x, data.point.y] :
	                    undefined;
	                var features = (data.features) ?
	                    data.features.map(function (f) { return new Feature(f.geometry, f.properties, f.id); }) :
	                    [];
	                var mapEventData = {
	                    type: data.type,
	                    originalEvent: data.originalEvent,
	                    position: position,
	                    coordinate: coordinate,
	                    features: features
	                };
	                callback(mapEventData);
	            };
	        }
	        else {
	            var lastOriginalEvent_1;
	            switch (eventType) {
	                case "data":
	                case "sourcedata":
	                case "styledata":
	                    modifiedCallback = function (data) {
	                        var mapEventData = __assign$3(__assign$3({ dataType: data.dataType }, (data.dataType === "source" && __assign$3(__assign$3(__assign$3({ isSourceLoaded: data.isSourceLoaded }, (data.sourceDataType && { sourceDataType: data.sourceDataType })), { source: _this.map.sources.getById(data.sourceId) }), (data.tile && {
	                            tile: {
	                                id: {
	                                    x: data.tile.tileID.canonical.x,
	                                    y: data.tile.tileID.canonical.y,
	                                    z: data.tile.tileID.canonical.z
	                                },
	                                size: data.tile.tileSize,
	                                state: data.tile.state
	                            }
	                        })))), { map: _this.map, type: data.type });
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "error":
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            error: data.error,
	                            map: _this.map,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "touchstart":
	                case "touchend":
	                case "touchmove":
	                case "touchcancel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var pixels = (data.points) ?
	                            data.points.map(function (p) { return new Pixel(p.x, p.y); }) :
	                            [];
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var positions = (data.lngLats) ?
	                            data.lngLats.map(function (l) { return new Position(l.lng, l.lat); }) :
	                            [];
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            pixel: pixel,
	                            pixels: pixels,
	                            position: position,
	                            positions: positions,
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            preventDefault: function () { return data.preventDefault(); },
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "mousedown":
	                case "mouseup":
	                case "mouseover":
	                case "mousemove":
	                case "click":
	                case "dblclick":
	                case "mouseout":
	                case "mouseenter":
	                case "mouseleave":
	                case "contextmenu":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var position = (data.lngLat) ?
	                            new Position(data.lngLat.lng, data.lngLat.lat) :
	                            undefined;
	                        var pixel = (data.point) ?
	                            new Pixel(data.point.x, data.point.y) :
	                            undefined;
	                        var shapes = position ?
	                            _this.map.layers.getRenderedShapes(new Point(position), layer ? [layer] : undefined) :
	                            [];
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            position: position,
	                            pixel: pixel,
	                            preventDefault: function () { return data.preventDefault(); },
	                            shapes: shapes,
	                            layerId: layer || undefined,
	                            type: data.type
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "styleimagemissing":
	                    modifiedCallback = function (data) {
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(data.id);
	                    };
	                    break;
	                case "wheel":
	                    modifiedCallback = function (data) {
	                        // Check if this callback was just called for the originating event.
	                        // If so return to prevent multiple callback calls for layers which build multiple mapbox layers.
	                        if (data.originalEvent) {
	                            if (data.originalEvent !== lastOriginalEvent_1) {
	                                lastOriginalEvent_1 = data.originalEvent;
	                            }
	                            else {
	                                return;
	                            }
	                        }
	                        var mapEventData = {
	                            map: _this.map,
	                            originalEvent: data.originalEvent,
	                            preventDefault: function () { return data.preventDefault(); },
	                            type: data.type,
	                        };
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                case "resize":
	                    // The resize event is technically one of the default callback types.
	                    // However, since users can specify custom eventData to add to the resize event
	                    // we need to make sure to include that in our modified callback.
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Add any extra properties to the modified callback data.
	                        // Skip the "type" and "target" properties as these are
	                        // replaced by the "type" and "map" properties above.
	                        for (var prop in data) {
	                            if (prop !== "type" && prop !== "target") {
	                                mapEventData[prop] = data[prop];
	                            }
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	                default:
	                    modifiedCallback = function (data) {
	                        var mapEventData = {
	                            map: _this.map,
	                            type: data.type
	                        };
	                        // Not every event will have an originalEvent property.
	                        // Only add this properties to our modified callback's data if it will be defined.
	                        if (data.originalEvent) {
	                            mapEventData.originalEvent = data.originalEvent;
	                        }
	                        if (once) {
	                            _this.map.events._removeListener(eventType, layer, callback);
	                        }
	                        callback(mapEventData);
	                    };
	                    break;
	            }
	        }
	        // Add an empty dictionary for the specified layer if one doesn't already exist.
	        if (!this.callbacks.has(layer)) {
	            this.callbacks.set(layer, new Dictionary());
	        }
	        // Add an empty dictionary for the specified event type if one doesn't already exist.
	        if (!this.callbacks.get(layer).has(eventType)) {
	            this.callbacks.get(layer).set(eventType, new Map());
	        }
	        this.callbacks.get(layer).get(eventType).set(callback, [modifiedCallback, once]);
	    };
	    MapCallbackHandler.prototype.removeCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            this.callbacks.get(layer).get(eventType).delete(callback);
	        }
	    };
	    MapCallbackHandler.prototype.getModifiedCallback = function (eventType, layer, callback) {
	        if (this.callbacks.has(layer) &&
	            this.callbacks.get(layer).has(eventType) &&
	            this.callbacks.get(layer).get(eventType).has(callback)) {
	            return this.callbacks.get(layer).get(eventType).get(callback)[0];
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getLayerCallbacks = function (layer) {
	        if (this.callbacks.has(layer)) {
	            return this.callbacks.get(layer);
	        }
	        return undefined;
	    };
	    MapCallbackHandler.prototype.getEventCallbacks = function (eventType, layer) {
	        if (this.callbacks.has(layer)) {
	            var layerCallbacks = this.callbacks.get(layer);
	            if (layerCallbacks.has(eventType)) {
	                return layerCallbacks.get(eventType);
	            }
	        }
	        return undefined;
	    };
	    return MapCallbackHandler;
	}());

	var __values$b = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$7 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	// Disable unified signatures linter rule so we can generate separate docs for function overloads.
	// tslint:disable:unified-signatures
	var MAP_CLIENT_EVENTS = ['maxzoomchanged', 'minzoomchanged', 'mapconfigurationchanged'];
	/**
	 * A manager for the map control's events.
	 * Exposed through the events property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var EventManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function EventManager(map) {
	        this.map = map;
	        this.mapCallbackHandler = new MapCallbackHandler(this.map);
	    }
	    EventManager.prototype.add = function (eventType, targetOrCallback, callback) {
	        var e_1, _a;
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, false);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            try {
	                for (var targetOrCallback_1 = __values$b(targetOrCallback), targetOrCallback_1_1 = targetOrCallback_1.next(); !targetOrCallback_1_1.done; targetOrCallback_1_1 = targetOrCallback_1.next()) {
	                    var target = targetOrCallback_1_1.value;
	                    if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                        this._addLayerListener(eventType, target, callback, false, false);
	                    }
	                    else {
	                        target._addEventListener(eventType, callback, false);
	                    }
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (targetOrCallback_1_1 && !targetOrCallback_1_1.done && (_a = targetOrCallback_1.return)) _a.call(targetOrCallback_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	    };
	    EventManager.prototype.addOnce = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, false, true);
	        }
	        else if (targetOrCallback instanceof Layer && Layer._isMBoxEvent(eventType)) {
	            this._addLayerListener(eventType, targetOrCallback, callback, false, true);
	        }
	        else {
	            targetOrCallback._addEventListener(eventType, callback, true);
	        }
	    };
	    EventManager.prototype._addLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._addGlobalListener(eventType, targetOrCallback, true, false);
	        }
	        else {
	            this._addLayerListener(eventType, targetOrCallback, callback, true, false);
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addLayerListener = function (eventType, target, callback, legacy, once) {
	        var e_2, _a, e_3, _b;
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var layer = this.map.layers.getLayerById(layerId);
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        // Must disable it on every Mapbox layer our layer builds.
	        if (modifiedCallback && layer) {
	            try {
	                for (var _c = __values$b(layer._getLayerIds()), _d = _c.next(); !_d.done; _d = _c.next()) {
	                    var id = _d.value;
	                    this.map._getMap().off(eventType, id, modifiedCallback);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, layerId, callback, legacy, once);
	        // If the layer already exists on the map immediately add the callbacks.
	        // Otherwise the callbacks will be added once the layer is added to the map.
	        if (layer) {
	            modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	            try {
	                for (var _e = __values$b(layer._getLayerIds()), _f = _e.next(); !_f.done; _f = _e.next()) {
	                    var id = _f.value;
	                    this.map._getMap().on(eventType, id, modifiedCallback);
	                }
	            }
	            catch (e_3_1) { e_3 = { error: e_3_1 }; }
	            finally {
	                try {
	                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                }
	                finally { if (e_3) throw e_3.error; }
	            }
	        }
	    };
	    /**
	     * Adds a listener to a single layer. Will add the event listeners to the layer's underlying Mapbox layers too.
	     * @private
	     */
	    EventManager.prototype._addGlobalListener = function (eventType, callback, legacy, once) {
	        // add our custom events emitted by Map client to the map (note: they don't utilize modifiedCallback) 
	        if (MAP_CLIENT_EVENTS.includes(eventType)) {
	            this.map._addEventListener(eventType, callback, once);
	            return;
	        }
	        var oldModifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // Get a new modified callback.
	        this.mapCallbackHandler.addCallback(eventType, "", callback, legacy, once);
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, "", callback);
	        // Enable the new modified callback on the Mapbox map.
	        if (eventType === "load" && this.map._isLoaded()) {
	            // Manually execute the callback if the load event has already fired.
	            // Use setTimeout to execute the callback async.
	            // This is for consistency with the case where the load event hasn't already fired.
	            // If the load event hasn't already fired the callback will also be executed async once it does fire.
	            var loadData_1 = { type: "load", map: this.map };
	            // tslint:disable-next-line: no-string-based-set-timeout
	            setTimeout(function () { return modifiedCallback(loadData_1); });
	        }
	        else if (eventType === "ready") {
	            // The ready event doesn't exist on the Mapbox map.
	            // Don't enable the callback for the Mapbox map.
	            if (this.map._isReady()) {
	                // Manually execute the callback if the ready event has already fired.
	                var readyData_1 = { type: "ready", map: this.map };
	                // tslint:disable-next-line: no-string-based-set-timeout
	                setTimeout(function () { return modifiedCallback(readyData_1); });
	            }
	        }
	        else {
	            // If a callback already exists disable it so the new one can replace it.
	            if (oldModifiedCallback) {
	                this.map._getMap().off(eventType, oldModifiedCallback);
	            }
	            this.map._getMap().on(eventType, modifiedCallback);
	        }
	    };
	    EventManager.prototype.invoke = function (eventType, targetOrArgs, args) {
	        // If args is undefined assume there is not target for the event.
	        if (typeof args === "undefined") {
	            // Empty string indicates the map global level.
	            this._invokeListeners(eventType, "", targetOrArgs);
	        }
	        else {
	            if (targetOrArgs instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                this._invokeListeners(eventType, targetOrArgs.getId(), args);
	            }
	            else if (targetOrArgs instanceof EventEmitter) {
	                targetOrArgs._invokeEvent(eventType, args);
	            }
	            else {
	                throw new Error("The invoke target is invalid.");
	            }
	        }
	    };
	    /**
	     * Invokes all listeners for the given event and layer.
	     * @param eventType The event type to invoke.
	     * @param layer The layer to invoke the event for. Use an empty string for map global events.
	     * @param args The data to pass to the listener callbacks.
	     * @private
	     */
	    EventManager.prototype._invokeListeners = function (eventType, layer, args) {
	        var _this = this;
	        // copy event callbacks in order to prevent being mutated during iteration below (even callbacks added as part of other event callbacks) 
	        var callbacks = new Dictionary(this.mapCallbackHandler.getEventCallbacks(eventType, layer));
	        if (callbacks) {
	            callbacks.forEach(function (_a, callback) {
	                var _b = __read$7(_a, 2); _b[0]; var once = _b[1];
	                // Invoking a listener this way circumvents the fire once logic in the modified callback.
	                // So we check if the callback was added as a fire once and if so remove it here.
	                if (once) {
	                    _this._removeListener(eventType, layer, callback);
	                }
	                callback(args);
	            });
	        }
	        else if (eventType === "error") {
	            // If there are no user specified callback for the error event print to console.
	            // tslint:disable-next-line:no-console
	            console.error("error" in args ? args.error : args);
	        }
	    };
	    EventManager.prototype.remove = function (eventType, targetOrCallback, callback) {
	        var e_4, _a;
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            targetOrCallback = Array.isArray(targetOrCallback) ? targetOrCallback : [targetOrCallback];
	            try {
	                for (var targetOrCallback_2 = __values$b(targetOrCallback), targetOrCallback_2_1 = targetOrCallback_2.next(); !targetOrCallback_2_1.done; targetOrCallback_2_1 = targetOrCallback_2.next()) {
	                    var target = targetOrCallback_2_1.value;
	                    if (target instanceof Layer && Layer._isMBoxEvent(eventType)) {
	                        this._removeListener(eventType, target, callback);
	                    }
	                    else {
	                        target === null || target === void 0 ? void 0 : target._removeEventListener(eventType, callback);
	                    }
	                }
	            }
	            catch (e_4_1) { e_4 = { error: e_4_1 }; }
	            finally {
	                try {
	                    if (targetOrCallback_2_1 && !targetOrCallback_2_1.done && (_a = targetOrCallback_2.return)) _a.call(targetOrCallback_2);
	                }
	                finally { if (e_4) throw e_4.error; }
	            }
	        }
	    };
	    EventManager.prototype._removeLegacy = function (eventType, targetOrCallback, callback) {
	        if (typeof targetOrCallback === "function") {
	            this._removeListener(eventType, "", targetOrCallback);
	        }
	        else {
	            this._removeListener(eventType, targetOrCallback, callback);
	        }
	    };
	    /**
	     * Removes a listener from the map or a single layer.
	     * Will remove the event listeners from the layer's underlying Mapbox layers too.
	     * @internal
	     */
	    EventManager.prototype._removeListener = function (eventType, target, callback) {
	        var e_5, _a;
	        // remove our custom events emitted by Map client to the map (note: they don't utilize modifiedCallback)
	        if (MAP_CLIENT_EVENTS.includes(eventType)) {
	            this.map._removeEventListener(eventType, callback);
	            return;
	        }
	        var layerId = target instanceof Layer ? target.getId() : target;
	        var modifiedCallback = this.mapCallbackHandler.getModifiedCallback(eventType, layerId, callback);
	        // If a callback already exists disable it so the new one can replace it.
	        if (modifiedCallback) {
	            // An empty layerId indicates the listener is being removed from the global map.
	            if (layerId) {
	                // If a callback already exists disable it so the new one can replace it.
	                // Must disable it on every Mapbox layer our layer builds.
	                var layer = this.map.layers.getLayerById(layerId);
	                if (layer) {
	                    try {
	                        for (var _b = __values$b(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                            var id = _c.value;
	                            this.map._getMap().off(eventType, id, modifiedCallback);
	                        }
	                    }
	                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
	                    finally {
	                        try {
	                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                        }
	                        finally { if (e_5) throw e_5.error; }
	                    }
	                }
	            }
	            else {
	                this.map._getMap().off(eventType, modifiedCallback);
	            }
	        }
	        this.mapCallbackHandler.removeCallback(eventType, layerId, callback);
	    };
	    /**
	     * Enables all the events associated with the specified layers.
	     * Enables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._enableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var e_6, _b;
	                    var _c = __read$7(_a, 1), modifiedCallback = _c[0];
	                    try {
	                        for (var _d = __values$b(layer._getLayerIds()), _e = _d.next(); !_e.done; _e = _d.next()) {
	                            var mbLayerId = _e.value;
	                            _this.map._getMap().on(eventType, mbLayerId, modifiedCallback);
	                        }
	                    }
	                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
	                    finally {
	                        try {
	                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
	                        }
	                        finally { if (e_6) throw e_6.error; }
	                    }
	                });
	            });
	        }
	    };
	    /**
	     * Disables all the events associated with the specified layers.
	     * Disables the events on the underlying Mapbox layers too.
	     * @param layers The list of layers to enable the events associated with them.
	     * @internal
	     */
	    EventManager.prototype._disableLayerEvents = function (layer) {
	        var _this = this;
	        var eventDict = this.mapCallbackHandler.getLayerCallbacks(layer.getId());
	        // For every event callback added to the layer add the callback
	        // to all Mapbox layers build by the specified layer.
	        if (eventDict) {
	            eventDict.forEach(function (callbackDict, eventType) {
	                callbackDict.forEach(function (_a) {
	                    var e_7, _b;
	                    var _c = __read$7(_a, 1), modifiedCallback = _c[0];
	                    try {
	                        for (var _d = __values$b(layer._getLayerIds()), _e = _d.next(); !_e.done; _e = _d.next()) {
	                            var mbLayerId = _e.value;
	                            _this.map._getMap().off(eventType, mbLayerId, modifiedCallback);
	                        }
	                    }
	                    catch (e_7_1) { e_7 = { error: e_7_1 }; }
	                    finally {
	                        try {
	                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
	                        }
	                        finally { if (e_7) throw e_7.error; }
	                    }
	                });
	            });
	        }
	    };
	    return EventManager;
	}());

	var __values$a = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's HTML markers.
	 * Exposed through the markers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var HtmlMarkerManager = /** @class */ (function () {
	    /**
	     * Constructs the marker manager to be exposed only through the markers property of the Map class.
	     * @param map The map whose markers are being managed by this.
	     * @internal
	     */
	    function HtmlMarkerManager(map) {
	        this.markers = new Set();
	        this.map = map;
	    }
	    HtmlMarkerManager.prototype.add = function (element, position) {
	        var e_1, _a;
	        if (Array.isArray(element)) {
	            try {
	                for (var element_1 = __values$a(element), element_1_1 = element_1.next(); !element_1_1.done; element_1_1 = element_1.next()) {
	                    var marker = element_1_1.value;
	                    this._addMarker(marker, position);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (element_1_1 && !element_1_1.done && (_a = element_1.return)) _a.call(element_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addMarker(element, position);
	        }
	    };
	    /**
	     * Adds a single marker.
	     */
	    HtmlMarkerManager.prototype._addMarker = function (marker, position) {
	        marker._addToMap(this.map, position);
	        this.markers.add(marker);
	    };
	    /**
	     * Gets an array of all the markers on the map.
	     */
	    HtmlMarkerManager.prototype.getMarkers = function () {
	        return Array.from(this.markers);
	    };
	    /**
	     * Removes one or more HTML markers from the map.
	     * @param marker A HtmlMarker instance, a string id of a marker's htmlContent, or an array of these.
	     */
	    HtmlMarkerManager.prototype.remove = function (marker) {
	        var e_2, _a;
	        if (Array.isArray(marker)) {
	            try {
	                for (var marker_1 = __values$a(marker), marker_1_1 = marker_1.next(); !marker_1_1.done; marker_1_1 = marker_1.next()) {
	                    var singleMarker = marker_1_1.value;
	                    this._removeMarker(singleMarker);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (marker_1_1 && !marker_1_1.done && (_a = marker_1.return)) _a.call(marker_1);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._removeMarker(marker);
	        }
	    };
	    /**
	     * Removes a single marker.
	     */
	    HtmlMarkerManager.prototype._removeMarker = function (marker) {
	        var _this = this;
	        if (marker instanceof HtmlMarker) {
	            marker._removeFromMap();
	            this.markers.delete(marker);
	        }
	        else {
	            this.markers.forEach(function (singleMarker) {
	                if (singleMarker._getId() === marker) {
	                    singleMarker._removeFromMap();
	                    _this.markers.delete(singleMarker);
	                }
	            });
	        }
	    };
	    /**
	     * Clears all markers.
	     */
	    HtmlMarkerManager.prototype.clear = function () {
	        var _this = this;
	        this.markers.forEach(function (singleMarker) {
	            singleMarker._removeFromMap();
	            _this.markers.delete(singleMarker);
	        });
	    };
	    return HtmlMarkerManager;
	}());

	/**
	 * A manager for the map control's image sprite.
	 * Exposed through the imageSprite property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var ImageSpriteManager = /** @class */ (function () {
	    /**
	     * Constructs the image sprite manager to be exposed only through the imageSprite property of the Map class.
	     * @param map The Map object this will manage the image sprite for.
	     * @internal
	     */
	    function ImageSpriteManager(map) {
	        this.userImages = new Dictionary();
	        this.imageLoadTimeout = 5000;
	        this.map = map;
	    }
	    /**
	     * Add an icon image to the map's image sprite for use with symbols and patterns.
	     * @param id The image's id.
	     * If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param icon The image to add to the map's sprite. Can be a data URI, inline SVG, or image URL.
	     * @param meta Additional options that describe the image
	     */
	    ImageSpriteManager.prototype.add = function (id, icon, meta) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            // Take no action if the new image uses the id of a previously added image.
	            if (_this.userImages.has(id)) {
	                resolve();
	                return;
	            }
	            if (icon instanceof HTMLImageElement || icon instanceof ImageData) {
	                _this.map._getMap().addImage(id, icon, meta);
	                _this.userImages.set(id, { image: icon, meta: meta });
	                resolve();
	            }
	            else if (typeof icon === "string") {
	                var imageSrc = void 0;
	                // Assume an inline svg image string if icon doesn't start with "data:", but does include "<svg"
	                if (/<svg/i.test(icon) && !(/^data:/i.test(icon))) {
	                    imageSrc = "data:image/svg+xml;base64," + window.btoa(icon);
	                }
	                else {
	                    imageSrc = icon;
	                }
	                // Use a timer to prevent the request from waiting forever.
	                var timeoutId_1;
	                var timedOut_1 = false;
	                // Use the map to send the request so transformRequest is used.
	                _this.map._sendRequest(imageSrc, "Image" /* ResourceType.Image */).then(function (response) {
	                    return !timedOut_1 ? response.blob() : undefined;
	                }).then(function (blob) {
	                    if (!timedOut_1 && blob) {
	                        clearTimeout(timeoutId_1);
	                        var imageEle_1 = new Image();
	                        // Wait for the blob to load into the element.
	                        imageEle_1.onload = function () {
	                            _this.map._getMap().addImage(id, imageEle_1, meta);
	                            _this.userImages.set(id, { image: imageEle_1, meta: meta });
	                            resolve();
	                        };
	                        // Reject if the blob failed to load in the element.
	                        imageEle_1.onerror = imageEle_1.onabort = function () {
	                            reject("Failed to load image into HTML element.");
	                        };
	                        // Convert the blob to a data url then load it into an Image element.
	                        imageEle_1.src = URL.createObjectURL(blob);
	                    }
	                }).catch(function () {
	                    if (!timedOut_1) {
	                        clearTimeout(timeoutId_1);
	                        reject("Failed to load image into HTML element.");
	                    }
	                });
	                // Allow the image a fixed amount of time to load the image before aborting.
	                // @ts-ignore
	                timeoutId_1 = setTimeout(function () {
	                    timedOut_1 = true;
	                    reject("Failed to load image within specified timeout: ".concat(_this.imageLoadTimeout, " ms."));
	                    // tslint:disable-next-line: no-string-based-set-timeout
	                }, _this.imageLoadTimeout);
	            }
	        });
	    };
	    /**
	     * Removes all images added by the user.
	     */
	    ImageSpriteManager.prototype.clear = function () {
	        var _this = this;
	        this.userImages.forEach(function (image, id) {
	            _this.map._getMap().removeImage(id);
	        });
	        // Clear the list of user added image ids.
	        this.userImages.clear();
	    };
	    /**
	     * Gets a list of all the image ids that have been added to the maps image sprite.
	     */
	    ImageSpriteManager.prototype.getImageIds = function () {
	        var ids = [];
	        this.userImages.forEach(function (image, id) {
	            ids.push(id);
	        });
	        return ids;
	    };
	    /**
	     * Creates and adds an image to the maps image sprite. Provide the name of the built-in template to use, and a color to apply.
	     * Optionally, specifiy a secondary color if the template supports one. A scale can also be specified.
	     * This will allow the SVG to be scaled before it is converted into an image and thus look much better when scaled up.
	     * Returns a promise.
	     * Reference this in the Polygon or Symbol layer.
	     * @param id  The image's id. If the specified id matches the id of a previously added image the new image will be ignored.
	     * @param templateName The name of the template to use.
	     * @param color The primary color value. Default: #1A73AA
	     * @param secondaryColor A secondary color value. Default: white
	     * @param scale Specifies how much to scale the template. For best results, scale the icon to the maximum size you want to display it on the map, then use the symbol layers icon size option to scale down if needed. This will reduce blurriness due to scaling. Default: 1
	     */
	    ImageSpriteManager.prototype.createFromTemplate = function (id, templateName, color, secondaryColor, scale) {
	        color = color || "#1A73AA";
	        secondaryColor = secondaryColor || "#fff";
	        var t = getImageTemplate(templateName, scale);
	        t = t.replace(/{color}/g, color).replace(/{secondaryColor}/g, secondaryColor).replace(/{text}/g, "");
	        return this.add(id, t);
	    };
	    /**
	     * Checks to see if an image is already loaded into the maps image sprite.
	     * @param id The id to check the map's image sprite for.
	     */
	    ImageSpriteManager.prototype.hasImage = function (id) {
	        return this.userImages.has(id);
	    };
	    /**
	     * Removes an image from the map's image sprite.
	     * @param id The id of the image to remove.
	     */
	    ImageSpriteManager.prototype.remove = function (id) {
	        this.map._getMap().removeImage(id);
	        this.userImages.delete(id);
	    };
	    /**
	     * Restores the images the user has added to the Mapbox image sprite.
	     * @internal
	     */
	    ImageSpriteManager.prototype._restoreImages = function () {
	        var _this = this;
	        // Check that all user added images still exist in the sprite after changing styles.
	        // Currently Mapbox doesn't support diff operations for sprites.
	        // Therefore changing a sprite will cause a full style rebuild.
	        this.userImages.forEach(function (image, id) {
	            if (!_this.map._getMap().hasImage(id)) {
	                _this.map._getMap().addImage(id, image.image, image.meta);
	            }
	        });
	    };
	    return ImageSpriteManager;
	}());

	var __extends$e = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$9 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * Used to represent the layer described by a resource files.
	 * Serves primarily as a wrapper for multiple Mapbox layers in LayerManger.
	 * @private
	 */
	var FundamentalMapLayer = /** @class */ (function (_super) {
	    __extends$e(FundamentalMapLayer, _super);
	    /**
	     * Constructs a base layer used to represent the base, transit, and labels layers.
	     * @param mbLayers The stylesheet used to define the style sources and style layers.
	     * @param id The layer's id.
	     */
	    function FundamentalMapLayer(mbLayers, id) {
	        var _this = _super.call(this, id) || this;
	        _this.layers = mbLayers;
	        return _this;
	    }
	    /**
	     * Gets the options of the layer.
	     */
	    FundamentalMapLayer.prototype.getOptions = function () {
	        return {};
	    };
	    /**
	     * Sets the options of the layer.
	     * @param options The new options of the layer.
	     */
	    FundamentalMapLayer.prototype.setOptions = function (options) { return; };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._buildLayers = function () {
	        return this.layers;
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getLayerIds = function () {
	        return this.layers.map(function (l) { return l.id; });
	    };
	    /**
	     * @internal
	     */
	    FundamentalMapLayer.prototype._getSourceIds = function () {
	        var e_1, _a;
	        var ids = new Set();
	        try {
	            for (var _b = __values$9(this.layers), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var layer = _c.value;
	                if ('source' in layer && typeof layer.source === "string") {
	                    // If the layer's source is just a string id use that.
	                    ids.add(layer.source);
	                }
	                else if ('source' in layer && layer.source) {
	                    // If the layer has an inline source definition the id will match the layer's.
	                    ids.add(layer.id);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return ids;
	    };
	    FundamentalMapLayer.prototype._updateLayoutProperty = function (name, newValue, oldValue, subValue) {
	        if (isEqual$1(newValue, oldValue))
	            return;
	        var map = this.map._getMap();
	        this.layers.forEach(function (layer) {
	            if (map.getLayer(layer.id)) {
	                map.setLayoutProperty(layer.id, name, subValue || newValue);
	            }
	            else {
	                console.warn("Could not update layout property ".concat(name, " for layer ").concat(layer.id, " to ").concat(subValue || newValue));
	            }
	        });
	    };
	    return FundamentalMapLayer;
	}(Layer));

	var __values$8 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$6 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$6 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * A manager for the map control's layers.
	 * Exposed through the layers property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var LayerManager = /** @class */ (function () {
	    /**
	     * Constructs the layer manager to be exposed only through the layers property of the Map class.
	     * @param map The map whose layers are being managed by this.
	     * @internal
	     */
	    function LayerManager(map) {
	        this.layerIndex = [];
	        this.userLayers = [];
	        this.map = map;
	    }
	    LayerManager.prototype.add = function (layer, before) {
	        var e_1, _a;
	        var beforeId = before instanceof Layer ?
	            before.getId() :
	            before;
	        if (Array.isArray(layer)) {
	            try {
	                for (var layer_1 = __values$8(layer), layer_1_1 = layer_1.next(); !layer_1_1.done; layer_1_1 = layer_1.next()) {
	                    var singleLayer = layer_1_1.value;
	                    this._addLayer(singleLayer, beforeId);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (layer_1_1 && !layer_1_1.done && (_a = layer_1.return)) _a.call(layer_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addLayer(layer, beforeId);
	        }
	    };
	    /**
	     * Adds a single layer to the map.
	     * @private
	     */
	    LayerManager.prototype._addLayer = function (layer, before) {
	        if (!this.map._isReady() && !(layer instanceof FundamentalMapLayer)) {
	            throw new Error("The layer '".concat(layer.getId(), "' could not be added to the map because ") +
	                "the map is not ready. Please use a ready event listener to guarantee " +
	                "the map is ready before adding a layer to it.");
	        }
	        if (before !== layer.getId() && this.layerIndex.find(function (l) { return before === l.getId(); })) {
	            if (this._getMapboxLayerExists(layer)) {
	                // Replace the existing layer with the new one.
	                // Place the new layer behind the specified before layer.
	                var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layer.getId(); });
	                var userLayerIndex = this.userLayers.findIndex(function (ul) { return ul.layer.getId() === layer.getId(); });
	                this._removeMapboxLayers(layer);
	                this._addMapboxLayers(layer, before);
	                var tempLayer = this.layerIndex[layerIndex];
	                if (tempLayer) {
	                    this.map.events._disableLayerEvents(tempLayer);
	                }
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex.splice(layerIndex, 1);
	                var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === before; });
	                this.layerIndex.splice(beforeIndex, 0, layer);
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers[userLayerIndex] = { layer: layer, before: before };
	                }
	                if (tempLayer) {
	                    tempLayer.onRemove();
	                }
	                layer.onAdd(this.map);
	            }
	            else {
	                // Add the new layer behind the specified before layer.
	                this._addMapboxLayers(layer, before);
	                this.map.events._enableLayerEvents(layer);
	                var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === before; });
	                this.layerIndex.splice(beforeIndex, 0, layer);
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers.push({ layer: layer, before: before });
	                }
	                layer.onAdd(this.map);
	            }
	        }
	        else {
	            var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layer.getId(); });
	            var userLayerIndex = this.userLayers.findIndex(function (ul) { return ul.layer.getId() === layer.getId(); });
	            if (layerIndex >= 0 && userLayerIndex >= 0) {
	                // Replace the existing layer with the new one.
	                var tempLayer = this.layerIndex[layerIndex];
	                this._removeMapboxLayers(tempLayer);
	                this._addMapboxLayers(layer, layerIndex + 1);
	                this.map.events._disableLayerEvents(tempLayer);
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex[layerIndex] = layer;
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers[userLayerIndex] = { layer: layer, before: undefined };
	                }
	                tempLayer.onRemove();
	                layer.onAdd(this.map);
	            }
	            else {
	                // Add the layer to the top of the z-order.
	                this._addMapboxLayers(layer);
	                this.map.events._enableLayerEvents(layer);
	                this.layerIndex.push(layer);
	                if (!(layer instanceof FundamentalMapLayer)) {
	                    this.userLayers.push({ layer: layer, before: before });
	                }
	                layer.onAdd(this.map);
	            }
	        }
	    };
	    /**
	     * Adds all the Mapbox layers built by an atlas layer to the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._addMapboxLayers = function (layer, before) {
	        var e_2, _a;
	        // if the TileLayer's tile URL isn't defined yet, don't add the source and layer.
	        if (layer instanceof TileLayer && !layer.getOptions().tileUrl) {
	            return;
	        }
	        // FundamentalMapLayers are a special case because they are created indirectly by StyleManager when mapbox
	        // loads a style by URL. When a FundamentalMapLayer is added to the LayerManager it is being done
	        // so to reflect layers that are already loaded in mapbox so they do not need to be added a second 
	        // time
	        if (layer instanceof FundamentalMapLayer) {
	            this.map.events._enableLayerEvents(layer);
	            return;
	        }
	        // SourceBuildingLayers are a special case because they create their own source and manage it internally.
	        // If adding a SourceBuildingLayer the source associated must also be added.
	        if (layer instanceof SourceBuildingLayer) {
	            this.map._getMap().addSource(layer._getSourceId(), layer._buildSource());
	            // we also need the abstraction for those source building layers added to the map if it is not already there
	            this.map.sources.setSourceState(layer._getSourceWrapper());
	        }
	        var mbBefore = this._getMapboxBefore(before);
	        try {
	            for (var _b = __values$8(layer._buildLayers()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayer = _c.value;
	                this.map._getMap().addLayer(mbLayer, mbBefore);
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        this.map.events._enableLayerEvents(layer);
	    };
	    /**
	     * Removes all the Mapbox layers built by an atlas layer from the Mapbox map.
	     * @private
	     */
	    LayerManager.prototype._removeMapboxLayers = function (layer, force) {
	        var e_3, _a;
	        // FundamentalMapLayers are a special case because they are created indirectly by StyleManager when mapbox
	        // loads a style by URL. When a FundamentalMapLayer is removed from the LayerManager it is being done
	        // so to reflect layers that are already removed from mapbox so they do not need to be removed a second 
	        // time
	        if (layer instanceof FundamentalMapLayer && !force) {
	            this.map.events._disableLayerEvents(layer);
	            return;
	        }
	        try {
	            for (var _b = __values$8(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayerId = _c.value;
	                // Check if the layer does exist.
	                if (this.map._getMap().getLayer(mbLayerId)) {
	                    this.map._getMap().removeLayer(mbLayerId);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        this.map.events._disableLayerEvents(layer);
	        // SourceBuildingLayer are a special case because they create their own source and manage it internally.
	        // If removing a SourceBuildingLayer the source associated must also be removed.
	        if (layer instanceof SourceBuildingLayer &&
	            this.map._getMap().getSource(layer._getSourceId())) {
	            this.map._getMap().removeSource(layer._getSourceId());
	        }
	    };
	    /**
	     * Test if mapbox contains a mapbox.Layer defined in an atlas Layer.
	     *
	     * @param layer: Atlas layer or layerID to test.
	     * @returns True if layer exists in mapbox.
	     */
	    LayerManager.prototype._getMapboxLayerExists = function (layer) {
	        var _this = this;
	        var found = false;
	        if (typeof layer === "string") {
	            layer = this.layerIndex.find(function (l) { return l.getId() === layer; });
	            if (!layer) {
	                return false;
	            }
	            return true;
	        }
	        layer._getLayerIds().forEach(function (mbLayerId) {
	            var mbLayer = _this.map._getMap().getLayer(mbLayerId);
	            if (mbLayer)
	                found = true;
	        });
	        return found;
	    };
	    /**
	     * Gets the ID of the Mapbox layer to add before given the id of the atlas before layer.
	     * @private
	     */
	    LayerManager.prototype._getMapboxBefore = function (before) {
	        var e_4, _a, e_5, _b;
	        // If passed a string use it as the name of an atlas layer.
	        if (typeof before === "string") {
	            var beforeLayer = this.layerIndex.find(function (l) { return l.getId() === before; });
	            // If the before layer exists iterate over the mapbox layers
	            // it would build until a layer exists on the mapbox map.
	            if (beforeLayer) {
	                try {
	                    for (var _c = __values$8(beforeLayer._getLayerIds()), _d = _c.next(); !_d.done; _d = _c.next()) {
	                        var layerId = _d.value;
	                        if (this.map._getMap().getLayer(layerId)) {
	                            return layerId;
	                        }
	                    }
	                }
	                catch (e_4_1) { e_4 = { error: e_4_1 }; }
	                finally {
	                    try {
	                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
	                    }
	                    finally { if (e_4) throw e_4.error; }
	                }
	                // If none of the layers built by the specified before layer
	                // actually exists on the map start checking the next layers.
	                before = this.layerIndex.findIndex(function (l) { return l.getId() === before; }) + 1;
	            }
	            else {
	                // If the before layer hasn't been added just return undefined.
	                return undefined;
	            }
	        }
	        // If passed a number assume it is the index of the before layer.
	        // Or the string passed didn't lead to finding any existing mapbox layers.
	        //
	        // Iterate over all layers at or after the before index until one of
	        // the mapbox layers built by an atlas layer exists in the mapbox map.
	        for (var i = before; i < this.layerIndex.length; i++) {
	            try {
	                for (var _e = (e_5 = void 0, __values$8(this.layerIndex[i]._getLayerIds())), _f = _e.next(); !_f.done; _f = _e.next()) {
	                    var layerId = _f.value;
	                    if (this.map._getMap().getLayer(layerId)) {
	                        return layerId;
	                    }
	                }
	            }
	            catch (e_5_1) { e_5 = { error: e_5_1 }; }
	            finally {
	                try {
	                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
	                }
	                finally { if (e_5) throw e_5.error; }
	            }
	        }
	        // If nothing was found just return undefined.
	        return undefined;
	    };
	    /**
	     * Removes all layers from the map.
	     */
	    LayerManager.prototype.clear = function () {
	        for (var layerIndexIndex = this.layerIndex.length - 1; layerIndexIndex >= 0; layerIndexIndex--) {
	            var tempLayer = this.layerIndex[layerIndexIndex];
	            if (tempLayer) {
	                this._removeMapboxLayers(tempLayer, true);
	                this.layerIndex.splice(layerIndexIndex, 1);
	                tempLayer.onRemove();
	            }
	        }
	        this.userLayers = [];
	    };
	    /**
	     * Retrieves a layer with the specified id.
	     * @param id The id of the layer to retrieve.
	     */
	    LayerManager.prototype.getLayerById = function (id) {
	        var result = this.layerIndex.find(function (l) { return l.getId() === id; });
	        if (result)
	            return result;
	        return undefined;
	    };
	    /**
	     * Retrieves all layers that have been added to the map.
	     */
	    LayerManager.prototype.getLayers = function () {
	        return this.layerIndex.slice(0);
	    };
	    /**
	     * Returns a set of all the source IDs that any layers depend on.
	     * @internal
	     */
	    LayerManager.prototype._getSourceIds = function () {
	        var e_6, _a;
	        var ids = new Set();
	        try {
	            for (var _b = __values$8(this.layerIndex), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var layer = _c.value;
	                layer._getSourceIds().forEach(function (id) { return ids.add(id); });
	            }
	        }
	        catch (e_6_1) { e_6 = { error: e_6_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_6) throw e_6.error; }
	        }
	        return ids;
	    };
	    /**
	     *
	     * @returns Returns a set of all layers added through this SDK.
	     * @internal
	     */
	    LayerManager.prototype._getUserLayers = function () {
	        return Array.from(this.userLayers);
	    };
	    /**
	     * Moves a layer to a different z-position.
	     * @param layer The layer or id of the layer to move.
	     * @param before Optionally specify to move the layer before this.
	     */
	    LayerManager.prototype.move = function (layer, before) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        var beforeId = before instanceof Layer ? before.getId() : before;
	        if (!this.layerIndex.find(function (l) { return l.getId() === layerId; })) {
	            throw new Error("The layer '".concat(layerId, "' has not been added to the map and cannot be moved."));
	        }
	        var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	        this._moveMapboxLayers(this.layerIndex[layerIndex], beforeId);
	        layer = this.layerIndex[layerIndex];
	        this.layerIndex.splice(layerIndex, 1);
	        var beforeIndex = this.layerIndex.findIndex(function (l) { return l.getId() === beforeId; });
	        if (beforeIndex > -1) {
	            this.layerIndex.splice(beforeIndex, 0, layer);
	        }
	        else {
	            this.layerIndex.push(layer);
	        }
	        // Update before property of the user layer
	        var userLayer = this.userLayers.find(function (ul) { return ul.layer.getId() === layerId; });
	        if (userLayer) {
	            userLayer.before = beforeId;
	        }
	    };
	    LayerManager.prototype._moveMapboxLayers = function (layer, before) {
	        var e_7, _a;
	        var mbBefore = this._getMapboxBefore(before);
	        try {
	            for (var _b = __values$8(layer._getLayerIds()), _c = _b.next(); !_c.done; _c = _b.next()) {
	                var mbLayerId = _c.value;
	                this.map._getMap().moveLayer(mbLayerId, mbBefore);
	            }
	        }
	        catch (e_7_1) { e_7 = { error: e_7_1 }; }
	        finally {
	            try {
	                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	            }
	            finally { if (e_7) throw e_7.error; }
	        }
	    };
	    /**
	        * Retrieve all Shapes and GeoJSON features that are visible on the map that are in a DataSource or VectorTileSource.
	        * Shape objects are editable, while Feature objects are not editable and either reside in a VectorTileSource or represent a cluster point.
	        * Clusters have the following properties:<br />
	        * `cluster`: `boolean` - Indicates that the point is a cluster.
	        * This will be set to true if Point object represents a cluster.
	        * All other point objects are unlikely to have this value unless
	        * a property with this same name was added to the Point property data from your app.<br />
	        * `cluster_id`: `string` - A unique id for the cluster.<br />
	        * `point_count`: `number` - The number of points inside the cluster.<br />
	        * `point_count_abbreviated`: `string` - An abbreviated string version of the point count. i.e. `"10K"`<br />
	        * Features/Shapes that are not visible or who's layer zoom range does not include the current zoom level will not be returned.
	        * Symbol features/Shapes that have been hidden due to text or icon collisions are not included.
	        * Features/Shapes from all other layers are included even if they have no contribution to the map rendering, e.g. alpha set to zero.
	        * The topmost rendered features/shapes appears first in the returned array and subsequent features are sorted in descending z-order.
	        * @param geometry A Position, Point, or BoundingBox that returned features must intersect. If not specified the whole visible world is used.
	        * @param layers An array of layers or their ids to limit the query to.
	        * @param filter A expression to filter the returned features by.
	        */
	    LayerManager.prototype.getRenderedShapes = function (geometry, layers, filter) {
	        var e_8, _a;
	        var _this = this;
	        // If no geometry was provided use a bounding box covering the whole world.
	        if (!geometry) {
	            geometry = [-180, -85.0511, 180, 85.0511];
	        }
	        // Mapbox's queryRenderedFeatures uses screen coordinates not GeoJSON positions.
	        // Here we convert the input bounding box or point into screen coordinates.
	        var scope;
	        if (Array.isArray(geometry)) {
	            if (geometry.length === 4 || geometry.length === 6) {
	                // BoundingBox has length of 4 or 6: [west, south, east, north] or [west, south, elevation1, east, north, elevation2]
	                scope = this.map.positionsToPixels([
	                    BoundingBox.getSouthWest(geometry),
	                    BoundingBox.getNorthEast(geometry)
	                ]);
	            }
	            else if (geometry.length === 2 || geometry.length === 3) {
	                // Position has length of 2, or 3: [lon, lat] or [lon, lat, elv]
	                scope = this.map.positionsToPixels([geometry])[0];
	            }
	        }
	        else {
	            scope = this.map.positionsToPixels([geometry.coordinates])[0];
	        }
	        // Create an array of all the mapbox layer ids that make up the layers specified by the user.
	        // Skip any mapbox layer ids that don't currently exist in the mapbox style.
	        var layerIds;
	        if (layers) {
	            layers = Array.isArray(layers) ? layers : [layers];
	            layerIds = [];
	            var _loop_1 = function (layer) {
	                var layerId = layer instanceof Layer ? layer.getId() : layer;
	                // If a specified layer hasn't been added to the map throw an error.
	                var index = this_1.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	                if (index > -1) {
	                    layerIds.push.apply(layerIds, __spreadArray$6([], __read$6(this_1.layerIndex[index]._getLayerIds()
	                        .filter(function (id) { return !!_this.map._getMap().getLayer(id); })), false));
	                }
	                else {
	                    throw new Error("The layer '".concat(layerId, "' has not been added to the map ") +
	                        "and its rendered features cannot be retrieved.");
	                }
	            };
	            var this_1 = this;
	            try {
	                for (var layers_1 = __values$8(layers), layers_1_1 = layers_1.next(); !layers_1_1.done; layers_1_1 = layers_1.next()) {
	                    var layer = layers_1_1.value;
	                    _loop_1(layer);
	                }
	            }
	            catch (e_8_1) { e_8 = { error: e_8_1 }; }
	            finally {
	                try {
	                    if (layers_1_1 && !layers_1_1.done && (_a = layers_1.return)) _a.call(layers_1);
	                }
	                finally { if (e_8) throw e_8.error; }
	            }
	        }
	        // Use queryRenderedFeatures to get a basic list of the features
	        // within the scope and belonging to the specified layers.
	        var features = this.map._getMap().queryRenderedFeatures(scope, {
	            layers: layerIds,
	            filter: filter
	        });
	        // Any features belonging to a DataSource will be mapped to the Shapes that wrap them.
	        return this.map.sources._mapFeaturesToShapes(features);
	    };
	    LayerManager.prototype.remove = function (layer) {
	        var e_9, _a;
	        if (Array.isArray(layer)) {
	            try {
	                for (var layer_2 = __values$8(layer), layer_2_1 = layer_2.next(); !layer_2_1.done; layer_2_1 = layer_2.next()) {
	                    var singleLayer = layer_2_1.value;
	                    this._removeLayer(singleLayer);
	                }
	            }
	            catch (e_9_1) { e_9 = { error: e_9_1 }; }
	            finally {
	                try {
	                    if (layer_2_1 && !layer_2_1.done && (_a = layer_2.return)) _a.call(layer_2);
	                }
	                finally { if (e_9) throw e_9.error; }
	            }
	        }
	        else {
	            this._removeLayer(layer);
	        }
	    };
	    /**
	     * Removes a single layer from the map.
	     * @private
	     */
	    LayerManager.prototype._removeLayer = function (layer) {
	        var layerId = layer instanceof Layer ? layer.getId() : layer;
	        var layerIndex = this.layerIndex.findIndex(function (l) { return l.getId() === layerId; });
	        if (layerIndex == -1) {
	            throw new Error("The layer '".concat(layerId, "' has not been added to the map and cannot be removed."));
	        }
	        var tempLayer = this.layerIndex[layerIndex];
	        this._removeMapboxLayers(tempLayer);
	        this.layerIndex.splice(layerIndex, 1);
	        var userLayerIndex = this.userLayers.findIndex(function (ul) { return ul.layer.getId() === layerId; });
	        if (userLayerIndex != -1) {
	            this.userLayers.splice(userLayerIndex, 1);
	        }
	        if (layer instanceof SourceBuildingLayer) {
	            this.map.sources.unsetSourceState(layer._getSourceId());
	        }
	        tempLayer.onRemove();
	    };
	    return LayerManager;
	}());

	var __values$7 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's popups.
	 * Exposed through the `popups` property of the `atlas.Map` class.
	 * Cannot be instantiated by the user.
	 */
	var PopupManager = /** @class */ (function () {
	    /**
	     * Constructs the popup manager to be exposed only through the `popups` property of the `Map` class.
	     * @param map The map whose popups are being managed by this.
	     * @internal
	     */
	    function PopupManager(map) {
	        var _this = this;
	        /**
	         * Listens for mouse or touch movement when dragging popups.
	         */
	        this._onDrag = function (event) {
	            // Determine the new x and y from the event data.
	            var x;
	            var y;
	            if (event.type === "mousemove") {
	                event = event;
	                x = event.clientX;
	                y = event.clientY;
	            }
	            else if (event.type === "touchmove") {
	                event = event;
	                x = event.touches[0].clientX;
	                y = event.touches[0].clientY;
	            }
	            _this.draggedPopups.forEach(function (popup) {
	                popup._dragToPixel([x, y]);
	            });
	        };
	        /**
	         * Listens for mouse up or touch end to indicate popups aren't being dragged anymore.
	         */
	        this._onUp = function () {
	            // Remove the listeners since no popups are being dragged anymore.
	            _this.map.getMapContainer().removeEventListener("mousemove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("touchmove", _this._onDrag);
	            _this.map.getMapContainer().removeEventListener("mouseup", _this._onUp);
	            _this.map.getMapContainer().removeEventListener("touchend", _this._onUp);
	            _this.draggedPopups.forEach(function (popup) {
	                _this.draggedPopups.delete(popup);
	                popup._onUp();
	            });
	        };
	        this.map = map;
	        this.popups = new Set();
	        this.draggedPopups = new Set();
	    }
	    /**
	     * Adds a popup to the map
	     * @param popup The popup(s) to add.
	     */
	    PopupManager.prototype.add = function (popup) {
	        var e_1, _a;
	        popup = Array.isArray(popup) ? popup : [popup];
	        try {
	            for (var popup_1 = __values$7(popup), popup_1_1 = popup_1.next(); !popup_1_1.done; popup_1_1 = popup_1.next()) {
	                var p = popup_1_1.value;
	                if (!this.popups.has(p)) {
	                    this.popups.add(p);
	                    p.attach(this.map);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (popup_1_1 && !popup_1_1.done && (_a = popup_1.return)) _a.call(popup_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * Removes all popups from the map.
	     */
	    PopupManager.prototype.clear = function () {
	        var _this = this;
	        this.popups.forEach(function (popup) {
	            _this.popups.delete(popup);
	            popup.remove();
	        });
	    };
	    /**
	     * Removes a popup from the map
	     * @param popup The popup(s) to remove.
	     */
	    PopupManager.prototype.remove = function (popup) {
	        var e_2, _a;
	        popup = Array.isArray(popup) ? popup : [popup];
	        try {
	            for (var popup_2 = __values$7(popup), popup_2_1 = popup_2.next(); !popup_2_1.done; popup_2_1 = popup_2.next()) {
	                var p = popup_2_1.value;
	                if (this.popups.has(p)) {
	                    this.popups.delete(p);
	                    p.remove();
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (popup_2_1 && !popup_2_1.done && (_a = popup_2.return)) _a.call(popup_2);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	    };
	    /**
	     * Returns the popups currently attached to the map.
	     */
	    PopupManager.prototype.getPopups = function () {
	        return Array.from(this.popups);
	    };
	    /**
	     * Returns the div element that should contain all the popup containers.
	     * Creates it if it doesn't already exist.
	     * @internal
	     */
	    PopupManager.prototype._getCollectionDiv = function () {
	        var collection = this.map.getMapContainer()
	            .querySelector(".".concat(PopupManager.Css.collection));
	        if (!collection) {
	            // If the collection div doesn't exist create it.
	            collection = document.createElement("div");
	            collection.classList.add(PopupManager.Css.collection);
	            collection.setAttribute("aria-label", "Map Information");
	            this.map.getMapContainer().appendChild(collection);
	        }
	        return collection;
	    };
	    /**
	     * Adds a popup to the set of popups actively being dragged.
	     * @internal
	     */
	    PopupManager.prototype._addDraggedPopup = function (popup) {
	        // If no popups are being dragged yet add the listeners.
	        if (this.draggedPopups.size === 0) {
	            this.map.getMapContainer().addEventListener("mousemove", this._onDrag);
	            this.map.getMapContainer().addEventListener("touchmove", this._onDrag);
	            this.map.getMapContainer().addEventListener("mouseup", this._onUp);
	            this.map.getMapContainer().addEventListener("touchend", this._onUp);
	        }
	        // Track the popups being dragged for the mousemove events.
	        this.draggedPopups.add(popup);
	    };
	    PopupManager.Css = {
	        collection: "popup-collection-container"
	    };
	    return PopupManager;
	}());

	var __values$6 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * A manager for the map control's sources.
	 * Exposed through the sources property of the atlas.Map class.
	 * Cannot be instantiated by the user.
	 */
	var SourceManager = /** @class */ (function () {
	    /**
	     * @internal
	     */
	    function SourceManager(map) {
	        this.map = map;
	        this.sources = new Dictionary();
	    }
	    SourceManager.prototype.add = function (source, update) {
	        var e_1, _a;
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            try {
	                for (var source_1 = __values$6(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
	                    var singleSource = source_1_1.value;
	                    this._addSource(singleSource, update);
	                }
	            }
	            catch (e_1_1) { e_1 = { error: e_1_1 }; }
	            finally {
	                try {
	                    if (source_1_1 && !source_1_1.done && (_a = source_1.return)) _a.call(source_1);
	                }
	                finally { if (e_1) throw e_1.error; }
	            }
	        }
	        else {
	            this._addSource(source, update);
	        }
	    };
	    /**
	     * Returns all rendered shape features in a source that match a specified filter. If the source is a vector tile source, a source layer name needs to be specified.
	     * @param source source to be queried
	     * @param filter a filter to limit the query
	     * @param sourceLayer the layer where shapes and features are matched
	     */
	    SourceManager.prototype.getRenderedShapes = function (source, filter, sourceLayer) {
	        var sourceID = typeof source === "string" ? source : source.getId();
	        var features = this.map._getMap().querySourceFeatures(sourceID, { sourceLayer: sourceLayer, filter: filter });
	        return this.map.sources._mapFeaturesToShapes(features, true, this.sources.get(sourceID));
	    };
	    /**
	     * Gets the state of a feature
	     * @param feature the ID of the feature
	     * @param source the ID of the source
	     * @param sourceLayer the ID of the layer
	     */
	    SourceManager.prototype.getFeatureState = function (feature, source, sourceLayer) {
	        var featureId;
	        if (typeof feature === "string") {
	            featureId = feature;
	        }
	        else {
	            featureId = feature instanceof Shape ? feature.getId() : feature.id;
	        }
	        var featureSource = typeof source === "string" ? source : source.getId();
	        return this.map._getMap().getFeatureState({ id: featureId, source: featureSource, sourceLayer: sourceLayer });
	    };
	    /**
	     * Removes the state or a single key value of the state of a feature.
	     * @param feature the ID of the feature
	     * @param source the ID of the source
	     * @param sourceLayer the ID of the layer
	     * @param key the key in the feature state to update
	     */
	    SourceManager.prototype.removeFeatureState = function (feature, source, sourceLayer, key) {
	        var featureId;
	        if (typeof feature === "string") {
	            featureId = feature;
	        }
	        else {
	            featureId = feature instanceof Shape ? feature.getId() : feature.id;
	        }
	        var featureSource = typeof source === "string" ? source : source.getId();
	        this.map._getMap().removeFeatureState({ id: featureId, source: featureSource, sourceLayer: sourceLayer }, key);
	    };
	    /**
	     * Sets the state of the feature by passing in a key value pair object.
	     * @param feature the ID of the feature
	     * @param source the ID of the source
	     * @param sourceLayer the ID of the layer
	     * @param key the key in the feature state to update
	     */
	    SourceManager.prototype.setFeatureState = function (feature, source, state, sourceLayer) {
	        var featureId;
	        if (typeof feature === "string") {
	            featureId = feature;
	        }
	        else {
	            featureId = feature instanceof Shape ? feature.getId() : feature.id;
	        }
	        var featureSource = typeof source === "string" ? source : source.getId();
	        this.map._getMap().setFeatureState({ id: featureId, source: featureSource, sourceLayer: sourceLayer }, state);
	    };
	    /**
	     * @internal
	     */
	    SourceManager.prototype._buildSources = function () {
	        var ret = {};
	        this.sources.forEach(function (source) {
	            ret[source.getId()] = source._buildSource();
	        });
	        return ret;
	    };
	    /**
	     * Removes all sources from the map.
	     */
	    SourceManager.prototype.clear = function () {
	        var _this = this;
	        this.sources.forEach(function (source) {
	            _this.remove(source);
	        });
	    };
	    /**
	     * Retrieves a source with the specified id.
	     * @param id
	     */
	    SourceManager.prototype.getById = function (id) {
	        return this.sources.get(id);
	    };
	    /**
	     * Retrieves all sources that have been added to the map.
	     */
	    SourceManager.prototype.getSources = function () {
	        return Array.from(this.sources.values());
	    };
	    /**
	     * Returns a boolean indicating if the source is loaded or not.
	     * @param source The id of a source or a Source object.
	     */
	    SourceManager.prototype.isSourceLoaded = function (source) {
	        var id = source instanceof Source ? source.getId() : source;
	        return this.map._getMap().isSourceLoaded(id);
	    };
	    SourceManager.prototype.remove = function (source, update) {
	        var e_2, _a;
	        if (update === void 0) { update = true; }
	        if (Array.isArray(source)) {
	            try {
	                for (var source_2 = __values$6(source), source_2_1 = source_2.next(); !source_2_1.done; source_2_1 = source_2.next()) {
	                    var singleSource = source_2_1.value;
	                    this._removeSource(singleSource, update);
	                }
	            }
	            catch (e_2_1) { e_2 = { error: e_2_1 }; }
	            finally {
	                try {
	                    if (source_2_1 && !source_2_1.done && (_a = source_2.return)) _a.call(source_2);
	                }
	                finally { if (e_2) throw e_2.error; }
	            }
	        }
	        else {
	            this._removeSource(source, update);
	        }
	    };
	    /**
	     * @internal
	     */
	    SourceManager.prototype.setSourceState = function (newSource, shouldInvokeAddEvent) {
	        if (shouldInvokeAddEvent === void 0) { shouldInvokeAddEvent = true; }
	        this.sources.set(newSource.getId(), newSource);
	        newSource._setMap(this.map, shouldInvokeAddEvent);
	    };
	    /**
	     * @internal
	     */
	    SourceManager.prototype.unsetSourceState = function (id) {
	        if (this.sources.has(id)) {
	            this.sources.get(id)._setMap(null);
	            this.sources.delete(id);
	        }
	    };
	    SourceManager.prototype._removeSource = function (source, update) {
	        var id = source instanceof Source ? source.getId() : source;
	        if (this.sources.has(id)) {
	            if (this.map._getMap().getSource(id) && update) {
	                this.map._getMap().removeSource(id);
	            }
	            if (!this.map._getMap().getSource(id) || !update) {
	                this.unsetSourceState(id);
	            }
	            else {
	                throw new Error("One or more layers have a dependency on the source '".concat(id, "'"));
	            }
	            return;
	        }
	        throw new Error("'".concat(id, "' is not added to the map"));
	    };
	    SourceManager.prototype._addSource = function (source, update) {
	        // If adding a source that shares an id with an existing source throw an error unless update is false.
	        // Update being false assumes that a call to map.setStyle(...) will occurs soon.
	        if (this.sources.has(source.getId())) {
	            if (update) {
	                throw new Error("'".concat(source.getId(), "' is already added to the map"));
	            }
	            else {
	                this.unsetSourceState(source.getId());
	            }
	        }
	        if (update) {
	            // Check if the map is ready before adding any sources.
	            if (!this.map._isReady()) {
	                throw new Error("The source '".concat(source.getId(), "' could not be added to the map because ") +
	                    "the map is not ready. Please use a ready event listener to guarantee " +
	                    "the map is ready before adding a source to it.");
	            }
	            this.map._getMap().addSource(source.getId(), source._buildSource());
	        }
	        this.setSourceState(source);
	    };
	    /**
	     * Converts an array of features as returned by one of Mapbox's query*Features(...) function
	     * to an array of our features or shapes if one is currently wrapping the feature.
	     * @internal
	     */
	    SourceManager.prototype._mapFeaturesToShapes = function (features, shapesOnly, dataSource) {
	        var e_3, _a;
	        var shapesOrFeatures = [];
	        try {
	            for (var features_1 = __values$6(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
	                var feature = features_1_1.value;
	                if ((dataSource || typeof feature["source"] === "string") &&
	                    typeof feature.properties[Shape._shapeIdPropName] === "string") {
	                    var source = dataSource || this.sources.get(feature["source"]);
	                    if (source instanceof DataSource) {
	                        var shape = source.getShapeById(feature.properties[Shape._shapeIdPropName]);
	                        if (shape instanceof Shape) {
	                            shapesOrFeatures.push(shape);
	                            continue;
	                        }
	                    }
	                }
	                if (!shapesOnly) {
	                    // If the feature couldn't be matched to a shape in a DataSource
	                    // just return the feature data as provided by mapbox.
	                    shapesOrFeatures.push(feature);
	                }
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return shapesOrFeatures;
	    };
	    /**
	     * Sync SourceManager with mapbox sources.
	     * This function is responsible for creating wrappers for mapbox sources
	     * and setting the approperiate sourceManager state with them
	     * @internal
	     */
	    SourceManager.prototype._syncSources = function (sources) {
	        var _this = this;
	        if (!sources) {
	            console.warn('syncSources called with no style sources which is unexpected.');
	            return;
	        }
	        // 1. add / update the source wrappers
	        Object.keys(sources)
	            .map(function (sourceId) {
	            var sourceToAdd = sources[sourceId];
	            var newSource;
	            switch (sourceToAdd.type) {
	                case 'vector':
	                case 'raster':
	                case 'raster-dem': {
	                    newSource = new FundamentalMapSource(sourceId, {
	                        name: sourceId,
	                        tiles: sourceToAdd.tiles,
	                        type: sourceToAdd.type,
	                        url: sourceToAdd.url,
	                        tileSize: 'tileSize' in sourceToAdd ? sourceToAdd.tileSize : undefined
	                    });
	                    break;
	                }
	                case 'canvas': {
	                    newSource = new CanvasSource(sourceId, sourceToAdd);
	                    break;
	                }
	                case 'geojson': {
	                    var dataSource = new DataSource(sourceId, {
	                        maxZoom: sourceToAdd.maxzoom,
	                        cluster: sourceToAdd.cluster,
	                        clusterRadius: sourceToAdd.clusterRadius,
	                        tolerance: sourceToAdd.tolerance,
	                        lineMetrics: sourceToAdd.lineMetrics,
	                        clusterProperties: sourceToAdd.clusterProperties,
	                        buffer: sourceToAdd.buffer,
	                        clusterMinPoints: sourceToAdd.clusterMinPoints,
	                        generateId: sourceToAdd.generateId,
	                        promoteId: sourceToAdd.promoteId,
	                        filter: sourceToAdd.filter,
	                        // attribution?: sourceToAdd.attribution
	                    });
	                    if (typeof sourceToAdd.data !== 'string' && sourceToAdd.data !== undefined) {
	                        dataSource._addNoUpdate(sourceToAdd.data);
	                    }
	                    newSource = dataSource;
	                    break;
	                }
	                case 'image': {
	                    newSource = new ImageSource(sourceId, sourceToAdd);
	                    break;
	                }
	                case 'video': {
	                    newSource = new VideoSource(sourceId, sourceToAdd);
	                    break;
	                }
	                default: {
	                    newSource = new UnknownSource(sourceId, sourceToAdd);
	                }
	            }
	            return newSource;
	        }).forEach(function (newSource) {
	            // use deep equality of underlying maplibre sources to determine if the source has been updated or overriden on style update
	            var existing = _this.sources.get(newSource.getId());
	            var isUpdate = existing && newSource._isDeepEqual(existing);
	            if (!isUpdate && existing) {
	                _this.unsetSourceState(existing.getId());
	            }
	            _this.setSourceState(newSource, !isUpdate);
	        });
	        // 2. remove the source wrappers that are not in the style
	        Array.from(this.sources.keys())
	            .filter(function (sourceId) { return !(sourceId in sources); })
	            .forEach(function (sourceId) { return _this.unsetSourceState(sourceId); });
	    };
	    return SourceManager;
	}());

	var __extends$d = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for animating changes to the map control's camera.
	 */
	var AnimationOptions = /** @class */ (function (_super) {
	    __extends$d(AnimationOptions, _super);
	    function AnimationOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The duration of the animation in milliseconds.
	         * Default `1000`.
	         * @default 1000
	         */
	        _this.duration = 1000;
	        /**
	         * The type of animation.<br />
	         * `"jump"` is an immediate change.<br />
	         * `"ease"` is a gradual change of the camera's settings.<br />
	         * `"fly"` is a gradual change of the camera's settings following an arc resembling flight.<br />
	         * Default `"jump"`.
	         * @default "jump"
	         */
	        // tslint:disable-next-line:no-reserved-keywords
	        _this.type = "jump";
	        return _this;
	    }
	    return AnimationOptions;
	}(Options));

	var __extends$c = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * Represent the amount of padding in pixels to add to the side of a BoundingBox when setting the camera of a map.
	 */
	var Padding = /** @class */ (function (_super) {
	    __extends$c(Padding, _super);
	    function Padding() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Amount of padding in pixels to add to the bottom.
	         * default `0`
	         * @default 0
	         */
	        _this.bottom = 0;
	        /**
	         * Amount of padding in pixels to add to the left.
	         * default `0`
	         * @default 0
	         */
	        _this.left = 0;
	        /**
	         * Amount of padding in pixels to add to the right.
	         * default `0`
	         * @default 0
	         */
	        _this.right = 0;
	        /**
	         * Amount of padding in pixels to add to the top.
	         * default `0`
	         * @default 0
	         */
	        _this.top = 0;
	        return _this;
	    }
	    return Padding;
	}(Options));

	var __extends$b = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$5 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$5 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$5 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * The options for setting the bounds of the map control's camera.
	 */
	var CameraBoundsOptions = /** @class */ (function (_super) {
	    __extends$b(CameraBoundsOptions, _super);
	    function CameraBoundsOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The bounds of the map control's camera.
	         * Default `[-180, -89, 180, 90]`.
	         * @default [-180, -89, 180, 90]
	         */
	        _this.bounds = [-180, -89, 180, 90];
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        /**
	         * The maximum zoom level to allow when the map view transitions to the specified bounds.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * An offset of the center of the given bounds relative to the map's center, measured in pixels.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.offset = new Pixel(0, 0);
	        /**
	         * The amount of padding in pixels to add to the given bounds.
	         * Default `{top: 0, bottom: 0, left: 0, right: 0}`.
	         * @default {top: 0, bottom: 0, left: 0, right: 0}
	         */
	        _this.padding = new Padding();
	        return _this;
	    }
	    /**
	     * overwriting merge to accept one value for padding
	     */
	    CameraBoundsOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valuesList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valuesList[_i] = arguments[_i];
	        }
	        try {
	            for (var valuesList_1 = __values$5(valuesList), valuesList_1_1 = valuesList_1.next(); !valuesList_1_1.done; valuesList_1_1 = valuesList_1.next()) {
	                var value = valuesList_1_1.value;
	                if (value && typeof value.padding === "number") {
	                    value.padding = {
	                        top: value.padding,
	                        bottom: value.padding,
	                        left: value.padding,
	                        right: value.padding
	                    };
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valuesList_1_1 && !valuesList_1_1.done && (_a = valuesList_1.return)) _a.call(valuesList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        return _super.prototype.merge.apply(this, __spreadArray$5([], __read$5(valuesList), false));
	    };
	    return CameraBoundsOptions;
	}(Options));

	var __extends$a = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for setting the map control's camera.
	 */
	var CameraOptions = /** @class */ (function (_super) {
	    __extends$a(CameraOptions, _super);
	    function CameraOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The zoom level of the map view.
	         * Default `1`.
	         * @default 1
	         */
	        _this.zoom = 1;
	        /**
	         * The position to align the center of the map view with.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.center = new Position(0, 0);
	        /**
	         * A pixel offset to apply to the center of the map.
	         * This is useful if you want to programmatically pan the map to another location or if you want to center the map over a shape, then offset the maps view to make room for a popup.
	         * Default `[0, 0]`.
	         * @default [0, 0]
	         */
	        _this.centerOffset = new Pixel(0, 0);
	        /**
	         * The bearing of the map (rotation) in degrees. When the bearing is 0, 90, 180, or 270 the top of the map container will be north, east, south or west respectively.
	         * Default `0`.
	         * @default 0
	         */
	        _this.bearing = 0;
	        /**
	         * The pitch (tilt) of the map in degrees between 0 and 60, where 0 is looking straight down on the map.
	         * Default `0`.
	         * @default 0
	         */
	        _this.pitch = 0;
	        /**
	         * The minimum zoom level that the map can be zoomed out to during the animation. Must be between 0 and 24, and less than or equal to `maxZoom`.
	         * Setting `minZoom` below 1 may result in an empty map when the zoom level is less than 1.
	         * Default `1`.
	         * @default 1
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom level that the map can be zoomed into during the animation. Must be between 0 and 24, and greater than or equal to `minZoom`.
	         * Default `20`.
	         * @default 20
	         */
	        _this.maxZoom = 20;
	        /**
	         * The minimum pitch that the map can be pitched to during the animation. Must be between 0 and 85, and less than or equal to `maxPitch`.
	         * Default `0`.
	         * @default 0
	         */
	        _this.minPitch = 0;
	        /**
	         * The maximum pitch that the map can be pitched to during the animation. Must be between 0 and 85, and greater than or equal to `minPitch`
	         * Default `60`.
	         * @default 60
	         */
	        _this.maxPitch = 60;
	        /**
	         * A bounding box in which to constrain the viewable map area to.
	         * Users won't be able to pan the center of the map outside of this bounding box.
	         * Set maxBounds to null or undefined to remove maxBounds
	         * Default `undefined`.
	         * @default undefined
	         */
	        _this.maxBounds = undefined;
	        return _this;
	    }
	    return CameraOptions;
	}(Options));

	var __extends$9 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a layer of the map.
	 */
	var LayerOptions = /** @class */ (function (_super) {
	    __extends$9(LayerOptions, _super);
	    function LayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = undefined;
	        /**
	         * The name of the layer to place this layer before.  If not specified, the layer will be placed at the top of the
	         * layer list.
	         */
	        _this.before = undefined;
	        /**
	         * The minimum zoom at which the layer will display inclusive.
	         */
	        _this.minZoom = 1;
	        /**
	         * The maximum zoom at which the layer will display inclusive.
	         */
	        _this.maxZoom = 20;
	        /**
	         * Whether to overwrite previous data for the layer.
	         */
	        _this.overwrite = false;
	        /**
	         * The opacity of the layer.
	         */
	        _this.opacity = 1;
	        return _this;
	    }
	    return LayerOptions;
	}(Options));

	var __extends$8 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a circle layer.
	 * @deprecated Use BubbleLayerOptions with atlas.layer.BubbleLayer instead.
	 */
	var CircleLayerOptions = /** @class */ (function (_super) {
	    __extends$8(CircleLayerOptions, _super);
	    function CircleLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the circles for the layer. Is used as the default if a fill color is not specified for a
	         * circle.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the circles for the layer. Is used as the default if an outline color is not specified for
	         * a circle.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The radius in pixels of the circles for the layer. Is used as the default if a radius is not specified for a
	         * circle.
	         */
	        _this.radius = 1;
	        /**
	         * The outline stroke width of the circles for the layer. Is used as the default if outline width is not specified
	         * for a circle.
	         */
	        _this.outlineWidth = 5;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-circles";
	        return _this;
	    }
	    return CircleLayerOptions;
	}(LayerOptions));

	var __extends$7 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a linestring layer.
	 * @deprecated Use LineLayerOptions with atlas.layer.LineLayer instead.
	 */
	var LinestringLayerOptions = /** @class */ (function (_super) {
	    __extends$7(LinestringLayerOptions, _super);
	    function LinestringLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The type of cap to use for the ends of the linestrings:
	         * <p>"butt" is a squared ending that is drawn to the exact endpoint of the line.</p>
	         * <p>"round" is a circular ending that is drawn past the exact endpoint with a radius of half the linestring's
	         * width.</p>
	         * <p>"square" is a squared ending that is drawn past the exact endpoint by half the linestring's width.
	         */
	        _this.cap = "butt";
	        /**
	         * The type of join to use for the linestrings:
	         * <p>"bevel" is a squared join that cuts a corner flat at half the linestring's width from the vertex.</p>
	         * <p>"round" is a circular join that rounds a corner with a radius of half the linestring's width from the
	         * vertex.</p>
	         * <p>"miter" is a sharp join that extends the segments of the linestring past the vertex until they intersect.</p>
	         */
	        _this.join = "miter";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-linestrings";
	        /**
	         * The color of the lines for the layer. Is used as the default if a specific color is not specified for a line.
	         */
	        _this.color = "#000";
	        /**
	         * The width of the lines for the layer. Is used as the default if a specific width is not specified for a line.
	         */
	        _this.width = 1;
	        return _this;
	    }
	    return LinestringLayerOptions;
	}(LayerOptions));

	var __extends$6 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a pin layer.
	 * @deprecated Use SymbolLayerOptions with atlas.layer.SymbolLayer instead.
	 */
	var PinLayerOptions = /** @class */ (function (_super) {
	    __extends$6(PinLayerOptions, _super);
	    function PinLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The factor by which the icon should be scaled. A value of 1 is the original size; a value of 2 will double the
	         * size of the icon.
	         */
	        _this.iconSize = 1;
	        /**
	         * The size of the title text.
	         */
	        _this.fontSize = 14;
	        /**
	         * The color of the title text.
	         */
	        _this.fontColor = "#000";
	        /**
	         * The font for the title of the pin.
	         */
	        _this.textFont = "SegoeUi-Regular";
	        /**
	         * Whether the icons should cluster when they collide on the map, or stay separate.
	         */
	        _this.cluster = true;
	        /**
	         * The icon to use to represent a cluster.
	         */
	        _this.clusterIcon = undefined;
	        /**
	         * An array of [pixelsRight, pixelsDown] for how many pixels to the right and down the title text should be
	         * offset. Negative numbers can be used to offset the title left and up.
	         */
	        _this.textOffset = [0, 0];
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-pins";
	        /**
	         * The icon of the pins for the layer. Is used as the default if an icon is not specified for a pin.
	         */
	        _this.icon = "pin-darkblue";
	        /**
	         * The title of the pins for the layer. Is used as the default if a title is not specified for a pin.
	         */
	        _this.title = "";
	        return _this;
	    }
	    return PinLayerOptions;
	}(LayerOptions));

	var __extends$5 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a polygon layer.
	 * @deprecated Use new PolygonLayerOptions with atlas.layer.PolygonLayer instead.
	 */
	var PolygonLayerOptions = /** @class */ (function (_super) {
	    __extends$5(PolygonLayerOptions, _super);
	    function PolygonLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The fill color of the polygons for the layer. Is used as the default if a fill color is not specified for a
	         * polygon.
	         */
	        _this.color = "rgba(0,0,0,.5)";
	        /**
	         * The outline color of the polygons for the layer. Is used as the default if an outline color is not specified for
	         * a polygon.
	         * @deprecated Use `atlas.layer.LineLayer` to provide an outline for a polygon.
	         */
	        _this.outlineColor = "#000";
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-polygons";
	        return _this;
	    }
	    return PolygonLayerOptions;
	}(LayerOptions));

	var __extends$4 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for a raster layer.
	 * @deprecated Use TileLayerOptions with atlas.layer.TileLayer instead.
	 */
	var RasterLayerOptions = /** @class */ (function (_super) {
	    __extends$4(RasterLayerOptions, _super);
	    function RasterLayerOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The name of the layer.
	         */
	        _this.name = "default-raster";
	        return _this;
	    }
	    return RasterLayerOptions;
	}(LayerOptions));

	var __extends$3 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	/**
	 * The options for the map's lighting.
	 */
	var LightOptions = /** @class */ (function (_super) {
	    __extends$3(LightOptions, _super);
	    function LightOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * Specifies wether extruded geometries are lit relative to the map or viewport.
	         * Supported values:<br />
	         * `"map"`: The position of the light source is aligned to the rotation of the map.<br />
	         * `"viewport"`: The position fo the light source is aligned to the rotation of the viewport.<br />
	         * Default: `"map"`
	         * @default "map"
	         */
	        _this.anchor = "map";
	        /**
	         * Color tint for lighting extruded geometries.
	         * Default: `"#FFFFFF"`
	         * @default "#FFFFFF"
	         */
	        _this.color = "#FFFFFF";
	        /**
	         * Intensity of lighting (on a scale from 0 to 1).
	         * Higher numbers will present as more extreme contrast.
	         * Default `0.5`
	         * @default 0.5
	         */
	        _this.intensity = 0.5;
	        /**
	         * Position of the light source relative to lit (extruded) geometries,
	         * in [r radial coordinate, a azimuthal angle, p polar angle]
	         * where r indicates the distance from the center of the base of an object to its light,
	         * a indicates the position of the light relative to 0°
	         * (0° when `anchor` is set to viewport corresponds to the top of the viewport,
	         * or 0° when `anchor` is set to map corresponds to due north, and degrees proceed clockwise),
	         * and p indicates the height of the light (from 0°, directly above, to 180°, directly below).
	         */
	        _this.position = [1.15, 210, 30];
	        return _this;
	    }
	    return LightOptions;
	}(Options));

	var __extends$2 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __values$4 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$4 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$4 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/**
	 * The options for the map's style.
	 */
	var StyleOptions = /** @class */ (function (_super) {
	    __extends$2(StyleOptions, _super);
	    function StyleOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * If true, the gl context will be created with MSAA antialiasing, which can be useful for antialiasing WebGL layers.
	         */
	        _this.antialias = undefined;
	        /**
	         * If true the map will automatically resize whenever the window's size changes.
	         * Otherwise map.resize() must be called.
	         * Default `true`.
	         * @default true
	         */
	        _this.autoResize = true;
	        /**
	         * The language of the map labels.
	         * [Supported language]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages}.
	         * Default `atlas.getLanguage()`.
	         * @default atlas.getLanguage()
	         */
	        _this.language = getLanguage();
	        /**
	         * Sets the lighting options of the map.
	         */
	        _this.light = new LightOptions();
	        /**
	         * If true, the map's canvas can be exported to a PNG using map.getCanvas().toDataURL().
	         * This option may only be set when initializing the map.
	         * Default `false`
	         * @default false
	         */
	        _this.preserveDrawingBuffer = false;
	        /**
	         * If true, the map will try to defer non-essential map layers and show essential layers as early as possible.
	         * This option may only be set when initializing the map.
	         * Default `false`
	         * @default false
	         */
	        _this.progressiveLoading = false;
	        /**
	         * The list of layer groups to be loaded at the initial stage. Passing an empty array will disable the progressive loading.
	         * This option may only be set when initializing the map.
	         * Default `['base']`
	         * @default ['base']
	         */
	        _this.progressiveLoadingInitialLayerGroups = ['base'];
	        /**
	         * Specifies if multiple copies of the world should be rendered when zoomed out.
	         * Default `true`
	         * @default true
	         */
	        _this.renderWorldCopies = true;
	        /**
	         * Specifies if buildings will be rendered with their models.
	         * If false all buildings will be rendered as just their footprints.
	         * Default `false`
	         * @default false
	         * @deprecated
	         */
	        _this.showBuildingModels = false;
	        /**
	         * Specifies if the feedback link should be displayed on the map or not.
	         * Default `true`
	         * @default true
	         */
	        _this.showFeedbackLink = true;
	        /**
	         * Specifies if the Microsoft logo should be hidden or not.
	         * If set to true a Microsoft copyright string will be added to the map.
	         * Default `true`
	         * @default true
	         */
	        _this.showLogo = true;
	        /**
	         * Specifies if the map should display labels
	         * @default true
	         */
	        _this.showLabels = true;
	        /**
	         * Additional custom attribution appended to map attribution.
	         * Default `undefined`
	         * @default undefined
	         */
	        _this.customAttribution = undefined;
	        /**
	         * Specifies if the map should render an outline around each tile and the tile ID.
	         * These tile boundaries are useful for debugging.
	         * The uncompressed file size of the first vector source is drawn in the top left corner of each tile,
	         * next to the tile ID.
	         * Default `false`
	         * @default false
	         */
	        _this.showTileBoundaries = false;
	        /**
	         * The name of the style to use when rendering the map. Available styles can be found in the
	         * [supported styles]{@link https://docs.microsoft.com/en-us/azure/azure-maps/supported-map-styles} article.
	         * The default style is defined in the style set.
	         * @default undefined
	         */
	        _this.style = undefined;
	        /**
	         * Specifies which set of geopolitically disputed borders and labels are displayed on the map. The View parameter (also referred to as “user region parameter”) is a 2-letter ISO-3166 Country Code that will show the correct maps for that country/region. Country/Regions that are not on the View list or if unspecified will default to the “Unified” View.
	         * Please see the supported [Views]{@link https://aka.ms/AzureMapsLocalizationViews}
	         * It is your responsibility to determine the location of your users, and then set the View parameter correctly for that location. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the country/region where maps, images and other data and third party content that You are authorized to access via Azure Maps is made available.
	         * default: `undefined`
	         * @default undefined
	         */
	        _this.view = getView();
	        /**
	         * @deprecated use `view` instead.
	         */
	        _this.userRegion = _this.view;
	        /**
	         * allows substituting a default MapControl's style transformer with custom one
	         * Default style transformer is meant to update the incoming fetched style to desired state, as well as to synchronize the SDK state with style state
	         * and move additional layers over
	         * @internal
	         */
	        _this.customStyleTransform = undefined;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the view property names to the new view one.
	     * Also converts the specified language to a best fit supported one.
	     * @internal
	     */
	    StyleOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        try {
	            for (var valueList_1 = __values$4(valueList), valueList_1_1 = valueList_1.next(); !valueList_1_1.done; valueList_1_1 = valueList_1.next()) {
	                var value = valueList_1_1.value;
	                if (value) {
	                    // Make sure both view and userRegion properties exist. Prefer view's value.
	                    if (value.hasOwnProperty("view")) {
	                        value.userRegion = value.view;
	                    }
	                    else if (value.hasOwnProperty("userRegion")) {
	                        value.view = value.userRegion;
	                    }
	                    // Make sure the language is converted to the best fit supported one.
	                    if (typeof value.language === "string") {
	                        value.language = Localizer.getCode(value.language);
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valueList_1_1 && !valueList_1_1.done && (_a = valueList_1.return)) _a.call(valueList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // Then execute the standard merge behavior.
	        return _super.prototype.merge.apply(this, __spreadArray$4([], __read$4(valueList), false));
	    };
	    return StyleOptions;
	}(Options));

	var __extends$1 = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$2 = (window && window.__assign) || function () {
	    __assign$2 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2.apply(this, arguments);
	};
	var __values$3 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	var __read$3 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$3 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var composeTransformers = function (transformers) { return transformers.length == 0
	    ? undefined
	    : transformers.slice(1).reduce(function (chained, transform) {
	        return function (url, resourceType) {
	            var resourceParams = chained(url, resourceType);
	            return __assign$2(__assign$2({}, resourceParams), transform(resourceParams.url, resourceType));
	        };
	    }, transformers[0]); };
	/**
	 * Global properties used in all atlas service requests.
	 */
	var ServiceOptions = /** @class */ (function (_super) {
	    __extends$1(ServiceOptions, _super);
	    function ServiceOptions() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        /**
	         * The authentication options used to customize how the map control authenticates with Azure Maps services.
	         * If these authentication options are specified then ServiceOptions.subscriptionKey should not be.
	         * Recommend using the atlas.setAuthenticationOptions function instead.
	         */
	        _this.authOptions = getAuthenticationOptions();
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * default: false (true for the Azure Government cloud)
	         * @default false
	         */
	        _this.disableTelemetry = getDomain() === "atlas.azure.us";
	        /**
	         * Disable telemetry collection
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using disableTelemetry instead.
	         */
	        _this["disable-telemetry"] = _this.disableTelemetry;
	        /**
	         * The domain to use when requesting map tiles and other Azure Maps services.
	         * If the protocol is not specified `https` is assumed.
	         * Recommend using atlas.setDomain function instead.
	         * @default "atlas.microsoft.com"
	         */
	        _this.domain = getDomain();
	        /**
	         * The domain to use when requesting style data and other static assets.
	         */
	        _this.staticAssetsDomain = getStaticAssetsDomain();
	        /**
	         * The styleDefinitionsPath to use for getting the map styles.
	         * Recommend using atlas.setStyleDefinitionsPath function instead.
	         * @default atlas.getStyleDefinitionsPath()
	         * @internal
	         */
	        _this.styleDefinitionsPath = getStyleDefinitionsPath();
	        /**
	         * The style definitions version to request when requesting styles
	         * from styleDefinitionsPath.
	         */
	        _this.styleDefinitionsVersion = getStyleDefinitionsVersion();
	        /**
	         * The style API version used when requesting styles and stylesets
	         */
	        _this.styleAPIVersion = getStyleAPIVersion();
	        /**
	         * The map configuration defines the set of styles available to the map.
	         */
	        _this.mapConfiguration = undefined;
	        /**
	         * @deprecated use mapConfiguration instead
	         */
	        _this.styleSet = undefined;
	        /**
	         * Enable the accessibility feature to provide screen reader support for users who have difficulty visualizing the web application.
	         * This property is set to true by default.
	         * @default true
	         */
	        _this.enableAccessibility = true;
	        /**
	         * Enable accessibility
	         * @deprecated Recommend using enableAccessibility instead.
	         */
	        _this["enable-accessibility"] = _this.enableAccessibility;
	        /**
	         * Enable the fallback to the REST API geocoder for detecting location accessibility if extracting location from vector data fails.
	         * Disabling this option will prevent the generation of geocode API requests but may lead to a lack of location information for screen readers.
	         * default: true
	         * @default true
	         */
	        _this.enableAccessibilityLocationFallback = true;
	        /**
	         * Maximum number of images (raster tiles, sprites, icons) to load in parallel,
	         * which affects performance in raster-heavy maps. 16 by default.
	         */
	        _this.maxParallelImageRequests = getMaxParallelImageRequests();
	        /**
	         * A boolean that specifies if vector and raster tiles should be reloaded when they expire (based on expires header).
	         * This is useful for data sets that update frequently. When set to false, each tile will be loaded once, when needed, and not reloaded when they expire.
	         * default: true
	         * @default true
	         */
	        _this.refreshExpiredTiles = true;
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this.subscriptionKey = getSubscriptionKey();
	        /**
	         * The customer subscription key used to authorize requests.
	         * This option may only be set when initializing the map.
	         * @deprecated Recommend using the atlas.setSubscriptionKey function instead
	         */
	        _this["subscription-key"] = _this.subscriptionKey;
	        /**
	         * The session id to pass with requests.
	         * Recommend using atlas.setSessionId instead.
	         * @default Random UUID generated at runtime
	         */
	        _this.sessionId = getSessionId();
	        /**
	         * The session id to pass with requests.
	         * @deprecated Recommend using atlas.setSessionId instead.
	         */
	        _this["session-id"] = _this.sessionId;
	        _this._transformers = [];
	        /**
	         * If defined transformRequest will be called to provide custom request parameters for loading a tile.
	         */
	        _this.transformRequest = undefined;
	        /**
	         * Number of web workers instantiated on a page.
	         * By default, it is set to half the number of CPU cores (capped at 6).
	         */
	        _this.workerCount = getWorkerCount();
	        /**
	         * Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds.
	         * This setting affects all symbol layers.
	         * This setting does not affect the duration of runtime styling transitions or raster tile cross-fading.
	         * @default 300
	         */
	        _this.fadeDuration = 300;
	        /**
	         * Defines a CSS font-family for locally overriding generation of glyphs in the
	         * 'CJK Unified Ideographs', 'Hiragana', 'Katakana' and 'Hangul Syllables' ranges.
	         * In these ranges, font settings from the map's style will be ignored,
	         * except for font-weight keywords (light/regular/medium/bold). Set to false,
	         * to enable font settings from the map's style for these glyph ranges.
	         * The purpose of this option is to avoid bandwidth-intensive glyph server requests.
	         * @default 'sans-serif'
	         */
	        _this.localIdeographFontFamily = 'sans-serif';
	        /**
	         * True to validate styles before it's getting applied.
	         * Validation takes significant(few hundred ms) time to process styles during initial load.
	         * Can be set to false for production environment to improve performance.
	         * @internal
	         * @default 'false'
	         */
	        _this.validateStyle = false;
	        return _this;
	    }
	    /**
	     * Override the standard merge behavior to first reassign the old dash property names to the new camelCase ones.
	     * @internal
	     */
	    ServiceOptions.prototype.merge = function () {
	        var e_1, _a;
	        var valueList = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            valueList[_i] = arguments[_i];
	        }
	        var currentStyleDefinitionsVersion = this.styleDefinitionsVersion;
	        try {
	            // Make sure both camel and dash case properties exist. Prefer the camel case ones.
	            for (var valueList_1 = __values$3(valueList), valueList_1_1 = valueList_1.next(); !valueList_1_1.done; valueList_1_1 = valueList_1.next()) {
	                var value = valueList_1_1.value;
	                if (value) {
	                    // authOptions can also have a subscription key so check for that first.
	                    // If authOptions are specified then they should be preferred over the previous ServiceOptions.subscriptionKey.
	                    if (value.authOptions) {
	                        if (typeof value.authOptions.subscriptionKey === "string") {
	                            value.subscriptionKey = value["subscription-key"] =
	                                value.authOptions.subscriptionKey;
	                        }
	                    }
	                    else {
	                        if (typeof value.subscriptionKey === "string") {
	                            value["subscription-key"] = value.subscriptionKey;
	                            value.authOptions = {
	                                authType: exports.AuthenticationType.subscriptionKey,
	                                subscriptionKey: value.subscriptionKey,
	                            };
	                        }
	                        else if (typeof value["subscription-key"] === "string") {
	                            value.subscriptionKey = value["subscription-key"];
	                            value.authOptions = {
	                                authType: exports.AuthenticationType.subscriptionKey,
	                                subscriptionKey: value["subscription-key"],
	                            };
	                        }
	                    }
	                    if (typeof value.sessionId === "string") {
	                        value["session-id"] = value.sessionId;
	                    }
	                    else if (typeof value["session-id"] === "string") {
	                        value.sessionId = value["session-id"];
	                    }
	                    if (typeof value.disableTelemetry === "boolean") {
	                        value["disable-telemetry"] = value.disableTelemetry;
	                    }
	                    else if (typeof value["disable-telemetry"] === "boolean") {
	                        value.disableTelemetry = value["disable-telemetry"];
	                    }
	                    if (typeof value.enableAccessibility === "boolean") {
	                        value["enable-accessibility"] = value.enableAccessibility;
	                    }
	                    else if (typeof value["enable-accessibility"] === "boolean") {
	                        value.enableAccessibility = value["enable-accessibility"];
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (valueList_1_1 && !valueList_1_1.done && (_a = valueList_1.return)) _a.call(valueList_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	        // default merge behavior overrides _transformers
	        // won't change default behavior in Options as usually that's what desired
	        // instead capture it here and reassign.
	        var currentTransforms = this._transformers;
	        var transformersToMerge = valueList ? valueList.filter(function (value) { return value !== undefined; }).reduce(function (flattened, value) { return __spreadArray$3(__spreadArray$3([], __read$3(flattened), false), __read$3(value._transformers || []), false); }, []) : [];
	        // Then execute the standard merge behavior.
	        // If subscription key auth method isn't being used then the subscription key property should be undefined.
	        var merged = _super.prototype.merge.apply(this, __spreadArray$3([], __read$3(valueList), false));
	        if (merged.authOptions.authType !== exports.AuthenticationType.subscriptionKey) {
	            merged["subscription-key"] = merged.subscriptionKey = undefined;
	        }
	        // if mapConfiguration is not set and legacy styleSet option is used, assign it to mapConfiguration
	        if (merged.styleSet !== undefined && merged.mapConfiguration === undefined) {
	            merged.mapConfiguration = merged.styleSet;
	        }
	        // reassign properties from legacy mapConfiguration to new structure if needed
	        if (merged.mapConfiguration && typeof merged.mapConfiguration !== 'string') {
	            merged.mapConfiguration = __assign$2(__assign$2({}, merged.mapConfiguration), { defaultConfiguration: merged.mapConfiguration.defaultConfiguration || merged.mapConfiguration['defaultStyle'], configurations: merged.mapConfiguration.configurations || merged.mapConfiguration['styles'] });
	        }
	        this._transformers = __spreadArray$3(__spreadArray$3([], __read$3(currentTransforms || []), false), __read$3(transformersToMerge.filter(function (toMerge) { return !currentTransforms.includes(toMerge); })), false);
	        if (this.transformRequest && !this._transformers.includes(this.transformRequest)) {
	            this._transformers.push(this.transformRequest);
	        }
	        // NOTE: do not allow changing to a soon deprecated style-version, only version above-equal 2023-01-01 should be allowed
	        var minVersionComparator = new Date(Date.UTC(2023, 0));
	        var styleDefinitionVersionDate = new Date(this.styleDefinitionsVersion);
	        if (isNaN(styleDefinitionVersionDate.getTime()) || styleDefinitionVersionDate.getTime() < minVersionComparator.getTime()) {
	            console.warn("Style definition version ".concat(this.styleDefinitionsVersion, " is invalid or deprecated, style definition version is unchanged (").concat(currentStyleDefinitionsVersion, ")"));
	            this.styleDefinitionsVersion = currentStyleDefinitionsVersion;
	        }
	        // chain transformers in a middleware fashion
	        this.transformRequest = composeTransformers(this._transformers);
	        return merged;
	    };
	    /**
	     * Appends request transformer
	     */
	    ServiceOptions.prototype.addTransformer = function (transformer) {
	        if (!this._transformers) {
	            this._transformers = [];
	        }
	        this._transformers.push(transformer);
	        this.transformRequest = composeTransformers(this._transformers);
	    };
	    /**
	     * Removes request transformer
	     */
	    ServiceOptions.prototype.removeTransformer = function (transformer) {
	        if (!this._transformers) {
	            return;
	        }
	        this._transformers = this._transformers.filter(function (existing) { return transformer !== existing; });
	        this.transformRequest = composeTransformers(this._transformers);
	    };
	    /**
	     * Customizer for _.cloneDeep calls, allows objects to pass through with only a shallow cloning.
	     * Currently the only objects being cloned should be the `AuthenticationOptions`.
	     * @param value The value being cloned.
	     * @internal
	     */
	    ServiceOptions._cloneCustomizer = function (value) {
	        if (typeof value === "object") {
	            return Object.assign({}, value);
	        }
	    };
	    return ServiceOptions;
	}(Options));

	var LayerGroupComparator = /** @class */ (function () {
	    function LayerGroupComparator() {
	    }
	    /**
	     * Extract layer group name from layer id. This method assumes the layer group is
	     * the fourth token in a dotted string where the first token is "microsoft".
	     * @param layer Mapbox layer to extract layer group name from
	     * @returns layer group if present, undefined otherwise.
	     * @internal
	     */
	    LayerGroupComparator.getLayerGroup = function (layer) {
	        if (typeof layer !== 'string' && layer.metadata && layer.metadata['microsoft.maps:layerGroup']) {
	            return layer.metadata['microsoft.maps:layerGroup'];
	        }
	        var layerId = typeof layer !== 'string' ? layer.id : layer;
	        if (!layerId.startsWith("microsoft.")) {
	            return undefined;
	        }
	        var idTokens = layerId.split('.');
	        if (idTokens.length >= 4) {
	            return idTokens[3];
	        }
	        return undefined;
	    };
	    return LayerGroupComparator;
	}());

	var HijackablePromise = /** @class */ (function () {
	    function HijackablePromise(origin) {
	        var _this = this;
	        this.isHijacked = function () { return _this._hijackedToResolve !== undefined || _this._hijackedToReject !== undefined; };
	        this.isResolved = function () { return _this._hijackedToResolve !== undefined || _this._toResolve !== undefined; };
	        this.isRejected = function () { return _this._hijackedToReject !== undefined || _this._toReject !== undefined; };
	        this.resultIfResolved = function () { return _this._hijackedToResolve || _this._toResolve; };
	        this.errorIfRejected = function () { return _this._hijackedToReject || _this._toReject; };
	        this._thenResolver = function (resolve, reject) {
	            if (_this._hijackedToResolve) {
	                resolve(_this._hijackedToResolve);
	            }
	            else if (_this._hijackedToReject) {
	                reject(_this._hijackedToReject);
	            }
	            else {
	                // we retain the origin, and check if stays the same as resolved
	                var retainedInvocator_1 = _this.origin;
	                _this.origin.then(function (result) {
	                    if (_this.isHijacked()) {
	                        return;
	                    }
	                    // origin was switched during invocation, discard the result and follow the chain
	                    if (retainedInvocator_1 !== _this.origin) {
	                        _this._thenResolver(resolve, reject);
	                    }
	                    else {
	                        _this._toResolve = result;
	                        resolve(result);
	                    }
	                }).catch(function (error) {
	                    if (_this.isHijacked()) {
	                        return;
	                    }
	                    // origin was switched during invocation, discard the result and follow the chain
	                    if (retainedInvocator_1 !== _this.origin) {
	                        _this._thenResolver(resolve, reject);
	                    }
	                    else {
	                        _this._toReject = error;
	                        reject(error);
	                    }
	                });
	            }
	        };
	        this.origin = origin;
	        this[Symbol.toStringTag] = this.origin[Symbol.toStringTag];
	    }
	    HijackablePromise.resolve = function (value) {
	        return new HijackablePromise(Promise.resolve(value));
	    };
	    HijackablePromise.reject = function (error) {
	        return new HijackablePromise(Promise.reject(error));
	    };
	    HijackablePromise.prototype.then = function (onfulfilled, onrejected) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	            _this._thenResolver(resolve, reject);
	        }).then(onfulfilled, onrejected);
	    };
	    // tslint:disable-next-line: no-reserved-keywords
	    HijackablePromise.prototype.catch = function (onrejected) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	            _this._thenResolver(resolve, reject);
	        }).catch(onrejected);
	    };
	    // tslint:disable-next-line: no-reserved-keywords
	    HijackablePromise.prototype.finally = function (onfinally) {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this._resolve = resolve;
	            _this._reject = reject;
	            _this._thenResolver(resolve, reject);
	        }).finally(onfinally);
	    };
	    HijackablePromise.prototype.hijackAndResolve = function (value) {
	        this._hijackedToResolve = value;
	        if (this._resolve) {
	            this._resolve(value);
	        }
	    };
	    HijackablePromise.prototype.hijackAndReject = function (error) {
	        this._hijackedToReject = error;
	        if (this._reject) {
	            this._reject(error);
	        }
	    };
	    HijackablePromise.prototype.switchWith = function (promise) {
	        // switching the origin will discard the original in-progress promise result, as well any resolved non-hijacked state
	        this.origin = promise;
	        this._toResolve = undefined;
	        this._toReject = undefined;
	    };
	    return HijackablePromise;
	}());

	var styleNamesMap = {
	    road: "Road",
	    satellite: "Satellite",
	    satellite_road_labels: "Hybrid",
	    grayscale_dark: "Grayscale (Dark)",
	    grayscale_light: "Grayscale (Light)",
	    night: "Night",
	    road_shaded_relief: "Terra",
	    blank: "Blank",
	    blank_accessible: "Blank (Accessible)",
	    high_contrast_dark: "High contrast (Dark)",
	    high_contrast_light: "High contrast (Light)"
	};

	var __assign$1 = (window && window.__assign) || function () {
	    __assign$1 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1.apply(this, arguments);
	};
	var __awaiter$1 = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator$1 = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$2 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$2 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var __values$2 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * @private
	 */
	var StyleManager = /** @class */ (function () {
	    /**
	     * Constructs the style manager to be exposed only through the styles property of the Map class.
	     * @param map The map whose styles are being managed by this.
	     * @param serviceOptions Service options contain domain to use for requesting style resources.
	     * @internal
	     */
	    function StyleManager(map, serviceOptions) {
	        var _this = this;
	        this.definitions = function () {
	            var resultPromise;
	            if (_this.initPromise) {
	                resultPromise = _this.initPromise;
	            }
	            else {
	                resultPromise = _this.initStyleset();
	            }
	            return resultPromise;
	        };
	        /**
	         * Compatibility indoor state used in styleDefinition filtering.
	         * Legacy indoor module (2.0.6) will not set tilesetId
	         */
	        this.indoorState = undefined;
	        /**
	         * Preserve the map configuration that was used before the indoor map configuration was set
	         */
	        this.preservedPreindoorMapConfiguration = undefined;
	        /**
	         * The state of the progressive loading
	         */
	        this._progressiveLoadingState = {
	            mapStyle: undefined,
	            pendingVisibilityChange: undefined,
	        };
	        this._deferLayerGroupVisibilities = function (layerGroupLayers, initLayerGroups) {
	            var validInitLayerGroups = initLayerGroups.filter(function (groupName) { return groupName in layerGroupLayers; });
	            // If the initial layer groups are invalid, skip the progressive loading.
	            if (validInitLayerGroups.length === 0)
	                return;
	            var map = _this.map._getMap();
	            var currentZoomLevel = map.getZoom();
	            var currentMapStyle = _this.map.getStyle().style;
	            // Cancel and release previous pending callback, if any.
	            if (_this._progressiveLoadingState.pendingVisibilityChange) {
	                _this.map.events.remove('load', _this._progressiveLoadingState.pendingVisibilityChange);
	                _this._progressiveLoadingState.pendingVisibilityChange = null;
	            }
	            // Keep the current map style for future comparison.
	            _this._progressiveLoadingState.mapStyle = currentMapStyle;
	            // Select deferrable layers
	            var deferredLayers = Object.entries(layerGroupLayers).reduce(function (deferred, _a) {
	                var _b = __read$2(_a, 2), groupName = _b[0], layers = _b[1];
	                var isInInitialLayerGroup = validInitLayerGroups.includes(groupName);
	                return __spreadArray$2(__spreadArray$2([], __read$2(deferred), false), __read$2(layers.filter(function (layer) {
	                    var _a;
	                    // Exclude custom layers
	                    if (layer.type === 'custom')
	                        return false;
	                    // Exclude visible layers from initial layer groups
	                    if (isInInitialLayerGroup) {
	                        if (typeof layer.maxzoom === 'number' && typeof layer.minzoom === 'number') {
	                            if (currentZoomLevel <= layer.maxzoom && currentZoomLevel >= layer.minzoom)
	                                return false;
	                        }
	                        else if (typeof layer.minzoom === 'number') {
	                            if (currentZoomLevel >= layer.minzoom)
	                                return false;
	                        }
	                        else if (typeof layer.maxzoom === 'number') {
	                            if (currentZoomLevel <= layer.maxzoom)
	                                return false;
	                        }
	                        else {
	                            return false;
	                        }
	                    }
	                    // Select visible layers only.
	                    return ((_a = layer.layout) === null || _a === void 0 ? void 0 : _a.visibility) !== 'none';
	                })), false);
	            }, []);
	            // Hide the deferrable layers at initial load, therefore we can save the render time.
	            deferredLayers.forEach(function (layer) {
	                // Since this happens before sending style object into the map rendering,
	                // we only need to update the style object, but not necessary to update maplibre's layout properties.
	                layer.layout = layer.layout || {};
	                layer.layout.visibility = 'none';
	            });
	            // Make the deferred layers visible once the map instance is fully loaded.
	            _this._progressiveLoadingState.pendingVisibilityChange = function () {
	                var _a;
	                // Release the callback.
	                _this._progressiveLoadingState.pendingVisibilityChange = null;
	                // Bail out the callback once map style has changed.
	                var nextMapStyle = _this.map.getStyle().style;
	                if (currentMapStyle !== nextMapStyle)
	                    return;
	                // Make deferred layers visible
	                deferredLayers.forEach(function (layer) {
	                    // This happens after the map rendering; Therefore, we need to update
	                    // both the style object and the maplibre's layout properties.
	                    layer.layout.visibility = 'visible';
	                    map.setLayoutProperty(layer.id, 'visibility', 'visible');
	                });
	                // Reload attribution after the deferred layers are visible.
	                (_a = _this.map.copyrightDelegate) === null || _a === void 0 ? void 0 : _a.reloadAttribution();
	            };
	            _this.map.events.addOnce('load', _this._progressiveLoadingState.pendingVisibilityChange);
	        };
	        this._onStyleData = function (definition) {
	            _this.map.events.invoke("stylechanged", {
	                style: definition.name,
	                map: _this.map,
	                type: "stylechanged"
	            });
	        };
	        /**
	         * Looks up the style type info from the style definitions: this is async unsafe
	         */
	        this._lookUp = function (options) {
	            var e_1, _a;
	            var definitionsPromise = _this.definitions();
	            var definitionsFetchError = definitionsPromise.errorIfRejected();
	            var definitions = definitionsPromise.resultIfResolved();
	            if (definitionsFetchError) {
	                return null;
	            }
	            else if (!definitions) {
	                return null;
	            }
	            else {
	                var configrationsArray = definitions.configurations;
	                // retrieve default style definition unless option.style's one was found
	                var result = void 0;
	                try {
	                    for (var configrationsArray_1 = __values$2(configrationsArray), configrationsArray_1_1 = configrationsArray_1.next(); !configrationsArray_1_1.done; configrationsArray_1_1 = configrationsArray_1.next()) {
	                        var style = configrationsArray_1_1.value;
	                        if (style.name === options.style) {
	                            // this result is the highest priority, can immediately return
	                            return style;
	                        }
	                        if (style.name === definitions.defaultConfiguration && !result) {
	                            // backup result, so dont break here yet.
	                            // Later in the loop there might be another one matching options.style
	                            result = style;
	                        }
	                    }
	                }
	                catch (e_1_1) { e_1 = { error: e_1_1 }; }
	                finally {
	                    try {
	                        if (configrationsArray_1_1 && !configrationsArray_1_1.done && (_a = configrationsArray_1.return)) _a.call(configrationsArray_1);
	                    }
	                    finally { if (e_1) throw e_1.error; }
	                }
	                // no default style in the mapConfiguration, pick the first style
	                if (!result) {
	                    result = configrationsArray[0];
	                }
	                return result;
	            }
	        };
	        this._lookUpAsync = function (options) { return __awaiter$1(_this, void 0, void 0, function () {
	            var definitions, result;
	            return __generator$1(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.definitions()];
	                    case 1:
	                        definitions = _a.sent();
	                        result = definitions.configurations.find(function (style) { return style.name === (options.style || definitions.defaultConfiguration); })
	                            // retrieve default style definition unless option.style's one was found
	                            || definitions.configurations.find(function (style) { return style.name === definitions.defaultConfiguration; })
	                            // no default style in the mapConfiguration -> pick the first style
	                            || definitions.configurations[0];
	                        return [2 /*return*/, result];
	                }
	            });
	        }); };
	        this.map = map;
	        this.serviceOptions = serviceOptions;
	    }
	    StyleManager.prototype.updateIndoorState = function (theme, tilesetId) {
	        var _this = this;
	        var _a;
	        var mapConfiguration = this.map.styles.getMapConfiguration();
	        if (mapConfiguration) {
	            this.preservedPreindoorMapConfiguration = mapConfiguration;
	            // tilesetId fallback
	            // MAGIC: if we are on a default style set - match existing style to the one in the default indoor style set
	            var desiredIndoorStyle = this.map.getStyle().style ? "".concat(this.map.getStyle().style, "_indoor").concat(theme === 'dark' ? '_dark' : '', "_tileset_").concat(tilesetId) : undefined;
	            this.map.styles.setMapConfiguration("defaultIndoor_".concat(tilesetId), mapConfiguration === 'microsoft-maps:default' ? desiredIndoorStyle : undefined);
	        }
	        else {
	            var didTilesetIdChange_1 = ((_a = this.indoorState) === null || _a === void 0 ? void 0 : _a.tilesetId) !== tilesetId;
	            this.indoorState = {
	                tilesetId: tilesetId,
	                theme: theme
	            };
	            this.initStyleset();
	            this.definitions().then(function (definitions) {
	                var currentStyle = (_this.map.getStyle().style || definitions.defaultConfiguration)
	                    .replace('_indoor_dark', '')
	                    .replace('_indoor', '');
	                // we cannot compose the precise style name for auto theme, search for prefix style name match
	                var targetStylePrefix = "".concat(currentStyle, "_indoor");
	                var candidateStyle = definitions.configurations.find(function (style) { return style.name.startsWith(targetStylePrefix); });
	                if (candidateStyle) {
	                    // force style reload if tileset id has changed to make sure the tiles will be re-requested with new tileset applied in indoor source placeholder
	                    _this.map.setStyle({ style: candidateStyle.name }, !didTilesetIdChange_1);
	                }
	            });
	        }
	    };
	    StyleManager.prototype.unsetIndoorState = function () {
	        var _this = this;
	        var mapConfiguration = this.preservedPreindoorMapConfiguration;
	        if (mapConfiguration) {
	            // we need to revert to the styleset that was ap
	            this.map.styles.setMapConfiguration(mapConfiguration);
	        }
	        else {
	            this.indoorState = undefined;
	            this.initStyleset();
	            this.definitions().then(function (definitions) {
	                var currentStyle = _this.map.getStyle().style;
	                if (currentStyle.includes('_indoor') && currentStyle.split('_indoor')[0]) {
	                    _this.map.setStyle({ style: currentStyle.split('_indoor')[0] });
	                }
	                else {
	                    _this.map.setStyle({ style: undefined });
	                }
	            });
	        }
	    };
	    /**
	     * If this method has been called before then the original promise is returned.
	     * Promise is resolved once the style set is successfully fetched and stored.
	     */
	    StyleManager.prototype.initStyleset = function () {
	        var _this = this;
	        var newPromise;
	        var mapStyleNameToFriendyWhenAvailable = function (styleName) {
	            var baseName = _this.indoorState && styleName.includes('_indoor') ? styleName.split('_indoor')[0] : styleName;
	            return baseName in styleNamesMap ? styleNamesMap[baseName] : baseName;
	        };
	        if (!this.serviceOptions.mapConfiguration) {
	            var ensureAuthentication = this.map.authentication ? this.map.authentication.initialize() : Promise.resolve();
	            newPromise = new HijackablePromise(ensureAuthentication.then(function () { return _this._request(_this.serviceOptions.staticAssetsDomain, "".concat(constants.stylePath, "/").concat(constants.styleResourcePath), "StyleDefinitions", {
	                version: _this.serviceOptions.styleDefinitionsVersion,
	                // add MapControlVersion to make sure we have different local cache between map control versions
	                mcv: version.replace(/\./g, ''),
	            }).then(function (definitions) { return ({
	                version: isNaN(definitions.version) ? 0 : parseFloat(definitions.version),
	                defaultConfiguration: definitions.defaultStyle,
	                configurations: definitions.styles
	                    .filter(function (style) {
	                    if (!_this.indoorState) {
	                        return !style.name.includes('indoor');
	                        // NOTE: azure-maps-indoor prior to 2.0.7 will not pass theme auto
	                        // the IndoorModule will request getTheme() from StyleManager and will call StyleManager.setStyleSet(theme == 'dark ? 'indoor_dark' : 'indoor') as approperaite
	                    }
	                    else if (_this.indoorState.theme === 'auto') {
	                        return style.name.endsWith(style.theme === 'dark' ? '_indoor_dark' : '_indoor');
	                    }
	                    else {
	                        return style.name.endsWith(_this.indoorState.theme === 'dark' ? '_indoor_dark' : '_indoor');
	                    }
	                })
	                    .map(function (style) { return ({
	                    copyright: style.copyright.join(' '),
	                    name: style.name,
	                    displayName: mapStyleNameToFriendyWhenAvailable(style.name),
	                    theme: style.theme,
	                    thumbnail: new Url({ domain: _this.serviceOptions.staticAssetsDomain, path: style.thumbnail, protocol: "https" }).toString(),
	                    url: new Url({
	                        domain: _this.serviceOptions.staticAssetsDomain,
	                        path: "".concat(constants.stylePath, "/").concat(constants.styleResourcePath, "/").concat(style.name),
	                        queryParams: {
	                            // Use the style version from the API response if it's available,
	                            // otherwise fallback to the version specified in the serviceOptions.
	                            // This is needed for flight testing the 2023-01-01 style version.
	                            styleVersion: definitions.version !== undefined && definitions.version !== null
	                                ? definitions.version
	                                : _this.serviceOptions.styleDefinitionsVersion,
	                            // thus far we don't need to differentiate based on parameter here, as stylePatch will be called on cached styles as well
	                            //language: styleOptions.language
	                            // add MapControlVersion to make sure we have different local cache between map control versions
	                            mcv: version.replace(/\./g, '')
	                        },
	                        protocol: "https"
	                    }).toString(),
	                }); })
	            }); }); }));
	        }
	        else if (typeof this.serviceOptions.mapConfiguration === 'string') {
	            var ensureAuthentication = this.map.authentication ? this.map.authentication.initialize() : Promise.resolve();
	            newPromise = new HijackablePromise(ensureAuthentication.then(function () { return _this._request(_this.serviceOptions.domain, "".concat(constants.styleResourcePath, "/mapconfigurations/metadata/").concat(_this.serviceOptions.mapConfiguration), "StyleDefinitions"
	            // reassign properties from legacy mapConfiguration to new structure if needed
	            ).then(function (definitions) { return (__assign$1(__assign$1({}, definitions), { defaultConfiguration: definitions.defaultConfiguration || definitions['defaultStyle'], configurations: definitions.configurations || definitions['styles'] })); }); }));
	        }
	        else {
	            newPromise = HijackablePromise.resolve(this.serviceOptions.mapConfiguration);
	        }
	        if (this.initPromise) {
	            this.initPromise.switchWith(newPromise);
	            this.initPromise = newPromise;
	        }
	        else {
	            this.initPromise = newPromise;
	        }
	        // propagate styleset change
	        this.initPromise.then(function (styleset) { return _this.map._invokeEvent("mapconfigurationchanged", styleset); });
	        return this.initPromise;
	    };
	    /**
	     * Gets URL or object of the style listed in style definition. Style definition's default style is used if
	     * styleOptions.style is not provided or if styleOptions.style is not present in the style definition.
	     */
	    StyleManager.prototype.getStyle = function (styleOptions) {
	        var styleDefinition = this._lookUp(styleOptions);
	        if (!styleDefinition) {
	            throw Error("Style definition is not available.");
	        }
	        if (styleDefinition.url) {
	            return styleDefinition.url;
	        }
	        if (styleDefinition.style) {
	            return styleDefinition.style;
	        }
	        throw Error("Style definition neither contains URL nor style object.");
	    };
	    StyleManager.prototype.deriveNewStyleAndLayerGroups = function (previousStyle, nextStyle) {
	        var _a, _b, _c, _d, _e, _f;
	        // Layers in the next style with default properties that do not align with current StyleOptions
	        // should be modified before they are applied to the map.
	        var styleOptions = this.map.getStyle();
	        var trafficOptions = this.map.getTraffic();
	        var layersGroups = {};
	        for (var i = 0; i < nextStyle.layers.length; i++) {
	            var nextLayer = nextStyle.layers[i];
	            var layerGroup = LayerGroupComparator.getLayerGroup(nextLayer);
	            if (!layerGroup) {
	                layersGroups[nextLayer.id] = [nextLayer];
	                continue;
	            }
	            if (!layersGroups[layerGroup]) {
	                layersGroups[layerGroup] = [];
	            }
	            var layerGroupLayers = layersGroups[layerGroup];
	            layerGroupLayers.push(nextLayer);
	            // 1. Set visiblity of fill-extrusion layers according to StyleOptions.showBuildingModels
	            if (!styleOptions.showBuildingModels && nextLayer.type === "fill-extrusion") {
	                nextLayer.layout = (_a = nextLayer.layout) !== null && _a !== void 0 ? _a : {};
	                nextLayer.layout.visibility = "none";
	            }
	            else if (nextLayer.type === "fill-extrusion") {
	                nextLayer.layout = (_b = nextLayer.layout) !== null && _b !== void 0 ? _b : {};
	                nextLayer.layout.visibility = "visible";
	            }
	            // 2. Set visibility of traffic layers depending on traffic settings.
	            if (trafficOptions.flow !== "none" && layerGroup) {
	                if (layerGroup === "traffic_".concat(trafficOptions.flow) && nextLayer.type == "line") {
	                    nextLayer.layout = (_c = nextLayer.layout) !== null && _c !== void 0 ? _c : {};
	                    nextLayer.layout.visibility = "visible";
	                }
	            }
	            // 3. Set visibility of labels
	            var isLabelLayerGroup = layerGroup === 'labels' || layerGroup === 'labels_places' || layerGroup === 'labels_indoor';
	            if (isLabelLayerGroup && nextLayer.type === 'symbol') {
	                if (styleOptions.showLabels && ((_d = nextLayer.layout) === null || _d === void 0 ? void 0 : _d.visibility) !== "none") {
	                    nextLayer.layout = (_e = nextLayer.layout) !== null && _e !== void 0 ? _e : {};
	                    nextLayer.layout.visibility = "visible";
	                }
	                else {
	                    nextLayer.layout = (_f = nextLayer.layout) !== null && _f !== void 0 ? _f : {};
	                    nextLayer.layout.visibility = "none";
	                }
	            }
	        }
	        return [nextStyle, layersGroups];
	    };
	    StyleManager.prototype.injectUserLayersIntoStyle = function (previousStyle, nextStyle, layerGroupLayers) {
	        // Custom layers added to mapbox through this SDK should be carried over to the next style.
	        return !previousStyle
	            ? nextStyle
	            : this.map.layers._getUserLayers().reduce(function (style, userLayer) {
	                var _a, _b;
	                if (userLayer.layer instanceof WebGLLayer) {
	                    // mapbox custom layers cannot be serialized and preserved,
	                    // return to continue to the next user layer.
	                    return style;
	                }
	                var beforeLayerId = ((_b = (_a = layerGroupLayers === null || layerGroupLayers === void 0 ? void 0 : layerGroupLayers[userLayer.before]) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.id) || userLayer.before;
	                var layer = previousStyle.layers.find(function (layer) { return layer.id === userLayer.layer.getId(); });
	                // when setStyle diff attempt is unsuccesful, _load will be called on the style that may have already injected user layers -> clean it up
	                var existingLayerIdx = nextStyle.layers.findIndex(function (layer) { return layer.id === userLayer.layer.getId(); });
	                if (existingLayerIdx > -1) {
	                    nextStyle.layers.splice(existingLayerIdx, 1);
	                }
	                if (layer) {
	                    var sourcesToCopy = new Set(Array.from(userLayer.layer._getSourceIds())
	                        .map(function (sourceId) {
	                        // If source is already present in the target style, skip copy
	                        if (style.sources[sourceId]) {
	                            return undefined;
	                        }
	                        var source = previousStyle.sources[sourceId];
	                        return source ? { source: source, id: sourceId } : undefined;
	                    })
	                        .filter(function (source) { return source !== undefined; }));
	                    var insertIdx = beforeLayerId ? style.layers.findIndex(function (layer) { return layer.id === beforeLayerId; }) : -1;
	                    if (insertIdx > -1) {
	                        style.layers.splice(insertIdx, 0, layer);
	                    }
	                    else {
	                        style.layers.push(layer);
	                    }
	                    sourcesToCopy.forEach(function (_a) {
	                        var source = _a.source, id = _a.id;
	                        style.sources[id] = source;
	                    });
	                }
	                return style;
	            }, __assign$1({}, nextStyle));
	    };
	    /**
	     * @internal
	     */
	    StyleManager.prototype.setStyle = function (styleOptions, diff) {
	        var _this = this;
	        if (diff === void 0) { diff = true; }
	        var transformStyleFunc;
	        var targetDefinition = this._lookUp(styleOptions);
	        if (!targetDefinition) {
	            throw Error("Style definition ".concat(styleOptions.style, " is not available."));
	        }
	        if (!targetDefinition.url && !targetDefinition.style) {
	            throw Error("Style definition neither contains URL nor style object.");
	        }
	        var styleDataCallback = function () { return _this._onStyleData(targetDefinition); };
	        var patchStyleEvent = function () {
	            // FIXME: below diffing will be soon fixed on the maplibre side
	            // If there was a previous styledata change event attached, remove it.
	            // When the sprite url changes between style changes then maplibre can't perform the diff
	            // In such cases it recalculate the style again. Removing previous attached
	            // event listener makes sure that style changed event is not fired twice in these cases.
	            _this.map.events.remove("styledata", styleDataCallback);
	            _this.map.events.addOnce("styledata", styleDataCallback);
	        };
	        if (styleOptions && styleOptions.customStyleTransform) {
	            transformStyleFunc = function (prev, next) {
	                var target = styleOptions.customStyleTransform(prev, next);
	                patchStyleEvent();
	                return target;
	            };
	        }
	        else {
	            transformStyleFunc = function (previousStyle, style) {
	                // make sure we always have a shallow clone to prevent mutating explicit json(rather then url) styles being set
	                var nextStyle = __assign$1(__assign$1({}, style), { layers: __spreadArray$2([], __read$2(style.layers), false), sources: __assign$1({}, style.sources) });
	                var shouldProgressiveLoading = (styleOptions.progressiveLoading &&
	                    // The feature only effective at the initial load.
	                    !_this.map._isLoaded());
	                // Shallow-clone the style object and duplicate layer.layout properties to avoid side-effects.
	                if (shouldProgressiveLoading && Array.isArray(style === null || style === void 0 ? void 0 : style.layers)) {
	                    nextStyle = __assign$1({}, style);
	                    nextStyle.layers = nextStyle.layers.map(function (layer) {
	                        var nextLayer = __assign$1({}, layer);
	                        if (layer.layout) {
	                            nextLayer.layout = __assign$1({}, layer.layout);
	                        }
	                        return nextLayer;
	                    });
	                }
	                // 1. derive the base new style (without user layers) and layer groups
	                var _a = __read$2(_this.deriveNewStyleAndLayerGroups(previousStyle, nextStyle), 2), targetStyle = _a[0], layerGroupLayers = _a[1];
	                // 2. side effect: progressively render map layers to the canvas to shorten the time to the first meaningful render.
	                if (shouldProgressiveLoading) {
	                    var initLayerGroups = styleOptions.progressiveLoadingInitialLayerGroups;
	                    if (Array.isArray(initLayerGroups) && initLayerGroups.length > 0) {
	                        _this._deferLayerGroupVisibilities(layerGroupLayers, initLayerGroups);
	                    }
	                }
	                // 3. copy user layers and sources from previous style into new one
	                var targetStyleWithUserLayers = _this.injectUserLayersIntoStyle(previousStyle, targetStyle, layerGroupLayers);
	                // 4. side effects: sync our control's LayerManager and SourceManager
	                var nextFundamentalLayers = Object.entries(layerGroupLayers).map(function (_a) {
	                    var _b = __read$2(_a, 2), layerGroupId = _b[0], layers = _b[1];
	                    return _this._buildFundamentalLayerFrom(layers, layerGroupId);
	                });
	                var layerIndex = _this.map.layers._getUserLayers().reduce(function (layerIndex, userLayer) {
	                    var layerInsertIndex = userLayer.before ? layerIndex.findIndex(function (layer) { return layer.getId() === userLayer.before; }) : -1;
	                    if (layerInsertIndex > -1) {
	                        layerIndex.splice(layerInsertIndex, 0, userLayer.layer);
	                    }
	                    else {
	                        layerIndex.push(userLayer.layer);
	                    }
	                    return layerIndex;
	                }, nextFundamentalLayers);
	                _this.map.layers['layerIndex'] = layerIndex;
	                _this.map.sources._syncSources(targetStyleWithUserLayers.sources);
	                // 5. temporarily patch style data event
	                patchStyleEvent();
	                return targetStyleWithUserLayers;
	            };
	        }
	        this.map._getMap().setStyle(targetDefinition.url || targetDefinition.style, {
	            diff: diff,
	            validate: this.serviceOptions.validateStyle,
	            transformStyle: transformStyleFunc
	        });
	    };
	    /**
	     * Gets the color theme (light/dark) for the style type specified by the style options.
	     */
	    StyleManager.prototype.getTheme = function (styleOptions) {
	        var style = this._lookUp(styleOptions);
	        if (!style) {
	            return undefined;
	        }
	        return style.theme.toLowerCase();
	    };
	    StyleManager.prototype.getThemeAsync = function (styleOptions) {
	        return __awaiter$1(this, void 0, void 0, function () {
	            return __generator$1(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this._lookUpAsync(styleOptions)];
	                    case 1: return [2 /*return*/, (_a.sent()).theme];
	                }
	            });
	        });
	    };
	    /**
	     * Replaces the style set used. Very costly as it reloads all controls and resources.
	     */
	    StyleManager.prototype.setMapConfiguration = function (mapConfiguration, styleName) {
	        var _this = this;
	        this.serviceOptions.mapConfiguration = mapConfiguration;
	        if (typeof mapConfiguration === 'string') {
	            this.initStyleset();
	        }
	        else {
	            if (this.initPromise) {
	                this.initPromise.hijackAndResolve(mapConfiguration);
	            }
	            else {
	                this.initPromise = HijackablePromise.resolve(mapConfiguration);
	            }
	        }
	        this.definitions().then(function (definitions) {
	            var targetStyleName = definitions.defaultConfiguration;
	            if (definitions.configurations.find(function (s) { return s.name === styleName; })) {
	                targetStyleName = styleName;
	            }
	            _this.map.setStyle({ style: targetStyleName });
	        });
	    };
	    StyleManager.prototype.getMapConfiguration = function () {
	        return this.serviceOptions.mapConfiguration;
	    };
	    // backward-compatibility: this method preserves the interface that azure-maps-indoor@2.0.6 assumes
	    StyleManager.prototype.setStyleSet = function (styleSet) {
	        this.updateIndoorState(styleSet === 'indoor_dark' ? 'dark' : 'light', null);
	    };
	    // backward-compatibility: this method preserves the interface that azure-maps-indoor@2.0.6 assumes
	    StyleManager.prototype.getStyleSet = function () {
	        var legacyStyleset = this.indoorState !== undefined
	            ? (this.indoorState.theme === 'dark' ? 'indoor_dark' : 'indoor')
	            : 'base';
	        return legacyStyleset;
	    };
	    // backward-compatibility: this method preserves the interface that azure-maps-indoor@2.0.6 assumes
	    StyleManager.prototype.clearStyleSet = function () {
	        this.unsetIndoorState();
	    };
	    StyleManager.prototype._buildFundamentalLayerFrom = function (layers, id) {
	        if (layers && layers.length > 0) {
	            var newLayer = new FundamentalMapLayer(layers, id);
	            newLayer.onAdd(this.map);
	            return newLayer;
	        }
	        throw new Error("Unable to construct fundamental map layer for ID: ".concat(id, "."));
	    };
	    /**
	     * Replace URL placeholders and add StyleManager API version to requests made for style resources.
	     * @param params RequestParameters to modify.
	     * @returns Valid style RequestParameters.
	     * @internal
	     */
	    StyleManager.prototype._transformStyleRequest = function (url, params) {
	        var _a;
	        if (url.includes(constants.domainPlaceHolder)) {
	            params.url = params.url.replace(constants.domainPlaceHolder, this.serviceOptions.domain);
	        }
	        if (url.includes(constants.stylePathHolder)) {
	            params.url = params.url.replace(constants.stylePathHolder, constants.stylePath);
	        }
	        if (url.includes(constants.styleResourcePlaceholder)) {
	            params.url = params.url.replace(constants.styleResourcePlaceholder, constants.styleResourcePath);
	        }
	        if (params.url.toLocaleLowerCase().includes(this.serviceOptions.domain.toLocaleLowerCase()) ||
	            params.url.toLocaleLowerCase().includes(this.serviceOptions.staticAssetsDomain.toLocaleLowerCase())) {
	            // Only add API version param for Azure maps domain requests
	            var targetUrl = new URL(params.url);
	            if (!targetUrl.searchParams.get(constants.apiVersionQueryParameter)) {
	                targetUrl.searchParams.set(constants.apiVersionQueryParameter, this.serviceOptions.styleAPIVersion);
	                params.url = targetUrl.href;
	            }
	            (_a = this.map.authentication) === null || _a === void 0 ? void 0 : _a.signRequest(params);
	            // Delete auth token for static assets to allow AFD caching
	            this._deleteAuthTokenForStaticAssets(params);
	        }
	    };
	    /**
	     * Fetches a json resource at the specified domain and path.
	     */
	    StyleManager.prototype._request = function (domain, path, resourceType, customQueryParams) {
	        var _a;
	        if (customQueryParams === void 0) { customQueryParams = {}; }
	        return __awaiter$1(this, void 0, void 0, function () {
	            var requestParams, fetchOptions;
	            var _b;
	            return __generator$1(this, function (_c) {
	                switch (_c.label) {
	                    case 0:
	                        requestParams = {
	                            url: new Url({
	                                protocol: "https",
	                                domain: domain,
	                                path: path,
	                                queryParams: __assign$1((_b = {}, _b[constants.apiVersionQueryParameter] = this.serviceOptions.styleAPIVersion, _b), customQueryParams)
	                            }).toString()
	                        };
	                        if (typeof this.serviceOptions.transformRequest === "function" && resourceType) {
	                            // If a transformRequest(...) was specified use it.
	                            requestParams = this.serviceOptions.transformRequest(requestParams.url, resourceType);
	                        }
	                        (_a = this.map.authentication) === null || _a === void 0 ? void 0 : _a.signRequest(requestParams);
	                        // Delete auth token for static assets to allow AFD caching
	                        this._deleteAuthTokenForStaticAssets(requestParams);
	                        fetchOptions = {
	                            method: "GET",
	                            mode: "cors",
	                        };
	                        requestParams.credentials &&
	                            (fetchOptions.credentials = requestParams.credentials);
	                        requestParams.headers &&
	                            (fetchOptions.headers = requestParams.headers);
	                        return [4 /*yield*/, fetch(requestParams.url, fetchOptions).then(function (response) {
	                                if (response.ok) {
	                                    return response.json();
	                                }
	                                else {
	                                    throw new Error("HTTP ".concat(response.status, ": ").concat(response.statusText, " "));
	                                }
	                            })];
	                    case 1: return [2 /*return*/, _c.sent()];
	                }
	            });
	        });
	    };
	    /**
	     * Delete auth token for static assets to allow AFD caching.
	     */
	    StyleManager.prototype._deleteAuthTokenForStaticAssets = function (params) {
	        // The following resources are considered as static assets.
	        // StyleSet    /styling/styles
	        // Style       /styling/styles/*
	        // Thumbnail   /styling/styles/*/thumbnail.png
	        // Sprite PNG  /styling/sprites/*/sprite@2x.png
	        // Sprite JSON /styling/sprites/*/sprite@2x.json
	        // Glyph       /styling/glyphs/*/0-255.pbf
	        if (params.url.startsWith("https://".concat(this.serviceOptions.staticAssetsDomain, "/").concat(constants.stylePath))) {
	            delete params.headers[constants.msClientIdHeaderName];
	            delete params.headers[constants.authorizationHeaderName];
	        }
	    };
	    return StyleManager;
	}());

	/**
	 * @private
	 */
	var isHMREnabled = function () { return 'ENVIRONMENT' in window && !!window['ENVIRONMENT']['hmr']; };

	var __values$1 = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * @internal
	 * A manager for the map control's hidden indicators.
	 * Exposed through the `indicators` property of the `atlas.Map` class.
	 * Cannot be instantiated by the user.
	 */
	var AccessibleIndicatorManager = /** @class */ (function () {
	    /**
	     * Constructs the indicator manager to be exposed only through the `indicators` property of the `Map` class.
	     * @param map The map whose indicators are being managed by this.
	     * @internal
	     */
	    function AccessibleIndicatorManager(map) {
	        this.map = map;
	        this.indicators = new Set();
	    }
	    /**
	     * Adds an indicator to the map
	     * @param indicator The indicator(s) to add.
	     */
	    AccessibleIndicatorManager.prototype.add = function (indicator) {
	        var e_1, _a;
	        indicator = Array.isArray(indicator) ? indicator : [indicator];
	        try {
	            for (var indicator_1 = __values$1(indicator), indicator_1_1 = indicator_1.next(); !indicator_1_1.done; indicator_1_1 = indicator_1.next()) {
	                var i = indicator_1_1.value;
	                if (!this.indicators.has(i)) {
	                    this.indicators.add(i);
	                    i.attach(this.map);
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (indicator_1_1 && !indicator_1_1.done && (_a = indicator_1.return)) _a.call(indicator_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * Removes all indicators from the map.
	     */
	    AccessibleIndicatorManager.prototype.clear = function () {
	        var _this = this;
	        this.indicators.forEach(function (indicator) {
	            _this.indicators.delete(indicator);
	            indicator.remove();
	        });
	    };
	    /**
	     * Removes an indicator from the map
	     * @param indicator The indicator(s) to remove.
	     */
	    AccessibleIndicatorManager.prototype.remove = function (indicator) {
	        var e_2, _a;
	        indicator = Array.isArray(indicator) ? indicator : [indicator];
	        try {
	            for (var indicator_2 = __values$1(indicator), indicator_2_1 = indicator_2.next(); !indicator_2_1.done; indicator_2_1 = indicator_2.next()) {
	                var i = indicator_2_1.value;
	                if (this.indicators.has(i)) {
	                    this.indicators.delete(i);
	                    i.remove();
	                }
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (indicator_2_1 && !indicator_2_1.done && (_a = indicator_2.return)) _a.call(indicator_2);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	    };
	    /**
	     * Returns the indicators currently attached to the map.
	     */
	    AccessibleIndicatorManager.prototype.getIndicators = function () {
	        return Array.from(this.indicators);
	    };
	    /**
	     * Returns the div element that should contain all the indicator containers.
	     * Creates it if it doesn't already exist.
	     * @internal
	     */
	    AccessibleIndicatorManager.prototype._getCollectionDiv = function () {
	        var collection = this.map.getMapContainer()
	            .querySelector(".".concat(AccessibleIndicatorManager.Css.collection));
	        if (!collection) {
	            // If the collection div doesn't exist create it.
	            collection = document.createElement("div");
	            collection.setAttribute("aria-label", "map data");
	            // Set the container role to listbox, and the descents' role to option, so the reader will read the listbox as a list.
	            // For example, NVDA will read "data point, 1 of 1" when the indicator is focused.
	            collection.setAttribute("role", "listbox");
	            collection.classList.add(AccessibleIndicatorManager.Css.collection);
	            this.map.getMapContainer().appendChild(collection);
	        }
	        return collection;
	    };
	    AccessibleIndicatorManager.Css = {
	        collection: "accessible-indicator-collection-container"
	    };
	    return AccessibleIndicatorManager;
	}());

	var __extends = (window && window.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        if (typeof b !== "function" && b !== null)
	            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (window && window.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __awaiter = (window && window.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (window && window.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (g && (g = 0, op[0] && (_ = 0)), _) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __read$1 = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray$1 = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	var __values = (window && window.__values) || function(o) {
	    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
	    if (m) return m.call(o);
	    if (o && typeof o.length === "number") return {
	        next: function () {
	            if (o && i >= o.length) o = void 0;
	            return { value: o && o[i++], done: !o };
	        }
	    };
	    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
	};
	/**
	 * The control for a visual and interactive web map.
	 */
	var Map$1 = /** @class */ (function (_super) {
	    __extends(Map, _super);
	    /**
	     * Displays a map in the specified container.
	     * @param container The id of the element where the map should be displayed.
	     * @param options Options for the initial display and interactability with the map.
	     */
	    function Map(container, options) {
	        var _this = _super.call(this) || this;
	        // Map state trackers
	        _this.removed = false;
	        _this.loaded = false;
	        _this.ready = false;
	        /**
	         * The callback used when styleOptions.autoResize is true.
	         */
	        _this._resizeCallback = function () { return _this.resize(); };
	        // Update global defaults based on which options were specified to this constructor.
	        _this._updateGlobalDefaults(options);
	        _this.serviceOptions = new ServiceOptions().merge(options);
	        _this.styleOptions = new StyleOptions().merge(options);
	        _this.trafficOptions = new TrafficOptions();
	        _this.styles = new StyleManager(_this, _this.serviceOptions);
	        if (_this.serviceOptions.authOptions.subscriptionKey) {
	            _this.serviceOptions.authOptions.subscriptionKey = encodeURIComponent(_this.serviceOptions.authOptions.subscriptionKey);
	        }
	        // If a client id is available use that for telemetry, fallback to subscription key if necessary.
	        // Only keep the last 3 characters of the subscription key.
	        var accountId;
	        if (_this.serviceOptions.authOptions.clientId) {
	            accountId = _this.serviceOptions.authOptions.clientId;
	        }
	        else if (_this.serviceOptions.authOptions.subscriptionKey) {
	            accountId = _this.serviceOptions.authOptions.subscriptionKey.replace(/.(?=.{3,}$)/g, "*");
	        }
	        else {
	            accountId = "invalid-setting";
	        }
	        if (_this.insights) {
	            _this.insights.setAuthenticatedUserContext(_this.serviceOptions.sessionId, accountId);
	        }
	        var mapboxMap;
	        if (arguments[2] && isHMREnabled()) {
	            mapboxMap = arguments[2];
	            _this.ready = true;
	            _this.loaded = true;
	        }
	        else {
	            var mapboxMapOptions = {
	                antialias: _this.styleOptions.antialias,
	                attributionControl: false,
	                container: container,
	                fadeDuration: _this.serviceOptions.fadeDuration,
	                localIdeographFontFamily: _this.serviceOptions.localIdeographFontFamily,
	                preserveDrawingBuffer: _this.styleOptions.preserveDrawingBuffer,
	                refreshExpiredTiles: _this.serviceOptions.refreshExpiredTiles,
	                renderWorldCopies: _this.styleOptions.renderWorldCopies,
	                trackResize: false,
	                transformRequest: function (url, resourceType) {
	                    var requestParams = {
	                        url: url
	                    };
	                    if (resourceType === "Tile" || resourceType === "Source") {
	                        // Note: if url includes legacyDomainPlaceHolder it will also include domainPlaceHolder
	                        //                       {azMapsDomain}                               {{azMapsDomain}}
	                        if (url.includes(constants.legacyDomainPlaceHolder) && _this.insights) {
	                            _this.insights.trackEvent({ name: "TileLoad" });
	                        }
	                        _this._substituteDomainLanguageViewAndSignInRequest(url, requestParams);
	                    }
	                    else if (resourceType === "Style" || resourceType === "SpriteJSON" || resourceType === "SpriteImage" || resourceType === "Glyphs") {
	                        _this.styles._transformStyleRequest(url, requestParams);
	                    }
	                    // Apply the users specified transform after ours
	                    if (_this.serviceOptions.transformRequest) {
	                        merge$1(requestParams, _this.serviceOptions.transformRequest(requestParams.url, resourceType));
	                    }
	                    // TODO: fix type variation
	                    return requestParams;
	                }
	            };
	            mapboxMap = new maplibregl.Map(mapboxMapOptions);
	        }
	        try {
	            _this.map = mapboxMap;
	            _this.controls = new ControlManager(_this);
	            _this.events = new EventManager(_this);
	            _this.imageSprite = new ImageSpriteManager(_this);
	            _this.layers = new LayerManager(_this);
	            _this.markers = new HtmlMarkerManager(_this);
	            _this.sources = new SourceManager(_this);
	            _this.popups = new PopupManager(_this);
	            _this.indicators = new AccessibleIndicatorManager(_this);
	            // Add CSS classes and set attributes for DOM elements.
	            _this.map.getContainer().classList.add(Map.Css.container);
	            _this.map.getCanvasContainer().classList.add(Map.Css.canvasContainer);
	            _this.map.getCanvas().classList.add(Map.Css.canvas);
	            _this._detectHighContrast();
	            // Always add the copyright label.
	            _this.copyrightControl = new CopyrightControl({
	                showFeedbackLink: _this.styleOptions.showFeedbackLink,
	                showLogo: _this.styleOptions.showLogo,
	                customAttribution: _this.styleOptions.customAttribution
	            });
	            _this.controls.add(_this.copyrightControl, {
	                position: exports.ControlPosition.NonFixed
	            });
	            // Add logo control to occupy the bottom left corner of the map.
	            _this.logoControl = new LogoControl({
	                showLogo: _this.styleOptions.showLogo
	            });
	            _this.controls.add(_this.logoControl, {
	                position: exports.ControlPosition.BottomLeft
	            });
	            // Initialize state of map
	            // --> Initialize the authentication manager
	            var authManInit = _this.authentication ?
	                _this.authentication.initialize() : Promise.resolve();
	            if (_this.removed) {
	                return _this;
	            }
	            // --> Track if the map has completed its first load
	            var setLoaded_1 = function () {
	                _this.loaded = true;
	                _this.map.off("load", setLoaded_1);
	            };
	            _this.map.on("load", setLoaded_1);
	            // --> Track if the map has set its initial style
	            var setReady_1 = function () {
	                _this.ready = true;
	                _this.map.off("styledata", setReady_1);
	                // Manually invoke the ready event the first time styledata fires.
	                var readyData = { map: _this, type: "ready" };
	                _this.events.invoke("ready", readyData);
	            };
	            _this.map.on("styledata", setReady_1);
	            // --> Set initial style including downloading style definitions and restyle map
	            _this._setAutoResize(_this.styleOptions.autoResize);
	            _this.map.showTileBoundaries = _this.styleOptions.showTileBoundaries;
	            _this.localizedStringsPromise = Localizer.getStrings(_this.styleOptions.language);
	            authManInit
	                // reuses this.styles.initPromise if initStyleset is already called
	                .then(function () { return _this.styles.definitions(); })
	                .then(function (definitions) {
	                // Check that the map hasn't been removed for any reason.
	                // If so no need to finish styling the map.
	                if (_this.removed) {
	                    return;
	                }
	                if (_this.authentication && !_this.authentication.getToken()) {
	                    throw new Error("AuthenticationManager finished initializing, but no token is available");
	                }
	                // Add the accessibility delegate to the map here
	                // so that the auth mechanism is setup before any calls are made.
	                if (_this.serviceOptions["enable-accessibility"]) {
	                    _this.accessibleMapDelegate.addToMap();
	                }
	                _this._setStyleComponents(_this.styleOptions);
	                _this.copyrightDelegate && _this.copyrightDelegate.addToMap();
	            }).catch(function (reason) {
	                var error = reason instanceof Error ? reason : new Error(reason);
	                // Invoke the error event to report any errors initializing the styles or auth.
	                var errorData = {
	                    map: _this,
	                    type: "error",
	                    error: error
	                };
	                _this.events.invoke("error", errorData);
	            });
	            // --> Set initial camera state of map
	            _this.setCamera(__assign(__assign({ 
	                // Default minZoom to ensure the map doesn't zoom out to unsupported zoom levels.
	                minZoom: 1 }, options), { type: "jump", duration: 0 }));
	            _this.flowDelegate = new FlowServiceDelegate(_this);
	            _this.accessibleMapDelegate = new AccessibleMapDelegate(_this);
	            _this.userInteractionDelegate = new UserInteractionDelegate(_this, options);
	            _this.userInteractionDelegate.addToMap();
	            {
	                _this.copyrightControl.setOptions({
	                    copyrightMessage: _this.copyrightControl.getDefaultAttributions().join(', ')
	                });
	            }
	        }
	        catch (err) {
	            throw err;
	        }
	        finally {
	        }
	        return _this;
	    }
	    Object.defineProperty(Map.prototype, "isDisposed", {
	        /**
	         * Returns true if the map has been disposed.
	         */
	        get: function () {
	            return this.removed;
	        },
	        enumerable: false,
	        configurable: true
	    });
	    /**
	     * Returns the HTMLCanvasElement that the map is drawn to.
	     */
	    Map.prototype.getCanvas = function () {
	        return this.map.getCanvas();
	    };
	    /**
	     * Returns the HTMLElement that contains the map's HTMLCanvasElement. The map's events (e.g. panning and zooming)
	     * are attached to this element.
	     */
	    Map.prototype.getCanvasContainer = function () {
	        return this.map.getCanvasContainer();
	    };
	    /**
	     * Returns the HTMLElement that contains the map.
	     */
	    Map.prototype.getMapContainer = function () {
	        return this.map.getContainer();
	    };
	    /**
	     * Returns the service options with which the map control was initialized.
	     */
	    Map.prototype.getServiceOptions = function () {
	        return cloneDeepWith$1(this.serviceOptions, ServiceOptions._cloneCustomizer);
	    };
	    /**
	     * Set the service options.
	     */
	    Map.prototype.setServiceOptions = function (options) {
	        this.serviceOptions = new ServiceOptions().merge(this.serviceOptions, options);
	        if (this.serviceOptions["enable-accessibility"]) {
	            this.accessibleMapDelegate.addToMap();
	        }
	        else {
	            this.accessibleMapDelegate.removeFromMap();
	        }
	        var shouldReloadStyle = this.styles.serviceOptions.mapConfiguration !== this.serviceOptions.mapConfiguration
	            || this.styles.serviceOptions.staticAssetsDomain !== this.serviceOptions.staticAssetsDomain
	            || this.styles.serviceOptions.styleDefinitionsVersion !== this.serviceOptions.styleDefinitionsVersion
	            || this.styles.serviceOptions.domain !== this.serviceOptions.domain
	            || this.styles.serviceOptions.styleAPIVersion !== this.serviceOptions.styleAPIVersion;
	        // NOTE: only perform a reload when the style dependent properties are changed
	        //|| this.styles.serviceOptions.validateStyle !== this.serviceOptions.validateStyle
	        //|| this.styles.serviceOptions.transformRequest !== this.serviceOptions.transformRequest
	        this.styles.serviceOptions = this.serviceOptions;
	        if (shouldReloadStyle) {
	            this.styles.initPromise = null;
	            this.setStyle({});
	        }
	    };
	    /**
	     * Adds request transformer
	     * @param transformer provides custom request parameters for loading a tile.
	     */
	    Map.prototype.addRequestTransformer = function (transformer) { this.serviceOptions.addTransformer(transformer); };
	    /**
	     * Removes request transformer
	     * @param transformer transformer to remove (provides custom request parameters for loading a tile)
	     */
	    Map.prototype.removeRequestTransformer = function (transformer) { this.serviceOptions.removeTransformer(transformer); };
	    Map.prototype.setCamera = function (options, fromControl) {
	        var _a;
	        if (fromControl === void 0) { fromControl = false; }
	        var mapboxCameraOptions;
	        var maxBounds;
	        // Test between CameraOptions and CameraBoundsOptions
	        if ("padding" in options || "offset" in options || "bounds" in options) {
	            var cameraBoundsOptions = new CameraBoundsOptions()
	                .merge({ maxZoom: this.getCamera().maxZoom }, options);
	            var bounds = this._generateSafeBounds(cameraBoundsOptions.bounds);
	            var cameraForBoundsOptions = {
	                padding: cameraBoundsOptions.padding,
	                offset: cameraBoundsOptions.offset,
	                maxZoom: cameraBoundsOptions.maxZoom
	            };
	            mapboxCameraOptions = this.map.cameraForBounds(bounds, cameraForBoundsOptions);
	            if (!mapboxCameraOptions) {
	                var currentContainer = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getContainer();
	                var errorDetails = {
	                    message: "The map cannot be fit to the current canvas with the given CameraBoundsOptions.",
	                    containerWidth: currentContainer === null || currentContainer === void 0 ? void 0 : currentContainer.clientWidth,
	                    containerHeight: currentContainer === null || currentContainer === void 0 ? void 0 : currentContainer.clientHeight,
	                    safeBounds: bounds,
	                    cameraForBoundsOptions: cameraForBoundsOptions
	                };
	                throw new Error(JSON.stringify(errorDetails));
	            }
	            if ('pitch' in options) {
	                mapboxCameraOptions.pitch = options.pitch;
	            }
	            if ('bearing' in options) {
	                mapboxCameraOptions.bearing = options.bearing;
	            }
	            if ('minPitch' in options) {
	                this.map.setMinPitch(options.minPitch);
	            }
	            if ('maxPitch' in options) {
	                this.map.setMaxPitch(options.maxPitch);
	            }
	            if ('minZoom' in options) {
	                this.map.setMinZoom(options.minZoom);
	            }
	            maxBounds = this._generateSafeBounds(cameraBoundsOptions.maxBounds);
	        }
	        else {
	            var cameraOptions = new CameraOptions().merge(this.getCamera(), options);
	            // adjust for center offset
	            if (cameraOptions.centerOffset && cameraOptions.centerOffset.length >= 2) {
	                var centerOffset = cameraOptions.centerOffset;
	                // Calculate a new center which accounts for the offset at the specified zoom level.
	                var p = mercatorPositionsToPixels([cameraOptions.center], cameraOptions.zoom);
	                p[0][0] += centerOffset[0];
	                p[0][1] += centerOffset[1];
	                cameraOptions.center = mercatorPixelsToPositions(p, cameraOptions.zoom)[0];
	            }
	            mapboxCameraOptions = {
	                center: cameraOptions.center,
	                zoom: cameraOptions.zoom,
	                bearing: cameraOptions.bearing,
	                pitch: cameraOptions.pitch,
	                around: undefined
	            };
	            if (cameraOptions.minZoom < 1) {
	                console.warn("Setting minZoom below 1 may result in an empty map when the zoom level is less than 1.");
	            }
	            this.map.setMinZoom(cameraOptions.minZoom);
	            this.map.setMaxZoom(cameraOptions.maxZoom);
	            if (cameraOptions.minPitch) {
	                this.map.setMinPitch(cameraOptions.minPitch);
	            }
	            if (cameraOptions.maxPitch) {
	                this.map.setMaxPitch(cameraOptions.maxPitch);
	            }
	            this._invokeEvent("minzoomchanged", this.map.getMinZoom());
	            this._invokeEvent("maxzoomchanged", this.map.getMaxZoom());
	            maxBounds = this._generateSafeBounds(cameraOptions.maxBounds);
	        }
	        // set maxBounds. maxBounds will be removed if null or undefined is provided.
	        if (maxBounds) {
	            this.map.setMaxBounds(maxBounds);
	        }
	        else {
	            this.map.setMaxBounds(null);
	        }
	        var animOptions = new AnimationOptions().merge(options);
	        var mapboxAnimationOptions = {
	            duration: animOptions.duration,
	            easing: function (t) { return t; },
	            offset: [0, 0],
	            animate: true
	        };
	        // Supply event data regarding if a control caused this camera change.
	        var eventData = { fromControl: fromControl };
	        if (animOptions.type === "jump") {
	            this.map.jumpTo(mapboxCameraOptions, eventData);
	        }
	        else if (animOptions.type === "ease") {
	            this.map.easeTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	        else if (animOptions.type === "fly") {
	            this.map.flyTo(__assign(__assign({}, mapboxCameraOptions), mapboxAnimationOptions), eventData);
	        }
	    };
	    /**
	     * Set the camera bounds of the map control.
	     * @param options The options for setting the map's camera bounds.
	     * @deprecated recommend setCamera.
	     */
	    Map.prototype.setCameraBounds = function (options) {
	        this.setCamera(options);
	    };
	    /**
	     * Returns the camera's current properties.
	     */
	    Map.prototype.getCamera = function () {
	        var southWest = this.map.getBounds().getSouthWest().toArray();
	        var northEast = this.map.getBounds().getNorthEast().toArray();
	        var cameraOptions = {
	            zoom: this.map.getZoom(),
	            center: this.map.getCenter().toArray(),
	            bearing: this.map.getBearing(),
	            pitch: this.map.getPitch(),
	            bounds: new BoundingBox(southWest, northEast),
	            minZoom: this.map.getMinZoom(),
	            maxZoom: this.map.getMaxZoom()
	        };
	        return cameraOptions;
	    };
	    /**
	     * Set the map control's style options. Any options not specified will default to their current values.
	     * @param options The options for setting the style of the map control.
	     * @param diff [true] If false, forces a 'full' style update, removing the current style and building the given one instead of attempting a diff-based update. Defaults to true.
	     */
	    Map.prototype.setStyle = function (options, diff) {
	        if (diff === void 0) { diff = true; }
	        // This option may only be set when initializing the map.
	        // The delete operation will handle non-exist property.
	        delete options.preserveDrawingBuffer;
	        var newOptions = new StyleOptions().merge(this.styleOptions, options);
	        // Add or remove the autoResize listener if needed.
	        if (newOptions.autoResize !== this.styleOptions.autoResize) {
	            this._setAutoResize(newOptions.autoResize);
	        }
	        // Update the localized strings promise if needed.
	        if (newOptions.language !== this.styleOptions.language) {
	            this.localizedStringsPromise = Localizer.getStrings(newOptions.language);
	        }
	        // Update rendering of world copies if needed.
	        if (newOptions.renderWorldCopies !== this.styleOptions.renderWorldCopies) {
	            this.map.setRenderWorldCopies(newOptions.renderWorldCopies);
	        }
	        // Add or remove the feedback link if needed.
	        if (newOptions.showFeedbackLink !== this.styleOptions.showFeedbackLink) {
	            this.copyrightControl.setOptions({ showFeedbackLink: newOptions.showFeedbackLink });
	        }
	        // Add or remove custom attribution if needed
	        if (newOptions.customAttribution !== this.styleOptions.customAttribution) {
	            this.copyrightControl.setOptions({ customAttribution: newOptions.customAttribution });
	        }
	        // Add or remove the logo if needed.
	        if (newOptions.showLogo !== this.styleOptions.showLogo) {
	            this.copyrightControl.setOptions({ showLogo: newOptions.showLogo });
	            this.logoControl.setOptions({ showLogo: newOptions.showLogo });
	        }
	        // Update showing tile boundaries if needed.
	        if (newOptions.showTileBoundaries !== this.styleOptions.showTileBoundaries) {
	            this.map.showTileBoundaries = newOptions.showTileBoundaries;
	        }
	        if (newOptions.showBuildingModels) {
	            console.warn("showBuildingModels is deprecated.");
	        }
	        // Some delegates may rely on a styledata event to know when to check if the language changes.
	        // If this function is restructured such that a styledata event won't always trigger
	        // if the language is changed, then either those delegates need changed
	        // or the styledata event manually invoked.
	        var noDiffOnLanguageViewChange = diff && (this.styleOptions.language === newOptions.language && this.styleOptions.view === newOptions.view);
	        this.styleOptions = newOptions;
	        this._setStyleComponents(newOptions, noDiffOnLanguageViewChange);
	    };
	    /**
	     * Returns the map control's current style settings.
	     */
	    Map.prototype.getStyle = function () {
	        return cloneDeep$1(this.styleOptions);
	    };
	    /**
	     * Add an icon to the map to use for pins.
	     * Map must be ready and the image must be fully loaded before the icon can be added.
	     * Use the events.add method with event type 'ready'.
	     * @param id The identifier of the icon.
	     * @param icon The icon image.
	     * @deprecated Use map.imageSprite.add instead.
	     */
	    Map.prototype.addIcon = function (id, icon) {
	        this.imageSprite.add(id, icon);
	    };
	    /**
	     * Add a collection of points to a layer of the map as pins. The layer and its options can be specified through a
	     * PinLayerOptions object. Options for the layer can
	     * only be specified upon the layer's initial creation. Map must be ready before the pins can be added. Use
	     * the events.add method with event type 'ready'.
	     * @param pins The points to add.
	     * @param options The layer options for the pins.
	     * @deprecated Use atlas.layer.SymbolLayer instead.
	     */
	    Map.prototype.addPins = function (pins, options) {
	        var layerOptions = new PinLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new SymbolLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                iconOptions: {
	                    anchor: "center",
	                    size: layerOptions.iconSize,
	                    image: ["case",
	                        ["has", "icon"], ["get", "icon"],
	                        layerOptions.icon
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity
	                },
	                textOptions: {
	                    anchor: "center",
	                    textField: ["case",
	                        ["has", "point_count"], ["to-string", ["get", "point_count"]],
	                        ["has", "title"], ["to-string", ["get", "title"]],
	                        layerOptions.title
	                    ],
	                    font: ["case",
	                        ["has", "point_count"], ["literal", ["StandardFontCondensed-Bold"]],
	                        ["literal", [layerOptions.textFont]]
	                    ],
	                    size: ["case",
	                        ["has", "point_count"], 20,
	                        layerOptions.fontSize
	                    ],
	                    ignorePlacement: !layerOptions.cluster,
	                    opacity: layerOptions.opacity,
	                    offset: ["case",
	                        ["has", "point_count"], ["literal", [0.50, -0.45]],
	                        ["literal", [layerOptions.textOffset[0] / 16, layerOptions.textOffset[1] / 16]]
	                    ],
	                    color: layerOptions.fontColor
	                }
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof SymbolLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a SymbolLayer.") +
	                "A SymbolLayer should be used for rendering pins.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId, {
	                cluster: layerOptions.cluster
	            });
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var pinCollection = new FeatureCollection(pins);
	        if (layerOptions.overwrite) {
	            source.setShapes(pinCollection);
	        }
	        else {
	            source.add(pinCollection);
	        }
	    };
	    /**
	     * Add a collection of points to a layer of the map as circles. The layer and its options can be specified through a
	     * CircleLayerOptions object. Options for the layer
	     * can only be specified upon the layer's initial creation. Map must be ready before the circles can be
	     * added. Use the events.add method with event type 'ready'.
	     * @param circles The circles to add.
	     * @param options The layer options for the circles.
	     * @deprecated Use atlas.layer.BubbleLayer instead.
	     */
	    Map.prototype.addCircles = function (circles, options) {
	        var layerOptions = new CircleLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new BubbleLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                opacity: layerOptions.opacity,
	                radius: ["case",
	                    ["has", "radius"], ["get", "radius"],
	                    layerOptions.radius
	                ],
	                color: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeColor: ["case",
	                    ["has", "outlineColor"], ["get", "outlineColor"],
	                    layerOptions.outlineColor
	                ],
	                strokeWidth: ["case",
	                    ["has", "outlineWidth"], ["get", "outlineWidth"],
	                    layerOptions.outlineWidth
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof BubbleLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a BubbleLayer.") +
	                "A BubbleLayer should be used for rendering circles.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var circleCollection = new FeatureCollection(circles);
	        if (layerOptions.overwrite) {
	            source.setShapes(circleCollection);
	        }
	        else {
	            source.add(circleCollection);
	        }
	    };
	    /**
	     * Add a collection of linestrings to a layer of the map. The layer and its options can be specified through a
	     * LinestringLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the
	     * linestrings can be added. Use the events.add method with event type 'ready'.
	     * @param linestrings The linestrings to add.
	     * @param options The layer options for the linestrings.
	     * @deprecated Use atlas.layer.LineLayer instead.
	     */
	    Map.prototype.addLinestrings = function (linestrings, options) {
	        var layerOptions = new LinestringLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new LineLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                lineCap: layerOptions.cap,
	                lineJoin: layerOptions.join,
	                strokeOpacity: layerOptions.opacity,
	                strokeColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ],
	                strokeWidth: ["case",
	                    ["has", "width"], ["get", "width"],
	                    layerOptions.width
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof LineLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a LineLayer.") +
	                "A LineLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var lineCollection = new FeatureCollection(linestrings);
	        if (layerOptions.overwrite) {
	            source.setShapes(lineCollection);
	        }
	        else {
	            source.add(lineCollection);
	        }
	    };
	    /**
	     * Add a collection of polygons to a layer of the map. The layer and its options can be specified through a
	     * PolygonLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation. Map must be ready before the polygons
	     * can be added. Use the events.add method with event type 'ready'.
	     * @param polygons The polygons to add.
	     * @param options The layer options for the polygons.
	     * @deprecated Use atlas.layer.PolygonLayer instead.
	     */
	    Map.prototype.addPolygons = function (polygons, options) {
	        var layerOptions = new PolygonLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        // If a layer with the specified layer name doesn't exist create one.
	        var newLayer = false;
	        if (!layer) {
	            newLayer = true;
	            layer = new PolygonLayer("".concat(layerOptions.name, "-source"), layerOptions.name, {
	                source: "".concat(layerOptions.name, "-source"),
	                minZoom: layerOptions.minZoom,
	                maxZoom: layerOptions.maxZoom,
	                fillOpacity: layerOptions.opacity,
	                fillColor: ["case",
	                    ["has", "color"], ["get", "color"],
	                    layerOptions.color
	                ]
	            });
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof PolygonLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a PolygonLayer.") +
	                "A PolygonLayer should be used for rendering linestrings.");
	        }
	        var sourceId;
	        var source = layer.getSource();
	        if (typeof source === "string") {
	            sourceId = source;
	            source = this.sources.getById(sourceId);
	        }
	        else {
	            sourceId = source.getId();
	        }
	        // If a source with the specified source name doesn't exist create one.
	        var newSource = false;
	        if (!source) {
	            newSource = true;
	            source = new DataSource(sourceId);
	        }
	        // Check that the source with the specified source name is the correct type of source.
	        if (!(source instanceof DataSource)) {
	            throw new Error("The source with name '".concat(sourceId, "' already exists but it is not a DataSource.") +
	                "New data can only be added to a DataSource.");
	        }
	        // If a new source was created add it to the source manager.
	        // Add the source before adding any GeoJSON data to it.
	        if (newSource) {
	            this.sources.add(source);
	        }
	        // If a new layer was created add it to the layer manager.
	        if (newLayer) {
	            this.layers.add(layer, layerOptions.before);
	        }
	        // Add the circles to the source.
	        var polygonCollection = new FeatureCollection(polygons);
	        if (layerOptions.overwrite) {
	            source.setShapes(polygonCollection);
	        }
	        else {
	            source.add(polygonCollection);
	        }
	    };
	    /**
	     * Adds a raster layer to the map. The layer and its options can be specified through a
	     * RasterLayerOptions object. Options for
	     * the layer can only be specified upon the layer's initial creation.
	     * @param tileSources  A list of endpoints specified as strings from which raster images can be requested. The
	     * endpoints can be parameterized with the tags '{z}', '{x}' and '{y}' to specify the zoom, x-index, and y-index of
	     * the needed tile respectively. The map control will request and place the tiles that are contained in the map's
	     * viewport.
	     * @param options The options for the raster layer.
	     * @deprecated Use atlas.layer.TileLayer instead.
	     */
	    Map.prototype.addRaster = function (tileSources, options) {
	        var layerOptions = new RasterLayerOptions().merge(options);
	        var layer = this.layers.getLayerById(layerOptions.name);
	        if (!layer) {
	            layer = new TileLayer({
	                maxZoom: layerOptions.maxZoom,
	                minZoom: layerOptions.minZoom,
	                opacity: layerOptions.opacity,
	                tileSize: 256,
	                tileUrl: "{subdomain}"
	            }, layerOptions.name);
	        }
	        // Check that the layer with the specified layer name is the correct type of layer.
	        if (!(layer instanceof TileLayer)) {
	            throw new Error("A layer with name '".concat(layerOptions.name, "' already exists but it is not a TileLayer.") +
	                "A TileLayer should be used for rendering raster images.");
	        }
	        // Multiple tile urls are made possible by the {subdomain} substitution
	        // If a layer doesn't use "{subdomain}" as its tileUrl it must have be created with new TileLayer(...)
	        // In that case throw an error.
	        if (layer.getOptions().tileUrl !== "{subdomain}") {
	            throw new Error("A TileLayer with name '".concat(layerOptions.name, "' already exists but was configured ") +
	                "for a single tile url [default for new TileLayer(...)].");
	        }
	        // Get the new tile urls.
	        var urls;
	        if (layerOptions.overwrite) {
	            urls = [];
	        }
	        else {
	            urls = layer.getOptions().subdomains || [];
	        }
	        // Add the tile urls to the layer, but don't update the map yet.
	        urls.push.apply(urls, __spreadArray$1([], __read$1(tileSources), false));
	        layer._setOptionsNoUpdate({
	            subdomains: urls
	        });
	        this.layers.add(layer, layerOptions.before);
	    };
	    /**
	     * Returns a list of the map's layers from bottom to top.
	     * @deprecated Use layers.getLayers() instead.
	     */
	    Map.prototype.getLayers = function () {
	        return this.layers.getLayers().map(function (l) { return l.getId(); });
	    };
	    /**
	     * Removes a collection of layers from the map.
	     * For each layer if a source by the name of "<layerName>-source" exists it will be removed too.
	     * @param layerNames An array of layer names to remove from the map.
	     * @deprecated Use layers.remove instead.
	     */
	    Map.prototype.removeLayers = function (layerNames) {
	        var e_1, _a;
	        try {
	            for (var layerNames_1 = __values(layerNames), layerNames_1_1 = layerNames_1.next(); !layerNames_1_1.done; layerNames_1_1 = layerNames_1.next()) {
	                var layerName = layerNames_1_1.value;
	                // Previously calling removeLayers for layers that didn't exist in the map just did nothing.
	                // Now, LayerManager will throw an error, so we need to check if the layer exists before calling remove.
	                if (this.layers.getLayerById(layerName)) {
	                    this.layers.remove(layerName);
	                    // Previously adding a layer also added a source with the name "<layerName>-source".
	                    // Calling removeLayers would also remove that source, so we attempt to do this too.
	                    var sourceName = "".concat(layerName, "-source");
	                    if (this.sources.getById(sourceName)) {
	                        this.sources.remove(sourceName);
	                    }
	                }
	            }
	        }
	        catch (e_1_1) { e_1 = { error: e_1_1 }; }
	        finally {
	            try {
	                if (layerNames_1_1 && !layerNames_1_1.done && (_a = layerNames_1.return)) _a.call(layerNames_1);
	            }
	            finally { if (e_1) throw e_1.error; }
	        }
	    };
	    /**
	     * @deprecated recommend map.markers.add
	     * Adds a custom HTMLElement to the map at a specified position.
	     * @param element The HTMLElement to add.
	     * @param position The position to place the element.
	     */
	    Map.prototype.addHtml = function (element, position) {
	        if (!element.id) {
	            element.id = "marker_".concat(uuid());
	        }
	        var marker = new HtmlMarker({
	            htmlContent: element,
	        });
	        this.markers.add(marker, position);
	        return element.id;
	    };
	    /**
	     * @deprecated recommend map.markers.remove
	     * Removes a custom HTMLElement from the map.
	     * @param elementId The id of element to remove.
	     */
	    Map.prototype.removeHtml = function (elementId) {
	        this.markers.remove(elementId);
	    };
	    Map.prototype.addEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._addLegacy(eventType, layerOrCallback, callback);
	    };
	    Map.prototype.removeEventListener = function (eventType, layerOrCallback, callback) {
	        this.events._removeLegacy(eventType, layerOrCallback, callback);
	    };
	    /**
	     * Set the map control's user interaction handlers. Any options not specified will default to their current values.
	     * @param options The options for enabling/disabling the user interaction handlers.
	     */
	    Map.prototype.setUserInteraction = function (options) {
	        this.userInteractionDelegate.setOptions(options);
	    };
	    /**
	     * Return the map control's current user interaction handler settings.
	     */
	    Map.prototype.getUserInteraction = function () {
	        return this.userInteractionDelegate.getOptions();
	    };
	    /**
	     * Add a control to the map.
	     * @param control The control to add.
	     * @param options The options for the added control.
	     * @deprecated Use map.controls.add instead.
	     */
	    Map.prototype.addControl = function (control, options) {
	        this.controls.add(control, options);
	    };
	    /**
	     * Remove a control from the map.
	     * @param control The control to remove.
	     * @deprecated Use map.controls.remove instead.
	     */
	    Map.prototype.removeControl = function (control) {
	        this.controls.remove(control);
	    };
	    /**
	     * Set the traffic options for the map. Any options not specified will default to their current values.
	     * @param options The options for defining the map's traffic display.
	     */
	    Map.prototype.setTraffic = function (options) {
	        var previousIncidentsOption = this.trafficOptions.incidents;
	        var previousFlowOption = this.trafficOptions.flow;
	        this.trafficOptions = new TrafficOptions().merge(this.trafficOptions, options);
	        this.controls.getControls().filter(function (control) { return control instanceof TrafficControl; }).forEach(function (control) {
	            return control.updateButtonState();
	        });
	        if (this.incidentDelegate) {
	            if (this.trafficOptions.incidents) {
	                if (!previousIncidentsOption) {
	                    this.incidentDelegate.addToMap();
	                }
	            }
	            else {
	                this.incidentDelegate.removeFromMap();
	            }
	        }
	        if (this.trafficOptions.flow && this.trafficOptions.flow !== "none") {
	            if (["absolute", "relative-delay"].includes(this.trafficOptions.flow)) {
	                console.warn("The 'absolute' and 'relative-delay' flow options are deprecated. Please use 'relative' instead.");
	            }
	            try {
	                if (this.trafficOptions.flow !== previousFlowOption) {
	                    this.flowDelegate.addToMap();
	                }
	            }
	            catch (error) {
	                this.trafficOptions.flow = previousFlowOption;
	                throw error;
	            }
	        }
	        else {
	            this.flowDelegate.removeFromMap();
	        }
	    };
	    /**
	     * Return the map control's current traffic settings.
	     */
	    Map.prototype.getTraffic = function () {
	        return cloneDeep$1(this.trafficOptions);
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     * @deprecated use map.dispose()
	     */
	    Map.prototype.remove = function () {
	        this.dispose();
	    };
	    /**
	     * Removes all sources, layers, markers, and popups from the map.
	     * User added images are preserved.
	     */
	    Map.prototype.clear = function () {
	        // Clear the layers, sources, and marker via their managers.
	        this.popups.clear();
	        this.layers.clear();
	        this.sources.clear();
	        this.markers.clear();
	        this.indicators.clear();
	    };
	    /**
	     * Clean up the map's resources. Map will not function correctly after calling this method.
	     */
	    Map.prototype.dispose = function () {
	        var _a, _b;
	        this.clear();
	        this.map.remove();
	        (_a = this.authentication) === null || _a === void 0 ? void 0 : _a.dispose();
	        this.removed = true;
	        // Remove event listeners
	        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
	        this.resizeObserver = null;
	        while (this.getMapContainer().firstChild) {
	            var currChild = this.getMapContainer().firstChild;
	            this.getMapContainer().removeChild(currChild);
	        }
	    };
	    Map.prototype.resize = function (heightOrData, width, eventData) {
	        if ((typeof heightOrData === "number" || typeof heightOrData === "string") &&
	            (typeof width === "number" || typeof width === "string")) {
	            var height = heightOrData;
	            this.getMapContainer().style.height = typeof height === "number" ? "".concat(height, "px") : height;
	            this.getMapContainer().style.width = typeof width === "number" ? "".concat(width, "px") : width;
	        }
	        else {
	            eventData = heightOrData;
	        }
	        // Occasionally, when resizing the window causes the map container to also resize, the canvas will re-resized
	        // as if expecting a scroll bar to be drawn for the canvas container.
	        // This leaves some whitespace gap on the bottom and right sides of the canvas.
	        // No actual scrollbars will be shown.
	        //
	        // This is because the canvas container and map container are resized before the canvas,
	        // so for a small fraction of time the canvas is bigger than its containers and a scroll bar would be required.
	        //
	        // To prevent this first the canvas container has overflow set to hidden.
	        // This ensures that scroll bars would never be needed.
	        // Then the Mapbox resize function is called, and the canvas should be the full, correct size.
	        // Finally the canvas container has overflow set back to the original value.
	        var oldOverflow = this.getMapContainer().style.overflow;
	        this.getMapContainer().style.overflow = "hidden";
	        this.map.resize(eventData);
	        this.getMapContainer().style.overflow = oldOverflow;
	    };
	    /**
	     * Converts an array of Pixel objects to an array of geographic Positions objects on the map.
	     * @param pixels The pixels to be converted.
	     */
	    Map.prototype.pixelsToPositions = function (pixels) {
	        var e_2, _a;
	        var positions = [];
	        try {
	            for (var pixels_1 = __values(pixels), pixels_1_1 = pixels_1.next(); !pixels_1_1.done; pixels_1_1 = pixels_1.next()) {
	                var pixel = pixels_1_1.value;
	                var lngLat = this.map.unproject(pixel);
	                positions.push(new Position(lngLat.lng, lngLat.lat));
	            }
	        }
	        catch (e_2_1) { e_2 = { error: e_2_1 }; }
	        finally {
	            try {
	                if (pixels_1_1 && !pixels_1_1.done && (_a = pixels_1.return)) _a.call(pixels_1);
	            }
	            finally { if (e_2) throw e_2.error; }
	        }
	        return positions;
	    };
	    /**
	     * Converts an array of Positions objects to an array of Pixel objects relative to the map container.
	     * @param positions The positions to be converted.
	     */
	    Map.prototype.positionsToPixels = function (positions) {
	        var e_3, _a;
	        var pixels = [];
	        try {
	            for (var positions_1 = __values(positions), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
	                var position = positions_1_1.value;
	                var point = this.map.project(position);
	                pixels.push(new Pixel(point.x, point.y));
	            }
	        }
	        catch (e_3_1) { e_3 = { error: e_3_1 }; }
	        finally {
	            try {
	                if (positions_1_1 && !positions_1_1.done && (_a = positions_1.return)) _a.call(positions_1);
	            }
	            finally { if (e_3) throw e_3.error; }
	        }
	        return pixels;
	    };
	    /**
	     * Returns a boolean indicating if all tiles in the current viewport for all sources have loaded or not.
	     */
	    Map.prototype.areTilesLoaded = function () {
	        return this.map.areTilesLoaded();
	    };
	    /**
	     * Stops any animated transition that is currently underway.
	     */
	    Map.prototype.stop = function () {
	        this.map.stop();
	    };
	    /**
	     * Trigger the rendering of a single frame.
	     * Use this method with WebGL layers to repaint the map when the layer's
	     * properties or properties associated with the layer's source change.
	     * Calling this multiple times before the next frame is rendered will still
	     * result in only a single frame being rendered.
	     */
	    Map.prototype.triggerRepaint = function () {
	        this.map.triggerRepaint();
	    };
	    /**
	     * Loads a 3D terrain mesh, based on a "raster-dem" source.
	     *
	     * @param elevationSource elevation tile source
	     * @param exaggeration the elevation exaggeration factor
	     */
	    Map.prototype.enableElevation = function (elevationSource, exaggeration) {
	        this.map.setTerrain(typeof elevationSource === 'string' ? { source: elevationSource, exaggeration: exaggeration } : { source: elevationSource.getId(), exaggeration: exaggeration });
	    };
	    /**
	     * Disables the 3D terrain mesh.
	     */
	    Map.prototype.disableElevation = function () {
	        this.map.setTerrain(null);
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._getMap = function () {
	        return this.map;
	    };
	    /**
	     * @internal
	     */
	    Map.prototype._rebuildStyle = function (diff) {
	        if (diff === void 0) { diff = true; }
	        return __awaiter(this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                this.styles.setStyle(this.styleOptions, diff);
	                this.imageSprite._restoreImages();
	                return [2 /*return*/];
	            });
	        });
	    };
	    /**
	     * Returns true if the map has completed loading for the first time.
	     * Will always return true after the initial load is completed.
	     * @internal
	     */
	    Map.prototype._isLoaded = function () {
	        return this.loaded;
	    };
	    /**
	     * Returns true if the map has set its style for the first time.
	     * Will always return true after the style has been set.
	     * @internal
	     */
	    Map.prototype._isReady = function () {
	        return this.ready;
	    };
	    /**
	     * Returns a promise which will resolve to a collection of localized strings based on the map's current language.
	     * @internal
	     */
	    Map.prototype._getLocalizedStrings = function () {
	        return this.localizedStringsPromise;
	    };
	    /**
	     * Sends a fetch request to the specified url with the specified headers.
	     * Processes the request through transformRequest(...) first before sending.
	     * @internal
	     */
	    Map.prototype._sendRequest = function (url, resourceType, headers) {
	        var requestParams;
	        if (typeof this.serviceOptions.transformRequest === "function") {
	            // If a transformRequest(...) was specified use it.
	            requestParams = this.serviceOptions.transformRequest(url, resourceType);
	        }
	        if (requestParams) {
	            // Send the fetch using the transformed parameters.
	            return fetch(requestParams.url || url, {
	                credentials: requestParams.credentials,
	                headers: __assign(__assign({}, headers), requestParams.headers),
	                method: "GET",
	                mode: "cors",
	            });
	        }
	        else {
	            // If not transformRequest has been supplied just make the request as specified.
	            return fetch(url, {
	                headers: headers,
	                method: "GET",
	                mode: "cors"
	            });
	        }
	    };
	    /**
	     * replaces the domain, view and language placeholders and signs request as needed
	     * @internal
	     */
	    Map.prototype._substituteDomainLanguageViewAndSignInRequest = function (url, requestParams) {
	        var _a;
	        if (url.includes(constants.legacyDomainPlaceHolder) || url.includes(constants.domainPlaceHolder)) {
	            // Update legacy domain placeholder if found
	            var isLegacy = new RegExp("[^{]".concat(constants.legacyDomainPlaceHolder, "[^}]"));
	            if (url.match(isLegacy)) {
	                requestParams.url = requestParams.url.replace(constants.legacyDomainPlaceHolder, constants.domainPlaceHolder);
	            }
	            if (Url.protoRegEx.test(this.serviceOptions.domain)) {
	                // If the user specified domain includes a protocol replace that in the url too.
	                var idx = requestParams.url.indexOf(constants.domainPlaceHolder);
	                requestParams.url = this.serviceOptions.domain +
	                    requestParams.url.substring(idx + constants.domainPlaceHolder.length);
	            }
	            else {
	                // If the user specified domain doesn't include a protocol keep the original.
	                requestParams.url = requestParams.url.replace(constants.domainPlaceHolder, this.serviceOptions.domain);
	            }
	        }
	        if (requestParams.url.toLocaleLowerCase().includes(this.serviceOptions.domain.toLocaleLowerCase()) ||
	            requestParams.url.toLocaleLowerCase().includes(this.serviceOptions.staticAssetsDomain.toLocaleLowerCase())) {
	            (_a = this.authentication) === null || _a === void 0 ? void 0 : _a.signRequest(requestParams);
	        }
	        if (url.includes(constants.languagePlaceHolder)) {
	            requestParams.url = requestParams.url.replace(constants.languagePlaceHolder, this.styleOptions.language);
	        }
	        if (url.includes(constants.viewPlaceHolder)) {
	            requestParams.url = this.styleOptions.view ?
	                requestParams.url.replace(constants.viewPlaceHolder, this.styleOptions.view) :
	                requestParams.url.replace(constants.viewPlaceHolder, "").replace("&".concat(constants.viewParameter, "="), "");
	        }
	    };
	    /**
	     * Sets whether the map will automatically resize when the browser window resizes.
	     * @private
	     */
	    Map.prototype._setAutoResize = function (autoResize) {
	        if (autoResize) {
	            if (!this.resizeObserver) {
	                this.resizeObserver = new ResizeObserver(this._resizeCallback);
	            }
	            this.resizeObserver.observe(this.map.getContainer());
	        }
	        else {
	            if (this.resizeObserver) {
	                this.resizeObserver.unobserve(this.map.getContainer());
	            }
	        }
	    };
	    /**
	     * Adds or replaces the relevant fundamental map components (layers and sources) based on the input options.
	     * Removes sources and layers that aren't used by the new style or any remaining layers.
	     * @private
	     */
	    Map.prototype._setStyleComponents = function (styleOptions, diff) {
	        var _this = this;
	        if (diff === void 0) { diff = true; }
	        if (this.removed) {
	            return;
	        }
	        var styleDefinitionPromise = this.styles.definitions();
	        styleDefinitionPromise.then(function (mapConfiguration) {
	            var e_4, _a;
	            // a flag indicating if need to set this.styleOptions.style
	            var needSetStyleOptionStyle = true;
	            // Check if the default style is set by the client and if it exists in the current style set
	            if (_this.styleOptions.style) {
	                try {
	                    for (var _b = __values(mapConfiguration.configurations), _c = _b.next(); !_c.done; _c = _b.next()) {
	                        var mapConfigurationStyle = _c.value;
	                        if (_this.styleOptions.style === mapConfigurationStyle.name) {
	                            needSetStyleOptionStyle = false;
	                            break;
	                        }
	                    }
	                }
	                catch (e_4_1) { e_4 = { error: e_4_1 }; }
	                finally {
	                    try {
	                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
	                    }
	                    finally { if (e_4) throw e_4.error; }
	                }
	            }
	            if (needSetStyleOptionStyle) {
	                // FIXME: this is very counter intuitive and unstable
	                // see details: https://msazure.visualstudio.com/One/_workitems/edit/19409195
	                _this.styleOptions.style = mapConfiguration.defaultConfiguration;
	            }
	            // it appears this line is overwriting everything done above
	            // but "styleOptions" has actually been changed by line 1578.
	            // NEED BETTER logic
	            _this.styleOptions = styleOptions;
	            _this._rebuildStyle(diff);
	        });
	        return;
	    };
	    /**
	     * Set the default service/style options.
	     * Only set defaults if the users provided a value for them and no other default have been set.
	     */
	    Map.prototype._updateGlobalDefaults = function (options) {
	        if (options) {
	            // Must account for deprecated property names because these checks occur before the merge operations.
	            if (options.authOptions && !_hasSetAuthenticationOptions()) {
	                setAuthenticationOptions(options.authOptions);
	            }
	            if (options.domain && !_hasSetDomain()) {
	                setDomain(options.domain);
	            }
	            if (options.styleDefinitionsPath && !_hasSetStyleDefinitionsPath()) {
	                setStyleDefinitionsPath(options.styleDefinitionsPath);
	            }
	            if (options.workerCount && !_hasWorkerCount()) {
	                setWorkerCount(options.workerCount);
	            }
	            if (options.maxParallelImageRequests && !_hasMaxParallelImageRequests()) {
	                setMaxParallelImageRequests(options.maxParallelImageRequests);
	            }
	            if ((options.subscriptionKey || options["subscription-key"]) && !_hasSetAuthenticationOptions()) {
	                setSubscriptionKey(options.subscriptionKey || options["subscription-key"]);
	            }
	            if ((options.sessionId || options["session-id"]) && !_hasSetSessionId()) {
	                setSessionId(options.sessionId || options["session-id"]);
	            }
	            if (options.language && !_hasSetLanguage()) {
	                setLanguage(options.language);
	            }
	            if ((options.userRegion || options.view) && !_hasSetView()) {
	                setUserRegion(options.userRegion || options.view);
	            }
	        }
	    };
	    Map.prototype._generateSafeBounds = function (bounds) {
	        if (bounds) {
	            var s = BoundingBox.getSouth(bounds);
	            var w = BoundingBox.getWest(bounds);
	            var n = BoundingBox.getNorth(bounds);
	            var e = BoundingBox.getEast(bounds);
	            if (!isFinite(s) || !isFinite(w) || !isFinite(n) || !isFinite(e)) {
	                throw new Error("The bounds specified are invalid: [".concat(bounds, "]"));
	            }
	            while (w > e) {
	                e += 360;
	            }
	            return new BoundingBox([w, s, e, n]);
	        }
	        return bounds;
	    };
	    Map.prototype._detectHighContrast = function () {
	        var hcType = Media.getHighContrastMode();
	        var hcClass;
	        var hcStyle;
	        switch (hcType) {
	            case "invert":
	                hcClass = Map.Css.hcLight;
	                hcStyle = "high_contrast_light";
	                break;
	            case "light":
	                hcClass = Map.Css.hcLight;
	                hcStyle = "high_contrast_light";
	                break;
	            case "dark":
	                hcClass = Map.Css.hcDark;
	                hcStyle = "high_contrast_dark";
	                break;
	        }
	        if (hcClass) {
	            this.map.getContainer().classList.add(hcClass);
	        }
	        if (hcStyle && this.styleOptions.style === "road") {
	            this.styleOptions.style = hcStyle;
	        }
	    };
	    // Static CSS classes
	    Map.Css = {
	        canvasContainer: "atlas-map-canvas-container",
	        canvas: "atlas-map-canvas",
	        container: "atlas-map",
	        hcDark: "high-contrast-dark",
	        hcLight: "high-contrast-light"
	    };
	    return Map;
	}(EventEmitter));

	var __read = (window && window.__read) || function (o, n) {
	    var m = typeof Symbol === "function" && o[Symbol.iterator];
	    if (!m) return o;
	    var i = m.call(o), r, ar = [], e;
	    try {
	        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	    }
	    catch (error) { e = { error: error }; }
	    finally {
	        try {
	            if (r && !r.done && (m = i["return"])) m.call(i);
	        }
	        finally { if (e) throw e.error; }
	    }
	    return ar;
	};
	var __spreadArray = (window && window.__spreadArray) || function (to, from, pack) {
	    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
	        if (ar || !(i in from)) {
	            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
	            ar[i] = from[i];
	        }
	    }
	    return to.concat(ar || Array.prototype.slice.call(from));
	};
	/** A layout template for a popup. */
	var PopupTemplate = /** @class */ (function () {
	    function PopupTemplate() {
	        //////////////////////
	        /// Properties
	        //////////////////////
	        /**
	         * Specifies if hyperlinks and email addresses should automatically be detected and rendered as clickable links.
	         * Default: `true`
	         * @default true
	         */
	        this.detectHyperlinks = true;
	        /**
	         * Specifies if property paths should be parsed using forward slashes "/" as sub-property dividers,
	         * or if the whole path should be treated as one property name.
	         * Default: `true`
	         * @default true
	         */
	        this.parsePropertyPaths = true;
	    }
	    //////////////////////
	    /// Public static functions
	    //////////////////////
	    /**
	     * Generates popup content by applying a template to a set of properties.
	     * If no template is specified, `title` or `name` properties will be used as fallbacks for the title if available.
	     * For content, a `description` property will be used or else all properties will be converted into a table.
	     * @param prop The properties object generate the popup content from.
	     * @param template The template to apply.
	     */
	    PopupTemplate.applyTemplate = function (prop, template) {
	        var _this = this;
	        var container = document.createElement("div");
	        container.classList.add(PopupTemplate.Css.template);
	        if (prop) {
	            if (!template) {
	                template = {};
	            }
	            if (typeof template.singleDescription !== "boolean") {
	                template.singleDescription = true;
	            }
	            template.sandboxContent = (typeof template.sandboxContent === "boolean") ? template.sandboxContent : true;
	            if (!(template.title && typeof template.content === "string" &&
	                (template.content.includes("{title}") || template.content.includes("{name}")))) {
	                if (prop.title) {
	                    template.title = "{title}";
	                }
	                else if (prop.name) {
	                    template.title = "{name}";
	                }
	            }
	            if (typeof template.detectHyperlinks !== "boolean") {
	                template.detectHyperlinks = true;
	            }
	            if (typeof template.parsePropertyPaths !== "boolean") {
	                template.parsePropertyPaths = true;
	            }
	            if (template.textColor) {
	                container.style.color = template.textColor;
	            }
	            if (template.fillColor) {
	                container.style.backgroundColor = template.fillColor;
	            }
	            if (template.title) {
	                // For security, strip out all HTML from the title and use the popup templates styling.
	                var c = this._applyStringTemplate(prop, template.title, template);
	                c.innerText = c.textContent || c.innerText || "";
	                this._appendChild(container, c, PopupTemplate.Css.title);
	            }
	            var contentItems_1 = document.createElement("div");
	            contentItems_1.classList.add(PopupTemplate.Css.content);
	            if (Array.isArray(template.content)) {
	                // Check to see if content is a PropertyInfo array.
	                if (template.content.length > 0 && template.content[0]["propertyPath"]) {
	                    this._appendChild(contentItems_1, this._generateContent(prop, template.content, template), PopupTemplate.Css.item);
	                }
	                else {
	                    template.content.forEach(function (x) {
	                        _this._appendChild(contentItems_1, _this._generateContent(prop, x, template), PopupTemplate.Css.item);
	                    });
	                }
	            }
	            else {
	                // If there is a description property, and no other properties, don't generate a table.
	                var propCount_1 = 0;
	                if (prop.description) {
	                    Object.keys(prop).forEach(function (k) {
	                        if (!_this._ignoreProperty(k, prop[k])) {
	                            propCount_1++;
	                        }
	                    });
	                }
	                var c = void 0;
	                // If there is only one property (description), or two (description + Snippet (KML)),
	                // or a flag to only display description, only add the description to the content.
	                if (propCount_1 === 1 ||
	                    (template.singleDescription && prop.description) ||
	                    (propCount_1 === 2 && prop.Snippet)) {
	                    c = document.createElement("div");
	                    c.innerHTML = prop.description;
	                }
	                else {
	                    c = this._generateContent(prop, template.content, template);
	                }
	                this._appendChild(contentItems_1, c, PopupTemplate.Css.item);
	            }
	            if (contentItems_1.innerHTML !== "") {
	                if (template.sandboxContent) {
	                    container.appendChild(PopupTemplate._createSandboxedIframe(contentItems_1, template));
	                }
	                else {
	                    container.appendChild(contentItems_1);
	                }
	            }
	        }
	        return container;
	    };
	    //////////////////////
	    /// Private functions
	    //////////////////////
	    /**
	     * Generates a sandboxed iframe that contains the specified content.
	     * @param content The content to sandbox.
	     */
	    PopupTemplate._createSandboxedIframe = function (content, template) {
	        var iframe = document.createElement("iframe");
	        iframe.sandbox.add("allow-popups");
	        var c = content.innerHTML;
	        // Need to estimate size of content and defined iframe size accordingly.
	        // Can't measure content in iframe without using cross-site scripting,
	        // so analyzing content HTML string instead for safety.
	        var hasMedia = false;
	        var lineLength = 100;
	        var width = 550;
	        var height = 10;
	        var longestStringLength = 0;
	        if (document.body.scrollWidth <= 340) {
	            width = 300;
	            lineLength = 50;
	        }
	        var lines = c.split(/<(tr|div|br|li|h[0-9]|p>)/);
	        longestStringLength = Math.max.apply(Math, __spreadArray([], __read((lines.map(function (el) { return el.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length; }))), false)) - 1;
	        var w = Math.ceil(longestStringLength * 3.5);
	        if (w < width) {
	            width = w;
	            lineLength = longestStringLength;
	        }
	        // Check to see if the content contains an image.
	        if (c.includes("<img") || c.includes("<video")) {
	            hasMedia = true;
	            iframe.width = "550px";
	        }
	        else {
	            var rowHeight = (c.indexOf(PopupTemplate.Css.table) > -1) ? 25 : 20;
	            height += Math.max(lines.length * 0.5 * rowHeight, Math.ceil(c.replace(/<[a-zA-Z0-9\s=\/]+>/g, "").length / lineLength) * rowHeight);
	        }
	        iframe.width = width + "px";
	        if (hasMedia || height > 280) {
	            // If there is an image in the content, then max out content height.
	            iframe.height = "280px";
	        }
	        else {
	            iframe.height = height + "px";
	        }
	        var textColor = (template.textColor) ? "color:".concat(template.textColor, ";") : "";
	        var bgColor = (template.fillColor) ? "background-color:".concat(template.fillColor, ";") : "";
	        // Wrap content with some HTML and CSS.
	        var doc = '<html><head><title></title><meta charset="utf-8" /><meta http-equiv="x-ua-compatible" content="IE=Edge" />' +
	            "<link rel=\"stylesheet\" href=\"".concat(PopupTemplate._cssUrl, "\" type=\"text/css\"/>") +
	            "<style>html, body{margin:0;padding:0;".concat(textColor).concat(bgColor, "}</style></head>") +
	            "<body><div class=\"".concat(PopupTemplate.Css.template, "\" style=\"padding:0;width:").concat(width - 20, "px\">").concat(c, "</div></body></html>");
	        // Check to see if srcdoc of iframe is supported (versions of Edge, pre-chromium, do not support srcdoc)
	        if (iframe.srcdoc === undefined) {
	            // Non-chromium versions of Edge do not support srcdoc property on iframes.
	            // In order to inject inline HTML into an iframe in a secure way, we have to pass in an encoded string.
	            // This has a limitation of only working with shorter strings
	            // (< 1,600 characters when encoded, assuming our CSS doesn't increase in size).
	            iframe.src = "data:text/html;charset=utf-8," + encodeURI(doc);
	        }
	        else {
	            iframe.srcdoc = doc;
	        }
	        return iframe;
	    };
	    /**
	     * Appends an HTML element as a child of another element and adds a class name to the child if specified.
	     * @param container The container to add the child element to.
	     * @param child The child element to add.
	     * @param className The class name to add to the child element.
	     */
	    PopupTemplate._appendChild = function (container, child, className) {
	        if (child) {
	            if (className) {
	                child.className = ((child.className) ? child.className + " " : "") + className;
	            }
	            container.appendChild(child);
	        }
	    };
	    /**
	     * Generates the popup content based on the template and available properties.
	     * @param properties The properties to apply to the template.
	     * @param content The template content.
	     * @param template The templates.
	     */
	    PopupTemplate._generateContent = function (properties, content, template) {
	        if (content) {
	            if (Array.isArray(content)) {
	                // Content is an array of PropertyInfo.
	                return this._generatePropertyInfoTable(properties, content, template);
	            }
	            else {
	                return this._applyStringTemplate(properties, content, template);
	            }
	        }
	        var t = this._generateDynamicTableHtml(properties, null, template);
	        if (t) {
	            var d = document.createElement("div");
	            d.innerHTML = t;
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Replaces placeholders with the property values in a string template.
	     * @param properties The properties to use.
	     * @param stringTemplate The string template to apply.
	     * @param template The template.
	     */
	    PopupTemplate._applyStringTemplate = function (properties, stringTemplate, template) {
	        if (stringTemplate) {
	            var content = stringTemplate;
	            var matches = this._placeholderRx.exec(stringTemplate);
	            // Search the template string using a regular expression.
	            while (matches) {
	                if (matches.length >= 2) {
	                    // Get the property path within a placeholder.
	                    var propValue = this._getPropertyValue(properties, matches[1], template);
	                    content = content.replace(matches[0], propValue);
	                }
	                matches = this._placeholderRx.exec(stringTemplate);
	            }
	            if (content) {
	                content = content.trim();
	                // If there is no HTML tags, replace newline characters with HTML line breaks.
	                if (content.includes("<")) {
	                    content = content.replace(/[\r\n]+/g, "<br/>");
	                }
	                var d = document.createElement("div");
	                d.innerHTML = content;
	                return d;
	            }
	        }
	        return null;
	    };
	    /**
	     * Retrieves the value of a property using its path.
	     * @param properties The set of properties to search from.
	     * @param propertyPath The path of the property.
	     * @param template The template.
	     * @param propertyInfo Property info to apply which specifies how the values should be displayed.
	     */
	    PopupTemplate._getPropertyValue = function (properties, propertyPath, template, propertyInfo) {
	        var path = template.parsePropertyPaths ? propertyPath.split("/") : [propertyPath];
	        var len = path.length;
	        if (len > 0 && properties) {
	            var key = path[0];
	            var obj = properties[key];
	            // Special case where a link may be a flattened link value from a atom feed.
	            if (template.detectHyperlinks && propertyPath === "link" &&
	                (!propertyInfo || propertyInfo.hyperlinkFormat)) {
	                var links_1 = [];
	                if (Array.isArray(obj)) {
	                    obj.forEach(function (l) {
	                        if (l.href) {
	                            links_1.push(l);
	                        }
	                        else if (typeof l === "string") {
	                            links_1.push({
	                                href: l
	                            });
	                        }
	                    });
	                }
	                else if (obj.href) {
	                    links_1.push(obj);
	                }
	                if (links_1.length > 0) {
	                    var f_1;
	                    if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                        f_1 = propertyInfo.hyperlinkFormat;
	                    }
	                    else if (template && template.hyperlinkFormat) {
	                        f_1 = template.hyperlinkFormat;
	                    }
	                    var t_1;
	                    if (f_1 && f_1.target) {
	                        t_1 = f_1.target;
	                    }
	                    else {
	                        t_1 = "_blank";
	                    }
	                    var html_1 = [];
	                    links_1.forEach(function (l) {
	                        if (!l.title && (!f_1 || !f_1.label) && l.rel) {
	                            html_1.push(l.rel, " - ");
	                        }
	                        html_1.push('<a href="', l.href, '" target="', t_1, '">');
	                        if (l.title) {
	                            html_1.push(l.title);
	                        }
	                        else if (f_1 && f_1.label) {
	                            html_1.push(f_1.label);
	                        }
	                        else {
	                            html_1.push(l.href);
	                        }
	                        html_1.push("</a>", "<br/>");
	                    });
	                    // Remove trailing <br/>
	                    html_1.pop();
	                    return html_1.join("");
	                }
	            }
	            if (obj != null) {
	                var i = void 0;
	                // Step through the property.
	                for (i = 1; i < len; i++) {
	                    obj = obj[path[i]];
	                    key = path[i];
	                    if (obj == null) {
	                        break;
	                    }
	                }
	                // Make sure that all properties were stepped through.
	                if (i === len && obj != null) {
	                    var propValue = void 0;
	                    if (typeof obj.value !== "undefined") {
	                        // Object is a SimpleField
	                        propValue = obj.value;
	                    }
	                    else {
	                        propValue = obj;
	                    }
	                    if (propValue instanceof Date) {
	                        if (propertyInfo && propertyInfo.dateFormat) {
	                            return propValue.toLocaleString(undefined, propertyInfo.dateFormat);
	                        }
	                        if (template.dateFormat) {
	                            return propValue.toLocaleString(undefined, template.dateFormat);
	                        }
	                        return propValue.toISOString();
	                    }
	                    else if (typeof propValue === "object") {
	                        // If the value of the property is an object, create a sub-table recursively.
	                        var t = this._generateDynamicTableHtml(propValue, path.slice(1), template);
	                        return (t) ? t : "";
	                    }
	                    else if (typeof propValue === "number") {
	                        if (propertyInfo) {
	                            if (propertyInfo.dateFormat) {
	                                // If the user assigned a date format to the field and the value is a number,
	                                // then assume that the number is the number of milliseconds.
	                                return new Date(propValue).toLocaleString(undefined, propertyInfo.dateFormat);
	                            }
	                            if (propertyInfo.numberFormat) {
	                                return propValue.toLocaleString(undefined, propertyInfo.numberFormat);
	                            }
	                        }
	                        else if (/(timestamp|date)/gi.test(key)) {
	                            // If the property name includes "timestamp" or "date" in it assume the number represents a Date object.
	                            return new Date(propValue).toISOString();
	                        }
	                        return propValue.toLocaleString(undefined, template.numberFormat);
	                    }
	                    else if (typeof propValue === "string" && propValue !== "" && !(/[\n\r<>\s]/g.test(propValue)) &&
	                        (template.detectHyperlinks || (propertyInfo && propertyInfo.hyperlinkFormat))) {
	                        // If the value is a string and doesn't include newline, spaces or xml <> characters,
	                        // then consider rendering as a hyperlink.
	                        propValue = propValue.trim();
	                        var isLink = this._isUrlRx.test(propValue) || (propertyInfo && propertyInfo.hyperlinkFormat);
	                        var isImage = this._isImageUrlRx.test(propValue) && (isLink || propValue.startsWith("data:image"));
	                        var isEmail = this._emailRx.test(propValue);
	                        if (isLink || isImage || isEmail) {
	                            var h = void 0;
	                            if (propertyInfo && propertyInfo.hyperlinkFormat) {
	                                h = propertyInfo.hyperlinkFormat;
	                            }
	                            else if (template && template.hyperlinkFormat) {
	                                h = template.hyperlinkFormat;
	                            }
	                            var t = void 0;
	                            if (h && h.target) {
	                                t = " target=\"".concat(h.target, "\"");
	                            }
	                            else {
	                                t = ' target="_blank"';
	                            }
	                            var c = "".concat(h && h.label ? h.label : propValue);
	                            if (h && h.scheme) {
	                                propValue = h.scheme + propValue;
	                            }
	                            else if (isEmail) {
	                                propValue = "mailto:" + propValue;
	                            }
	                            var alt = h && h.label ? " alt=\"".concat(h.label, "\"") : "";
	                            if ((h && h.isImage) || isImage) {
	                                c = "<img src=\"".concat(propValue, "\" style=\"max-width:100%\"").concat(alt, "\"/>");
	                            }
	                            return "<a href=\"".concat(propValue, "\"").concat(t, ">").concat(c, "</a>");
	                        }
	                    }
	                    var p = propValue.toString();
	                    return p;
	                }
	            }
	        }
	        return "";
	    };
	    /**
	     * Generates a table from a set of properties filtered on an array of property info values.
	     * @param properties The properties.
	     * @param propertyInfo The property info values that specify which properties to display and how to display them.
	     * @param template The template.
	     */
	    PopupTemplate._generatePropertyInfoTable = function (properties, propertyInfo, template) {
	        if (properties && propertyInfo && propertyInfo.length > 0) {
	            var html_2 = [];
	            var self_1 = this;
	            // Create a HTML table from an objects property names and values.
	            html_2.push("<table class=\"".concat(self_1.Css.table, "\">"));
	            propertyInfo.forEach(function (pi) {
	                var c = self_1._getPropertyValue(properties, pi.propertyPath, template, pi);
	                if (pi.hideLabel) {
	                    html_2.push('<tr><td colspan="2">', c, "</td></tr>");
	                }
	                else {
	                    var l = pi.label || pi.propertyPath.split("/")[0];
	                    html_2.push("<tr><th>", l, "</th><td>", c, "</td></tr>");
	                }
	            });
	            html_2.push("</table>");
	            var d = document.createElement("div");
	            d.innerHTML = html_2.join("");
	            return d;
	        }
	        return null;
	    };
	    /**
	     * Dynamically creates a table from the property information. Recursively steps through the property tree.
	     * @param properties The properties to generate a table for.
	     * @param subPath The sub-path within the properties to generate the table for.
	     * @param template The template.
	     */
	    PopupTemplate._generateDynamicTableHtml = function (properties, subPath, template) {
	        var _this = this;
	        if (properties) {
	            var html_3 = [];
	            var self_2 = this;
	            // Create a HTML table from an objects property names and values.
	            html_3.push("<table class=\"".concat(self_2.Css.table, "\">"));
	            var sp_1 = (subPath && subPath.length > 0) ? subPath.join("/") + "/" : "";
	            // Count the number of rows actually added to table.
	            var cnt_1 = 0;
	            Object.keys(properties).forEach(function (key) {
	                // Ignore private properties which are commonly denoted using an underscore, and style properties.
	                if (!_this._ignoreProperty(key, properties[key])) {
	                    html_3.push("<tr><th>", key, "</th><td>", self_2._getPropertyValue(properties, sp_1 + key, template), "</td></tr>");
	                    cnt_1++;
	                }
	            });
	            // If no rows added, don't return a table.
	            if (cnt_1 === 0) {
	                return null;
	            }
	            html_3.push("</table>");
	            return html_3.join("");
	        }
	        return null;
	    };
	    /**
	     * Checks to see if the property should be ignored based on the key or value.
	     * @param key The property name key.
	     * @param value The value of the property.
	     */
	    PopupTemplate._ignoreProperty = function (key, value) {
	        switch (key) {
	            // Ignore style and title properties.
	            case "title":
	            case "name":
	            case "base":
	            case "popupTemplate":
	            case "anchor":
	            case "icon":
	            case "image":
	            case "imageUrl":
	            case "rotation":
	            case "color":
	            case "size":
	            case "offset":
	            case "strokeColor":
	            case "strokeWidth":
	            case "strokeOpacity":
	            case "subType":
	            case "fillColor":
	            case "fillOpacity":
	            case "visibility":
	            case "visible":
	                return true;
	            default:
	                if (key.indexOf("_") === 0 || value == null || value === "") {
	                    return true;
	                }
	                break;
	        }
	        return false;
	    };
	    //////////////////////
	    /// Private properties
	    //////////////////////
	    /** Regular expression for content property placeholders. */
	    PopupTemplate._placeholderRx = /\{([a-zA-Z0-9_\/\s]+)\}/gi;
	    /** Regular expression for external URLs. */
	    PopupTemplate._isUrlRx = /^(http|https|ftp|tel|mailto):\/\//i;
	    /** Regular expression for image urls. */
	    PopupTemplate._isImageUrlRx = /(^data:image|.png$|.jpg$|.jpeg$|.gif$|.bmp$|.svg|.tif|.tiff$)/i;
	    /** Regular expression for email addresses. */
	    PopupTemplate._emailRx = /^[^\.\s@:](?:[^\s@:]*[^\s@:\.])?@[^\.\s@]+(?:\.[^\.\s@]+)*$/;
	    /** The URL to load our CSS from for iframed popups. */
	    PopupTemplate._cssUrl = new Url({
	        domain: env.staticAssetsDomain,
	        path: "sdk/javascript/mapcontrol/".concat(Version.getEndpointVersion(), "/atlas.min.css")
	    }).toString();
	    PopupTemplate.Css = {
	        template: "azure-maps-control-popup-template",
	        title: "azure-maps-control-popup-template-title",
	        content: "azure-maps-control-popup-template-content",
	        item: "azure-maps-control-popup-template-content-item",
	        table: "azure-maps-control-popup-template-table"
	    };
	    return PopupTemplate;
	}());

	exports.HtmlMarker = HtmlMarker;
	exports.Map = Map$1;
	exports.Pixel = Pixel;
	exports.Popup = Popup;
	exports.PopupTemplate = PopupTemplate;
	exports.Shape = Shape;
	exports._enableRTLTextPlugin = _enableRTLTextPlugin;
	exports._getAssetDomain = _getAssetDomain;
	exports._getDomain = _getDomain;
	exports._hasMaxParallelImageRequests = _hasMaxParallelImageRequests;
	exports._hasSetAuthenticationOptions = _hasSetAuthenticationOptions;
	exports._hasSetDomain = _hasSetDomain;
	exports._hasSetLanguage = _hasSetLanguage;
	exports._hasSetSessionId = _hasSetSessionId;
	exports._hasSetStyleDefinitionsPath = _hasSetStyleDefinitionsPath;
	exports._hasSetStyleDefinitionsVersion = _hasSetStyleDefinitionsVersion;
	exports._hasSetView = _hasSetView;
	exports._hasWorkerCount = _hasWorkerCount;
	exports.addImageTemplate = addImageTemplate;
	exports.addProtocol = addProtocol;
	exports.clearPrewarmedResources = clearPrewarmedResources;
	exports.control = index$2;
	exports.data = index$4;
	exports.getAllImageTemplateNames = getAllImageTemplateNames;
	exports.getAuthenticationOptions = getAuthenticationOptions;
	exports.getDomain = getDomain;
	exports.getImageTemplate = getImageTemplate;
	exports.getLanguage = getLanguage;
	exports.getMaxParallelImageRequests = getMaxParallelImageRequests;
	exports.getSessionId = getSessionId;
	exports.getStaticAssetsDomain = getStaticAssetsDomain;
	exports.getStyleAPIVersion = getStyleAPIVersion;
	exports.getStyleDefinitionsPath = getStyleDefinitionsPath;
	exports.getStyleDefinitionsVersion = getStyleDefinitionsVersion;
	exports.getSubscriptionKey = getSubscriptionKey;
	exports.getUserRegion = getUserRegion;
	exports.getVersion = getVersion;
	exports.getView = getView;
	exports.getWorkerCount = getWorkerCount;
	exports.internal = index$5;
	exports.isSupported = isSupported;
	exports.layer = index;
	exports.math = index$3;
	exports.prewarm = prewarm;
	exports.removeProtocol = removeProtocol;
	exports.setAuthenticationOptions = setAuthenticationOptions;
	exports.setDomain = setDomain;
	exports.setLanguage = setLanguage;
	exports.setMaxParallelImageRequests = setMaxParallelImageRequests;
	exports.setSessionId = setSessionId;
	exports.setStyleAPIVersion = setStyleAPIVersion;
	exports.setStyleDefinitionsPath = setStyleDefinitionsPath;
	exports.setStyleDefinitionsVersion = setStyleDefinitionsVersion;
	exports.setSubscriptionKey = setSubscriptionKey;
	exports.setUserRegion = setUserRegion;
	exports.setView = setView;
	exports.setWorkerCount = setWorkerCount;
	exports.source = index$1;

}));
